diff -r -u -P lab6_origin/answer.md lab6/answer.md
--- lab6_origin/answer.md	1970-01-01 08:00:00.000000000 +0800
+++ lab6/answer.md	2019-05-13 22:06:38.712630800 +0800
@@ -0,0 +1,761 @@
+# 实验六: 调度器
+## 实验目的
+- 理解操作系统的调度管理机制
+- 熟悉 ucore 的系统调度器框架，以及缺省的Round-Robin 调度算法
+- 基于调度器框架实现一个(Stride Scheduling)调度算法来替换缺省的调度算法
+
+## 实验内容
+- 实验五完成了用户进程的管理，可在用户态运行多个进程。
+- 之前采用的调度策略是很简单的FIFO调度策略。
+- 本次实验，主要是熟悉ucore的系统调度器框架，以及基于此框架的Round-Robin（RR） 调度算法。
+- 然后参考RR调度算法的实现，完成Stride Scheduling调度算法。
+
+## 调度框架和调度算法设计与实现
+实验六中的kern/schedule/sched.c只实现了调度器框架，而不再涉及具体的调度算法实现，调度算法在单独的文件（default_sched.[ch]）中实现。
+
+在init.c中的kern_init函数中的proc_init之前增加了对sched_init函数的调用。sched_init函数主要完成了对实现特定调度算法的调度类（sched_class，这里是default_sched_class）的绑定，使得ucore在后续的执行中，能够通过调度框架找到实现特定调度算法的调度类并完成进程调度相关工作。
+
+### 进程状态
+```
+struct proc_struct {
+    enum proc_state state;                      // Process state
+    int pid;                                    // Process ID
+    int runs;                                   // the running times of Proces
+    uintptr_t kstack;                           // Process kernel stack
+    volatile bool need_resched;                 // bool value: need to be rescheduled to release CPU?
+    struct proc_struct *parent;                 // the parent process
+    struct mm_struct *mm;                       // Process's memory management field
+    struct context context;                     // Switch here to run process
+    struct trapframe *tf;                       // Trap frame for current interrupt
+    uintptr_t cr3;                              // CR3 register: the base addr of Page Directroy Table(PDT)
+    uint32_t flags;                             // Process flag
+    char name[PROC_NAME_LEN + 1];               // Process name
+    list_entry_t list_link;                     // Process link list
+    list_entry_t hash_link;                     // Process hash list
+};
+```
+
+ucore定义的进程控制块struct proc_struct包含了成员变量state,用于描述进程的运行状态，而running和runnable共享同一个状态(state)值(PROC_RUNNABLE。不同之处在于处于running态的进程不会放在运行队列中。进程的正常生命周期如下：
+- 进程首先在 cpu 初始化或者 sys_fork 的时候被创建，当为该进程分配了一个进程控制块之后，该进程进入 uninit态(在proc.c 中 alloc_proc)。
+- 当进程完全完成初始化之后，该进程转为runnable态。
+- 当到达调度点时，由调度器`sched_class`根据运行队列run_queue的内容来判断一个进程是否应该被运行，即把处于runnable态的进程转换成running状态，从而占用CPU执行。
+- running态的进程通过wait等系统调用被阻塞，进入sleeping态。
+- sleeping态的进程被wakeup变成runnable态的进程。
+- running态的进程主动 exit 变成zombie态，然后由其父进程完成对其资源的最后释放，子进程的进程控制块成为unused。
+- 所有从runnable态变成其他状态的进程都要出运行队列，反之，被放入某个运行队列中。
+
+### 进程调度实现
+#### 内核抢占点
+对于用户进程而言，由于有中断的产生，可以随时打断用户进程的执行，转到操作系统内部，从而给了操作系统以调度控制权，让操作系统可以根据具体情况（比如用户进程时间片已经用完了）选择其他用户进程执行。这体现了用户进程的可抢占性。
+
+ucore内核执行是不可抢占的（non-preemptive），即在执行“任意”内核代码时，CPU控制权不可被强制剥夺。这里需要注意，不是在所有情况下ucore内核执行都是不可抢占的，有以下几种“固定”情况是例外：
+1. 进行同步互斥操作，比如争抢一个信号量、锁（lab7中会详细分析）；
+2. 进行磁盘读写等耗时的异步操作，由于等待完成的耗时太长，ucore会调用shcedule让其他就绪进程执行。
+
+以上两种是因为某个资源（也可称为事件）无法得到满足，无法继续执行下去，从而不得不主动放弃对CPU的控制权。在lab5中有几种情况是调用了schedule函数的。
+
+编号|位置|原因
+---|---|---
+1|proc.c:do_exit|用户线程执行结束，主动放弃CPU
+2|proc.c:do_wait|用户线程等待着子进程结束，主动放弃CPU
+3|proc.c:init_main|Init_porc内核线程等待所有用户进程结束；所有用户进程结束后回收系统资源
+4|proc.c:cpu_idle|idleproc内核线程等待处于就绪态的进程或线程，如果有选择一个并切换
+5|sync.h:lock|进程无法得到锁，则主动放弃CPU
+6|trap.c:trap|修改当前进程时间片，若时间片用完，则设置need_resched为1，让当前进程放弃CPU
+
+第1、2、5处的执行位置体现了由于获取某种资源一时等不到满足、进程要退出、进程要睡眠等原因而不得不主动放弃CPU。第3、4处的执行位置比较特殊，initproc内核线程等待用户进程结束而执行schedule函数；idle内核线程在没有进程处于就绪态时才执行，一旦有了就绪态的进程，它将执行schedule函数完成进程调度。这里只有第6处的位置比较特殊：
+```
+if (!in_kernel) {
+    ……
+
+    if (current->need_resched) {
+        schedule();
+    }
+}
+```
+
+只有当进程在用户态执行到“任意”某处用户代码位置时发生了中断，且当前进程控制块成员变量need_resched为1（表示需要调度了）时，才会执行shedule函数。这实际上体现了对用户进程的可抢占性。如果没有第一行的if语句，那么就可以体现对内核代码的可抢占性。但如果要把这一行if语句去掉，我们就不得不实现对ucore中的所有全局变量的互斥访问操作，以防止所谓的race-condition现象，这样ucore的实现复杂度会增加不少。
+
+Race condition旨在描述一个系统或者进程的输出依赖于不受控制的事件出现顺序或者出现时机。此词源自于两个信号试着彼此竞争，来影响谁先输出。 举例来说，如果计算机中的两个进程同时试图修改一个共享内存的内容，在没有并发控制的情况下，最后的结果依赖于两个进程的执行顺序与时机。而且如果发生了并发访问冲突，则最后的结果是不正确的。从维基百科的定义来看，race condition不仅仅是出现在程序中。以下讨论的race conditon全是计算机中多个进程同时访问一个共享内存，共享变量的例子。
+
+要阻止出现race condition情况的关键就是不能让多个进程同时访问那块共享内存。访问共享内存的那段代码就是critical section。所有的解决方法都是围绕这个critical section来设计的。想要成功的解决race condition问题，并且程序还可以正确运行，从理论上应该满足以下四个条件： 
+1. 不会有两个及以上进程同时出现在他们的critical section。 
+2. 不要做任何关于CPU速度和数量的假设。 
+3. 任何进程在运行到critical section之外时都不能阻塞其他进程。 
+4. 不会有进程永远等在critical section之前。
+
+#### 进程切换过程
+进程调度函数schedule选择了下一个将占用CPU执行的进程后，将调用进程切换，从而让新的进程得以执行。
+
+两个用户进程，在二者进行进程切换的过程中，具体的步骤如下：
+1. 首先在执行某进程A的用户代码时，出现了一个`trap`，这个时候就会从进程A的用户态切换到内核态(过程(1))，并且保存好进程A的trapframe；当内核态处理中断时发现需要进行进程切换时，ucore要通过schedule函数选择下一个将占用CPU执行的进程（即进程B），然后会调用proc_run函数，proc_run函数进一步调用switch_to函数，切换到进程B的内核态(过程(2))，继续进程B上一次在内核态的操作，并通过iret指令，最终将执行权转交给进程B的用户空间(过程(3))。
+2. 当进程B由于某种原因发生中断之后(过程(4))，会从进程B的用户态切换到**内核态**，并且保存好进程B的trapframe；当内核态处理中断时发现需要进行进程切换时，即需要切换到进程A，ucore再次切换到进程A(过程(5))，会执行进程A上一次在内核调用schedule函数返回后的下一行代码，这行代码当然还是在进程A的上一次中断处理流程中。最后当进程A的中断处理完毕的时候，执行权又会反交给进程A的用户代码(过程(6))。这就是在只有两个进程的情况下，进程切换间的大体流程。
+
+### 调度框架和调度算法
+#### 设计思路
+在操作方面，如果需要选择一个就绪进程，就可以从基于某种组织方式的就绪进程集合中选择出一个进程执行。**选择**是在集合中挑选一个“合适”的进程，**出**意味着离开就绪进程集合。
+
+另外考虑到一个处于运行态的进程还会由于某种原因（比如时间片用完了）回到就绪态而不能继续占用CPU执行，这就会重新进入到就绪进程集合中。这两种情况就形成了调度器相关的三个基本操作：**在就绪进程集合中选择**、**进入就绪进程集合**和**离开就绪进程集合**。这三个操作属于调度器的基本操作。
+
+在进程的执行过程中，**就绪进程的等待时间**和**执行进程的执行时间**是影响调度选择的重要因素。这些进程状态变化的情况需要及时让进程调度器知道，便于选择更合适的进程执行。所以这种进程变化的情况就形成了调度器相关的一个变化感知操作：**timer时间事件感知操作**。这样在进程运行或等待的过程中，调度器可以调整进程控制块中与进程调度相关的属性值（比如消耗的时间片、进程优先级等），并可能导致对进程组织形式的调整（比如以时间片大小的顺序来重排双向链表等），并最终可能导致调选择新的进程占用CPU运行。这个操作属于调度器的进程调度属性调整操作。
+
+#### 数据结构
+- 在 ucore 中，调度器引入 run-queue（简称rq,即运行队列）的概念，通过链表结构管理进程。
+- 由于目前 ucore 设计运行在单CPU上，其内部只有一个全局的运行队列，用来管理系统内全部的进程。
+- 运行队列通过链表的形式进行组织。链表的每一个节点是一个list_entry_t,每个list_entry_t 又对应到了`struct proc_struct *`，这其间的转换是通过宏`le2proc`来完成。
+- 具体来说，我们知道在`struct proc_struct`中有一个叫`run_link`的`list_entry_t`，因此可以通过偏移量逆向找到对因某个`run_list`的`struct proc_struct`。即进程结构指针`proc = le2proc(链表节点指针, run_link)`。
+
+```
+// The introduction of scheduling classes is borrrowed from Linux, and makes the
+// core scheduler quite extensible. These classes (the scheduler modules) encapsulate
+// the scheduling policies.
+struct sched_class {
+    // the name of sched_class
+    const char *name;
+    // 初始化运行队列
+    void (*init)(struct run_queue *rq);
+
+    // put the proc into runqueue, and this function must be called with rq_lock
+    // 进程放入运行队列
+    void (*enqueue)(struct run_queue *rq, struct proc_struct *proc);
+
+    // get the proc out runqueue, and this function must be called with rq_lock
+    // 从队列中取出
+    void (*dequeue)(struct run_queue *rq, struct proc_struct *proc);
+
+    // choose the next runnable task
+    // 选择下一个可运行的任务
+    struct proc_struct *(*pick_next)(struct run_queue *rq);
+
+    // dealer of the time-tick
+    // 处理tick中断
+    void (*proc_tick)(struct run_queue *rq, struct proc_struct *proc);
+
+    /* for SMP support in the future
+     *  load_balance
+     *     void (*load_balance)(struct rq* rq);
+     *  get some proc from this rq, used in load_balance,
+     *  return value is the num of gotten proc
+     *  int (*get_proc)(struct rq* rq, struct proc* procs_moved[]);
+     */
+};
+```
+
+proc.h 中的 struct proc_struct 中也记录了一些调度相关的信息：
+```
+struct proc_struct {
+    enum proc_state state;                      // Process state
+    int pid;                                    // Process ID
+    int runs;                                   // the running times of Proces
+    uintptr_t kstack;                           // Process kernel stack
+    volatile bool need_resched;                 // bool value: need to be rescheduled to release CPU?
+    struct proc_struct *parent;                 // the parent process
+    struct mm_struct *mm;                       // Process's memory management field
+    struct context context;                     // Switch here to run process
+    struct trapframe *tf;                       // Trap frame for current interrupt
+    uintptr_t cr3;                              // CR3 register: the base addr of Page Directroy Table(PDT)
+    uint32_t flags;                             // Process flag
+    char name[PROC_NAME_LEN + 1];               // Process name
+    list_entry_t list_link;                     // Process link list
+    list_entry_t hash_link;                     // Process hash list
+    int exit_code;                              // exit code (be sent to parent proc)
+    uint32_t wait_state;                        // waiting state
+    struct proc_struct *cptr, *yptr, *optr;     // relations between processes
+    struct run_queue *rq;                       // running queue contains Process
+    list_entry_t run_link;                      // the entry linked in run queue 
+    // 该进程的调度链表结构，该结构内部的连接组成了 运行队列 列表
+
+    int time_slice;                             // time slice for occupying the CPU
+    // 进程剩余的时间片
+    skew_heap_entry_t lab6_run_pool;            // FOR LAB6 ONLY: the entry in the run pool
+    //在优先队列中用到的
+
+    uint32_t lab6_stride;                       // FOR LAB6 ONLY: the current stride of the process
+    // 步进值
+
+    uint32_t lab6_priority;                     // FOR LAB6 ONLY: the priority of process, set by lab6_set_priority(uint32_t)
+    // 优先级
+
+};
+```
+
+RR调度算法在`RR_sched_class`调度策略类中实现。
+通过数据结构 struct run_queue 来描述完整的 run_queue（运行队列）。它的主要结构如下：
+```
+struct run_queue {
+    //其运行队列的哨兵结构，可以看作是队列头和尾
+    list_entry_t run_list;
+    //优先队列形式的进程容器，只在 LAB6 中使用
+    skew_heap_entry_t *lab6_run_pool;
+    //表示其内部的进程总数
+    unsigned int proc_num;
+    //每个进程一轮占用的最多时间片
+    int max_time_slice;
+};
+```
+在 ucore 框架中，运行队列存储的是当前可以调度的进程，所以，只有状态为runnable的进程才能够进入运行队列。当前正在运行的进程并不会在运行队列中。
+
+#### 调度点的相关关键函数
+如果我们能够让`wakup_proc`、`schedule`、`run_timer_list`这三个调度相关函数的实现与具体调度算法无关，那么就可以认为ucore实现了一个与调度算法无关的调度框架。
+
+`wakeup_proc`函数完成了把一个就绪进程放入到就绪进程队列中的工作，为此还调用了一个调度类接口函数`sched_class_enqueue`，这使得`wakeup_proc`的实现与具体调度算法无关。
+```
+void wakeup_proc(struct proc_struct *proc) {
+    assert(proc->state != PROC_ZOMBIE);
+    bool intr_flag;
+    local_intr_save(intr_flag);
+    {
+        if (proc->state != PROC_RUNNABLE) {
+            proc->state = PROC_RUNNABLE;
+            proc->wait_state = 0;
+            if (proc != current) {
+                sched_class_enqueue(proc);
+            }
+        }
+        else {
+            warn("wakeup runnable process.\n");
+        }
+    }
+    local_intr_restore(intr_flag);
+}
+```
+
+`schedule`函数完成了与调度框架和调度算法相关三件事情:
+- 把当前继续占用CPU执行的运行进程放放入到就绪进程队列中；
+- 从就绪进程队列中选择一个“合适”就绪进程；
+- 把这个“合适”的就绪进程从就绪进程队列中取出；
+- 如果没有的话，说明现在没有合适的进程可以执行，就执行idle_proc；
+- 加了一个runs，表明这个进程运行过几次了；
+
+```
+void schedule(void) {
+    bool intr_flag;
+    struct proc_struct *next;
+    local_intr_save(intr_flag);
+    {
+        current->need_resched = 0;
+        if (current->state == PROC_RUNNABLE) {
+            sched_class_enqueue(current);
+        }
+        if ((next = sched_class_pick_next()) != NULL) {
+            sched_class_dequeue(next);
+        }
+        if (next == NULL) {
+            next = idleproc;
+        }
+        next->runs ++;
+        if (next != current) {
+            proc_run(next);
+        }
+    }
+    local_intr_restore(intr_flag);
+}
+```
+
+run_time_list在lab6中并没有涉及，是在lab7中的。
+
+通过调用三个调度类接口函数`sched_class_enqueue`、`sched_class_pick_next`、`sched_class_enqueue`来使得完成这三件事情与具体的调度算法无关。`run_timer_list`函数在每次timer中断处理过程中被调用，从而可用来调用调度算法所需的timer时间事件感知操作，调整相关进程的进程调度相关的属性值。通过调用调度类接口函数`sched_class_proc_tick`使得此操作与具体调度算法无关。
+这里涉及了一系列调度类接口函数：
+- sched_class_enqueue
+- sched_class_dequeue
+- sched_class_pick_next
+- sched_class_proc_tick
+
+这4个函数的实现其实就是调用某基于sched_class数据结构的特定调度算法实现的4个指针函数。采用这样的调度类框架后，如果我们需要实现一个新的调度算法，则我们需要定义一个针对此算法的调度类的实例，一个就绪进程队列的组织结构描述就行了，其他的事情都可交给调度类框架来完成。
+
+#### RR调度算法
+RR调度算法的调度思想是让所有runnable态的进程分时轮流使用CPU时间。
+
+RR调度器维护当前runnable进程的有序运行队列。当前进程的时间片用完之后，调度器将当前进程放置到运行队列的尾部，再从其头部取出进程进行调度。
+
+RR调度算法的就绪队列在组织结构上也是一个双向链表，只是增加了一个成员变量，表明在此就绪进程队列中的最大执行时间片。而且在进程控制块proc_struct中增加了一个成员变量time_slice，用来记录进程当前的可运行时间片段。这是由于RR调度算法需要考虑执行进程的运行时间不能太长。在每个timer到时的时候，操作系统会递减当前执行进程的time_slice，当time_slice为0时，就意味着这个进程运行了一段时间（这个时间片段称为进程的时间片），需要把CPU让给其他进程执行，于是操作系统就需要让此进程重新回到rq的队列尾，且重置此进程的时间片为就绪队列的成员变量最大时间片max_time_slice值，然后再从rq的队列头取出一个新的进程执行。
+
+RR_enqueue的函数实现如下表所示。即把某进程的进程控制块指针放入到rq队列末尾，且如果进程控制块的时间片为0，则需要把它重置为rq成员变量max_time_slice。这表示如果进程在当前的执行时间片已经用完，需要等到下一次有机会运行时，才能再执行一段时间。
+```
+static void RR_enqueue(struct run_queue *rq, struct proc_struct *proc) {
+    assert(list_empty(&(proc->run_link)));
+    list_add_before(&(rq->run_list), &(proc->run_link));
+    if (proc->time_slice == 0 || proc->time_slice > rq->max_time_slice) {
+        proc->time_slice = rq->max_time_slice;
+    }
+    proc->rq = rq;
+    rq->proc_num ++;
+}
+```
+RR_pick_next的函数实现如下表所示。即选取就绪进程队列rq中的队头队列元素，并把队列元素转换成进程控制块指针。
+```
+static struct proc_struct *
+FCFS_pick_next(struct run_queue *rq) {
+    list_entry_t *le = list_next(&(rq->run_list));
+    if (le != &(rq->run_list)) {
+        return le2proc(le, run_link);
+    }
+    return NULL;
+}
+```
+RR_dequeue的函数实现如下表所示。即把就绪进程队列rq的进程控制块指针的队列元素删除，并把表示就绪进程个数的proc_num减一。
+```
+static void FCFS_dequeue(struct run_queue *rq, struct proc_struct *proc) {
+    assert(!list_empty(&(proc->run_link)) && proc->rq == rq);
+    list_del_init(&(proc->run_link));
+    rq->proc_num --;
+}
+```
+RR_proc_tick的函数实现如下表所示。每次timer到时后，trap函数将会间接调用此函数来把当前执行进程的时间片time_slice减一。如果time_slice降到零，则设置此进程成员变量need_resched标识为1，这样在下一次中断来后执行trap函数时，会由于当前进程程成员变量need_resched标识为1而执行schedule函数，从而把当前执行进程放回就绪队列末尾，而从就绪队列头取出在就绪队列上等待时间最久的那个就绪进程执行。
+```
+static void
+RR_proc_tick(struct run_queue *rq, struct proc_struct *proc) {
+    if (proc->time_slice > 0) {
+        proc->time_slice --;
+    }
+    if (proc->time_slice == 0) {
+        proc->need_resched = 1;
+    }
+}
+```
+
+### Stride Scheduling
+#### 基本思路
+1. 为每个runnable的进程设置一个当前状态stride，表示该进程当前的调度权，也可以表示这个进程执行了多久了。另外定义其对应的pass值，表示对应进程在调度后，stride 需要进行的累加值。
+2. 每次需要调度时，从当前 runnable 态的进程中选择**stride最小**的进程调度。
+3. 对于获得调度的进程P，将对应的stride加上其对应的步长pass（只与进程的优先权有关系）。
+4. 在一段固定的时间之后，回到2步骤，重新调度当前stride最小的进程。
+
+可以证明，如果令`P.pass =BigStride / P.priority`，其中`P.priority`表示进程的优先权（大于 1），而 BigStride 表示一个预先定义的大常数，则该调度方案为每个进程分配的时间将与其优先级成正比。
+
+将该调度器应用到 ucore 的调度器框架中来，则需要将调度器接口实现如下：
+
+- init:
+    - 初始化调度器类的信息（如果有的话）。
+    - 初始化当前的运行队列为一个空的容器结构。（比如和RR调度算法一样，初始化为一个有序列表）
+- enqueue
+    - 初始化刚进入运行队列的进程 proc的stride属性。
+    - 将 proc插入放入运行队列中去（注意：这里并不要求放置在队列头部）。
+- dequeue
+    - 从运行队列中删除相应的元素。
+- pick next
+    - 扫描整个运行队列，返回其中stride值最小的对应进程。
+    - 更新对应进程的stride值，即pass = BIG_STRIDE / P->priority; P->stride += pass。
+- proc tick:
+    - 检测当前进程是否已用完分配的时间片。如果时间片用完，应该正确设置进程结构的相关标记来引起进程切换。
+    - 一个 process 最多可以连续运行 rq.max_time_slice个时间片。
+
+#### 使用优先队列实现 Stride Scheduling
+使用优化的优先队列数据结构实现该调度。
+
+优先队列是这样一种数据结构：使用者可以快速的插入和删除队列中的元素，并且在预先指定的顺序下快速取得当前在队列中的最小（或者最大）值及其对应元素。可以看到，这样的数据结构非常符合 Stride 调度器的实现。
+
+libs/skew_heap.h中是优先队列的一个实现。
+```
+static inline void skew_heap_init(skew_heap_entry_t *a) __attribute__((always_inline));
+// 初始化一个队列节点
+
+static inline skew_heap_entry_t *skew_heap_merge(
+     skew_heap_entry_t *a, skew_heap_entry_t *b,
+     compare_f comp);
+// 合并两个优先队列
+
+static inline skew_heap_entry_t *skew_heap_insert(
+     skew_heap_entry_t *a, skew_heap_entry_t *b,
+     compare_f comp) __attribute__((always_inline));
+// 将节点 b 插入至以节点 a 为队列头的队列中去，返回插入后的队列
+
+static inline skew_heap_entry_t *skew_heap_remove(
+     skew_heap_entry_t *a, skew_heap_entry_t *b,
+     compare_f comp) __attribute__((always_inline));
+// 将节点 b 插入从以节点 a 为队列头的队列中去，返回删除后的队列
+```
+当使用优先队列作为Stride调度器的实现方式之后，运行队列结构也需要作相关改变，其中包括：
+1. `struct run_queue`中的`lab6_run_pool`指针，在使用优先队列的实现中表示当前优先队列的头元素，如果优先队列为空，则其指向空指针（NULL）。
+2. `struct proc_struct`中的`lab6_run_pool`结构，表示当前进程对应的优先队列节点。本次实验已经修改了系统相关部分的代码，使得其能够很好地适应LAB6新加入的数据结构和接口。而在实验中我们需要做的是用优先队列实现一个正确和高效的Stride调度器，如果用较简略的伪代码描述，则有：
+
+- init(rq):
+    - Initialize rq->run_list
+    - Set rq->lab6_run_pool to NULL
+    - Set rq->proc_num to 0
+- enqueue(rq, proc)
+    - Initialize proc->time_slice
+    - Insert proc->lab6_run_pool into rq->lab6_run_pool
+    - rq->proc_num ++
+- dequeue(rq, proc)
+    - Remove proc->lab6_run_pool from rq->lab6_run_pool
+    - rq->proc_num --
+- pick_next(rq)
+    - If rq->lab6_run_pool == NULL, return NULL
+    - Find the proc corresponding to the pointer rq->lab6_run_pool
+    - proc->lab6_stride += BIG_STRIDE / proc->lab6_priority
+    - Return proc
+- proc_tick(rq, proc):
+    - If proc->time_slice > 0, proc->time_slice --
+    – If proc->time_slice == 0, set the flag proc->need_resched    
+
+## 练习1: 使用 Round Robin 调度算法（不需要编码）
+与之前相比，新增了斜堆数据结构的实现；新增了调度算法Round Robin的实现，具体为调用sched.c文件中的`sched_class`的一系列函数，主要有enqueue、dequeue、pick_next等。之后，这些函数进一步调用调度器中的相应函数，默认该调度器为Round Robin调度器，这是在`default_sched.[c|h]`中定义的；新增了set_priority，get_time等函数；
+
+首先在init.c中调用了sched_init函数，在这里把sched_class赋值为default_sched_class，也就是RR，如下：
+```
+void
+sched_init(void) {
+    list_init(&timer_list);
+
+    sched_class = &default_sched_class;
+    rq = &__rq;
+    rq->max_time_slice = MAX_TIME_SLICE;
+    sched_class->init(rq);
+    cprintf("sched class: %s\n", sched_class->name);
+}
+```
+
+- RR_init函数：这个函数会被封装为sched_init函数，用于调度算法的初始化，它是在ucore的init.c里面被调用进行初始化，主要完成了计时器list、run_queue的run_list的初始化；
+- enqueue函数：将某个进程放入调用算法中的可执行队列中，被封装成sched_class_enqueue函数，这个函数仅在wakeup_proc和schedule函数中被调用，wakeup_proc将某个不是RUNNABLE的进程改成RUNNABLE的并调用enqueue加入可执行队列，而后者是将正在执行的进程换出到可执行队列中去并取出一个可执行进程；
+- dequeue函数：将某个在队列中的进程取出，sched_class_dequeue将其封装并在schedule中被调用，将调度算法选择的进程从等待的可执行进程队列中取出；
+- pick_next函数：根据调度算法选择下一个要执行的进程，仅在schedule中被调用；
+- proc_tick函数：在时钟中断时执行的操作，时间片减一，当时间片为0时，说明这个进程需要重新调度了。仅在进行时间中断的ISR中调用；
+
+> 请理解并分析sched_calss中各个函数指针的用法，并接合Round Robin 调度算法描述ucore的调度执行过程：
+
+- ucore中的调度主要通过schedule和wakeup_proc函数完成，schedule主要把当前执行的进程入队，调用sched_class_pick_next选择下一个执行的进程并将其出队，开始执行。scheduleha函数把当前的进程入队，挑选一个进程将其出队并开始执行。
+- 当需要将某一个进程加入就绪进程队列中，需要调用enqueue，将其插入到使用链表组织run_queue的队尾，将这个进程的能够使用的时间片初始化为max_time_slice；
+- 当需要将某一个进程从就绪队列中取出，需要调用dequeue，调用list_del_init将其直接删除即可；
+- 当需要取出执行的下一个进程时，只需调用pick_next将就绪队列run_queue的队头取出即可；
+- 在一个时钟中断中，调用proc_tick将当前执行的进程的剩余可执行时间减1，一旦减到了0，则这个进程的need_resched为1，设成可以被调度的，这样之后就会调用schedule函数将这个进程切换出去；
+
+> 请在实验报告中简要说明如何设计实现”多级反馈队列调度算法“，给出概要设计，鼓励给出详细设计;
+
+1.调度机制：
+
+1. 进程在进入待调度的队列等待时，首先进入优先级最高的Q1等待。
+2. 设置多个就绪队列。在系统中设置多个就绪队列，并为每个队列赋予不同的优先级，从第一个开始逐个降低。不同队列进程中所赋予的执行时间也不同，优先级越高，时间片越小。
+3. 每个队列都采用FCFS（先来先服务）算法。轮到该进程执行时，若在该时间片内完成，便撤离操作系统，否则调度程序将其转入第二队列的末尾等待调度，.......。若进程最后被调到第N队列中时，便采用RR方式运行。
+4. 按队列优先级调度。调度按照优先级最高队列中诸进程运行，仅当第一队列空闲时才调度第二队列进程执行。若低优先级队列执行中有优先级高队列进程执行，应立刻将此进程放入队列末尾，把处理机分配给新到高优先级进程。
+
+- 设置N个多级反馈队列的入口，Q0，Q1，Q2，Q3，...，编号越靠前的队列优先级越低，优先级越低的队列上时间片的长度越大；
+- 调用sched_init对调度算法初始化的时候需要同时对N个队列进行初始化；
+- 在将进程加入到就绪进程集合的时候，观察这个进程的时间片有没有使用完，如果使用完了，就将所在队列的优先级调低，加入到优先级低一级的队列中去，如果没有使用完时间片，则加入到当前优先级的队列中去；
+- 在同一个优先级的队列内使用时间片轮转算法；
+- 在选择下一个执行的进程的时候，先考虑更高优先级的队列中是否存在任务，如果不存在在去找较低优先级的队列；
+- 从就绪进程集合中删除某一个进程的话直接在对应队列中删除；
+
+## 练习2：实现 Stride Scheduling 调度算法（需要编码）
+
+**啊啊啊忘了在trap.c里改怪不得怎么都搞不对啊啊啊啊啊啊啊啊啊这下子总算有170了！！！**
+
+还是先看看代码里斜堆（skew heap）的实现吧，好多地方要用到这个结构，具体可以在yuhao0102.github.io里仔细看。
+在libs/skew.h中定义了skew heap。
+
+猜测这只是一个入口，类似链表那种实现，不包括数据，只有指针。
+```
+struct skew_heap_entry {
+     struct skew_heap_entry *parent, *left, *right;
+};
+```
+
+`proc_stride_comp_f`函数是用来比较这两个进程的stride的，a比b大返回1，相等返回0，a比b小返回-1。
+```
+/* The compare function for two skew_heap_node_t's and the
+ * corresponding procs*/
+static int proc_stride_comp_f(void *a, void *b)
+{
+     struct proc_struct *p = le2proc(a, lab6_run_pool);
+     struct proc_struct *q = le2proc(b, lab6_run_pool);
+     int32_t c = p->lab6_stride - q->lab6_stride;
+     if (c > 0) return 1;
+     else if (c == 0) return 0;
+     else return -1;
+}
+```
+
+这是初始化的函数，把三个指针初始化为NULL
+```
+static inline void
+skew_heap_init(skew_heap_entry_t *a)
+{
+     a->left = a->right = a->parent = NULL;
+}
+```
+
+这个是把两个堆merge在一起的操作，强行内联hhh，这个是递归的！
+```
+static inline skew_heap_entry_t *
+skew_heap_merge(skew_heap_entry_t *a, skew_heap_entry_t *b,
+                compare_f comp)
+{
+     if (a == NULL) return b;
+     else if (b == NULL) return a;
+// 如果a或b有一个为空，则返回另一个
+
+     skew_heap_entry_t *l, *r;
+     if (comp(a, b) == -1)
+     {
+          r = a->left;
+          l = skew_heap_merge(a->right, b, comp);
+
+          a->left = l;
+          a->right = r;
+          if (l) l->parent = a;
+
+          return a;
+// 否则判断a和b的值哪个大，如果a比b小，则a的右子树和b合并，a作为堆顶        
+     }
+     else
+     {
+          r = b->left;
+          l = skew_heap_merge(a, b->right, comp);
+
+          b->left = l;
+          b->right = r;
+          if (l) 
+          	l->parent = b;
+	      return b;
+// 另一种情况	      
+     }
+}
+```
+
+insert就是把一个单节点的堆跟大堆合并
+```
+static inline skew_heap_entry_t *
+skew_heap_insert(skew_heap_entry_t *a, skew_heap_entry_t *b,
+                 compare_f comp)
+{
+     skew_heap_init(b);
+     return skew_heap_merge(a, b, comp);
+}
+```
+
+删除就是把节点的左右子树进行merge，比较简单，记得删掉这个节点之后补充它的parent即可
+```
+static inline skew_heap_entry_t *
+skew_heap_remove(skew_heap_entry_t *a, skew_heap_entry_t *b,
+                 compare_f comp)
+{
+     skew_heap_entry_t *p   = b->parent;
+     skew_heap_entry_t *rep = skew_heap_merge(b->left, b->right, comp);
+     if (rep) rep->parent = p;
+
+     if (p)
+     {
+          if (p->left == b)
+               p->left = rep;
+          else p->right = rep;
+          return a;
+     }
+     else return rep;
+}
+```
+
+首先把default_sched.c中设置RR调度器为默认调度器的部分注释掉，然后把default_sched_stride_c改成default_sched_stride.c，这里对默认调度器进行了重新定义。
+```
+struct sched_class default_sched_class = {
+     .name = "stride_scheduler",
+     .init = stride_init,
+     .enqueue = stride_enqueue,
+     .dequeue = stride_dequeue,
+     .pick_next = stride_pick_next,
+     .proc_tick = stride_proc_tick,
+};
+```
+针对PCB的初始化，代码如下，综合了几个实验的初始化代码，也是一个总结：
+```
+//LAB4:EXERCISE1 YOUR CODE
+/*
+ * below fields in proc_struct need to be initialized
+ *       enum proc_state state;                      // Process state
+ *       int pid;                                    // Process ID
+ *       int runs;                                   // the running times of Proces
+ *       uintptr_t kstack;                           // Process kernel stack
+ *       volatile bool need_resched;                 // bool value: need to be rescheduled to release CPU?
+ *       struct proc_struct *parent;                 // the parent process
+ *       struct mm_struct *mm;                       // Process's memory management field
+ *       struct context context;                     // Switch here to run process
+ *       struct trapframe *tf;                       // Trap frame for current interrupt
+ *       uintptr_t cr3;                              // CR3 register: the base addr of Page Directroy Table(PDT)
+ *       uint32_t flags;                             // Process flag
+ *       char name[PROC_NAME_LEN + 1];               // Process name
+ */
+        proc->state = PROC_UNINIT;
+        proc->pid = -1;
+        proc->cr3 = boot_cr3;
+
+        proc->runs = 0;
+        proc->kstack = 0;
+        proc->need_resched = 0;
+        proc->parent = NULL;
+        proc->mm = NULL;
+        memset(&proc->context, 0, sizeof(struct context));
+        proc->tf = NULL;
+        proc->flags = 0;
+        memset(proc->name, 0, PROC_NAME_LEN);
+
+//LAB5 YOUR CODE : (update LAB4 steps)
+/*
+ * below fields(add in LAB5) in proc_struct need to be initialized
+ *       uint32_t wait_state;                        // waiting state
+ *       struct proc_struct *cptr, *yptr, *optr;     // relations between processes
+ */
+        proc->wait_state = 0;
+        proc->cptr = proc->optr = proc->yptr = NULL;
+//LAB6 YOUR CODE : (update LAB5 steps)
+/*
+ * below fields(add in LAB6) in proc_struct need to be initialized
+ *     struct run_queue *rq;                       // running queue contains Process
+ *     list_entry_t run_link;                      // the entry linked in run queue
+ *     int time_slice;                             // time slice for occupying the CPU
+ *     skew_heap_entry_t lab6_run_pool;            // FOR LAB6 ONLY: the entry in the run pool
+ *     uint32_t lab6_stride;                       // FOR LAB6 ONLY: the current stride of the process
+ *     uint32_t lab6_priority;                     // FOR LAB6 ONLY: the priority of process, set by lab6_set_priority(uint32_t)
+ */
+        proc->rq = NULL;
+        memset(&proc->run_link, 0, sizeof(list_entry_t));
+        proc->time_slice = 0;
+        memset(&proc->lab6_run_pool,0,sizeof(skew_heap_entry_t));
+        proc->lab6_stride=0;
+        proc->lab6_priority=1;
+```
+主要就是在`vim kern/schedule/default_sched_stride.c`里的修改。
+```
+#define BIG_STRIDE ((uint32_t)(1<<31)-3)
+```
+BIG_STRIDE应该设置成小于2^32-1的一个常数。
+
+这个函数用来对run_queue进行初始化等操作
+```
+/*
+ * stride_init initializes the run-queue rq with correct assignment for
+ * member variables, including:
+ *
+ *   - run_list: should be a empty list after initialization.
+ *   - lab6_run_pool: NULL
+ *   - proc_num: 0
+ *   - max_time_slice: no need here, the variable would be assigned by the caller.
+ *
+ * hint: see libs/list.h for routines of the list structures.
+ */
+static void
+stride_init(struct run_queue *rq) {
+     /* LAB6: YOUR CODE
+      * (1) init the ready process list: rq->run_list
+      * (2) init the run pool: rq->lab6_run_pool
+      * (3) set number of process: rq->proc_num to 0
+      */
+      list_init(&rq->run_list);
+      rq->lab6_run_pool = NULL;
+      rq->proc_num = 0;
+}
+```
+
+
+```
+
+/*
+ * stride_enqueue inserts the process ``proc'' into the run-queue
+ * ``rq''. The procedure should verify/initialize the relevant members
+ * of ``proc'', and then put the ``lab6_run_pool'' node into the
+ * queue(since we use priority queue here). The procedure should also
+ * update the meta date in ``rq'' structure.
+ *
+ * proc->time_slice denotes the time slices allocation for the
+ * process, which should set to rq->max_time_slice.
+ *
+ * hint: see libs/skew_heap.h for routines of the priority
+ * queue structures.
+ */
+static void
+stride_enqueue(struct run_queue *rq, struct proc_struct *proc) {
+     /* LAB6: YOUR CODE
+      * (1) insert the proc into rq correctly
+      * NOTICE: you can use skew_heap or list. Important functions
+      *         skew_heap_insert: insert a entry into skew_heap
+      *         list_add_before: insert  a entry into the last of list
+      * (2) recalculate proc->time_slice
+      * (3) set proc->rq pointer to rq
+      * (4) increase rq->proc_num
+      */
+      rq->lab6_run_pool = skew_heap_insert(rq->lab6_run_pool, &proc->lab6_run_pool, proc_stride_comp_f);
+      // 做插入操作，把这个进程插到run_pool里。
+      if(proc->time_slice == 0 || proc->time_slice > rq->max_time_slice) {
+          proc->time_slice = rq->max_time_slice;
+      }
+      // 如果这个进程的时间片不符合要求，就把它初始化成最大值。
+      proc->rq = rq;
+      rq->proc_num ++;
+      //run_queue里的进程数++
+}
+```
+
+做删除操作，把这个进程从run_pool里删除，并且将run_queue里的进程数减一。
+```
+/*
+ * stride_dequeue removes the process ``proc'' from the run-queue
+ * ``rq'', the operation would be finished by the skew_heap_remove
+ * operations. Remember to update the ``rq'' structure.
+ *
+ * hint: see libs/skew_heap.h for routines of the priority
+ * queue structures.
+ */
+static void
+stride_dequeue(struct run_queue *rq, struct proc_struct *proc) {
+     /* LAB6: YOUR CODE
+      * (1) remove the proc from rq correctly
+      * NOTICE: you can use skew_heap or list. Important functions
+      *         skew_heap_remove: remove a entry from skew_heap
+      *         list_del_init: remove a entry from the  list
+      */
+      rq->lab6_run_pool = skew_heap_remove(rq->lab6_run_pool, &proc->lab6_run_pool, proc_stride_comp_f);
+      rq->proc_num --;
+}
+```
+
+pick_next从run_queue中选择stride值最小的进程，即斜堆的根节点对应的进程，并且返回这个proc，同时更新这个proc的stride
+```
+/*
+ * stride_pick_next pick the element from the ``run-queue'', with the
+ * minimum value of stride, and returns the corresponding process
+ * pointer. The process pointer would be calculated by macro le2proc,
+ * see kern/process/proc.h for definition. Return NULL if
+ * there is no process in the queue.
+ *
+ * When one proc structure is selected, remember to update the stride
+ * property of the proc. (stride += BIG_STRIDE / priority)
+ *
+ * hint: see libs/skew_heap.h for routines of the priority
+ * queue structures.
+ */
+static struct proc_struct *
+stride_pick_next(struct run_queue *rq) {
+     /* LAB6: YOUR CODE
+      * (1) get a  proc_struct pointer p  with the minimum value of stride
+             (1.1) If using skew_heap, we can use le2proc get the p from rq->lab6_run_poll
+             (1.2) If using list, we have to search list to find the p with minimum stride value
+      * (2) update p;s stride value: p->lab6_stride
+      * (3) return p
+      */
+      if (rq->lab6_run_pool == NULL)
+          return NULL;
+      struct proc_struct *p = le2proc(rq->lab6_run_pool, lab6_run_pool);
+      p->lab6_stride += BIG_STRIDE/p->lab6_priority;
+      return p;
+}
+```
+
+要在trap的时候调用！！！！如果这个proc的时间片还有的话，就减一，如果这个时间片为0了，就把它设成可调度的，参与调度。
+```
+/*
+ * stride_proc_tick works with the tick event of current process. You
+ * should check whether the time slices for current process is
+ * exhausted and update the proc struct ``proc''. proc->time_slice
+ * denotes the time slices left for current
+ * process. proc->need_resched is the flag variable for process
+ * switching.
+ */
+static void
+stride_proc_tick(struct run_queue *rq, struct proc_struct *proc) {
+     /* LAB6: YOUR CODE */
+        if (proc->time_slice > 0) {
+                proc->time_slice --;
+        }
+        if (proc->time_slice == 0) {
+                proc->need_resched = 1;
+        }
+}
+```
\ No newline at end of file
diff -r -u -P lab6_origin/.badarg.log lab6/.badarg.log
--- lab6_origin/.badarg.log	1970-01-01 08:00:00.000000000 +0800
+++ lab6/.badarg.log	2019-05-13 17:40:30.058186300 +0800
@@ -0,0 +1,112 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc010b8ec (phys)
+  edata  0xc01b0000 (phys)
+  end    0xc01b3178 (phys)
+Kernel executable memory footprint: 717KB
+ebp:0xc012bf48 eip:0xc0100b65 args:0x00010094 0x00010094 0xc012bf78 0xc01000d1 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc012bf58 eip:0xc0100e65 args:0x00000000 0x00000000 0x00000000 0xc012bfc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc012bf78 eip:0xc01000d1 args:0x00000000 0xc012bfa0 0xffff0000 0xc012bfa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc012bf98 eip:0xc01000f3 args:0x00000000 0xffff0000 0xc012bfc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc012bfb8 eip:0xc0100110 args:0x00000000 0xc0100036 0xffff0000 0xc0100079 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc012bfd8 eip:0xc0100131 args:0x00000000 0x00000000 0x00000000 0xc010b900 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc012bff8 eip:0xc0100086 args:0xc010bafc 0xc010bb04 0xc0100dee 0xc010bb23 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 31818, total 31818
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 5, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+kernel_execve: pid = 2, name = "badarg".
+fork ok.
+badarg pass.
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:477:
+    initproc exit.
+
+stack trackback:
+ebp:0xc0395f98 eip:0xc0100b65 args:0x00000018 0x00000000 0x00000010 0xc0395fcc 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc0395fb8 eip:0xc0100461 args:0xc010d994 0x000001dd 0xc010d9e6 0x00000000 
+    kern/debug/panic.c:27: __panic+107
+ebp:0xc0395fe8 eip:0xc0109511 args:0x00000000 0x00000000 0x00000000 0x00000010 
+    kern/process/proc.c:477: do_exit+81
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -r -u -P lab6_origin/.badsegment.log lab6/.badsegment.log
--- lab6_origin/.badsegment.log	1970-01-01 08:00:00.000000000 +0800
+++ lab6/.badsegment.log	2019-05-13 17:39:54.467391300 +0800
@@ -0,0 +1,131 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc010b8ec (phys)
+  edata  0xc01b0000 (phys)
+  end    0xc01b3178 (phys)
+Kernel executable memory footprint: 717KB
+ebp:0xc012bf48 eip:0xc0100b65 args:0x00010094 0x00010094 0xc012bf78 0xc01000d1 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc012bf58 eip:0xc0100e65 args:0x00000000 0x00000000 0x00000000 0xc012bfc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc012bf78 eip:0xc01000d1 args:0x00000000 0xc012bfa0 0xffff0000 0xc012bfa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc012bf98 eip:0xc01000f3 args:0x00000000 0xffff0000 0xc012bfc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc012bfb8 eip:0xc0100110 args:0x00000000 0xc0100036 0xffff0000 0xc0100079 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc012bfd8 eip:0xc0100131 args:0x00000000 0x00000000 0x00000000 0xc010b900 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc012bff8 eip:0xc0100086 args:0xc010bafc 0xc010bb04 0xc0100dee 0xc010bb23 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 31818, total 31818
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 5, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+kernel_execve: pid = 2, name = "badsegment".
+trapframe at 0xc039cfb4
+  edi  0x00000000
+  esi  0x00000000
+  ebp  0xafffffa8
+  oesp 0xc039cfd4
+  ebx  0x00000000
+  edx  0x00000000
+  ecx  0xafffffc0
+  eax  0x00000028
+  ds   0x----0023
+  es   0x----0023
+  fs   0x----0000
+  gs   0x----0000
+  trap 0x0000000d General Protection
+  err  0x00000028
+  eip  0x00800f40
+  cs   0x----001b
+  flag 0x00000286 PF,SF,IF,IOPL=0
+  esp  0xafffffa0
+  ss   0x----0023
+unhandled trap.
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:477:
+    initproc exit.
+
+stack trackback:
+ebp:0xc0395f98 eip:0xc0100b65 args:0x00000018 0x00000000 0x00000000 0xc0395fcc 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc0395fb8 eip:0xc0100461 args:0xc010d994 0x000001dd 0xc010d9e6 0x00000000 
+    kern/debug/panic.c:27: __panic+107
+ebp:0xc0395fe8 eip:0xc0109511 args:0x00000000 0x00000000 0x00000000 0x00000010 
+    kern/process/proc.c:477: do_exit+81
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
Binary files lab6_origin/bin/bootblock and lab6/bin/bootblock differ
Binary files lab6_origin/bin/kernel and lab6/bin/kernel differ
Binary files lab6_origin/bin/sign and lab6/bin/sign differ
Binary files lab6_origin/bin/swap.img and lab6/bin/swap.img differ
Binary files lab6_origin/bin/ucore.img and lab6/bin/ucore.img differ
diff -r -u -P lab6_origin/boot/asm.h lab6/boot/asm.h
--- lab6_origin/boot/asm.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/boot/asm.h	2019-02-26 20:51:17.029426000 +0800
@@ -0,0 +1,26 @@
+#ifndef __BOOT_ASM_H__
+#define __BOOT_ASM_H__
+
+/* Assembler macros to create x86 segments */
+
+/* Normal segment */
+#define SEG_NULLASM                                             \
+    .word 0, 0;                                                 \
+    .byte 0, 0, 0, 0
+
+#define SEG_ASM(type,base,lim)                                  \
+    .word (((lim) >> 12) & 0xffff), ((base) & 0xffff);          \
+    .byte (((base) >> 16) & 0xff), (0x90 | (type)),             \
+        (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
+
+
+/* Application segment type bits */
+#define STA_X       0x8     // Executable segment
+#define STA_E       0x4     // Expand down (non-executable segments)
+#define STA_C       0x4     // Conforming code segment (executable only)
+#define STA_W       0x2     // Writeable (non-executable segments)
+#define STA_R       0x2     // Readable (executable segments)
+#define STA_A       0x1     // Accessed
+
+#endif /* !__BOOT_ASM_H__ */
+
diff -r -u -P lab6_origin/boot/bootasm.S lab6/boot/bootasm.S
--- lab6_origin/boot/bootasm.S	1970-01-01 08:00:00.000000000 +0800
+++ lab6/boot/bootasm.S	2019-02-26 20:51:17.029924900 +0800
@@ -0,0 +1,107 @@
+#include <asm.h>
+
+# Start the CPU: switch to 32-bit protected mode, jump into C.
+# The BIOS loads this code from the first sector of the hard disk into
+# memory at physical address 0x7c00 and starts executing in real mode
+# with %cs=0 %ip=7c00.
+
+.set PROT_MODE_CSEG,        0x8                     # kernel code segment selector
+.set PROT_MODE_DSEG,        0x10                    # kernel data segment selector
+.set CR0_PE_ON,             0x1                     # protected mode enable flag
+.set SMAP,                  0x534d4150
+
+# start address should be 0:7c00, in real mode, the beginning address of the running bootloader
+.globl start
+start:
+.code16                                             # Assemble for 16-bit mode
+    cli                                             # Disable interrupts
+    cld                                             # String operations increment
+
+    # Set up the important data segment registers (DS, ES, SS).
+    xorw %ax, %ax                                   # Segment number zero
+    movw %ax, %ds                                   # -> Data Segment
+    movw %ax, %es                                   # -> Extra Segment
+    movw %ax, %ss                                   # -> Stack Segment
+
+    # Enable A20:
+    #  For backwards compatibility with the earliest PCs, physical
+    #  address line 20 is tied low, so that addresses higher than
+    #  1MB wrap around to zero by default. This code undoes this.
+seta20.1:
+    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
+    testb $0x2, %al
+    jnz seta20.1
+
+    movb $0xd1, %al                                 # 0xd1 -> port 0x64
+    outb %al, $0x64                                 # 0xd1 means: write data to 8042's P2 port
+
+seta20.2:
+    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
+    testb $0x2, %al
+    jnz seta20.2
+
+    movb $0xdf, %al                                 # 0xdf -> port 0x60
+    outb %al, $0x60                                 # 0xdf = 11011111, means set P2's A20 bit(the 1 bit) to 1
+
+probe_memory:
+    movl $0, 0x8000
+    xorl %ebx, %ebx
+    movw $0x8004, %di
+start_probe:
+    movl $0xE820, %eax
+    movl $20, %ecx
+    movl $SMAP, %edx
+    int $0x15
+    jnc cont
+    movw $12345, 0x8000
+    jmp finish_probe
+cont:
+    addw $20, %di
+    incl 0x8000
+    cmpl $0, %ebx
+    jnz start_probe
+finish_probe:
+
+    # Switch from real to protected mode, using a bootstrap GDT
+    # and segment translation that makes virtual addresses
+    # identical to physical addresses, so that the
+    # effective memory map does not change during the switch.
+    lgdt gdtdesc
+    movl %cr0, %eax
+    orl $CR0_PE_ON, %eax
+    movl %eax, %cr0
+
+    # Jump to next instruction, but in 32-bit code segment.
+    # Switches processor into 32-bit mode.
+    ljmp $PROT_MODE_CSEG, $protcseg
+
+.code32                                             # Assemble for 32-bit mode
+protcseg:
+    # Set up the protected-mode data segment registers
+    movw $PROT_MODE_DSEG, %ax                       # Our data segment selector
+    movw %ax, %ds                                   # -> DS: Data Segment
+    movw %ax, %es                                   # -> ES: Extra Segment
+    movw %ax, %fs                                   # -> FS
+    movw %ax, %gs                                   # -> GS
+    movw %ax, %ss                                   # -> SS: Stack Segment
+
+    # Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00)
+    movl $0x0, %ebp
+    movl $start, %esp
+    call bootmain
+
+    # If bootmain returns (it shouldn't), loop.
+spin:
+    jmp spin
+
+.data
+# Bootstrap GDT
+.p2align 2                                          # force 4 byte alignment
+gdt:
+    SEG_NULLASM                                     # null seg
+    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel
+    SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel
+
+gdtdesc:
+    .word 0x17                                      # sizeof(gdt) - 1
+    .long gdt                                       # address gdt
diff -r -u -P lab6_origin/boot/bootmain.c lab6/boot/bootmain.c
--- lab6_origin/boot/bootmain.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/boot/bootmain.c	2019-02-26 20:51:17.030922700 +0800
@@ -0,0 +1,116 @@
+#include <defs.h>
+#include <x86.h>
+#include <elf.h>
+
+/* *********************************************************************
+ * This a dirt simple boot loader, whose sole job is to boot
+ * an ELF kernel image from the first IDE hard disk.
+ *
+ * DISK LAYOUT
+ *  * This program(bootasm.S and bootmain.c) is the bootloader.
+ *    It should be stored in the first sector of the disk.
+ *
+ *  * The 2nd sector onward holds the kernel image.
+ *
+ *  * The kernel image must be in ELF format.
+ *
+ * BOOT UP STEPS
+ *  * when the CPU boots it loads the BIOS into memory and executes it
+ *
+ *  * the BIOS intializes devices, sets of the interrupt routines, and
+ *    reads the first sector of the boot device(e.g., hard-drive)
+ *    into memory and jumps to it.
+ *
+ *  * Assuming this boot loader is stored in the first sector of the
+ *    hard-drive, this code takes over...
+ *
+ *  * control starts in bootasm.S -- which sets up protected mode,
+ *    and a stack so C code then run, then calls bootmain()
+ *
+ *  * bootmain() in this file takes over, reads in the kernel and jumps to it.
+ * */
+
+#define SECTSIZE        512
+#define ELFHDR          ((struct elfhdr *)0x10000)      // scratch space
+
+/* waitdisk - wait for disk ready */
+static void
+waitdisk(void) {
+    while ((inb(0x1F7) & 0xC0) != 0x40)
+        /* do nothing */;
+}
+
+/* readsect - read a single sector at @secno into @dst */
+static void
+readsect(void *dst, uint32_t secno) {
+    // wait for disk to be ready
+    waitdisk();
+
+    outb(0x1F2, 1);                         // count = 1
+    outb(0x1F3, secno & 0xFF);
+    outb(0x1F4, (secno >> 8) & 0xFF);
+    outb(0x1F5, (secno >> 16) & 0xFF);
+    outb(0x1F6, ((secno >> 24) & 0xF) | 0xE0);
+    outb(0x1F7, 0x20);                      // cmd 0x20 - read sectors
+
+    // wait for disk to be ready
+    waitdisk();
+
+    // read a sector
+    insl(0x1F0, dst, SECTSIZE / 4);
+}
+
+/* *
+ * readseg - read @count bytes at @offset from kernel into virtual address @va,
+ * might copy more than asked.
+ * */
+static void
+readseg(uintptr_t va, uint32_t count, uint32_t offset) {
+    uintptr_t end_va = va + count;
+
+    // round down to sector boundary
+    va -= offset % SECTSIZE;
+
+    // translate from bytes to sectors; kernel starts at sector 1
+    uint32_t secno = (offset / SECTSIZE) + 1;
+
+    // If this is too slow, we could read lots of sectors at a time.
+    // We'd write more to memory than asked, but it doesn't matter --
+    // we load in increasing order.
+    for (; va < end_va; va += SECTSIZE, secno ++) {
+        readsect((void *)va, secno);
+    }
+}
+
+/* bootmain - the entry of bootloader */
+void
+bootmain(void) {
+    // read the 1st page off disk
+    readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);
+
+    // is this a valid ELF?
+    if (ELFHDR->e_magic != ELF_MAGIC) {
+        goto bad;
+    }
+
+    struct proghdr *ph, *eph;
+
+    // load each program segment (ignores ph flags)
+    ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR->e_phoff);
+    eph = ph + ELFHDR->e_phnum;
+    for (; ph < eph; ph ++) {
+        readseg(ph->p_va & 0xFFFFFF, ph->p_memsz, ph->p_offset);
+    }
+
+    // call the entry point from the ELF header
+    // note: does not return
+    ((void (*)(void))(ELFHDR->e_entry & 0xFFFFFF))();
+
+bad:
+    outw(0x8A00, 0x8A00);
+    outw(0x8A00, 0x8E00);
+
+    /* do nothing */
+    while (1);
+}
+
diff -r -u -P lab6_origin/.divzero.log lab6/.divzero.log
--- lab6_origin/.divzero.log	1970-01-01 08:00:00.000000000 +0800
+++ lab6/.divzero.log	2019-05-13 17:39:58.471620400 +0800
@@ -0,0 +1,131 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc010b8ec (phys)
+  edata  0xc01b0000 (phys)
+  end    0xc01b3178 (phys)
+Kernel executable memory footprint: 717KB
+ebp:0xc012bf48 eip:0xc0100b65 args:0x00010094 0x00010094 0xc012bf78 0xc01000d1 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc012bf58 eip:0xc0100e65 args:0x00000000 0x00000000 0x00000000 0xc012bfc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc012bf78 eip:0xc01000d1 args:0x00000000 0xc012bfa0 0xffff0000 0xc012bfa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc012bf98 eip:0xc01000f3 args:0x00000000 0xffff0000 0xc012bfc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc012bfb8 eip:0xc0100110 args:0x00000000 0xc0100036 0xffff0000 0xc0100079 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc012bfd8 eip:0xc0100131 args:0x00000000 0x00000000 0x00000000 0xc010b900 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc012bff8 eip:0xc0100086 args:0xc010bafc 0xc010bb04 0xc0100dee 0xc010bb23 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 31818, total 31818
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 5, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+kernel_execve: pid = 2, name = "divzero".
+trapframe at 0xc039cfb4
+  edi  0x00000000
+  esi  0x00000000
+  ebp  0xafffffa8
+  oesp 0xc039cfd4
+  ebx  0x00000000
+  edx  0x00000000
+  ecx  0x00000000
+  eax  0x00000001
+  ds   0x----0023
+  es   0x----0023
+  fs   0x----0000
+  gs   0x----0000
+  trap 0x00000000 Divide error
+  err  0x00000000
+  eip  0x00800f48
+  cs   0x----001b
+  flag 0x00000286 PF,SF,IF,IOPL=0
+  esp  0xafffffa0
+  ss   0x----0023
+unhandled trap.
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:477:
+    initproc exit.
+
+stack trackback:
+ebp:0xc0395f98 eip:0xc0100b65 args:0x00000018 0x00000000 0x00000000 0xc0395fcc 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc0395fb8 eip:0xc0100461 args:0xc010d994 0x000001dd 0xc010d9e6 0x00000000 
+    kern/debug/panic.c:27: __panic+107
+ebp:0xc0395fe8 eip:0xc0109511 args:0x00000000 0x00000000 0x00000000 0x00000010 
+    kern/process/proc.c:477: do_exit+81
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -r -u -P lab6_origin/.exit.log lab6/.exit.log
--- lab6_origin/.exit.log	1970-01-01 08:00:00.000000000 +0800
+++ lab6/.exit.log	2019-05-13 17:40:34.089391900 +0800
@@ -0,0 +1,116 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc010b8ec (phys)
+  edata  0xc01b0000 (phys)
+  end    0xc01b3178 (phys)
+Kernel executable memory footprint: 717KB
+ebp:0xc012bf48 eip:0xc0100b65 args:0x00010094 0x00010094 0xc012bf78 0xc01000d1 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc012bf58 eip:0xc0100e65 args:0x00000000 0x00000000 0x00000000 0xc012bfc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc012bf78 eip:0xc01000d1 args:0x00000000 0xc012bfa0 0xffff0000 0xc012bfa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc012bf98 eip:0xc01000f3 args:0x00000000 0xffff0000 0xc012bfc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc012bfb8 eip:0xc0100110 args:0x00000000 0xc0100036 0xffff0000 0xc0100079 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc012bfd8 eip:0xc0100131 args:0x00000000 0x00000000 0x00000000 0xc010b900 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc012bff8 eip:0xc0100086 args:0xc010bafc 0xc010bb04 0xc0100dee 0xc010bb23 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 31818, total 31818
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 5, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+kernel_execve: pid = 2, name = "exit".
+I am the parent. Forking the child...
+I am parent, fork a child pid 3
+I am the parent, waiting now..
+I am the child.
+waitpid 3 ok.
+exit pass.
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:477:
+    initproc exit.
+
+stack trackback:
+ebp:0xc0395f98 eip:0xc0100b65 args:0x00000018 0x00000000 0x00000000 0xc0395fcc 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc0395fb8 eip:0xc0100461 args:0xc010d994 0x000001dd 0xc010d9e6 0x00000000 
+    kern/debug/panic.c:27: __panic+107
+ebp:0xc0395fe8 eip:0xc0109511 args:0x00000000 0x00000000 0x00000000 0x00000010 
+    kern/process/proc.c:477: do_exit+81
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -r -u -P lab6_origin/.faultreadkernel.log lab6/.faultreadkernel.log
--- lab6_origin/.faultreadkernel.log	1970-01-01 08:00:00.000000000 +0800
+++ lab6/.faultreadkernel.log	2019-05-13 17:40:10.516613700 +0800
@@ -0,0 +1,136 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc010b8ec (phys)
+  edata  0xc01b0000 (phys)
+  end    0xc01b3178 (phys)
+Kernel executable memory footprint: 717KB
+ebp:0xc012bf48 eip:0xc0100b65 args:0x00010094 0x00010094 0xc012bf78 0xc01000d1 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc012bf58 eip:0xc0100e65 args:0x00000000 0x00000000 0x00000000 0xc012bfc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc012bf78 eip:0xc01000d1 args:0x00000000 0xc012bfa0 0xffff0000 0xc012bfa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc012bf98 eip:0xc01000f3 args:0x00000000 0xffff0000 0xc012bfc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc012bfb8 eip:0xc0100110 args:0x00000000 0xc0100036 0xffff0000 0xc0100079 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc012bfd8 eip:0xc0100131 args:0x00000000 0x00000000 0x00000000 0xc010b900 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc012bff8 eip:0xc0100086 args:0xc010bafc 0xc010bb04 0xc0100dee 0xc010bb23 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 31818, total 31818
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 5, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+kernel_execve: pid = 2, name = "faultreadkernel".
+not valid addr fac00000, and  can not find it in vma
+trapframe at 0xc039cfb4
+  edi  0x00000000
+  esi  0x00000000
+  ebp  0xafffffa8
+  oesp 0xc039cfd4
+  ebx  0x00000000
+  edx  0x00000000
+  ecx  0xafffffc0
+  eax  0xfac00000
+  ds   0x----0023
+  es   0x----0023
+  fs   0x----0000
+  gs   0x----0000
+  trap 0x0000000e Page Fault
+  err  0x00000005
+  eip  0x00800f41
+  cs   0x----001b
+  flag 0x00000286 PF,SF,IF,IOPL=0
+  esp  0xafffffa0
+  ss   0x----0023
+killed by kernel.
+kernel panic at kern/trap/trap.c:213:
+    handle user mode pgfault failed. ret=-3
+
+stack trackback:
+ebp:0xc039cf28 eip:0xc0100b65 args:0xc010b3ac 0x0000000a 0xc039cf54 0xc039cf5c 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc039cf48 eip:0xc0100461 args:0xc010bd8e 0x000000d5 0xc010c030 0xfffffffd 
+    kern/debug/panic.c:27: __panic+107
+ebp:0xc039cf78 eip:0xc0102883 args:0xc039cfb4 0x00000000 0x00000023 0x00000023 
+    kern/trap/trap.c:213: trap_dispatch+266
+ebp:0xc039cfa8 eip:0xc01029d7 args:0xc039cfb4 0x00000000 0x00000000 0xafffffa8 
+    kern/trap/trap.c:299: trap+80
+ebp:0xafffffa8 eip:0xc01034a3 args:0x00000000 0x00000000 0x00000000 0x00800358 
+    kern/trap/trapentry.S:24: <unknown>+0
+ebp:0xafffffd8 eip:0x00800358 args:0x00000000 0x00000000 0x00000000 0x00000000 
+    user/libs/umain.c:7: umain+10
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -r -u -P lab6_origin/.faultread.log lab6/.faultread.log
--- lab6_origin/.faultread.log	1970-01-01 08:00:00.000000000 +0800
+++ lab6/.faultread.log	2019-05-13 17:40:06.217008300 +0800
@@ -0,0 +1,136 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc010b8ec (phys)
+  edata  0xc01b0000 (phys)
+  end    0xc01b3178 (phys)
+Kernel executable memory footprint: 717KB
+ebp:0xc012bf48 eip:0xc0100b65 args:0x00010094 0x00010094 0xc012bf78 0xc01000d1 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc012bf58 eip:0xc0100e65 args:0x00000000 0x00000000 0x00000000 0xc012bfc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc012bf78 eip:0xc01000d1 args:0x00000000 0xc012bfa0 0xffff0000 0xc012bfa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc012bf98 eip:0xc01000f3 args:0x00000000 0xffff0000 0xc012bfc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc012bfb8 eip:0xc0100110 args:0x00000000 0xc0100036 0xffff0000 0xc0100079 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc012bfd8 eip:0xc0100131 args:0x00000000 0x00000000 0x00000000 0xc010b900 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc012bff8 eip:0xc0100086 args:0xc010bafc 0xc010bb04 0xc0100dee 0xc010bb23 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 31818, total 31818
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 5, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+kernel_execve: pid = 2, name = "faultread".
+not valid addr 0, and  can not find it in vma
+trapframe at 0xc039cfb4
+  edi  0x00000000
+  esi  0x00000000
+  ebp  0xafffffa8
+  oesp 0xc039cfd4
+  ebx  0x00000000
+  edx  0x00000000
+  ecx  0xafffffc0
+  eax  0x00000000
+  ds   0x----0023
+  es   0x----0023
+  fs   0x----0000
+  gs   0x----0000
+  trap 0x0000000e Page Fault
+  err  0x00000004
+  eip  0x00800f41
+  cs   0x----001b
+  flag 0x00000286 PF,SF,IF,IOPL=0
+  esp  0xafffffa0
+  ss   0x----0023
+killed by kernel.
+kernel panic at kern/trap/trap.c:213:
+    handle user mode pgfault failed. ret=-3
+
+stack trackback:
+ebp:0xc039cf28 eip:0xc0100b65 args:0xc010b3ac 0x0000000a 0xc039cf54 0xc039cf5c 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc039cf48 eip:0xc0100461 args:0xc010bd8e 0x000000d5 0xc010c030 0xfffffffd 
+    kern/debug/panic.c:27: __panic+107
+ebp:0xc039cf78 eip:0xc0102883 args:0xc039cfb4 0x00000000 0x00000023 0x00000023 
+    kern/trap/trap.c:213: trap_dispatch+266
+ebp:0xc039cfa8 eip:0xc01029d7 args:0xc039cfb4 0x00000000 0x00000000 0xafffffa8 
+    kern/trap/trap.c:299: trap+80
+ebp:0xafffffa8 eip:0xc01034a3 args:0x00000000 0x00000000 0x00000000 0x00800358 
+    kern/trap/trapentry.S:24: <unknown>+0
+ebp:0xafffffd8 eip:0x00800358 args:0x00000000 0x00000000 0x00000000 0x00000000 
+    user/libs/umain.c:7: umain+10
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -r -u -P lab6_origin/.forktest.log lab6/.forktest.log
--- lab6_origin/.forktest.log	1970-01-01 08:00:00.000000000 +0800
+++ lab6/.forktest.log	2019-05-13 17:40:46.547788100 +0800
@@ -0,0 +1,143 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc010b8ec (phys)
+  edata  0xc01b0000 (phys)
+  end    0xc01b3178 (phys)
+Kernel executable memory footprint: 717KB
+ebp:0xc012bf48 eip:0xc0100b65 args:0x00010094 0x00010094 0xc012bf78 0xc01000d1 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc012bf58 eip:0xc0100e65 args:0x00000000 0x00000000 0x00000000 0xc012bfc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc012bf78 eip:0xc01000d1 args:0x00000000 0xc012bfa0 0xffff0000 0xc012bfa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc012bf98 eip:0xc01000f3 args:0x00000000 0xffff0000 0xc012bfc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc012bfb8 eip:0xc0100110 args:0x00000000 0xc0100036 0xffff0000 0xc0100079 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc012bfd8 eip:0xc0100131 args:0x00000000 0x00000000 0x00000000 0xc010b900 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc012bff8 eip:0xc0100086 args:0xc010bafc 0xc010bb04 0xc0100dee 0xc010bb23 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 31818, total 31818
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 5, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+kernel_execve: pid = 2, name = "forktest".
+I am child 31
+I am child 30
+I am child 29
+I am child 28
+I am child 27
+I am child 26
+I am child 25
+I am child 24
+I am child 23
+I am child 22
+I am child 21
+I am child 20
+I am child 19
+I am child 18
+I am child 17
+I am child 16
+I am child 15
+I am child 14
+I am child 13
+I am child 12
+I am child 11
+I am child 10
+I am child 9
+I am child 8
+I am child 7
+I am child 6
+I am child 5
+I am child 4
+I am child 3
+I am child 2
+I am child 1
+I am child 0
+forktest pass.
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:477:
+    initproc exit.
+
+stack trackback:
+ebp:0xc0395f98 eip:0xc0100b65 args:0x00000018 0x00000000 0x00000000 0xc0395fcc 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc0395fb8 eip:0xc0100461 args:0xc010d994 0x000001dd 0xc010d9e6 0x00000000 
+    kern/debug/panic.c:27: __panic+107
+ebp:0xc0395fe8 eip:0xc0109511 args:0x00000000 0x00000000 0x00000000 0x00000010 
+    kern/process/proc.c:477: do_exit+81
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -r -u -P lab6_origin/.forktree.log lab6/.forktree.log
--- lab6_origin/.forktree.log	1970-01-01 08:00:00.000000000 +0800
+++ lab6/.forktree.log	2019-05-13 17:40:50.411935800 +0800
@@ -0,0 +1,141 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc010b8ec (phys)
+  edata  0xc01b0000 (phys)
+  end    0xc01b3178 (phys)
+Kernel executable memory footprint: 717KB
+ebp:0xc012bf48 eip:0xc0100b65 args:0x00010094 0x00010094 0xc012bf78 0xc01000d1 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc012bf58 eip:0xc0100e65 args:0x00000000 0x00000000 0x00000000 0xc012bfc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc012bf78 eip:0xc01000d1 args:0x00000000 0xc012bfa0 0xffff0000 0xc012bfa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc012bf98 eip:0xc01000f3 args:0x00000000 0xffff0000 0xc012bfc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc012bfb8 eip:0xc0100110 args:0x00000000 0xc0100036 0xffff0000 0xc0100079 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc012bfd8 eip:0xc0100131 args:0x00000000 0x00000000 0x00000000 0xc010b900 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc012bff8 eip:0xc0100086 args:0xc010bafc 0xc010bb04 0xc0100dee 0xc010bb23 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 31818, total 31818
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 5, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+kernel_execve: pid = 2, name = "forktree".
+0002: I am ''
+0004: I am '1'
+0006: I am '11'
+0008: I am '111'
+000a: I am '1111'
+0009: I am '1110'
+0007: I am '110'
+000c: I am '1101'
+000b: I am '1100'
+0005: I am '10'
+000e: I am '101'
+0010: I am '1011'
+000f: I am '1010'
+000d: I am '100'
+0012: I am '1001'
+0011: I am '1000'
+0003: I am '0'
+0014: I am '01'
+0016: I am '011'
+0018: I am '0111'
+0017: I am '0110'
+0015: I am '010'
+001a: I am '0101'
+0019: I am '0100'
+0013: I am '00'
+001c: I am '001'
+001e: I am '0011'
+001d: I am '0010'
+001b: I am '000'
+0020: I am '0001'
+001f: I am '0000'
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:477:
+    initproc exit.
+
+stack trackback:
+ebp:0xc0395f98 eip:0xc0100b65 args:0x00000018 0x00000000 0x00000000 0xc0395fcc 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc0395fb8 eip:0xc0100461 args:0xc010d994 0x000001dd 0xc010d9e6 0x00000000 
+    kern/debug/panic.c:27: __panic+107
+ebp:0xc0395fe8 eip:0xc0109511 args:0x00000000 0x00000000 0x00000000 0x00000010 
+    kern/process/proc.c:477: do_exit+81
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -r -u -P lab6_origin/.gdb.in lab6/.gdb.in
--- lab6_origin/.gdb.in	1970-01-01 08:00:00.000000000 +0800
+++ lab6/.gdb.in	2019-05-13 17:41:12.213517400 +0800
@@ -0,0 +1,4 @@
+target remote localhost:1234
+break *0xc0100333
+break *0x00100333
+continue
diff -r -u -P lab6_origin/.hello.log lab6/.hello.log
--- lab6_origin/.hello.log	1970-01-01 08:00:00.000000000 +0800
+++ lab6/.hello.log	2019-05-13 17:40:14.306287700 +0800
@@ -0,0 +1,113 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc010b8ec (phys)
+  edata  0xc01b0000 (phys)
+  end    0xc01b3178 (phys)
+Kernel executable memory footprint: 717KB
+ebp:0xc012bf48 eip:0xc0100b65 args:0x00010094 0x00010094 0xc012bf78 0xc01000d1 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc012bf58 eip:0xc0100e65 args:0x00000000 0x00000000 0x00000000 0xc012bfc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc012bf78 eip:0xc01000d1 args:0x00000000 0xc012bfa0 0xffff0000 0xc012bfa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc012bf98 eip:0xc01000f3 args:0x00000000 0xffff0000 0xc012bfc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc012bfb8 eip:0xc0100110 args:0x00000000 0xc0100036 0xffff0000 0xc0100079 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc012bfd8 eip:0xc0100131 args:0x00000000 0x00000000 0x00000000 0xc010b900 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc012bff8 eip:0xc0100086 args:0xc010bafc 0xc010bb04 0xc0100dee 0xc010bb23 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 31818, total 31818
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 5, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+kernel_execve: pid = 2, name = "hello".
+Hello world!!.
+I am process 2.
+hello pass.
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:477:
+    initproc exit.
+
+stack trackback:
+ebp:0xc0395f98 eip:0xc0100b65 args:0x00000018 0x00000000 0x00000000 0xc0395fcc 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc0395fb8 eip:0xc0100461 args:0xc010d994 0x000001dd 0xc010d9e6 0x00000000 
+    kern/debug/panic.c:27: __panic+107
+ebp:0xc0395fe8 eip:0xc0109511 args:0x00000000 0x00000000 0x00000000 0x00000010 
+    kern/process/proc.c:477: do_exit+81
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -r -u -P lab6_origin/kern/debug/assert.h lab6/kern/debug/assert.h
--- lab6_origin/kern/debug/assert.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/debug/assert.h	2019-02-26 20:51:17.033419000 +0800
@@ -0,0 +1,27 @@
+#ifndef __KERN_DEBUG_ASSERT_H__
+#define __KERN_DEBUG_ASSERT_H__
+
+#include <defs.h>
+
+void __warn(const char *file, int line, const char *fmt, ...);
+void __noreturn __panic(const char *file, int line, const char *fmt, ...);
+
+#define warn(...)                                       \
+    __warn(__FILE__, __LINE__, __VA_ARGS__)
+
+#define panic(...)                                      \
+    __panic(__FILE__, __LINE__, __VA_ARGS__)
+
+#define assert(x)                                       \
+    do {                                                \
+        if (!(x)) {                                     \
+            panic("assertion failed: %s", #x);          \
+        }                                               \
+    } while (0)
+
+// static_assert(x) will generate a compile-time error if 'x' is false.
+#define static_assert(x)                                \
+    switch (x) { case 0: case (x): ; }
+
+#endif /* !__KERN_DEBUG_ASSERT_H__ */
+
diff -r -u -P lab6_origin/kern/debug/kdebug.c lab6/kern/debug/kdebug.c
--- lab6_origin/kern/debug/kdebug.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/debug/kdebug.c	2019-05-06 16:46:09.733329600 +0800
@@ -0,0 +1,366 @@
+#include <defs.h>
+#include <x86.h>
+#include <stab.h>
+#include <stdio.h>
+#include <string.h>
+#include <memlayout.h>
+#include <sync.h>
+#include <vmm.h>
+#include <proc.h>
+#include <kdebug.h>
+#include <kmonitor.h>
+#include <assert.h>
+
+#define STACKFRAME_DEPTH 20
+
+extern const struct stab __STAB_BEGIN__[];  // beginning of stabs table
+extern const struct stab __STAB_END__[];    // end of stabs table
+extern const char __STABSTR_BEGIN__[];      // beginning of string table
+extern const char __STABSTR_END__[];        // end of string table
+
+/* debug information about a particular instruction pointer */
+struct eipdebuginfo {
+    const char *eip_file;                   // source code filename for eip
+    int eip_line;                           // source code line number for eip
+    const char *eip_fn_name;                // name of function containing eip
+    int eip_fn_namelen;                     // length of function's name
+    uintptr_t eip_fn_addr;                  // start address of function
+    int eip_fn_narg;                        // number of function arguments
+};
+
+/* user STABS data structure  */
+struct userstabdata {
+    const struct stab *stabs;
+    const struct stab *stab_end;
+    const char *stabstr;
+    const char *stabstr_end;
+};
+
+/* *
+ * stab_binsearch - according to the input, the initial value of
+ * range [*@region_left, *@region_right], find a single stab entry
+ * that includes the address @addr and matches the type @type,
+ * and then save its boundary to the locations that pointed
+ * by @region_left and @region_right.
+ *
+ * Some stab types are arranged in increasing order by instruction address.
+ * For example, N_FUN stabs (stab entries with n_type == N_FUN), which
+ * mark functions, and N_SO stabs, which mark source files.
+ *
+ * Given an instruction address, this function finds the single stab entry
+ * of type @type that contains that address.
+ *
+ * The search takes place within the range [*@region_left, *@region_right].
+ * Thus, to search an entire set of N stabs, you might do:
+ *
+ *      left = 0;
+ *      right = N - 1;    (rightmost stab)
+ *      stab_binsearch(stabs, &left, &right, type, addr);
+ *
+ * The search modifies *region_left and *region_right to bracket the @addr.
+ * *@region_left points to the matching stab that contains @addr,
+ * and *@region_right points just before the next stab.
+ * If *@region_left > *region_right, then @addr is not contained in any
+ * matching stab.
+ *
+ * For example, given these N_SO stabs:
+ *      Index  Type   Address
+ *      0      SO     f0100000
+ *      13     SO     f0100040
+ *      117    SO     f0100176
+ *      118    SO     f0100178
+ *      555    SO     f0100652
+ *      556    SO     f0100654
+ *      657    SO     f0100849
+ * this code:
+ *      left = 0, right = 657;
+ *      stab_binsearch(stabs, &left, &right, N_SO, 0xf0100184);
+ * will exit setting left = 118, right = 554.
+ * */
+static void
+stab_binsearch(const struct stab *stabs, int *region_left, int *region_right,
+           int type, uintptr_t addr) {
+    int l = *region_left, r = *region_right, any_matches = 0;
+
+    while (l <= r) {
+        int true_m = (l + r) / 2, m = true_m;
+
+        // search for earliest stab with right type
+        while (m >= l && stabs[m].n_type != type) {
+            m --;
+        }
+        if (m < l) {    // no match in [l, m]
+            l = true_m + 1;
+            continue;
+        }
+
+        // actual binary search
+        any_matches = 1;
+        if (stabs[m].n_value < addr) {
+            *region_left = m;
+            l = true_m + 1;
+        } else if (stabs[m].n_value > addr) {
+            *region_right = m - 1;
+            r = m - 1;
+        } else {
+            // exact match for 'addr', but continue loop to find
+            // *region_right
+            *region_left = m;
+            l = m;
+            addr ++;
+        }
+    }
+
+    if (!any_matches) {
+        *region_right = *region_left - 1;
+    }
+    else {
+        // find rightmost region containing 'addr'
+        l = *region_right;
+        for (; l > *region_left && stabs[l].n_type != type; l --)
+            /* do nothing */;
+        *region_left = l;
+    }
+}
+
+/* *
+ * debuginfo_eip - Fill in the @info structure with information about
+ * the specified instruction address, @addr.  Returns 0 if information
+ * was found, and negative if not.  But even if it returns negative it
+ * has stored some information into '*info'.
+ * */
+int
+debuginfo_eip(uintptr_t addr, struct eipdebuginfo *info) {
+    const struct stab *stabs, *stab_end;
+    const char *stabstr, *stabstr_end;
+
+    info->eip_file = "<unknown>";
+    info->eip_line = 0;
+    info->eip_fn_name = "<unknown>";
+    info->eip_fn_namelen = 9;
+    info->eip_fn_addr = addr;
+    info->eip_fn_narg = 0;
+
+    // find the relevant set of stabs
+    if (addr >= KERNBASE) {
+        stabs = __STAB_BEGIN__;
+        stab_end = __STAB_END__;
+        stabstr = __STABSTR_BEGIN__;
+        stabstr_end = __STABSTR_END__;
+    }
+    else {
+        // user-program linker script, tools/user.ld puts the information about the
+        // program's stabs (included __STAB_BEGIN__, __STAB_END__, __STABSTR_BEGIN__,
+        // and __STABSTR_END__) in a structure located at virtual address USTAB.
+        const struct userstabdata *usd = (struct userstabdata *)USTAB;
+
+        // make sure that debugger (current process) can access this memory
+        struct mm_struct *mm;
+        if (current == NULL || (mm = current->mm) == NULL) {
+            return -1;
+        }
+        if (!user_mem_check(mm, (uintptr_t)usd, sizeof(struct userstabdata), 0)) {
+            return -1;
+        }
+
+        stabs = usd->stabs;
+        stab_end = usd->stab_end;
+        stabstr = usd->stabstr;
+        stabstr_end = usd->stabstr_end;
+
+        // make sure the STABS and string table memory is valid
+        if (!user_mem_check(mm, (uintptr_t)stabs, (uintptr_t)stab_end - (uintptr_t)stabs, 0)) {
+            return -1;
+        }
+        if (!user_mem_check(mm, (uintptr_t)stabstr, stabstr_end - stabstr, 0)) {
+            return -1;
+        }
+    }
+
+    // String table validity checks
+    if (stabstr_end <= stabstr || stabstr_end[-1] != 0) {
+        return -1;
+    }
+
+    // Now we find the right stabs that define the function containing
+    // 'eip'.  First, we find the basic source file containing 'eip'.
+    // Then, we look in that source file for the function.  Then we look
+    // for the line number.
+
+    // Search the entire set of stabs for the source file (type N_SO).
+    int lfile = 0, rfile = (stab_end - stabs) - 1;
+    stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
+    if (lfile == 0)
+        return -1;
+
+    // Search within that file's stabs for the function definition
+    // (N_FUN).
+    int lfun = lfile, rfun = rfile;
+    int lline, rline;
+    stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
+
+    if (lfun <= rfun) {
+        // stabs[lfun] points to the function name
+        // in the string table, but check bounds just in case.
+        if (stabs[lfun].n_strx < stabstr_end - stabstr) {
+            info->eip_fn_name = stabstr + stabs[lfun].n_strx;
+        }
+        info->eip_fn_addr = stabs[lfun].n_value;
+        addr -= info->eip_fn_addr;
+        // Search within the function definition for the line number.
+        lline = lfun;
+        rline = rfun;
+    } else {
+        // Couldn't find function stab!  Maybe we're in an assembly
+        // file.  Search the whole file for the line number.
+        info->eip_fn_addr = addr;
+        lline = lfile;
+        rline = rfile;
+    }
+    info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
+
+    // Search within [lline, rline] for the line number stab.
+    // If found, set info->eip_line to the right line number.
+    // If not found, return -1.
+    stab_binsearch(stabs, &lline, &rline, N_SLINE, addr);
+    if (lline <= rline) {
+        info->eip_line = stabs[rline].n_desc;
+    } else {
+        return -1;
+    }
+
+    // Search backwards from the line number for the relevant filename stab.
+    // We can't just use the "lfile" stab because inlined functions
+    // can interpolate code from a different file!
+    // Such included source files use the N_SOL stab type.
+    while (lline >= lfile
+           && stabs[lline].n_type != N_SOL
+           && (stabs[lline].n_type != N_SO || !stabs[lline].n_value)) {
+        lline --;
+    }
+    if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr) {
+        info->eip_file = stabstr + stabs[lline].n_strx;
+    }
+
+    // Set eip_fn_narg to the number of arguments taken by the function,
+    // or 0 if there was no containing function.
+    if (lfun < rfun) {
+        for (lline = lfun + 1;
+             lline < rfun && stabs[lline].n_type == N_PSYM;
+             lline ++) {
+            info->eip_fn_narg ++;
+        }
+    }
+    return 0;
+}
+
+/* *
+ * print_kerninfo - print the information about kernel, including the location
+ * of kernel entry, the start addresses of data and text segements, the start
+ * address of free memory and how many memory that kernel has used.
+ * */
+void
+print_kerninfo(void) {
+    extern char etext[], edata[], end[], kern_init[];
+    cprintf("Special kernel symbols:\n");
+    cprintf("  entry  0x%08x (phys)\n", kern_init);
+    cprintf("  etext  0x%08x (phys)\n", etext);
+    cprintf("  edata  0x%08x (phys)\n", edata);
+    cprintf("  end    0x%08x (phys)\n", end);
+    cprintf("Kernel executable memory footprint: %dKB\n", (end - kern_init + 1023)/1024);
+}
+
+/* *
+ * print_debuginfo - read and print the stat information for the address @eip,
+ * and info.eip_fn_addr should be the first address of the related function.
+ * */
+void
+print_debuginfo(uintptr_t eip) {
+    struct eipdebuginfo info;
+    if (debuginfo_eip(eip, &info) != 0) {
+        cprintf("    <unknow>: -- 0x%08x --\n", eip);
+    }
+    else {
+        char fnname[256];
+        int j;
+        for (j = 0; j < info.eip_fn_namelen; j ++) {
+            fnname[j] = info.eip_fn_name[j];
+        }
+        fnname[j] = '\0';
+        cprintf("    %s:%d: %s+%d\n", info.eip_file, info.eip_line,
+                fnname, eip - info.eip_fn_addr);
+    }
+}
+
+static __noinline uint32_t
+read_eip(void) {
+    uint32_t eip;
+    asm volatile("movl 4(%%ebp), %0" : "=r" (eip));
+    return eip;
+}
+
+/* *
+ * print_stackframe - print a list of the saved eip values from the nested 'call'
+ * instructions that led to the current point of execution
+ *
+ * The x86 stack pointer, namely esp, points to the lowest location on the stack
+ * that is currently in use. Everything below that location in stack is free. Pushing
+ * a value onto the stack will invole decreasing the stack pointer and then writing
+ * the value to the place that stack pointer pointes to. And popping a value do the
+ * opposite.
+ *
+ * The ebp (base pointer) register, in contrast, is associated with the stack
+ * primarily by software convention. On entry to a C function, the function's
+ * prologue code normally saves the previous function's base pointer by pushing
+ * it onto the stack, and then copies the current esp value into ebp for the duration
+ * of the function. If all the functions in a program obey this convention,
+ * then at any given point during the program's execution, it is possible to trace
+ * back through the stack by following the chain of saved ebp pointers and determining
+ * exactly what nested sequence of function calls caused this particular point in the
+ * program to be reached. This capability can be particularly useful, for example,
+ * when a particular function causes an assert failure or panic because bad arguments
+ * were passed to it, but you aren't sure who passed the bad arguments. A stack
+ * backtrace lets you find the offending function.
+ *
+ * The inline function read_ebp() can tell us the value of current ebp. And the
+ * non-inline function read_eip() is useful, it can read the value of current eip,
+ * since while calling this function, read_eip() can read the caller's eip from
+ * stack easily.
+ *
+ * In print_debuginfo(), the function debuginfo_eip() can get enough information about
+ * calling-chain. Finally print_stackframe() will trace and print them for debugging.
+ *
+ * Note that, the length of ebp-chain is limited. In boot/bootasm.S, before jumping
+ * to the kernel entry, the value of ebp has been set to zero, that's the boundary.
+ * */
+void
+print_stackframe(void) {
+     /* LAB1 YOUR CODE : STEP 1 */
+     /* (1) call read_ebp() to get the value of ebp. the type is (uint32_t);
+      * (2) call read_eip() to get the value of eip. the type is (uint32_t);
+      * (3) from 0 .. STACKFRAME_DEPTH
+      *    (3.1) printf value of ebp, eip
+      *    (3.2) (uint32_t)calling arguments [0..4] = the contents in address (uint32_t)ebp +2 [0..4]
+      *    (3.3) cprintf("\n");
+      *    (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.
+      *    (3.5) popup a calling stackframe
+      *           NOTICE: the calling funciton's return addr eip  = ss:[ebp+4]
+      *                   the calling funciton's ebp = ss:[ebp]
+      */
+    uint32_t my_ebp = read_ebp();
+    uint32_t my_eip = read_eip();
+
+    int i, j;
+    for (i = 0; my_ebp != 0 && i < STACKFRAME_DEPTH; i ++) {
+        cprintf("ebp:0x%08x eip:0x%08x args:", my_ebp, my_eip);
+        uint32_t *args = (uint32_t *)my_ebp + 2;
+        for (j = 0; j < 4; j ++) {
+            cprintf("0x%08x ", args[j]);
+        }
+    cprintf("\n");
+    print_debuginfo(my_eip - 1);
+    my_eip = ((uint32_t *)my_ebp)[1];
+    my_ebp = ((uint32_t *)my_ebp)[0];
+    }
+}
+
diff -r -u -P lab6_origin/kern/debug/kdebug.h lab6/kern/debug/kdebug.h
--- lab6_origin/kern/debug/kdebug.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/debug/kdebug.h	2019-02-26 20:51:17.034917000 +0800
@@ -0,0 +1,12 @@
+#ifndef __KERN_DEBUG_KDEBUG_H__
+#define __KERN_DEBUG_KDEBUG_H__
+
+#include <defs.h>
+#include <trap.h>
+
+void print_kerninfo(void);
+void print_stackframe(void);
+void print_debuginfo(uintptr_t eip);
+
+#endif /* !__KERN_DEBUG_KDEBUG_H__ */
+
diff -r -u -P lab6_origin/kern/debug/kmonitor.c lab6/kern/debug/kmonitor.c
--- lab6_origin/kern/debug/kmonitor.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/debug/kmonitor.c	2019-02-26 20:51:17.035415500 +0800
@@ -0,0 +1,132 @@
+#include <stdio.h>
+#include <string.h>
+#include <mmu.h>
+#include <trap.h>
+#include <kmonitor.h>
+#include <kdebug.h>
+
+/* *
+ * Simple command-line kernel monitor useful for controlling the
+ * kernel and exploring the system interactively.
+ * */
+
+struct command {
+    const char *name;
+    const char *desc;
+    // return -1 to force monitor to exit
+    int(*func)(int argc, char **argv, struct trapframe *tf);
+};
+
+static struct command commands[] = {
+    {"help", "Display this list of commands.", mon_help},
+    {"kerninfo", "Display information about the kernel.", mon_kerninfo},
+    {"backtrace", "Print backtrace of stack frame.", mon_backtrace},
+};
+
+/* return if kernel is panic, in kern/debug/panic.c */
+bool is_kernel_panic(void);
+
+#define NCOMMANDS (sizeof(commands)/sizeof(struct command))
+
+/***** Kernel monitor command interpreter *****/
+
+#define MAXARGS         16
+#define WHITESPACE      " \t\n\r"
+
+/* parse - parse the command buffer into whitespace-separated arguments */
+static int
+parse(char *buf, char **argv) {
+    int argc = 0;
+    while (1) {
+        // find global whitespace
+        while (*buf != '\0' && strchr(WHITESPACE, *buf) != NULL) {
+            *buf ++ = '\0';
+        }
+        if (*buf == '\0') {
+            break;
+        }
+
+        // save and scan past next arg
+        if (argc == MAXARGS - 1) {
+            cprintf("Too many arguments (max %d).\n", MAXARGS);
+        }
+        argv[argc ++] = buf;
+        while (*buf != '\0' && strchr(WHITESPACE, *buf) == NULL) {
+            buf ++;
+        }
+    }
+    return argc;
+}
+
+/* *
+ * runcmd - parse the input string, split it into separated arguments
+ * and then lookup and invoke some related commands/
+ * */
+static int
+runcmd(char *buf, struct trapframe *tf) {
+    char *argv[MAXARGS];
+    int argc = parse(buf, argv);
+    if (argc == 0) {
+        return 0;
+    }
+    int i;
+    for (i = 0; i < NCOMMANDS; i ++) {
+        if (strcmp(commands[i].name, argv[0]) == 0) {
+            return commands[i].func(argc - 1, argv + 1, tf);
+        }
+    }
+    cprintf("Unknown command '%s'\n", argv[0]);
+    return 0;
+}
+
+/***** Implementations of basic kernel monitor commands *****/
+
+void
+kmonitor(struct trapframe *tf) {
+    cprintf("Welcome to the kernel debug monitor!!\n");
+    cprintf("Type 'help' for a list of commands.\n");
+
+    if (tf != NULL) {
+        print_trapframe(tf);
+    }
+
+    char *buf;
+    while (1) {
+        if ((buf = readline("K> ")) != NULL) {
+            if (runcmd(buf, tf) < 0) {
+                break;
+            }
+        }
+    }
+}
+
+/* mon_help - print the information about mon_* functions */
+int
+mon_help(int argc, char **argv, struct trapframe *tf) {
+    int i;
+    for (i = 0; i < NCOMMANDS; i ++) {
+        cprintf("%s - %s\n", commands[i].name, commands[i].desc);
+    }
+    return 0;
+}
+
+/* *
+ * mon_kerninfo - call print_kerninfo in kern/debug/kdebug.c to
+ * print the memory occupancy in kernel.
+ * */
+int
+mon_kerninfo(int argc, char **argv, struct trapframe *tf) {
+    print_kerninfo();
+    return 0;
+}
+
+/* *
+ * mon_backtrace - call print_stackframe in kern/debug/kdebug.c to
+ * print a backtrace of the stack.
+ * */
+int
+mon_backtrace(int argc, char **argv, struct trapframe *tf) {
+    print_stackframe();
+    return 0;
+}
+
diff -r -u -P lab6_origin/kern/debug/kmonitor.h lab6/kern/debug/kmonitor.h
--- lab6_origin/kern/debug/kmonitor.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/debug/kmonitor.h	2019-02-26 20:51:17.035916200 +0800
@@ -0,0 +1,19 @@
+#ifndef __KERN_DEBUG_MONITOR_H__
+#define __KERN_DEBUG_MONITOR_H__
+
+#include <trap.h>
+
+void kmonitor(struct trapframe *tf);
+
+int mon_help(int argc, char **argv, struct trapframe *tf);
+int mon_kerninfo(int argc, char **argv, struct trapframe *tf);
+int mon_backtrace(int argc, char **argv, struct trapframe *tf);
+int mon_continue(int argc, char **argv, struct trapframe *tf);
+int mon_step(int argc, char **argv, struct trapframe *tf);
+int mon_breakpoint(int argc, char **argv, struct trapframe *tf);
+int mon_watchpoint(int argc, char **argv, struct trapframe *tf);
+int mon_delete_dr(int argc, char **argv, struct trapframe *tf);
+int mon_list_dr(int argc, char **argv, struct trapframe *tf);
+
+#endif /* !__KERN_DEBUG_MONITOR_H__ */
+
diff -r -u -P lab6_origin/kern/debug/panic.c lab6/kern/debug/panic.c
--- lab6_origin/kern/debug/panic.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/debug/panic.c	2019-02-26 20:51:17.036912700 +0800
@@ -0,0 +1,53 @@
+#include <defs.h>
+#include <stdio.h>
+#include <intr.h>
+#include <kmonitor.h>
+
+static bool is_panic = 0;
+
+/* *
+ * __panic - __panic is called on unresolvable fatal errors. it prints
+ * "panic: 'message'", and then enters the kernel monitor.
+ * */
+void
+__panic(const char *file, int line, const char *fmt, ...) {
+    if (is_panic) {
+        goto panic_dead;
+    }
+    is_panic = 1;
+
+    // print the 'message'
+    va_list ap;
+    va_start(ap, fmt);
+    cprintf("kernel panic at %s:%d:\n    ", file, line);
+    vcprintf(fmt, ap);
+    cprintf("\n");
+    
+    cprintf("stack trackback:\n");
+    print_stackframe();
+    
+    va_end(ap);
+
+panic_dead:
+    intr_disable();
+    while (1) {
+        kmonitor(NULL);
+    }
+}
+
+/* __warn - like panic, but don't */
+void
+__warn(const char *file, int line, const char *fmt, ...) {
+    va_list ap;
+    va_start(ap, fmt);
+    cprintf("kernel warning at %s:%d:\n    ", file, line);
+    vcprintf(fmt, ap);
+    cprintf("\n");
+    va_end(ap);
+}
+
+bool
+is_kernel_panic(void) {
+    return is_panic;
+}
+
diff -r -u -P lab6_origin/kern/debug/stab.h lab6/kern/debug/stab.h
--- lab6_origin/kern/debug/stab.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/debug/stab.h	2019-02-26 20:51:17.037911800 +0800
@@ -0,0 +1,54 @@
+#ifndef __KERN_DEBUG_STAB_H__
+#define __KERN_DEBUG_STAB_H__
+
+#include <defs.h>
+
+/* *
+ * STABS debugging info
+ *
+ * The kernel debugger can understand some debugging information in
+ * the STABS format.  For more information on this format, see
+ * http://sources.redhat.com/gdb/onlinedocs/stabs_toc.html
+ *
+ * The constants below define some symbol types used by various debuggers
+ * and compilers.  Kernel uses the N_SO, N_SOL, N_FUN, and N_SLINE types.
+ * */
+
+#define N_GSYM      0x20    // global symbol
+#define N_FNAME     0x22    // F77 function name
+#define N_FUN       0x24    // procedure name
+#define N_STSYM     0x26    // data segment variable
+#define N_LCSYM     0x28    // bss segment variable
+#define N_MAIN      0x2a    // main function name
+#define N_PC        0x30    // global Pascal symbol
+#define N_RSYM      0x40    // register variable
+#define N_SLINE     0x44    // text segment line number
+#define N_DSLINE    0x46    // data segment line number
+#define N_BSLINE    0x48    // bss segment line number
+#define N_SSYM      0x60    // structure/union element
+#define N_SO        0x64    // main source file name
+#define N_LSYM      0x80    // stack variable
+#define N_BINCL     0x82    // include file beginning
+#define N_SOL       0x84    // included source file name
+#define N_PSYM      0xa0    // parameter variable
+#define N_EINCL     0xa2    // include file end
+#define N_ENTRY     0xa4    // alternate entry point
+#define N_LBRAC     0xc0    // left bracket
+#define N_EXCL      0xc2    // deleted include file
+#define N_RBRAC     0xe0    // right bracket
+#define N_BCOMM     0xe2    // begin common
+#define N_ECOMM     0xe4    // end common
+#define N_ECOML     0xe8    // end common (local name)
+#define N_LENG      0xfe    // length of preceding entry
+
+/* Entries in the STABS table are formatted as follows. */
+struct stab {
+    uint32_t n_strx;        // index into string table of name
+    uint8_t n_type;         // type of symbol
+    uint8_t n_other;        // misc info (usually empty)
+    uint16_t n_desc;        // description field
+    uintptr_t n_value;      // value of symbol
+};
+
+#endif /* !__KERN_DEBUG_STAB_H__ */
+
diff -r -u -P lab6_origin/kern/driver/clock.c lab6/kern/driver/clock.c
--- lab6_origin/kern/driver/clock.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/driver/clock.c	2019-02-26 20:51:17.039408500 +0800
@@ -0,0 +1,45 @@
+#include <x86.h>
+#include <trap.h>
+#include <stdio.h>
+#include <picirq.h>
+
+/* *
+ * Support for time-related hardware gadgets - the 8253 timer,
+ * which generates interruptes on IRQ-0.
+ * */
+
+#define IO_TIMER1           0x040               // 8253 Timer #1
+
+/* *
+ * Frequency of all three count-down timers; (TIMER_FREQ/freq)
+ * is the appropriate count to generate a frequency of freq Hz.
+ * */
+
+#define TIMER_FREQ      1193182
+#define TIMER_DIV(x)    ((TIMER_FREQ + (x) / 2) / (x))
+
+#define TIMER_MODE      (IO_TIMER1 + 3)         // timer mode port
+#define TIMER_SEL0      0x00                    // select counter 0
+#define TIMER_RATEGEN   0x04                    // mode 2, rate generator
+#define TIMER_16BIT     0x30                    // r/w counter 16 bits, LSB first
+
+volatile size_t ticks;
+
+/* *
+ * clock_init - initialize 8253 clock to interrupt 100 times per second,
+ * and then enable IRQ_TIMER.
+ * */
+void
+clock_init(void) {
+    // set 8253 timer-chip
+    outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
+    outb(IO_TIMER1, TIMER_DIV(100) % 256);
+    outb(IO_TIMER1, TIMER_DIV(100) / 256);
+
+    // initialize time counter 'ticks' to zero
+    ticks = 0;
+
+    cprintf("++ setup timer interrupts\n");
+    pic_enable(IRQ_TIMER);
+}
+
diff -r -u -P lab6_origin/kern/driver/clock.h lab6/kern/driver/clock.h
--- lab6_origin/kern/driver/clock.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/driver/clock.h	2019-02-26 20:51:17.039906500 +0800
@@ -0,0 +1,11 @@
+#ifndef __KERN_DRIVER_CLOCK_H__
+#define __KERN_DRIVER_CLOCK_H__
+
+#include <defs.h>
+
+extern volatile size_t ticks;
+
+void clock_init(void);
+
+#endif /* !__KERN_DRIVER_CLOCK_H__ */
+
diff -r -u -P lab6_origin/kern/driver/console.c lab6/kern/driver/console.c
--- lab6_origin/kern/driver/console.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/driver/console.c	2019-02-26 20:51:17.040904400 +0800
@@ -0,0 +1,465 @@
+#include <defs.h>
+#include <x86.h>
+#include <stdio.h>
+#include <string.h>
+#include <kbdreg.h>
+#include <picirq.h>
+#include <trap.h>
+#include <memlayout.h>
+#include <sync.h>
+
+/* stupid I/O delay routine necessitated by historical PC design flaws */
+static void
+delay(void) {
+    inb(0x84);
+    inb(0x84);
+    inb(0x84);
+    inb(0x84);
+}
+
+/***** Serial I/O code *****/
+#define COM1            0x3F8
+
+#define COM_RX          0       // In:  Receive buffer (DLAB=0)
+#define COM_TX          0       // Out: Transmit buffer (DLAB=0)
+#define COM_DLL         0       // Out: Divisor Latch Low (DLAB=1)
+#define COM_DLM         1       // Out: Divisor Latch High (DLAB=1)
+#define COM_IER         1       // Out: Interrupt Enable Register
+#define COM_IER_RDI     0x01    // Enable receiver data interrupt
+#define COM_IIR         2       // In:  Interrupt ID Register
+#define COM_FCR         2       // Out: FIFO Control Register
+#define COM_LCR         3       // Out: Line Control Register
+#define COM_LCR_DLAB    0x80    // Divisor latch access bit
+#define COM_LCR_WLEN8   0x03    // Wordlength: 8 bits
+#define COM_MCR         4       // Out: Modem Control Register
+#define COM_MCR_RTS     0x02    // RTS complement
+#define COM_MCR_DTR     0x01    // DTR complement
+#define COM_MCR_OUT2    0x08    // Out2 complement
+#define COM_LSR         5       // In:  Line Status Register
+#define COM_LSR_DATA    0x01    // Data available
+#define COM_LSR_TXRDY   0x20    // Transmit buffer avail
+#define COM_LSR_TSRE    0x40    // Transmitter off
+
+#define MONO_BASE       0x3B4
+#define MONO_BUF        0xB0000
+#define CGA_BASE        0x3D4
+#define CGA_BUF         0xB8000
+#define CRT_ROWS        25
+#define CRT_COLS        80
+#define CRT_SIZE        (CRT_ROWS * CRT_COLS)
+
+#define LPTPORT         0x378
+
+static uint16_t *crt_buf;
+static uint16_t crt_pos;
+static uint16_t addr_6845;
+
+/* TEXT-mode CGA/VGA display output */
+
+static void
+cga_init(void) {
+    volatile uint16_t *cp = (uint16_t *)(CGA_BUF + KERNBASE);
+    uint16_t was = *cp;
+    *cp = (uint16_t) 0xA55A;
+    if (*cp != 0xA55A) {
+        cp = (uint16_t*)(MONO_BUF + KERNBASE);
+        addr_6845 = MONO_BASE;
+    } else {
+        *cp = was;
+        addr_6845 = CGA_BASE;
+    }
+
+    // Extract cursor location
+    uint32_t pos;
+    outb(addr_6845, 14);
+    pos = inb(addr_6845 + 1) << 8;
+    outb(addr_6845, 15);
+    pos |= inb(addr_6845 + 1);
+
+    crt_buf = (uint16_t*) cp;
+    crt_pos = pos;
+}
+
+static bool serial_exists = 0;
+
+static void
+serial_init(void) {
+    // Turn off the FIFO
+    outb(COM1 + COM_FCR, 0);
+
+    // Set speed; requires DLAB latch
+    outb(COM1 + COM_LCR, COM_LCR_DLAB);
+    outb(COM1 + COM_DLL, (uint8_t) (115200 / 9600));
+    outb(COM1 + COM_DLM, 0);
+
+    // 8 data bits, 1 stop bit, parity off; turn off DLAB latch
+    outb(COM1 + COM_LCR, COM_LCR_WLEN8 & ~COM_LCR_DLAB);
+
+    // No modem controls
+    outb(COM1 + COM_MCR, 0);
+    // Enable rcv interrupts
+    outb(COM1 + COM_IER, COM_IER_RDI);
+
+    // Clear any preexisting overrun indications and interrupts
+    // Serial port doesn't exist if COM_LSR returns 0xFF
+    serial_exists = (inb(COM1 + COM_LSR) != 0xFF);
+    (void) inb(COM1+COM_IIR);
+    (void) inb(COM1+COM_RX);
+
+    if (serial_exists) {
+        pic_enable(IRQ_COM1);
+    }
+}
+
+static void
+lpt_putc_sub(int c) {
+    int i;
+    for (i = 0; !(inb(LPTPORT + 1) & 0x80) && i < 12800; i ++) {
+        delay();
+    }
+    outb(LPTPORT + 0, c);
+    outb(LPTPORT + 2, 0x08 | 0x04 | 0x01);
+    outb(LPTPORT + 2, 0x08);
+}
+
+/* lpt_putc - copy console output to parallel port */
+static void
+lpt_putc(int c) {
+    if (c != '\b') {
+        lpt_putc_sub(c);
+    }
+    else {
+        lpt_putc_sub('\b');
+        lpt_putc_sub(' ');
+        lpt_putc_sub('\b');
+    }
+}
+
+/* cga_putc - print character to console */
+static void
+cga_putc(int c) {
+    // set black on white
+    if (!(c & ~0xFF)) {
+        c |= 0x0700;
+    }
+
+    switch (c & 0xff) {
+    case '\b':
+        if (crt_pos > 0) {
+            crt_pos --;
+            crt_buf[crt_pos] = (c & ~0xff) | ' ';
+        }
+        break;
+    case '\n':
+        crt_pos += CRT_COLS;
+    case '\r':
+        crt_pos -= (crt_pos % CRT_COLS);
+        break;
+    default:
+        crt_buf[crt_pos ++] = c;     // write the character
+        break;
+    }
+
+    // What is the purpose of this?
+    if (crt_pos >= CRT_SIZE) {
+        int i;
+        memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
+        for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i ++) {
+            crt_buf[i] = 0x0700 | ' ';
+        }
+        crt_pos -= CRT_COLS;
+    }
+
+    // move that little blinky thing
+    outb(addr_6845, 14);
+    outb(addr_6845 + 1, crt_pos >> 8);
+    outb(addr_6845, 15);
+    outb(addr_6845 + 1, crt_pos);
+}
+
+static void
+serial_putc_sub(int c) {
+    int i;
+    for (i = 0; !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800; i ++) {
+        delay();
+    }
+    outb(COM1 + COM_TX, c);
+}
+
+/* serial_putc - print character to serial port */
+static void
+serial_putc(int c) {
+    if (c != '\b') {
+        serial_putc_sub(c);
+    }
+    else {
+        serial_putc_sub('\b');
+        serial_putc_sub(' ');
+        serial_putc_sub('\b');
+    }
+}
+
+/* *
+ * Here we manage the console input buffer, where we stash characters
+ * received from the keyboard or serial port whenever the corresponding
+ * interrupt occurs.
+ * */
+
+#define CONSBUFSIZE 512
+
+static struct {
+    uint8_t buf[CONSBUFSIZE];
+    uint32_t rpos;
+    uint32_t wpos;
+} cons;
+
+/* *
+ * cons_intr - called by device interrupt routines to feed input
+ * characters into the circular console input buffer.
+ * */
+static void
+cons_intr(int (*proc)(void)) {
+    int c;
+    while ((c = (*proc)()) != -1) {
+        if (c != 0) {
+            cons.buf[cons.wpos ++] = c;
+            if (cons.wpos == CONSBUFSIZE) {
+                cons.wpos = 0;
+            }
+        }
+    }
+}
+
+/* serial_proc_data - get data from serial port */
+static int
+serial_proc_data(void) {
+    if (!(inb(COM1 + COM_LSR) & COM_LSR_DATA)) {
+        return -1;
+    }
+    int c = inb(COM1 + COM_RX);
+    if (c == 127) {
+        c = '\b';
+    }
+    return c;
+}
+
+/* serial_intr - try to feed input characters from serial port */
+void
+serial_intr(void) {
+    if (serial_exists) {
+        cons_intr(serial_proc_data);
+    }
+}
+
+/***** Keyboard input code *****/
+
+#define NO              0
+
+#define SHIFT           (1<<0)
+#define CTL             (1<<1)
+#define ALT             (1<<2)
+
+#define CAPSLOCK        (1<<3)
+#define NUMLOCK         (1<<4)
+#define SCROLLLOCK      (1<<5)
+
+#define E0ESC           (1<<6)
+
+static uint8_t shiftcode[256] = {
+    [0x1D] CTL,
+    [0x2A] SHIFT,
+    [0x36] SHIFT,
+    [0x38] ALT,
+    [0x9D] CTL,
+    [0xB8] ALT
+};
+
+static uint8_t togglecode[256] = {
+    [0x3A] CAPSLOCK,
+    [0x45] NUMLOCK,
+    [0x46] SCROLLLOCK
+};
+
+static uint8_t normalmap[256] = {
+    NO,   0x1B, '1',  '2',  '3',  '4',  '5',  '6',  // 0x00
+    '7',  '8',  '9',  '0',  '-',  '=',  '\b', '\t',
+    'q',  'w',  'e',  'r',  't',  'y',  'u',  'i',  // 0x10
+    'o',  'p',  '[',  ']',  '\n', NO,   'a',  's',
+    'd',  'f',  'g',  'h',  'j',  'k',  'l',  ';',  // 0x20
+    '\'', '`',  NO,   '\\', 'z',  'x',  'c',  'v',
+    'b',  'n',  'm',  ',',  '.',  '/',  NO,   '*',  // 0x30
+    NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
+    NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  // 0x40
+    '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
+    '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   // 0x50
+    [0xC7] KEY_HOME,    [0x9C] '\n' /*KP_Enter*/,
+    [0xB5] '/' /*KP_Div*/,  [0xC8] KEY_UP,
+    [0xC9] KEY_PGUP,    [0xCB] KEY_LF,
+    [0xCD] KEY_RT,      [0xCF] KEY_END,
+    [0xD0] KEY_DN,      [0xD1] KEY_PGDN,
+    [0xD2] KEY_INS,     [0xD3] KEY_DEL
+};
+
+static uint8_t shiftmap[256] = {
+    NO,   033,  '!',  '@',  '#',  '$',  '%',  '^',  // 0x00
+    '&',  '*',  '(',  ')',  '_',  '+',  '\b', '\t',
+    'Q',  'W',  'E',  'R',  'T',  'Y',  'U',  'I',  // 0x10
+    'O',  'P',  '{',  '}',  '\n', NO,   'A',  'S',
+    'D',  'F',  'G',  'H',  'J',  'K',  'L',  ':',  // 0x20
+    '"',  '~',  NO,   '|',  'Z',  'X',  'C',  'V',
+    'B',  'N',  'M',  '<',  '>',  '?',  NO,   '*',  // 0x30
+    NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
+    NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  // 0x40
+    '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
+    '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   // 0x50
+    [0xC7] KEY_HOME,    [0x9C] '\n' /*KP_Enter*/,
+    [0xB5] '/' /*KP_Div*/,  [0xC8] KEY_UP,
+    [0xC9] KEY_PGUP,    [0xCB] KEY_LF,
+    [0xCD] KEY_RT,      [0xCF] KEY_END,
+    [0xD0] KEY_DN,      [0xD1] KEY_PGDN,
+    [0xD2] KEY_INS,     [0xD3] KEY_DEL
+};
+
+#define C(x) (x - '@')
+
+static uint8_t ctlmap[256] = {
+    NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
+    NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
+    C('Q'),  C('W'),  C('E'),  C('R'),  C('T'),  C('Y'),  C('U'),  C('I'),
+    C('O'),  C('P'),  NO,      NO,      '\r',    NO,      C('A'),  C('S'),
+    C('D'),  C('F'),  C('G'),  C('H'),  C('J'),  C('K'),  C('L'),  NO,
+    NO,      NO,      NO,      C('\\'), C('Z'),  C('X'),  C('C'),  C('V'),
+    C('B'),  C('N'),  C('M'),  NO,      NO,      C('/'),  NO,      NO,
+    [0x97] KEY_HOME,
+    [0xB5] C('/'),      [0xC8] KEY_UP,
+    [0xC9] KEY_PGUP,    [0xCB] KEY_LF,
+    [0xCD] KEY_RT,      [0xCF] KEY_END,
+    [0xD0] KEY_DN,      [0xD1] KEY_PGDN,
+    [0xD2] KEY_INS,     [0xD3] KEY_DEL
+};
+
+static uint8_t *charcode[4] = {
+    normalmap,
+    shiftmap,
+    ctlmap,
+    ctlmap
+};
+
+/* *
+ * kbd_proc_data - get data from keyboard
+ *
+ * The kbd_proc_data() function gets data from the keyboard.
+ * If we finish a character, return it, else 0. And return -1 if no data.
+ * */
+static int
+kbd_proc_data(void) {
+    int c;
+    uint8_t data;
+    static uint32_t shift;
+
+    if ((inb(KBSTATP) & KBS_DIB) == 0) {
+        return -1;
+    }
+
+    data = inb(KBDATAP);
+
+    if (data == 0xE0) {
+        // E0 escape character
+        shift |= E0ESC;
+        return 0;
+    } else if (data & 0x80) {
+        // Key released
+        data = (shift & E0ESC ? data : data & 0x7F);
+        shift &= ~(shiftcode[data] | E0ESC);
+        return 0;
+    } else if (shift & E0ESC) {
+        // Last character was an E0 escape; or with 0x80
+        data |= 0x80;
+        shift &= ~E0ESC;
+    }
+
+    shift |= shiftcode[data];
+    shift ^= togglecode[data];
+
+    c = charcode[shift & (CTL | SHIFT)][data];
+    if (shift & CAPSLOCK) {
+        if ('a' <= c && c <= 'z')
+            c += 'A' - 'a';
+        else if ('A' <= c && c <= 'Z')
+            c += 'a' - 'A';
+    }
+
+    // Process special keys
+    // Ctrl-Alt-Del: reboot
+    if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
+        cprintf("Rebooting!\n");
+        outb(0x92, 0x3); // courtesy of Chris Frost
+    }
+    return c;
+}
+
+/* kbd_intr - try to feed input characters from keyboard */
+static void
+kbd_intr(void) {
+    cons_intr(kbd_proc_data);
+}
+
+static void
+kbd_init(void) {
+    // drain the kbd buffer
+    kbd_intr();
+    pic_enable(IRQ_KBD);
+}
+
+/* cons_init - initializes the console devices */
+void
+cons_init(void) {
+    cga_init();
+    serial_init();
+    kbd_init();
+    if (!serial_exists) {
+        cprintf("serial port does not exist!!\n");
+    }
+}
+
+/* cons_putc - print a single character @c to console devices */
+void
+cons_putc(int c) {
+    bool intr_flag;
+    local_intr_save(intr_flag);
+    {
+        lpt_putc(c);
+        cga_putc(c);
+        serial_putc(c);
+    }
+    local_intr_restore(intr_flag);
+}
+
+/* *
+ * cons_getc - return the next input character from console,
+ * or 0 if none waiting.
+ * */
+int
+cons_getc(void) {
+    int c = 0;
+    bool intr_flag;
+    local_intr_save(intr_flag);
+    {
+        // poll for any pending input characters,
+        // so that this function works even when interrupts are disabled
+        // (e.g., when called from the kernel monitor).
+        serial_intr();
+        kbd_intr();
+
+        // grab the next character from the input buffer.
+        if (cons.rpos != cons.wpos) {
+            c = cons.buf[cons.rpos ++];
+            if (cons.rpos == CONSBUFSIZE) {
+                cons.rpos = 0;
+            }
+        }
+    }
+    local_intr_restore(intr_flag);
+    return c;
+}
+
diff -r -u -P lab6_origin/kern/driver/console.h lab6/kern/driver/console.h
--- lab6_origin/kern/driver/console.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/driver/console.h	2019-02-26 20:51:17.041403300 +0800
@@ -0,0 +1,11 @@
+#ifndef __KERN_DRIVER_CONSOLE_H__
+#define __KERN_DRIVER_CONSOLE_H__
+
+void cons_init(void);
+void cons_putc(int c);
+int cons_getc(void);
+void serial_intr(void);
+void kbd_intr(void);
+
+#endif /* !__KERN_DRIVER_CONSOLE_H__ */
+
diff -r -u -P lab6_origin/kern/driver/ide.c lab6/kern/driver/ide.c
--- lab6_origin/kern/driver/ide.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/driver/ide.c	2019-02-26 20:51:17.042401500 +0800
@@ -0,0 +1,214 @@
+#include <defs.h>
+#include <stdio.h>
+#include <trap.h>
+#include <picirq.h>
+#include <fs.h>
+#include <ide.h>
+#include <x86.h>
+#include <assert.h>
+
+#define ISA_DATA                0x00
+#define ISA_ERROR               0x01
+#define ISA_PRECOMP             0x01
+#define ISA_CTRL                0x02
+#define ISA_SECCNT              0x02
+#define ISA_SECTOR              0x03
+#define ISA_CYL_LO              0x04
+#define ISA_CYL_HI              0x05
+#define ISA_SDH                 0x06
+#define ISA_COMMAND             0x07
+#define ISA_STATUS              0x07
+
+#define IDE_BSY                 0x80
+#define IDE_DRDY                0x40
+#define IDE_DF                  0x20
+#define IDE_DRQ                 0x08
+#define IDE_ERR                 0x01
+
+#define IDE_CMD_READ            0x20
+#define IDE_CMD_WRITE           0x30
+#define IDE_CMD_IDENTIFY        0xEC
+
+#define IDE_IDENT_SECTORS       20
+#define IDE_IDENT_MODEL         54
+#define IDE_IDENT_CAPABILITIES  98
+#define IDE_IDENT_CMDSETS       164
+#define IDE_IDENT_MAX_LBA       120
+#define IDE_IDENT_MAX_LBA_EXT   200
+
+#define IO_BASE0                0x1F0
+#define IO_BASE1                0x170
+#define IO_CTRL0                0x3F4
+#define IO_CTRL1                0x374
+
+#define MAX_IDE                 4
+#define MAX_NSECS               128
+#define MAX_DISK_NSECS          0x10000000U
+#define VALID_IDE(ideno)        (((ideno) >= 0) && ((ideno) < MAX_IDE) && (ide_devices[ideno].valid))
+
+static const struct {
+    unsigned short base;        // I/O Base
+    unsigned short ctrl;        // Control Base
+} channels[2] = {
+    {IO_BASE0, IO_CTRL0},
+    {IO_BASE1, IO_CTRL1},
+};
+
+#define IO_BASE(ideno)          (channels[(ideno) >> 1].base)
+#define IO_CTRL(ideno)          (channels[(ideno) >> 1].ctrl)
+
+static struct ide_device {
+    unsigned char valid;        // 0 or 1 (If Device Really Exists)
+    unsigned int sets;          // Commend Sets Supported
+    unsigned int size;          // Size in Sectors
+    unsigned char model[41];    // Model in String
+} ide_devices[MAX_IDE];
+
+static int
+ide_wait_ready(unsigned short iobase, bool check_error) {
+    int r;
+    while ((r = inb(iobase + ISA_STATUS)) & IDE_BSY)
+        /* nothing */;
+    if (check_error && (r & (IDE_DF | IDE_ERR)) != 0) {
+        return -1;
+    }
+    return 0;
+}
+
+void
+ide_init(void) {
+    static_assert((SECTSIZE % 4) == 0);
+    unsigned short ideno, iobase;
+    for (ideno = 0; ideno < MAX_IDE; ideno ++) {
+        /* assume that no device here */
+        ide_devices[ideno].valid = 0;
+
+        iobase = IO_BASE(ideno);
+
+        /* wait device ready */
+        ide_wait_ready(iobase, 0);
+
+        /* step1: select drive */
+        outb(iobase + ISA_SDH, 0xE0 | ((ideno & 1) << 4));
+        ide_wait_ready(iobase, 0);
+
+        /* step2: send ATA identify command */
+        outb(iobase + ISA_COMMAND, IDE_CMD_IDENTIFY);
+        ide_wait_ready(iobase, 0);
+
+        /* step3: polling */
+        if (inb(iobase + ISA_STATUS) == 0 || ide_wait_ready(iobase, 1) != 0) {
+            continue ;
+        }
+
+        /* device is ok */
+        ide_devices[ideno].valid = 1;
+
+        /* read identification space of the device */
+        unsigned int buffer[128];
+        insl(iobase + ISA_DATA, buffer, sizeof(buffer) / sizeof(unsigned int));
+
+        unsigned char *ident = (unsigned char *)buffer;
+        unsigned int sectors;
+        unsigned int cmdsets = *(unsigned int *)(ident + IDE_IDENT_CMDSETS);
+        /* device use 48-bits or 28-bits addressing */
+        if (cmdsets & (1 << 26)) {
+            sectors = *(unsigned int *)(ident + IDE_IDENT_MAX_LBA_EXT);
+        }
+        else {
+            sectors = *(unsigned int *)(ident + IDE_IDENT_MAX_LBA);
+        }
+        ide_devices[ideno].sets = cmdsets;
+        ide_devices[ideno].size = sectors;
+
+        /* check if supports LBA */
+        assert((*(unsigned short *)(ident + IDE_IDENT_CAPABILITIES) & 0x200) != 0);
+
+        unsigned char *model = ide_devices[ideno].model, *data = ident + IDE_IDENT_MODEL;
+        unsigned int i, length = 40;
+        for (i = 0; i < length; i += 2) {
+            model[i] = data[i + 1], model[i + 1] = data[i];
+        }
+        do {
+            model[i] = '\0';
+        } while (i -- > 0 && model[i] == ' ');
+
+        cprintf("ide %d: %10u(sectors), '%s'.\n", ideno, ide_devices[ideno].size, ide_devices[ideno].model);
+    }
+
+    // enable ide interrupt
+    pic_enable(IRQ_IDE1);
+    pic_enable(IRQ_IDE2);
+}
+
+bool
+ide_device_valid(unsigned short ideno) {
+    return VALID_IDE(ideno);
+}
+
+size_t
+ide_device_size(unsigned short ideno) {
+    if (ide_device_valid(ideno)) {
+        return ide_devices[ideno].size;
+    }
+    return 0;
+}
+
+int
+ide_read_secs(unsigned short ideno, uint32_t secno, void *dst, size_t nsecs) {
+    assert(nsecs <= MAX_NSECS && VALID_IDE(ideno));
+    assert(secno < MAX_DISK_NSECS && secno + nsecs <= MAX_DISK_NSECS);
+    unsigned short iobase = IO_BASE(ideno), ioctrl = IO_CTRL(ideno);
+
+    ide_wait_ready(iobase, 0);
+
+    // generate interrupt
+    outb(ioctrl + ISA_CTRL, 0);
+    outb(iobase + ISA_SECCNT, nsecs);
+    outb(iobase + ISA_SECTOR, secno & 0xFF);
+    outb(iobase + ISA_CYL_LO, (secno >> 8) & 0xFF);
+    outb(iobase + ISA_CYL_HI, (secno >> 16) & 0xFF);
+    outb(iobase + ISA_SDH, 0xE0 | ((ideno & 1) << 4) | ((secno >> 24) & 0xF));
+    outb(iobase + ISA_COMMAND, IDE_CMD_READ);
+
+    int ret = 0;
+    for (; nsecs > 0; nsecs --, dst += SECTSIZE) {
+        if ((ret = ide_wait_ready(iobase, 1)) != 0) {
+            goto out;
+        }
+        insl(iobase, dst, SECTSIZE / sizeof(uint32_t));
+    }
+
+out:
+    return ret;
+}
+
+int
+ide_write_secs(unsigned short ideno, uint32_t secno, const void *src, size_t nsecs) {
+    assert(nsecs <= MAX_NSECS && VALID_IDE(ideno));
+    assert(secno < MAX_DISK_NSECS && secno + nsecs <= MAX_DISK_NSECS);
+    unsigned short iobase = IO_BASE(ideno), ioctrl = IO_CTRL(ideno);
+
+    ide_wait_ready(iobase, 0);
+
+    // generate interrupt
+    outb(ioctrl + ISA_CTRL, 0);
+    outb(iobase + ISA_SECCNT, nsecs);
+    outb(iobase + ISA_SECTOR, secno & 0xFF);
+    outb(iobase + ISA_CYL_LO, (secno >> 8) & 0xFF);
+    outb(iobase + ISA_CYL_HI, (secno >> 16) & 0xFF);
+    outb(iobase + ISA_SDH, 0xE0 | ((ideno & 1) << 4) | ((secno >> 24) & 0xF));
+    outb(iobase + ISA_COMMAND, IDE_CMD_WRITE);
+
+    int ret = 0;
+    for (; nsecs > 0; nsecs --, src += SECTSIZE) {
+        if ((ret = ide_wait_ready(iobase, 1)) != 0) {
+            goto out;
+        }
+        outsl(iobase, src, SECTSIZE / sizeof(uint32_t));
+    }
+
+out:
+    return ret;
+}
+
diff -r -u -P lab6_origin/kern/driver/ide.h lab6/kern/driver/ide.h
--- lab6_origin/kern/driver/ide.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/driver/ide.h	2019-02-26 20:51:17.043402400 +0800
@@ -0,0 +1,14 @@
+#ifndef __KERN_DRIVER_IDE_H__
+#define __KERN_DRIVER_IDE_H__
+
+#include <defs.h>
+
+void ide_init(void);
+bool ide_device_valid(unsigned short ideno);
+size_t ide_device_size(unsigned short ideno);
+
+int ide_read_secs(unsigned short ideno, uint32_t secno, void *dst, size_t nsecs);
+int ide_write_secs(unsigned short ideno, uint32_t secno, const void *src, size_t nsecs);
+
+#endif /* !__KERN_DRIVER_IDE_H__ */
+
diff -r -u -P lab6_origin/kern/driver/intr.c lab6/kern/driver/intr.c
--- lab6_origin/kern/driver/intr.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/driver/intr.c	2019-02-26 20:51:17.043901800 +0800
@@ -0,0 +1,15 @@
+#include <x86.h>
+#include <intr.h>
+
+/* intr_enable - enable irq interrupt */
+void
+intr_enable(void) {
+    sti();
+}
+
+/* intr_disable - disable irq interrupt */
+void
+intr_disable(void) {
+    cli();
+}
+
diff -r -u -P lab6_origin/kern/driver/intr.h lab6/kern/driver/intr.h
--- lab6_origin/kern/driver/intr.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/driver/intr.h	2019-02-26 20:51:17.044400700 +0800
@@ -0,0 +1,8 @@
+#ifndef __KERN_DRIVER_INTR_H__
+#define __KERN_DRIVER_INTR_H__
+
+void intr_enable(void);
+void intr_disable(void);
+
+#endif /* !__KERN_DRIVER_INTR_H__ */
+
diff -r -u -P lab6_origin/kern/driver/kbdreg.h lab6/kern/driver/kbdreg.h
--- lab6_origin/kern/driver/kbdreg.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/driver/kbdreg.h	2019-02-26 20:51:17.044899200 +0800
@@ -0,0 +1,84 @@
+#ifndef __KERN_DRIVER_KBDREG_H__
+#define __KERN_DRIVER_KBDREG_H__
+
+// Special keycodes
+#define KEY_HOME            0xE0
+#define KEY_END             0xE1
+#define KEY_UP              0xE2
+#define KEY_DN              0xE3
+#define KEY_LF              0xE4
+#define KEY_RT              0xE5
+#define KEY_PGUP            0xE6
+#define KEY_PGDN            0xE7
+#define KEY_INS             0xE8
+#define KEY_DEL             0xE9
+
+
+/* This is i8042reg.h + kbdreg.h from NetBSD. */
+
+#define KBSTATP             0x64    // kbd controller status port(I)
+#define KBS_DIB             0x01    // kbd data in buffer
+#define KBS_IBF             0x02    // kbd input buffer low
+#define KBS_WARM            0x04    // kbd input buffer low
+#define BS_OCMD             0x08    // kbd output buffer has command
+#define KBS_NOSEC           0x10    // kbd security lock not engaged
+#define KBS_TERR            0x20    // kbd transmission error
+#define KBS_RERR            0x40    // kbd receive error
+#define KBS_PERR            0x80    // kbd parity error
+
+#define KBCMDP              0x64    // kbd controller port(O)
+#define KBC_RAMREAD         0x20    // read from RAM
+#define KBC_RAMWRITE        0x60    // write to RAM
+#define KBC_AUXDISABLE      0xa7    // disable auxiliary port
+#define KBC_AUXENABLE       0xa8    // enable auxiliary port
+#define KBC_AUXTEST         0xa9    // test auxiliary port
+#define KBC_KBDECHO         0xd2    // echo to keyboard port
+#define KBC_AUXECHO         0xd3    // echo to auxiliary port
+#define KBC_AUXWRITE        0xd4    // write to auxiliary port
+#define KBC_SELFTEST        0xaa    // start self-test
+#define KBC_KBDTEST         0xab    // test keyboard port
+#define KBC_KBDDISABLE      0xad    // disable keyboard port
+#define KBC_KBDENABLE       0xae    // enable keyboard port
+#define KBC_PULSE0          0xfe    // pulse output bit 0
+#define KBC_PULSE1          0xfd    // pulse output bit 1
+#define KBC_PULSE2          0xfb    // pulse output bit 2
+#define KBC_PULSE3          0xf7    // pulse output bit 3
+
+#define KBDATAP             0x60    // kbd data port(I)
+#define KBOUTP              0x60    // kbd data port(O)
+
+#define K_RDCMDBYTE         0x20
+#define K_LDCMDBYTE         0x60
+
+#define KC8_TRANS           0x40    // convert to old scan codes
+#define KC8_MDISABLE        0x20    // disable mouse
+#define KC8_KDISABLE        0x10    // disable keyboard
+#define KC8_IGNSEC          0x08    // ignore security lock
+#define KC8_CPU             0x04    // exit from protected mode reset
+#define KC8_MENABLE         0x02    // enable mouse interrupt
+#define KC8_KENABLE         0x01    // enable keyboard interrupt
+#define CMDBYTE             (KC8_TRANS|KC8_CPU|KC8_MENABLE|KC8_KENABLE)
+
+/* keyboard commands */
+#define KBC_RESET           0xFF    // reset the keyboard
+#define KBC_RESEND          0xFE    // request the keyboard resend the last byte
+#define KBC_SETDEFAULT      0xF6    // resets keyboard to its power-on defaults
+#define KBC_DISABLE         0xF5    // as per KBC_SETDEFAULT, but also disable key scanning
+#define KBC_ENABLE          0xF4    // enable key scanning
+#define KBC_TYPEMATIC       0xF3    // set typematic rate and delay
+#define KBC_SETTABLE        0xF0    // set scancode translation table
+#define KBC_MODEIND         0xED    // set mode indicators(i.e. LEDs)
+#define KBC_ECHO            0xEE    // request an echo from the keyboard
+
+/* keyboard responses */
+#define KBR_EXTENDED        0xE0    // extended key sequence
+#define KBR_RESEND          0xFE    // needs resend of command
+#define KBR_ACK             0xFA    // received a valid command
+#define KBR_OVERRUN         0x00    // flooded
+#define KBR_FAILURE         0xFD    // diagnosic failure
+#define KBR_BREAK           0xF0    // break code prefix - sent on key release
+#define KBR_RSTDONE         0xAA    // reset complete
+#define KBR_ECHO            0xEE    // echo response
+
+#endif /* !__KERN_DRIVER_KBDREG_H__ */
+
diff -r -u -P lab6_origin/kern/driver/picirq.c lab6/kern/driver/picirq.c
--- lab6_origin/kern/driver/picirq.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/driver/picirq.c	2019-02-26 20:51:17.045398500 +0800
@@ -0,0 +1,86 @@
+#include <defs.h>
+#include <x86.h>
+#include <picirq.h>
+
+// I/O Addresses of the two programmable interrupt controllers
+#define IO_PIC1             0x20    // Master (IRQs 0-7)
+#define IO_PIC2             0xA0    // Slave (IRQs 8-15)
+
+#define IRQ_SLAVE           2       // IRQ at which slave connects to master
+
+// Current IRQ mask.
+// Initial IRQ mask has interrupt 2 enabled (for slave 8259A).
+static uint16_t irq_mask = 0xFFFF & ~(1 << IRQ_SLAVE);
+static bool did_init = 0;
+
+static void
+pic_setmask(uint16_t mask) {
+    irq_mask = mask;
+    if (did_init) {
+        outb(IO_PIC1 + 1, mask);
+        outb(IO_PIC2 + 1, mask >> 8);
+    }
+}
+
+void
+pic_enable(unsigned int irq) {
+    pic_setmask(irq_mask & ~(1 << irq));
+}
+
+/* pic_init - initialize the 8259A interrupt controllers */
+void
+pic_init(void) {
+    did_init = 1;
+
+    // mask all interrupts
+    outb(IO_PIC1 + 1, 0xFF);
+    outb(IO_PIC2 + 1, 0xFF);
+
+    // Set up master (8259A-1)
+
+    // ICW1:  0001g0hi
+    //    g:  0 = edge triggering, 1 = level triggering
+    //    h:  0 = cascaded PICs, 1 = master only
+    //    i:  0 = no ICW4, 1 = ICW4 required
+    outb(IO_PIC1, 0x11);
+
+    // ICW2:  Vector offset
+    outb(IO_PIC1 + 1, IRQ_OFFSET);
+
+    // ICW3:  (master PIC) bit mask of IR lines connected to slaves
+    //        (slave PIC) 3-bit # of slave's connection to master
+    outb(IO_PIC1 + 1, 1 << IRQ_SLAVE);
+
+    // ICW4:  000nbmap
+    //    n:  1 = special fully nested mode
+    //    b:  1 = buffered mode
+    //    m:  0 = slave PIC, 1 = master PIC
+    //        (ignored when b is 0, as the master/slave role
+    //         can be hardwired).
+    //    a:  1 = Automatic EOI mode
+    //    p:  0 = MCS-80/85 mode, 1 = intel x86 mode
+    outb(IO_PIC1 + 1, 0x3);
+
+    // Set up slave (8259A-2)
+    outb(IO_PIC2, 0x11);    // ICW1
+    outb(IO_PIC2 + 1, IRQ_OFFSET + 8);  // ICW2
+    outb(IO_PIC2 + 1, IRQ_SLAVE);       // ICW3
+    // NB Automatic EOI mode doesn't tend to work on the slave.
+    // Linux source code says it's "to be investigated".
+    outb(IO_PIC2 + 1, 0x3);             // ICW4
+
+    // OCW3:  0ef01prs
+    //   ef:  0x = NOP, 10 = clear specific mask, 11 = set specific mask
+    //    p:  0 = no polling, 1 = polling mode
+    //   rs:  0x = NOP, 10 = read IRR, 11 = read ISR
+    outb(IO_PIC1, 0x68);    // clear specific mask
+    outb(IO_PIC1, 0x0a);    // read IRR by default
+
+    outb(IO_PIC2, 0x68);    // OCW3
+    outb(IO_PIC2, 0x0a);    // OCW3
+
+    if (irq_mask != 0xFFFF) {
+        pic_setmask(irq_mask);
+    }
+}
+
diff -r -u -P lab6_origin/kern/driver/picirq.h lab6/kern/driver/picirq.h
--- lab6_origin/kern/driver/picirq.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/driver/picirq.h	2019-02-26 20:51:17.046396800 +0800
@@ -0,0 +1,10 @@
+#ifndef __KERN_DRIVER_PICIRQ_H__
+#define __KERN_DRIVER_PICIRQ_H__
+
+void pic_init(void);
+void pic_enable(unsigned int irq);
+
+#define IRQ_OFFSET      32
+
+#endif /* !__KERN_DRIVER_PICIRQ_H__ */
+
diff -r -u -P lab6_origin/kern/fs/fs.h lab6/kern/fs/fs.h
--- lab6_origin/kern/fs/fs.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/fs/fs.h	2019-02-26 20:51:17.047394100 +0800
@@ -0,0 +1,12 @@
+#ifndef __KERN_FS_FS_H__
+#define __KERN_FS_FS_H__
+
+#include <mmu.h>
+
+#define SECTSIZE            512
+#define PAGE_NSECT          (PGSIZE / SECTSIZE)
+
+#define SWAP_DEV_NO         1
+
+#endif /* !__KERN_FS_FS_H__ */
+
diff -r -u -P lab6_origin/kern/fs/swapfs.c lab6/kern/fs/swapfs.c
--- lab6_origin/kern/fs/swapfs.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/fs/swapfs.c	2019-02-26 20:51:17.048391500 +0800
@@ -0,0 +1,27 @@
+#include <swap.h>
+#include <swapfs.h>
+#include <mmu.h>
+#include <fs.h>
+#include <ide.h>
+#include <pmm.h>
+#include <assert.h>
+
+void
+swapfs_init(void) {
+    static_assert((PGSIZE % SECTSIZE) == 0);
+    if (!ide_device_valid(SWAP_DEV_NO)) {
+        panic("swap fs isn't available.\n");
+    }
+    max_swap_offset = ide_device_size(SWAP_DEV_NO) / (PGSIZE / SECTSIZE);
+}
+
+int
+swapfs_read(swap_entry_t entry, struct Page *page) {
+    return ide_read_secs(SWAP_DEV_NO, swap_offset(entry) * PAGE_NSECT, page2kva(page), PAGE_NSECT);
+}
+
+int
+swapfs_write(swap_entry_t entry, struct Page *page) {
+    return ide_write_secs(SWAP_DEV_NO, swap_offset(entry) * PAGE_NSECT, page2kva(page), PAGE_NSECT);
+}
+
diff -r -u -P lab6_origin/kern/fs/swapfs.h lab6/kern/fs/swapfs.h
--- lab6_origin/kern/fs/swapfs.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/fs/swapfs.h	2019-02-26 20:51:17.048890800 +0800
@@ -0,0 +1,12 @@
+#ifndef __KERN_FS_SWAPFS_H__
+#define __KERN_FS_SWAPFS_H__
+
+#include <memlayout.h>
+#include <swap.h>
+
+void swapfs_init(void);
+int swapfs_read(swap_entry_t entry, struct Page *page);
+int swapfs_write(swap_entry_t entry, struct Page *page);
+
+#endif /* !__KERN_FS_SWAPFS_H__ */
+
diff -r -u -P lab6_origin/kern/init/entry.S lab6/kern/init/entry.S
--- lab6_origin/kern/init/entry.S	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/init/entry.S	2019-02-26 20:51:17.049889100 +0800
@@ -0,0 +1,70 @@
+#include <mmu.h>
+#include <memlayout.h>
+
+#define REALLOC(x) (x - KERNBASE)
+
+.text
+.globl kern_entry
+kern_entry:
+    # load pa of boot pgdir
+    movl $REALLOC(__boot_pgdir), %eax
+    movl %eax, %cr3
+
+    # enable paging
+    movl %cr0, %eax
+    orl $(CR0_PE | CR0_PG | CR0_AM | CR0_WP | CR0_NE | CR0_TS | CR0_EM | CR0_MP), %eax
+    andl $~(CR0_TS | CR0_EM), %eax
+    movl %eax, %cr0
+
+    # update eip
+    # now, eip = 0x1.....
+    leal next, %eax
+    # set eip = KERNBASE + 0x1.....
+    jmp *%eax
+next:
+
+    # unmap va 0 ~ 4M, it's temporary mapping
+    xorl %eax, %eax
+    movl %eax, __boot_pgdir
+
+    # set ebp, esp
+    movl $0x0, %ebp
+    # the kernel stack region is from bootstack -- bootstacktop,
+    # the kernel stack size is KSTACKSIZE (8KB)defined in memlayout.h
+    movl $bootstacktop, %esp
+    # now kernel stack is ready , call the first C function
+    call kern_init
+
+# should never get here
+spin:
+    jmp spin
+
+.data
+.align PGSIZE
+    .globl bootstack
+bootstack:
+    .space KSTACKSIZE
+    .globl bootstacktop
+bootstacktop:
+
+# kernel builtin pgdir
+# an initial page directory (Page Directory Table, PDT)
+# These page directory table and page table can be reused!
+.section .data.pgdir
+.align PGSIZE
+__boot_pgdir:
+.globl __boot_pgdir
+    # map va 0 ~ 4M to pa 0 ~ 4M (temporary)
+    .long REALLOC(__boot_pt1) + (PTE_P | PTE_U | PTE_W)
+    .space (KERNBASE >> PGSHIFT >> 10 << 2) - (. - __boot_pgdir) # pad to PDE of KERNBASE
+    # map va KERNBASE + (0 ~ 4M) to pa 0 ~ 4M
+    .long REALLOC(__boot_pt1) + (PTE_P | PTE_U | PTE_W)
+    .space PGSIZE - (. - __boot_pgdir) # pad to PGSIZE
+
+.set i, 0
+__boot_pt1:
+.rept 1024
+    .long i * PGSIZE + (PTE_P | PTE_W)
+    .set i, i + 1
+.endr
+
diff -r -u -P lab6_origin/kern/init/init.c lab6/kern/init/init.c
--- lab6_origin/kern/init/init.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/init/init.c	2019-05-06 17:12:32.063626100 +0800
@@ -0,0 +1,115 @@
+#include <defs.h>
+#include <stdio.h>
+#include <string.h>
+#include <console.h>
+#include <kdebug.h>
+#include <picirq.h>
+#include <trap.h>
+#include <clock.h>
+#include <intr.h>
+#include <pmm.h>
+#include <vmm.h>
+#include <ide.h>
+#include <swap.h>
+#include <proc.h>
+#include <kmonitor.h>
+
+int kern_init(void) __attribute__((noreturn));
+void grade_backtrace(void);
+static void lab1_switch_test(void);
+
+int
+kern_init(void) {
+    extern char edata[], end[];
+    memset(edata, 0, end - edata);
+
+    cons_init();                // init the console
+
+    const char *message = "(THU.CST) os is loading ...";
+    cprintf("%s\n\n", message);
+
+    print_kerninfo();
+
+    grade_backtrace();
+
+    pmm_init();                 // init physical memory management
+
+    pic_init();                 // init interrupt controller
+    idt_init();                 // init interrupt descriptor table
+
+    vmm_init();                 // init virtual memory management
+    sched_init();               // init scheduler
+    proc_init();                // init process table
+    
+    ide_init();                 // init ide devices
+    swap_init();                // init swap
+
+    clock_init();               // init clock interrupt
+    intr_enable();              // enable irq interrupt
+
+    //LAB1: CAHLLENGE 1 If you try to do it, uncomment lab1_switch_test()
+    // user/kernel mode switch test
+    //lab1_switch_test();
+    
+    cpu_idle();                 // run idle process
+}
+
+void __attribute__((noinline))
+grade_backtrace2(int arg0, int arg1, int arg2, int arg3) {
+    mon_backtrace(0, NULL, NULL);
+}
+
+void __attribute__((noinline))
+grade_backtrace1(int arg0, int arg1) {
+    grade_backtrace2(arg0, (int)&arg0, arg1, (int)&arg1);
+}
+
+void __attribute__((noinline))
+grade_backtrace0(int arg0, int arg1, int arg2) {
+    grade_backtrace1(arg0, arg2);
+}
+
+void
+grade_backtrace(void) {
+    grade_backtrace0(0, (int)kern_init, 0xffff0000);
+}
+
+static void
+lab1_print_cur_status(void) {
+    static int round = 0;
+    uint16_t reg1, reg2, reg3, reg4;
+    asm volatile (
+            "mov %%cs, %0;"
+            "mov %%ds, %1;"
+            "mov %%es, %2;"
+            "mov %%ss, %3;"
+            : "=m"(reg1), "=m"(reg2), "=m"(reg3), "=m"(reg4));
+    cprintf("%d: @ring %d\n", round, reg1 & 3);
+    cprintf("%d:  cs = %x\n", round, reg1);
+    cprintf("%d:  ds = %x\n", round, reg2);
+    cprintf("%d:  es = %x\n", round, reg3);
+    cprintf("%d:  ss = %x\n", round, reg4);
+    round ++;
+}
+
+static void
+lab1_switch_to_user(void) {
+    //LAB1 CHALLENGE 1 : TODO
+}
+
+static void
+lab1_switch_to_kernel(void) {
+    //LAB1 CHALLENGE 1 :  TODO
+}
+
+static void
+lab1_switch_test(void) {
+    lab1_print_cur_status();
+    cprintf("+++ switch to  user  mode +++\n");
+    lab1_switch_to_user();
+    lab1_print_cur_status();
+    cprintf("+++ switch to kernel mode +++\n");
+    lab1_switch_to_kernel();
+    lab1_print_cur_status();
+}
+
diff -r -u -P lab6_origin/kern/libs/readline.c lab6/kern/libs/readline.c
--- lab6_origin/kern/libs/readline.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/libs/readline.c	2019-02-26 20:51:17.051885200 +0800
@@ -0,0 +1,50 @@
+#include <stdio.h>
+
+#define BUFSIZE 1024
+static char buf[BUFSIZE];
+
+/* *
+ * readline - get a line from stdin
+ * @prompt:     the string to be written to stdout
+ *
+ * The readline() function will write the input string @prompt to
+ * stdout first. If the @prompt is NULL or the empty string,
+ * no prompt is issued.
+ *
+ * This function will keep on reading characters and saving them to buffer
+ * 'buf' until '\n' or '\r' is encountered.
+ *
+ * Note that, if the length of string that will be read is longer than
+ * buffer size, the end of string will be discarded.
+ *
+ * The readline() function returns the text of the line read. If some errors
+ * are happened, NULL is returned. The return value is a global variable,
+ * thus it should be copied before it is used.
+ * */
+char *
+readline(const char *prompt) {
+    if (prompt != NULL) {
+        cprintf("%s", prompt);
+    }
+    int i = 0, c;
+    while (1) {
+        c = getchar();
+        if (c < 0) {
+            return NULL;
+        }
+        else if (c >= ' ' && i < BUFSIZE - 1) {
+            cputchar(c);
+            buf[i ++] = c;
+        }
+        else if (c == '\b' && i > 0) {
+            cputchar(c);
+            i --;
+        }
+        else if (c == '\n' || c == '\r') {
+            cputchar(c);
+            buf[i] = '\0';
+            return buf;
+        }
+    }
+}
+
diff -r -u -P lab6_origin/kern/libs/stdio.c lab6/kern/libs/stdio.c
--- lab6_origin/kern/libs/stdio.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/libs/stdio.c	2019-02-26 20:51:17.052384100 +0800
@@ -0,0 +1,78 @@
+#include <defs.h>
+#include <stdio.h>
+#include <console.h>
+
+/* HIGH level console I/O */
+
+/* *
+ * cputch - writes a single character @c to stdout, and it will
+ * increace the value of counter pointed by @cnt.
+ * */
+static void
+cputch(int c, int *cnt) {
+    cons_putc(c);
+    (*cnt) ++;
+}
+
+/* *
+ * vcprintf - format a string and writes it to stdout
+ *
+ * The return value is the number of characters which would be
+ * written to stdout.
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want cprintf() instead.
+ * */
+int
+vcprintf(const char *fmt, va_list ap) {
+    int cnt = 0;
+    vprintfmt((void*)cputch, &cnt, fmt, ap);
+    return cnt;
+}
+
+/* *
+ * cprintf - formats a string and writes it to stdout
+ *
+ * The return value is the number of characters which would be
+ * written to stdout.
+ * */
+int
+cprintf(const char *fmt, ...) {
+    va_list ap;
+    int cnt;
+    va_start(ap, fmt);
+    cnt = vcprintf(fmt, ap);
+    va_end(ap);
+    return cnt;
+}
+
+/* cputchar - writes a single character to stdout */
+void
+cputchar(int c) {
+    cons_putc(c);
+}
+
+/* *
+ * cputs- writes the string pointed by @str to stdout and
+ * appends a newline character.
+ * */
+int
+cputs(const char *str) {
+    int cnt = 0;
+    char c;
+    while ((c = *str ++) != '\0') {
+        cputch(c, &cnt);
+    }
+    cputch('\n', &cnt);
+    return cnt;
+}
+
+/* getchar - reads a single non-zero character from stdin */
+int
+getchar(void) {
+    int c;
+    while ((c = cons_getc()) == 0)
+        /* do nothing */;
+    return c;
+}
+
diff -r -u -P lab6_origin/kern/mm/default_pmm.c lab6/kern/mm/default_pmm.c
--- lab6_origin/kern/mm/default_pmm.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/mm/default_pmm.c	2019-05-06 16:47:40.298141400 +0800
@@ -0,0 +1,329 @@
+#include <pmm.h>
+#include <list.h>
+#include <string.h>
+#include <default_pmm.h>
+
+/*  In the First Fit algorithm, the allocator keeps a list of free blocks
+ * (known as the free list). Once receiving a allocation request for memory,
+ * it scans along the list for the first block that is large enough to satisfy
+ * the request. If the chosen block is significantly larger than requested, it
+ * is usually splitted, and the remainder will be added into the list as
+ * another free block.
+ *  Please refer to Page 196~198, Section 8.2 of Yan Wei Min's Chinese book
+ * "Data Structure -- C programming language".
+*/
+// LAB2 EXERCISE 1: YOUR CODE
+// you should rewrite functions: `default_init`, `default_init_memmap`,
+// `default_alloc_pages`, `default_free_pages`.
+/*
+ * Details of FFMA
+ * (1) Preparation:
+ *  In order to implement the First-Fit Memory Allocation (FFMA), we should
+ * manage the free memory blocks using a list. The struct `free_area_t` is used
+ * for the management of free memory blocks.
+ *  First, you should get familiar with the struct `list` in list.h. Struct
+ * `list` is a simple doubly linked list implementation. You should know how to
+ * USE `list_init`, `list_add`(`list_add_after`), `list_add_before`, `list_del`,
+ * `list_next`, `list_prev`.
+ *  There's a tricky method that is to transform a general `list` struct to a
+ * special struct (such as struct `page`), using the following MACROs: `le2page`
+ * (in memlayout.h), (and in future labs: `le2vma` (in vmm.h), `le2proc` (in
+ * proc.h), etc).
+ * (2) `default_init`:
+ *  You can reuse the demo `default_init` function to initialize the `free_list`
+ * and set `nr_free` to 0. `free_list` is used to record the free memory blocks.
+ * `nr_free` is the total number of the free memory blocks.
+ * (3) `default_init_memmap`:
+ *  CALL GRAPH: `kern_init` --> `pmm_init` --> `page_init` --> `init_memmap` -->
+ * `pmm_manager` --> `init_memmap`.
+ *  This function is used to initialize a free block (with parameter `addr_base`,
+ * `page_number`). In order to initialize a free block, firstly, you should
+ * initialize each page (defined in memlayout.h) in this free block. This
+ * procedure includes:
+ *  - Setting the bit `PG_property` of `p->flags`, which means this page is
+ * valid. P.S. In function `pmm_init` (in pmm.c), the bit `PG_reserved` of
+ * `p->flags` is already set.
+ *  - If this page is free and is not the first page of a free block,
+ * `p->property` should be set to 0.
+ *  - If this page is free and is the first page of a free block, `p->property`
+ * should be set to be the total number of pages in the block.
+ *  - `p->ref` should be 0, because now `p` is free and has no reference.
+ *  After that, We can use `p->page_link` to link this page into `free_list`.
+ * (e.g.: `list_add_before(&free_list, &(p->page_link));` )
+ *  Finally, we should update the sum of the free memory blocks: `nr_free += n`.
+ * (4) `default_alloc_pages`:
+ *  Search for the first free block (block size >= n) in the free list and reszie
+ * the block found, returning the address of this block as the address required by
+ * `malloc`.
+ *  (4.1)
+ *      So you should search the free list like this:
+ *          list_entry_t le = &free_list;
+ *          while((le=list_next(le)) != &free_list) {
+ *          ...
+ *      (4.1.1)
+ *          In the while loop, get the struct `page` and check if `p->property`
+ *      (recording the num of free pages in this block) >= n.
+ *              struct Page *p = le2page(le, page_link);
+ *              if(p->property >= n){ ...
+ *      (4.1.2)
+ *          If we find this `p`, it means we've found a free block with its size
+ *      >= n, whose first `n` pages can be malloced. Some flag bits of this page
+ *      should be set as the following: `PG_reserved = 1`, `PG_property = 0`.
+ *      Then, unlink the pages from `free_list`.
+ *          (4.1.2.1)
+ *              If `p->property > n`, we should re-calculate number of the rest
+ *          pages of this free block. (e.g.: `le2page(le,page_link))->property
+ *          = p->property - n;`)
+ *          (4.1.3)
+ *              Re-caluclate `nr_free` (number of the the rest of all free block).
+ *          (4.1.4)
+ *              return `p`.
+ *      (4.2)
+ *          If we can not find a free block with its size >=n, then return NULL.
+ * (5) `default_free_pages`:
+ *  re-link the pages into the free list, and may merge small free blocks into
+ * the big ones.
+ *  (5.1)
+ *      According to the base address of the withdrawed blocks, search the free
+ *  list for its correct position (with address from low to high), and insert
+ *  the pages. (May use `list_next`, `le2page`, `list_add_before`)
+ *  (5.2)
+ *      Reset the fields of the pages, such as `p->ref` and `p->flags` (PageProperty)
+ *  (5.3)
+ *      Try to merge blocks at lower or higher addresses. Notice: This should
+ *  change some pages' `p->property` correctly.
+ */
+free_area_t free_area;
+
+#define free_list (free_area.free_list)
+#define nr_free (free_area.nr_free)
+static void
+default_init(void) {
+    list_init(&free_list);
+    nr_free = 0;
+}
+
+static void
+default_init_memmap(struct Page *base, size_t n) {
+    assert(n > 0);
+    struct Page *p = base;
+    for (; p != base + n; p ++) {
+        assert(PageReserved(p));
+        p->flags =0;
+        SetPageProperty(p);
+        p->property = 0;
+        set_page_ref(p, 0);
+    list_add_before(&free_list,&(p->page_link));
+    }
+    nr_free += n;
+    base->property=n;
+}
+
+static struct Page *
+default_alloc_pages(size_t n) {
+    assert(n > 0);
+    if (n > nr_free) {
+        return NULL;
+    }
+    list_entry_t *le, *len;
+    le = &free_list;
+    struct Page *p=NULL;
+    while((le=list_next(le)) != &free_list) {
+        p = le2page(le, page_link);
+        if(p->property>=n)
+        break;
+    }
+    if(p != NULL){
+        int i;
+        for(i=0;i<n;i++){
+            len = list_next(le);
+            struct Page *pp = le2page(le, page_link);
+            SetPageReserved(pp);
+            ClearPageProperty(pp);
+            list_del(le);
+            le = len;
+        }
+        if(p->property>n){
+            (le2page(le,page_link))->property = p->property - n;
+        }
+        ClearPageProperty(p);
+        SetPageReserved(p);
+        nr_free -= n;
+        return p;
+      }
+    return NULL;
+}
+
+static void
+default_free_pages(struct Page *base, size_t n) {
+    assert(n > 0);
+    list_entry_t *le = &free_list;
+    struct Page *p = base;
+    while((le=list_next(le)) != &free_list){
+        p = le2page(le,page_link);
+    if(p>base)
+        break;
+    }
+    //found where to insert
+    for(p=base;p<base+n;p++){
+        //cprintf("%x\n",p);
+        list_add_before(le,&(p->page_link));
+    }
+    base->flags=0;
+    set_page_ref(base,0);
+    ClearPageProperty(base);
+    SetPageProperty(base);
+    base->property = n;
+    p = le2page(le,page_link);
+    if(base+n == p){
+        base->property+=p->property;
+    p->property=0;
+    }
+    le=list_prev(&(base->page_link));
+    p = le2page(le, page_link);
+    if(le!=&free_list && p==base-1){
+        while(le!=&free_list){
+            if(p->property){
+                p->property+=base->property;
+                base->property=0;
+                break;
+            }
+            le = list_prev(le);
+            p=le2page(le,page_link);
+        }
+    }
+    nr_free +=n;
+    //cprintf("release %d page,last %d.\n",n,nr_free);
+}
+
+static size_t
+default_nr_free_pages(void) {
+    return nr_free;
+}
+
+static void
+basic_check(void) {
+    struct Page *p0, *p1, *p2;
+    p0 = p1 = p2 = NULL;
+    assert((p0 = alloc_page()) != NULL);
+    assert((p1 = alloc_page()) != NULL);
+    assert((p2 = alloc_page()) != NULL);
+
+    assert(p0 != p1 && p0 != p2 && p1 != p2);
+    assert(page_ref(p0) == 0 && page_ref(p1) == 0 && page_ref(p2) == 0);
+
+    assert(page2pa(p0) < npage * PGSIZE);
+    assert(page2pa(p1) < npage * PGSIZE);
+    assert(page2pa(p2) < npage * PGSIZE);
+
+    list_entry_t free_list_store = free_list;
+    list_init(&free_list);
+    assert(list_empty(&free_list));
+
+    unsigned int nr_free_store = nr_free;
+    nr_free = 0;
+
+    assert(alloc_page() == NULL);
+
+    free_page(p0);
+    free_page(p1);
+    free_page(p2);
+    assert(nr_free == 3);
+
+    assert((p0 = alloc_page()) != NULL);
+    assert((p1 = alloc_page()) != NULL);
+    assert((p2 = alloc_page()) != NULL);
+
+    assert(alloc_page() == NULL);
+
+    free_page(p0);
+    assert(!list_empty(&free_list));
+
+    struct Page *p;
+    assert((p = alloc_page()) == p0);
+    assert(alloc_page() == NULL);
+
+    assert(nr_free == 0);
+    free_list = free_list_store;
+    nr_free = nr_free_store;
+
+    free_page(p);
+    free_page(p1);
+    free_page(p2);
+}
+
+// LAB2: below code is used to check the first fit allocation algorithm (your EXERCISE 1) 
+// NOTICE: You SHOULD NOT CHANGE basic_check, default_check functions!
+static void
+default_check(void) {
+    int count = 0, total = 0;
+    list_entry_t *le = &free_list;
+    while ((le = list_next(le)) != &free_list) {
+        struct Page *p = le2page(le, page_link);
+        assert(PageProperty(p));
+        count ++, total += p->property;
+    }
+    assert(total == nr_free_pages());
+
+    basic_check();
+
+    struct Page *p0 = alloc_pages(5), *p1, *p2;
+    assert(p0 != NULL);
+    assert(!PageProperty(p0));
+
+    list_entry_t free_list_store = free_list;
+    list_init(&free_list);
+    assert(list_empty(&free_list));
+    assert(alloc_page() == NULL);
+
+    unsigned int nr_free_store = nr_free;
+    nr_free = 0;
+
+    free_pages(p0 + 2, 3);
+    assert(alloc_pages(4) == NULL);
+    assert(PageProperty(p0 + 2) && p0[2].property == 3);
+    assert((p1 = alloc_pages(3)) != NULL);
+    assert(alloc_page() == NULL);
+    assert(p0 + 2 == p1);
+
+    p2 = p0 + 1;
+    free_page(p0);
+    free_pages(p1, 3);
+    assert(PageProperty(p0) && p0->property == 1);
+    assert(PageProperty(p1) && p1->property == 3);
+
+    assert((p0 = alloc_page()) == p2 - 1);
+    free_page(p0);
+    assert((p0 = alloc_pages(2)) == p2 + 1);
+
+    free_pages(p0, 2);
+    free_page(p2);
+
+    assert((p0 = alloc_pages(5)) != NULL);
+    assert(alloc_page() == NULL);
+
+    assert(nr_free == 0);
+    nr_free = nr_free_store;
+
+    free_list = free_list_store;
+    free_pages(p0, 5);
+
+    le = &free_list;
+    while ((le = list_next(le)) != &free_list) {
+        struct Page *p = le2page(le, page_link);
+        count --, total -= p->property;
+    }
+    assert(count == 0);
+    assert(total == 0);
+}
+
+const struct pmm_manager default_pmm_manager = {
+    .name = "default_pmm_manager",
+    .init = default_init,
+    .init_memmap = default_init_memmap,
+    .alloc_pages = default_alloc_pages,
+    .free_pages = default_free_pages,
+    .nr_free_pages = default_nr_free_pages,
+    .check = default_check,
+};
+
diff -r -u -P lab6_origin/kern/mm/default_pmm.h lab6/kern/mm/default_pmm.h
--- lab6_origin/kern/mm/default_pmm.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/mm/default_pmm.h	2019-02-26 20:51:17.055380600 +0800
@@ -0,0 +1,9 @@
+#ifndef __KERN_MM_DEFAULT_PMM_H__
+#define  __KERN_MM_DEFAULT_PMM_H__
+
+#include <pmm.h>
+
+extern const struct pmm_manager default_pmm_manager;
+extern free_area_t free_area;
+#endif /* ! __KERN_MM_DEFAULT_PMM_H__ */
+
diff -r -u -P lab6_origin/kern/mm/kmalloc.c lab6/kern/mm/kmalloc.c
--- lab6_origin/kern/mm/kmalloc.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/mm/kmalloc.c	2019-02-26 20:51:17.055877300 +0800
@@ -0,0 +1,305 @@
+#include <defs.h>
+#include <list.h>
+#include <memlayout.h>
+#include <assert.h>
+#include <kmalloc.h>
+#include <sync.h>
+#include <pmm.h>
+#include <stdio.h>
+
+/*
+ * SLOB Allocator: Simple List Of Blocks
+ *
+ * Matt Mackall <mpm@selenic.com> 12/30/03
+ *
+ * How SLOB works:
+ *
+ * The core of SLOB is a traditional K&R style heap allocator, with
+ * support for returning aligned objects. The granularity of this
+ * allocator is 8 bytes on x86, though it's perhaps possible to reduce
+ * this to 4 if it's deemed worth the effort. The slob heap is a
+ * singly-linked list of pages from __get_free_page, grown on demand
+ * and allocation from the heap is currently first-fit.
+ *
+ * Above this is an implementation of kmalloc/kfree. Blocks returned
+ * from kmalloc are 8-byte aligned and prepended with a 8-byte header.
+ * If kmalloc is asked for objects of PAGE_SIZE or larger, it calls
+ * __get_free_pages directly so that it can return page-aligned blocks
+ * and keeps a linked list of such pages and their orders. These
+ * objects are detected in kfree() by their page alignment.
+ *
+ * SLAB is emulated on top of SLOB by simply calling constructors and
+ * destructors for every SLAB allocation. Objects are returned with
+ * the 8-byte alignment unless the SLAB_MUST_HWCACHE_ALIGN flag is
+ * set, in which case the low-level allocator will fragment blocks to
+ * create the proper alignment. Again, objects of page-size or greater
+ * are allocated by calling __get_free_pages. As SLAB objects know
+ * their size, no separate size bookkeeping is necessary and there is
+ * essentially no allocation space overhead.
+ */
+
+
+//some helper
+#define spin_lock_irqsave(l, f) local_intr_save(f)
+#define spin_unlock_irqrestore(l, f) local_intr_restore(f)
+typedef unsigned int gfp_t;
+#ifndef PAGE_SIZE
+#define PAGE_SIZE PGSIZE
+#endif
+
+#ifndef L1_CACHE_BYTES
+#define L1_CACHE_BYTES 64
+#endif
+
+#ifndef ALIGN
+#define ALIGN(addr,size)   (((addr)+(size)-1)&(~((size)-1))) 
+#endif
+
+
+struct slob_block {
+	int units;
+	struct slob_block *next;
+};
+typedef struct slob_block slob_t;
+
+#define SLOB_UNIT sizeof(slob_t)
+#define SLOB_UNITS(size) (((size) + SLOB_UNIT - 1)/SLOB_UNIT)
+#define SLOB_ALIGN L1_CACHE_BYTES
+
+struct bigblock {
+	int order;
+	void *pages;
+	struct bigblock *next;
+};
+typedef struct bigblock bigblock_t;
+
+static slob_t arena = { .next = &arena, .units = 1 };
+static slob_t *slobfree = &arena;
+static bigblock_t *bigblocks;
+
+
+static void* __slob_get_free_pages(gfp_t gfp, int order)
+{
+  struct Page * page = alloc_pages(1 << order);
+  if(!page)
+    return NULL;
+  return page2kva(page);
+}
+
+#define __slob_get_free_page(gfp) __slob_get_free_pages(gfp, 0)
+
+static inline void __slob_free_pages(unsigned long kva, int order)
+{
+  free_pages(kva2page(kva), 1 << order);
+}
+
+static void slob_free(void *b, int size);
+
+static void *slob_alloc(size_t size, gfp_t gfp, int align)
+{
+  assert( (size + SLOB_UNIT) < PAGE_SIZE );
+
+	slob_t *prev, *cur, *aligned = 0;
+	int delta = 0, units = SLOB_UNITS(size);
+	unsigned long flags;
+
+	spin_lock_irqsave(&slob_lock, flags);
+	prev = slobfree;
+	for (cur = prev->next; ; prev = cur, cur = cur->next) {
+		if (align) {
+			aligned = (slob_t *)ALIGN((unsigned long)cur, align);
+			delta = aligned - cur;
+		}
+		if (cur->units >= units + delta) { /* room enough? */
+			if (delta) { /* need to fragment head to align? */
+				aligned->units = cur->units - delta;
+				aligned->next = cur->next;
+				cur->next = aligned;
+				cur->units = delta;
+				prev = cur;
+				cur = aligned;
+			}
+
+			if (cur->units == units) /* exact fit? */
+				prev->next = cur->next; /* unlink */
+			else { /* fragment */
+				prev->next = cur + units;
+				prev->next->units = cur->units - units;
+				prev->next->next = cur->next;
+				cur->units = units;
+			}
+
+			slobfree = prev;
+			spin_unlock_irqrestore(&slob_lock, flags);
+			return cur;
+		}
+		if (cur == slobfree) {
+			spin_unlock_irqrestore(&slob_lock, flags);
+
+			if (size == PAGE_SIZE) /* trying to shrink arena? */
+				return 0;
+
+			cur = (slob_t *)__slob_get_free_page(gfp);
+			if (!cur)
+				return 0;
+
+			slob_free(cur, PAGE_SIZE);
+			spin_lock_irqsave(&slob_lock, flags);
+			cur = slobfree;
+		}
+	}
+}
+
+static void slob_free(void *block, int size)
+{
+	slob_t *cur, *b = (slob_t *)block;
+	unsigned long flags;
+
+	if (!block)
+		return;
+
+	if (size)
+		b->units = SLOB_UNITS(size);
+
+	/* Find reinsertion point */
+	spin_lock_irqsave(&slob_lock, flags);
+	for (cur = slobfree; !(b > cur && b < cur->next); cur = cur->next)
+		if (cur >= cur->next && (b > cur || b < cur->next))
+			break;
+
+	if (b + b->units == cur->next) {
+		b->units += cur->next->units;
+		b->next = cur->next->next;
+	} else
+		b->next = cur->next;
+
+	if (cur + cur->units == b) {
+		cur->units += b->units;
+		cur->next = b->next;
+	} else
+		cur->next = b;
+
+	slobfree = cur;
+
+	spin_unlock_irqrestore(&slob_lock, flags);
+}
+
+
+
+void
+slob_init(void) {
+  cprintf("use SLOB allocator\n");
+}
+
+inline void 
+kmalloc_init(void) {
+    slob_init();
+    cprintf("kmalloc_init() succeeded!\n");
+}
+
+size_t
+slob_allocated(void) {
+  return 0;
+}
+
+size_t
+kallocated(void) {
+   return slob_allocated();
+}
+
+static int find_order(int size)
+{
+	int order = 0;
+	for ( ; size > 4096 ; size >>=1)
+		order++;
+	return order;
+}
+
+static void *__kmalloc(size_t size, gfp_t gfp)
+{
+	slob_t *m;
+	bigblock_t *bb;
+	unsigned long flags;
+
+	if (size < PAGE_SIZE - SLOB_UNIT) {
+		m = slob_alloc(size + SLOB_UNIT, gfp, 0);
+		return m ? (void *)(m + 1) : 0;
+	}
+
+	bb = slob_alloc(sizeof(bigblock_t), gfp, 0);
+	if (!bb)
+		return 0;
+
+	bb->order = find_order(size);
+	bb->pages = (void *)__slob_get_free_pages(gfp, bb->order);
+
+	if (bb->pages) {
+		spin_lock_irqsave(&block_lock, flags);
+		bb->next = bigblocks;
+		bigblocks = bb;
+		spin_unlock_irqrestore(&block_lock, flags);
+		return bb->pages;
+	}
+
+	slob_free(bb, sizeof(bigblock_t));
+	return 0;
+}
+
+void *
+kmalloc(size_t size)
+{
+  return __kmalloc(size, 0);
+}
+
+
+void kfree(void *block)
+{
+	bigblock_t *bb, **last = &bigblocks;
+	unsigned long flags;
+
+	if (!block)
+		return;
+
+	if (!((unsigned long)block & (PAGE_SIZE-1))) {
+		/* might be on the big block list */
+		spin_lock_irqsave(&block_lock, flags);
+		for (bb = bigblocks; bb; last = &bb->next, bb = bb->next) {
+			if (bb->pages == block) {
+				*last = bb->next;
+				spin_unlock_irqrestore(&block_lock, flags);
+				__slob_free_pages((unsigned long)block, bb->order);
+				slob_free(bb, sizeof(bigblock_t));
+				return;
+			}
+		}
+		spin_unlock_irqrestore(&block_lock, flags);
+	}
+
+	slob_free((slob_t *)block - 1, 0);
+	return;
+}
+
+
+unsigned int ksize(const void *block)
+{
+	bigblock_t *bb;
+	unsigned long flags;
+
+	if (!block)
+		return 0;
+
+	if (!((unsigned long)block & (PAGE_SIZE-1))) {
+		spin_lock_irqsave(&block_lock, flags);
+		for (bb = bigblocks; bb; bb = bb->next)
+			if (bb->pages == block) {
+				spin_unlock_irqrestore(&slob_lock, flags);
+				return PAGE_SIZE << bb->order;
+			}
+		spin_unlock_irqrestore(&block_lock, flags);
+	}
+
+	return ((slob_t *)block - 1)->units * SLOB_UNIT;
+}
+
+
+
diff -r -u -P lab6_origin/kern/mm/kmalloc.h lab6/kern/mm/kmalloc.h
--- lab6_origin/kern/mm/kmalloc.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/mm/kmalloc.h	2019-02-26 20:51:17.057876500 +0800
@@ -0,0 +1,16 @@
+#ifndef __KERN_MM_KMALLOC_H__
+#define __KERN_MM_KMALLOC_H__
+
+#include <defs.h>
+
+#define KMALLOC_MAX_ORDER       10
+
+void kmalloc_init(void);
+
+void *kmalloc(size_t n);
+void kfree(void *objp);
+
+size_t kallocated(void);
+
+#endif /* !__KERN_MM_KMALLOC_H__ */
+
diff -r -u -P lab6_origin/kern/mm/memlayout.h lab6/kern/mm/memlayout.h
--- lab6_origin/kern/mm/memlayout.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/mm/memlayout.h	2019-02-26 20:51:17.058374900 +0800
@@ -0,0 +1,163 @@
+#ifndef __KERN_MM_MEMLAYOUT_H__
+#define __KERN_MM_MEMLAYOUT_H__
+
+/* This file contains the definitions for memory management in our OS. */
+
+/* global segment number */
+#define SEG_KTEXT   1
+#define SEG_KDATA   2
+#define SEG_UTEXT   3
+#define SEG_UDATA   4
+#define SEG_TSS     5
+
+/* global descrptor numbers */
+#define GD_KTEXT    ((SEG_KTEXT) << 3)      // kernel text
+#define GD_KDATA    ((SEG_KDATA) << 3)      // kernel data
+#define GD_UTEXT    ((SEG_UTEXT) << 3)      // user text
+#define GD_UDATA    ((SEG_UDATA) << 3)      // user data
+#define GD_TSS      ((SEG_TSS) << 3)        // task segment selector
+
+#define DPL_KERNEL  (0)
+#define DPL_USER    (3)
+
+#define KERNEL_CS   ((GD_KTEXT) | DPL_KERNEL)
+#define KERNEL_DS   ((GD_KDATA) | DPL_KERNEL)
+#define USER_CS     ((GD_UTEXT) | DPL_USER)
+#define USER_DS     ((GD_UDATA) | DPL_USER)
+
+/* *
+ * Virtual memory map:                                          Permissions
+ *                                                              kernel/user
+ *
+ *     4G ------------------> +---------------------------------+
+ *                            |                                 |
+ *                            |         Empty Memory (*)        |
+ *                            |                                 |
+ *                            +---------------------------------+ 0xFB000000
+ *                            |   Cur. Page Table (Kern, RW)    | RW/-- PTSIZE
+ *     VPT -----------------> +---------------------------------+ 0xFAC00000
+ *                            |        Invalid Memory (*)       | --/--
+ *     KERNTOP -------------> +---------------------------------+ 0xF8000000
+ *                            |                                 |
+ *                            |    Remapped Physical Memory     | RW/-- KMEMSIZE
+ *                            |                                 |
+ *     KERNBASE ------------> +---------------------------------+ 0xC0000000
+ *                            |        Invalid Memory (*)       | --/--
+ *     USERTOP -------------> +---------------------------------+ 0xB0000000
+ *                            |           User stack            |
+ *                            +---------------------------------+
+ *                            |                                 |
+ *                            :                                 :
+ *                            |         ~~~~~~~~~~~~~~~~        |
+ *                            :                                 :
+ *                            |                                 |
+ *                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *                            |       User Program & Heap       |
+ *     UTEXT ---------------> +---------------------------------+ 0x00800000
+ *                            |        Invalid Memory (*)       | --/--
+ *                            |  - - - - - - - - - - - - - - -  |
+ *                            |    User STAB Data (optional)    |
+ *     USERBASE, USTAB------> +---------------------------------+ 0x00200000
+ *                            |        Invalid Memory (*)       | --/--
+ *     0 -------------------> +---------------------------------+ 0x00000000
+ * (*) Note: The kernel ensures that "Invalid Memory" is *never* mapped.
+ *     "Empty Memory" is normally unmapped, but user programs may map pages
+ *     there if desired.
+ *
+ * */
+
+/* All physical memory mapped at this address */
+#define KERNBASE            0xC0000000
+#define KMEMSIZE            0x38000000                  // the maximum amount of physical memory
+#define KERNTOP             (KERNBASE + KMEMSIZE)
+
+/* *
+ * Virtual page table. Entry PDX[VPT] in the PD (Page Directory) contains
+ * a pointer to the page directory itself, thereby turning the PD into a page
+ * table, which maps all the PTEs (Page Table Entry) containing the page mappings
+ * for the entire virtual address space into that 4 Meg region starting at VPT.
+ * */
+#define VPT                 0xFAC00000
+
+#define KSTACKPAGE          2                           // # of pages in kernel stack
+#define KSTACKSIZE          (KSTACKPAGE * PGSIZE)       // sizeof kernel stack
+
+#define USERTOP             0xB0000000
+#define USTACKTOP           USERTOP
+#define USTACKPAGE          256                         // # of pages in user stack
+#define USTACKSIZE          (USTACKPAGE * PGSIZE)       // sizeof user stack
+
+#define USERBASE            0x00200000
+#define UTEXT               0x00800000                  // where user programs generally begin
+#define USTAB               USERBASE                    // the location of the user STABS data structure
+
+#define USER_ACCESS(start, end)                     \
+(USERBASE <= (start) && (start) < (end) && (end) <= USERTOP)
+
+#define KERN_ACCESS(start, end)                     \
+(KERNBASE <= (start) && (start) < (end) && (end) <= KERNTOP)
+
+#ifndef __ASSEMBLER__
+
+#include <defs.h>
+#include <atomic.h>
+#include <list.h>
+
+typedef uintptr_t pte_t;
+typedef uintptr_t pde_t;
+typedef pte_t swap_entry_t; //the pte can also be a swap entry
+
+// some constants for bios interrupt 15h AX = 0xE820
+#define E820MAX             20      // number of entries in E820MAP
+#define E820_ARM            1       // address range memory
+#define E820_ARR            2       // address range reserved
+
+struct e820map {
+    int nr_map;
+    struct {
+        uint64_t addr;
+        uint64_t size;
+        uint32_t type;
+    } __attribute__((packed)) map[E820MAX];
+};
+
+/* *
+ * struct Page - Page descriptor structures. Each Page describes one
+ * physical page. In kern/mm/pmm.h, you can find lots of useful functions
+ * that convert Page to other data types, such as phyical address.
+ * */
+struct Page {
+    int ref;                        // page frame's reference counter
+    uint32_t flags;                 // array of flags that describe the status of the page frame
+    unsigned int property;          // the num of free block, used in first fit pm manager
+    list_entry_t page_link;         // free list link
+    list_entry_t pra_page_link;     // used for pra (page replace algorithm)
+    uintptr_t pra_vaddr;            // used for pra (page replace algorithm)
+};
+
+/* Flags describing the status of a page frame */
+#define PG_reserved                 0       // if this bit=1: the Page is reserved for kernel, cannot be used in alloc/free_pages; otherwise, this bit=0 
+#define PG_property                 1       // if this bit=1: the Page is the head page of a free memory block(contains some continuous_addrress pages), and can be used in alloc_pages; if this bit=0: if the Page is the the head page of a free memory block, then this Page and the memory block is alloced. Or this Page isn't the head page.
+
+#define SetPageReserved(page)       set_bit(PG_reserved, &((page)->flags))
+#define ClearPageReserved(page)     clear_bit(PG_reserved, &((page)->flags))
+#define PageReserved(page)          test_bit(PG_reserved, &((page)->flags))
+#define SetPageProperty(page)       set_bit(PG_property, &((page)->flags))
+#define ClearPageProperty(page)     clear_bit(PG_property, &((page)->flags))
+#define PageProperty(page)          test_bit(PG_property, &((page)->flags))
+
+// convert list entry to page
+#define le2page(le, member)                 \
+    to_struct((le), struct Page, member)
+
+/* free_area_t - maintains a doubly linked list to record free (unused) pages */
+typedef struct {
+    list_entry_t free_list;         // the list header
+    unsigned int nr_free;           // # of free pages in this free list
+} free_area_t;
+
+
+#endif /* !__ASSEMBLER__ */
+
+#endif /* !__KERN_MM_MEMLAYOUT_H__ */
+
diff -r -u -P lab6_origin/kern/mm/mmu.h lab6/kern/mm/mmu.h
--- lab6_origin/kern/mm/mmu.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/mm/mmu.h	2019-02-26 20:51:17.058870700 +0800
@@ -0,0 +1,272 @@
+#ifndef __KERN_MM_MMU_H__
+#define __KERN_MM_MMU_H__
+
+/* Eflags register */
+#define FL_CF           0x00000001  // Carry Flag
+#define FL_PF           0x00000004  // Parity Flag
+#define FL_AF           0x00000010  // Auxiliary carry Flag
+#define FL_ZF           0x00000040  // Zero Flag
+#define FL_SF           0x00000080  // Sign Flag
+#define FL_TF           0x00000100  // Trap Flag
+#define FL_IF           0x00000200  // Interrupt Flag
+#define FL_DF           0x00000400  // Direction Flag
+#define FL_OF           0x00000800  // Overflow Flag
+#define FL_IOPL_MASK    0x00003000  // I/O Privilege Level bitmask
+#define FL_IOPL_0       0x00000000  //   IOPL == 0
+#define FL_IOPL_1       0x00001000  //   IOPL == 1
+#define FL_IOPL_2       0x00002000  //   IOPL == 2
+#define FL_IOPL_3       0x00003000  //   IOPL == 3
+#define FL_NT           0x00004000  // Nested Task
+#define FL_RF           0x00010000  // Resume Flag
+#define FL_VM           0x00020000  // Virtual 8086 mode
+#define FL_AC           0x00040000  // Alignment Check
+#define FL_VIF          0x00080000  // Virtual Interrupt Flag
+#define FL_VIP          0x00100000  // Virtual Interrupt Pending
+#define FL_ID           0x00200000  // ID flag
+
+/* Application segment type bits */
+#define STA_X           0x8         // Executable segment
+#define STA_E           0x4         // Expand down (non-executable segments)
+#define STA_C           0x4         // Conforming code segment (executable only)
+#define STA_W           0x2         // Writeable (non-executable segments)
+#define STA_R           0x2         // Readable (executable segments)
+#define STA_A           0x1         // Accessed
+
+/* System segment type bits */
+#define STS_T16A        0x1         // Available 16-bit TSS
+#define STS_LDT         0x2         // Local Descriptor Table
+#define STS_T16B        0x3         // Busy 16-bit TSS
+#define STS_CG16        0x4         // 16-bit Call Gate
+#define STS_TG          0x5         // Task Gate / Coum Transmitions
+#define STS_IG16        0x6         // 16-bit Interrupt Gate
+#define STS_TG16        0x7         // 16-bit Trap Gate
+#define STS_T32A        0x9         // Available 32-bit TSS
+#define STS_T32B        0xB         // Busy 32-bit TSS
+#define STS_CG32        0xC         // 32-bit Call Gate
+#define STS_IG32        0xE         // 32-bit Interrupt Gate
+#define STS_TG32        0xF         // 32-bit Trap Gate
+
+#ifdef __ASSEMBLER__
+
+#define SEG_NULL                                                \
+    .word 0, 0;                                                 \
+    .byte 0, 0, 0, 0
+
+#define SEG_ASM(type,base,lim)                                  \
+    .word (((lim) >> 12) & 0xffff), ((base) & 0xffff);          \
+    .byte (((base) >> 16) & 0xff), (0x90 | (type)),             \
+        (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
+
+#else /* not __ASSEMBLER__ */
+
+#include <defs.h>
+
+/* Gate descriptors for interrupts and traps */
+struct gatedesc {
+    unsigned gd_off_15_0 : 16;      // low 16 bits of offset in segment
+    unsigned gd_ss : 16;            // segment selector
+    unsigned gd_args : 5;           // # args, 0 for interrupt/trap gates
+    unsigned gd_rsv1 : 3;           // reserved(should be zero I guess)
+    unsigned gd_type : 4;           // type(STS_{TG,IG32,TG32})
+    unsigned gd_s : 1;              // must be 0 (system)
+    unsigned gd_dpl : 2;            // descriptor(meaning new) privilege level
+    unsigned gd_p : 1;              // Present
+    unsigned gd_off_31_16 : 16;     // high bits of offset in segment
+};
+
+/* *
+ * Set up a normal interrupt/trap gate descriptor
+ *   - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate
+ *   - sel: Code segment selector for interrupt/trap handler
+ *   - off: Offset in code segment for interrupt/trap handler
+ *   - dpl: Descriptor Privilege Level - the privilege level required
+ *          for software to invoke this interrupt/trap gate explicitly
+ *          using an int instruction.
+ * */
+#define SETGATE(gate, istrap, sel, off, dpl) {               \
+        (gate).gd_off_15_0 = (uint32_t)(off) & 0xffff;      \
+        (gate).gd_ss = (sel);                                \
+        (gate).gd_args = 0;                                 \
+        (gate).gd_rsv1 = 0;                                 \
+        (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;    \
+        (gate).gd_s = 0;                                    \
+        (gate).gd_dpl = (dpl);                              \
+        (gate).gd_p = 1;                                    \
+        (gate).gd_off_31_16 = (uint32_t)(off) >> 16;        \
+    }
+
+/* Set up a call gate descriptor */
+#define SETCALLGATE(gate, ss, off, dpl) {                   \
+        (gate).gd_off_15_0 = (uint32_t)(off) & 0xffff;      \
+        (gate).gd_ss = (ss);                                \
+        (gate).gd_args = 0;                                 \
+        (gate).gd_rsv1 = 0;                                 \
+        (gate).gd_type = STS_CG32;                          \
+        (gate).gd_s = 0;                                    \
+        (gate).gd_dpl = (dpl);                              \
+        (gate).gd_p = 1;                                    \
+        (gate).gd_off_31_16 = (uint32_t)(off) >> 16;        \
+    }
+
+/* segment descriptors */
+struct segdesc {
+    unsigned sd_lim_15_0 : 16;      // low bits of segment limit
+    unsigned sd_base_15_0 : 16;     // low bits of segment base address
+    unsigned sd_base_23_16 : 8;     // middle bits of segment base address
+    unsigned sd_type : 4;           // segment type (see STS_ constants)
+    unsigned sd_s : 1;              // 0 = system, 1 = application
+    unsigned sd_dpl : 2;            // descriptor Privilege Level
+    unsigned sd_p : 1;              // present
+    unsigned sd_lim_19_16 : 4;      // high bits of segment limit
+    unsigned sd_avl : 1;            // unused (available for software use)
+    unsigned sd_rsv1 : 1;           // reserved
+    unsigned sd_db : 1;             // 0 = 16-bit segment, 1 = 32-bit segment
+    unsigned sd_g : 1;              // granularity: limit scaled by 4K when set
+    unsigned sd_base_31_24 : 8;     // high bits of segment base address
+};
+
+#define SEG_NULL                                            \
+    (struct segdesc) {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
+
+#define SEG(type, base, lim, dpl)                           \
+    (struct segdesc) {                                      \
+        ((lim) >> 12) & 0xffff, (base) & 0xffff,            \
+        ((base) >> 16) & 0xff, type, 1, dpl, 1,             \
+        (unsigned)(lim) >> 28, 0, 0, 1, 1,                  \
+        (unsigned) (base) >> 24                             \
+    }
+
+#define SEGTSS(type, base, lim, dpl)                        \
+    (struct segdesc) {                                      \
+        (lim) & 0xffff, (base) & 0xffff,                    \
+        ((base) >> 16) & 0xff, type, 0, dpl, 1,             \
+        (unsigned) (lim) >> 16, 0, 0, 1, 0,                 \
+        (unsigned) (base) >> 24                             \
+    }
+
+/* task state segment format (as described by the Pentium architecture book) */
+struct taskstate {
+    uint32_t ts_link;       // old ts selector
+    uintptr_t ts_esp0;      // stack pointers and segment selectors
+    uint16_t ts_ss0;        // after an increase in privilege level
+    uint16_t ts_padding1;
+    uintptr_t ts_esp1;
+    uint16_t ts_ss1;
+    uint16_t ts_padding2;
+    uintptr_t ts_esp2;
+    uint16_t ts_ss2;
+    uint16_t ts_padding3;
+    uintptr_t ts_cr3;       // page directory base
+    uintptr_t ts_eip;       // saved state from last task switch
+    uint32_t ts_eflags;
+    uint32_t ts_eax;        // more saved state (registers)
+    uint32_t ts_ecx;
+    uint32_t ts_edx;
+    uint32_t ts_ebx;
+    uintptr_t ts_esp;
+    uintptr_t ts_ebp;
+    uint32_t ts_esi;
+    uint32_t ts_edi;
+    uint16_t ts_es;         // even more saved state (segment selectors)
+    uint16_t ts_padding4;
+    uint16_t ts_cs;
+    uint16_t ts_padding5;
+    uint16_t ts_ss;
+    uint16_t ts_padding6;
+    uint16_t ts_ds;
+    uint16_t ts_padding7;
+    uint16_t ts_fs;
+    uint16_t ts_padding8;
+    uint16_t ts_gs;
+    uint16_t ts_padding9;
+    uint16_t ts_ldt;
+    uint16_t ts_padding10;
+    uint16_t ts_t;          // trap on task switch
+    uint16_t ts_iomb;       // i/o map base address
+} __attribute__((packed));
+
+#endif /* !__ASSEMBLER__ */
+
+// A linear address 'la' has a three-part structure as follows:
+//
+// +--------10------+-------10-------+---------12----------+
+// | Page Directory |   Page Table   | Offset within Page  |
+// |      Index     |     Index      |                     |
+// +----------------+----------------+---------------------+
+//  \--- PDX(la) --/ \--- PTX(la) --/ \---- PGOFF(la) ----/
+//  \----------- PPN(la) -----------/
+//
+// The PDX, PTX, PGOFF, and PPN macros decompose linear addresses as shown.
+// To construct a linear address la from PDX(la), PTX(la), and PGOFF(la),
+// use PGADDR(PDX(la), PTX(la), PGOFF(la)).
+
+// page directory index
+#define PDX(la) ((((uintptr_t)(la)) >> PDXSHIFT) & 0x3FF)
+
+// page table index
+#define PTX(la) ((((uintptr_t)(la)) >> PTXSHIFT) & 0x3FF)
+
+// page number field of address
+#define PPN(la) (((uintptr_t)(la)) >> PTXSHIFT)
+
+// offset in page
+#define PGOFF(la) (((uintptr_t)(la)) & 0xFFF)
+
+// construct linear address from indexes and offset
+#define PGADDR(d, t, o) ((uintptr_t)((d) << PDXSHIFT | (t) << PTXSHIFT | (o)))
+
+// address in page table or page directory entry
+#define PTE_ADDR(pte)   ((uintptr_t)(pte) & ~0xFFF)
+#define PDE_ADDR(pde)   PTE_ADDR(pde)
+
+/* page directory and page table constants */
+#define NPDEENTRY       1024                    // page directory entries per page directory
+#define NPTEENTRY       1024                    // page table entries per page table
+
+#define PGSIZE          4096                    // bytes mapped by a page
+#define PGSHIFT         12                      // log2(PGSIZE)
+#define PTSIZE          (PGSIZE * NPTEENTRY)    // bytes mapped by a page directory entry
+#define PTSHIFT         22                      // log2(PTSIZE)
+
+#define PTXSHIFT        12                      // offset of PTX in a linear address
+#define PDXSHIFT        22                      // offset of PDX in a linear address
+
+/* page table/directory entry flags */
+#define PTE_P           0x001                   // Present
+#define PTE_W           0x002                   // Writeable
+#define PTE_U           0x004                   // User
+#define PTE_PWT         0x008                   // Write-Through
+#define PTE_PCD         0x010                   // Cache-Disable
+#define PTE_A           0x020                   // Accessed
+#define PTE_D           0x040                   // Dirty
+#define PTE_PS          0x080                   // Page Size
+#define PTE_MBZ         0x180                   // Bits must be zero
+#define PTE_AVAIL       0xE00                   // Available for software use
+                                                // The PTE_AVAIL bits aren't used by the kernel or interpreted by the
+                                                // hardware, so user processes are allowed to set them arbitrarily.
+
+#define PTE_USER        (PTE_U | PTE_W | PTE_P)
+
+/* Control Register flags */
+#define CR0_PE          0x00000001              // Protection Enable
+#define CR0_MP          0x00000002              // Monitor coProcessor
+#define CR0_EM          0x00000004              // Emulation
+#define CR0_TS          0x00000008              // Task Switched
+#define CR0_ET          0x00000010              // Extension Type
+#define CR0_NE          0x00000020              // Numeric Errror
+#define CR0_WP          0x00010000              // Write Protect
+#define CR0_AM          0x00040000              // Alignment Mask
+#define CR0_NW          0x20000000              // Not Writethrough
+#define CR0_CD          0x40000000              // Cache Disable
+#define CR0_PG          0x80000000              // Paging
+
+#define CR4_PCE         0x00000100              // Performance counter enable
+#define CR4_MCE         0x00000040              // Machine Check Enable
+#define CR4_PSE         0x00000010              // Page Size Extensions
+#define CR4_DE          0x00000008              // Debugging Extensions
+#define CR4_TSD         0x00000004              // Time Stamp Disable
+#define CR4_PVI         0x00000002              // Protected-Mode Virtual Interrupts
+#define CR4_VME         0x00000001              // V86 Mode Extensions
+
+#endif /* !__KERN_MM_MMU_H__ */
+
diff -r -u -P lab6_origin/kern/mm/pmm.c lab6/kern/mm/pmm.c
--- lab6_origin/kern/mm/pmm.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/mm/pmm.c	2019-05-06 17:02:38.829162100 +0800
@@ -0,0 +1,743 @@
+#include <defs.h>
+#include <x86.h>
+#include <stdio.h>
+#include <string.h>
+#include <mmu.h>
+#include <memlayout.h>
+#include <pmm.h>
+#include <default_pmm.h>
+#include <sync.h>
+#include <error.h>
+#include <swap.h>
+#include <vmm.h>
+#include <kmalloc.h>
+
+/* *
+ * Task State Segment:
+ *
+ * The TSS may reside anywhere in memory. A special segment register called
+ * the Task Register (TR) holds a segment selector that points a valid TSS
+ * segment descriptor which resides in the GDT. Therefore, to use a TSS
+ * the following must be done in function gdt_init:
+ *   - create a TSS descriptor entry in GDT
+ *   - add enough information to the TSS in memory as needed
+ *   - load the TR register with a segment selector for that segment
+ *
+ * There are several fileds in TSS for specifying the new stack pointer when a
+ * privilege level change happens. But only the fields SS0 and ESP0 are useful
+ * in our os kernel.
+ *
+ * The field SS0 contains the stack segment selector for CPL = 0, and the ESP0
+ * contains the new ESP value for CPL = 0. When an interrupt happens in protected
+ * mode, the x86 CPU will look in the TSS for SS0 and ESP0 and load their value
+ * into SS and ESP respectively.
+ * */
+static struct taskstate ts = {0};
+
+// virtual address of physicall page array
+struct Page *pages;
+// amount of physical memory (in pages)
+size_t npage = 0;
+
+// virtual address of boot-time page directory
+extern pde_t __boot_pgdir;
+pde_t *boot_pgdir = &__boot_pgdir;
+// physical address of boot-time page directory
+uintptr_t boot_cr3;
+
+// physical memory management
+const struct pmm_manager *pmm_manager;
+
+/* *
+ * The page directory entry corresponding to the virtual address range
+ * [VPT, VPT + PTSIZE) points to the page directory itself. Thus, the page
+ * directory is treated as a page table as well as a page directory.
+ *
+ * One result of treating the page directory as a page table is that all PTEs
+ * can be accessed though a "virtual page table" at virtual address VPT. And the
+ * PTE for number n is stored in vpt[n].
+ *
+ * A second consequence is that the contents of the current page directory will
+ * always available at virtual address PGADDR(PDX(VPT), PDX(VPT), 0), to which
+ * vpd is set bellow.
+ * */
+pte_t * const vpt = (pte_t *)VPT;
+pde_t * const vpd = (pde_t *)PGADDR(PDX(VPT), PDX(VPT), 0);
+
+/* *
+ * Global Descriptor Table:
+ *
+ * The kernel and user segments are identical (except for the DPL). To load
+ * the %ss register, the CPL must equal the DPL. Thus, we must duplicate the
+ * segments for the user and the kernel. Defined as follows:
+ *   - 0x0 :  unused (always faults -- for trapping NULL far pointers)
+ *   - 0x8 :  kernel code segment
+ *   - 0x10:  kernel data segment
+ *   - 0x18:  user code segment
+ *   - 0x20:  user data segment
+ *   - 0x28:  defined for tss, initialized in gdt_init
+ * */
+static struct segdesc gdt[] = {
+    SEG_NULL,
+    [SEG_KTEXT] = SEG(STA_X | STA_R, 0x0, 0xFFFFFFFF, DPL_KERNEL),
+    [SEG_KDATA] = SEG(STA_W, 0x0, 0xFFFFFFFF, DPL_KERNEL),
+    [SEG_UTEXT] = SEG(STA_X | STA_R, 0x0, 0xFFFFFFFF, DPL_USER),
+    [SEG_UDATA] = SEG(STA_W, 0x0, 0xFFFFFFFF, DPL_USER),
+    [SEG_TSS]   = SEG_NULL,
+};
+
+static struct pseudodesc gdt_pd = {
+    sizeof(gdt) - 1, (uintptr_t)gdt
+};
+
+static void check_alloc_page(void);
+static void check_pgdir(void);
+static void check_boot_pgdir(void);
+
+/* *
+ * lgdt - load the global descriptor table register and reset the
+ * data/code segement registers for kernel.
+ * */
+static inline void
+lgdt(struct pseudodesc *pd) {
+    asm volatile ("lgdt (%0)" :: "r" (pd));
+    asm volatile ("movw %%ax, %%gs" :: "a" (USER_DS));
+    asm volatile ("movw %%ax, %%fs" :: "a" (USER_DS));
+    asm volatile ("movw %%ax, %%es" :: "a" (KERNEL_DS));
+    asm volatile ("movw %%ax, %%ds" :: "a" (KERNEL_DS));
+    asm volatile ("movw %%ax, %%ss" :: "a" (KERNEL_DS));
+    // reload cs
+    asm volatile ("ljmp %0, $1f\n 1:\n" :: "i" (KERNEL_CS));
+}
+
+/* *
+ * load_esp0 - change the ESP0 in default task state segment,
+ * so that we can use different kernel stack when we trap frame
+ * user to kernel.
+ * */
+void
+load_esp0(uintptr_t esp0) {
+    ts.ts_esp0 = esp0;
+}
+
+/* gdt_init - initialize the default GDT and TSS */
+static void
+gdt_init(void) {
+    // set boot kernel stack and default SS0
+    load_esp0((uintptr_t)bootstacktop);
+    ts.ts_ss0 = KERNEL_DS;
+
+    // initialize the TSS filed of the gdt
+    gdt[SEG_TSS] = SEGTSS(STS_T32A, (uintptr_t)&ts, sizeof(ts), DPL_KERNEL);
+
+    // reload all segment registers
+    lgdt(&gdt_pd);
+
+    // load the TSS
+    ltr(GD_TSS);
+}
+
+//init_pmm_manager - initialize a pmm_manager instance
+static void
+init_pmm_manager(void) {
+    pmm_manager = &default_pmm_manager;
+    cprintf("memory management: %s\n", pmm_manager->name);
+    pmm_manager->init();
+}
+
+//init_memmap - call pmm->init_memmap to build Page struct for free memory  
+static void
+init_memmap(struct Page *base, size_t n) {
+    pmm_manager->init_memmap(base, n);
+}
+
+//alloc_pages - call pmm->alloc_pages to allocate a continuous n*PAGESIZE memory 
+struct Page *
+alloc_pages(size_t n) {
+    struct Page *page=NULL;
+    bool intr_flag;
+    
+    while (1)
+    {
+         local_intr_save(intr_flag);
+         {
+              page = pmm_manager->alloc_pages(n);
+         }
+         local_intr_restore(intr_flag);
+
+         if (page != NULL || n > 1 || swap_init_ok == 0) break;
+         
+         extern struct mm_struct *check_mm_struct;
+         //cprintf("page %x, call swap_out in alloc_pages %d\n",page, n);
+         swap_out(check_mm_struct, n, 0);
+    }
+    //cprintf("n %d,get page %x, No %d in alloc_pages\n",n,page,(page-pages));
+    return page;
+}
+
+//free_pages - call pmm->free_pages to free a continuous n*PAGESIZE memory 
+void
+free_pages(struct Page *base, size_t n) {
+    bool intr_flag;
+    local_intr_save(intr_flag);
+    {
+        pmm_manager->free_pages(base, n);
+    }
+    local_intr_restore(intr_flag);
+}
+
+//nr_free_pages - call pmm->nr_free_pages to get the size (nr*PAGESIZE) 
+//of current free memory
+size_t
+nr_free_pages(void) {
+    size_t ret;
+    bool intr_flag;
+    local_intr_save(intr_flag);
+    {
+        ret = pmm_manager->nr_free_pages();
+    }
+    local_intr_restore(intr_flag);
+    return ret;
+}
+
+/* pmm_init - initialize the physical memory management */
+static void
+page_init(void) {
+    struct e820map *memmap = (struct e820map *)(0x8000 + KERNBASE);
+    uint64_t maxpa = 0;
+
+    cprintf("e820map:\n");
+    int i;
+    for (i = 0; i < memmap->nr_map; i ++) {
+        uint64_t begin = memmap->map[i].addr, end = begin + memmap->map[i].size;
+        cprintf("  memory: %08llx, [%08llx, %08llx], type = %d.\n",
+                memmap->map[i].size, begin, end - 1, memmap->map[i].type);
+        if (memmap->map[i].type == E820_ARM) {
+            if (maxpa < end && begin < KMEMSIZE) {
+                maxpa = end;
+            }
+        }
+    }
+    if (maxpa > KMEMSIZE) {
+        maxpa = KMEMSIZE;
+    }
+
+    extern char end[];
+
+    npage = maxpa / PGSIZE;
+    pages = (struct Page *)ROUNDUP((void *)end, PGSIZE);
+
+    for (i = 0; i < npage; i ++) {
+        SetPageReserved(pages + i);
+    }
+
+    uintptr_t freemem = PADDR((uintptr_t)pages + sizeof(struct Page) * npage);
+
+    for (i = 0; i < memmap->nr_map; i ++) {
+        uint64_t begin = memmap->map[i].addr, end = begin + memmap->map[i].size;
+        if (memmap->map[i].type == E820_ARM) {
+            if (begin < freemem) {
+                begin = freemem;
+            }
+            if (end > KMEMSIZE) {
+                end = KMEMSIZE;
+            }
+            if (begin < end) {
+                begin = ROUNDUP(begin, PGSIZE);
+                end = ROUNDDOWN(end, PGSIZE);
+                if (begin < end) {
+                    init_memmap(pa2page(begin), (end - begin) / PGSIZE);
+                }
+            }
+        }
+    }
+}
+
+//boot_map_segment - setup&enable the paging mechanism
+// parameters
+//  la:   linear address of this memory need to map (after x86 segment map)
+//  size: memory size
+//  pa:   physical address of this memory
+//  perm: permission of this memory  
+static void
+boot_map_segment(pde_t *pgdir, uintptr_t la, size_t size, uintptr_t pa, uint32_t perm) {
+    assert(PGOFF(la) == PGOFF(pa));
+    size_t n = ROUNDUP(size + PGOFF(la), PGSIZE) / PGSIZE;
+    la = ROUNDDOWN(la, PGSIZE);
+    pa = ROUNDDOWN(pa, PGSIZE);
+    for (; n > 0; n --, la += PGSIZE, pa += PGSIZE) {
+        pte_t *ptep = get_pte(pgdir, la, 1);
+        assert(ptep != NULL);
+        *ptep = pa | PTE_P | perm;
+    }
+}
+
+//boot_alloc_page - allocate one page using pmm->alloc_pages(1) 
+// return value: the kernel virtual address of this allocated page
+//note: this function is used to get the memory for PDT(Page Directory Table)&PT(Page Table)
+static void *
+boot_alloc_page(void) {
+    struct Page *p = alloc_page();
+    if (p == NULL) {
+        panic("boot_alloc_page failed.\n");
+    }
+    return page2kva(p);
+}
+
+//pmm_init - setup a pmm to manage physical memory, build PDT&PT to setup paging mechanism 
+//         - check the correctness of pmm & paging mechanism, print PDT&PT
+void
+pmm_init(void) {
+    // We've already enabled paging
+    boot_cr3 = PADDR(boot_pgdir);
+
+    //We need to alloc/free the physical memory (granularity is 4KB or other size). 
+    //So a framework of physical memory manager (struct pmm_manager)is defined in pmm.h
+    //First we should init a physical memory manager(pmm) based on the framework.
+    //Then pmm can alloc/free the physical memory. 
+    //Now the first_fit/best_fit/worst_fit/buddy_system pmm are available.
+    init_pmm_manager();
+
+    // detect physical memory space, reserve already used memory,
+    // then use pmm->init_memmap to create free page list
+    page_init();
+
+    //use pmm->check to verify the correctness of the alloc/free function in a pmm
+    check_alloc_page();
+
+    check_pgdir();
+
+    static_assert(KERNBASE % PTSIZE == 0 && KERNTOP % PTSIZE == 0);
+
+    // recursively insert boot_pgdir in itself
+    // to form a virtual page table at virtual address VPT
+    boot_pgdir[PDX(VPT)] = PADDR(boot_pgdir) | PTE_P | PTE_W;
+
+    // map all physical memory to linear memory with base linear addr KERNBASE
+    // linear_addr KERNBASE ~ KERNBASE + KMEMSIZE = phy_addr 0 ~ KMEMSIZE
+    boot_map_segment(boot_pgdir, KERNBASE, KMEMSIZE, 0, PTE_W);
+
+    // Since we are using bootloader's GDT,
+    // we should reload gdt (second time, the last time) to get user segments and the TSS
+    // map virtual_addr 0 ~ 4G = linear_addr 0 ~ 4G
+    // then set kernel stack (ss:esp) in TSS, setup TSS in gdt, load TSS
+    gdt_init();
+
+    //now the basic virtual memory map(see memalyout.h) is established.
+    //check the correctness of the basic virtual memory map.
+    check_boot_pgdir();
+
+    print_pgdir();
+    
+    kmalloc_init();
+
+}
+
+//get_pte - get pte and return the kernel virtual address of this pte for la
+//        - if the PT contians this pte didn't exist, alloc a page for PT
+// parameter:
+//  pgdir:  the kernel virtual base address of PDT
+//  la:     the linear address need to map
+//  create: a logical value to decide if alloc a page for PT
+// return vaule: the kernel virtual address of this pte
+pte_t *
+get_pte(pde_t *pgdir, uintptr_t la, bool create) {
+    /* LAB2 EXERCISE 2: YOUR CODE
+     *
+     * If you need to visit a physical address, please use KADDR()
+     * please read pmm.h for useful macros
+     *
+     * Maybe you want help comment, BELOW comments can help you finish the code
+     *
+     * Some Useful MACROs and DEFINEs, you can use them in below implementation.
+     * MACROs or Functions:
+     *   PDX(la) = the index of page directory entry of VIRTUAL ADDRESS la.
+     *   KADDR(pa) : takes a physical address and returns the corresponding kernel virtual address.
+     *   set_page_ref(page,1) : means the page be referenced by one time
+     *   page2pa(page): get the physical address of memory which this (struct Page *) page  manages
+     *   struct Page * alloc_page() : allocation a page
+     *   memset(void *s, char c, size_t n) : sets the first n bytes of the memory area pointed by s
+     *                                       to the specified value c.
+     * DEFINEs:
+     *   PTE_P           0x001                   // page table/directory entry flags bit : Present
+     *   PTE_W           0x002                   // page table/directory entry flags bit : Writeable
+     *   PTE_U           0x004                   // page table/directory entry flags bit : User can access
+     */
+    pde_t *pdep = &pgdir[PDX(la)];   // (1) find page directory entry
+    struct Page *page;
+    if (!(*pdep & PTE_P) ) {              // (2) check if entry is not present
+        if (!create || (page = alloc_page()) == NULL) {
+            return NULL;
+        }     // (3) check if creating is needed, then alloc page for page table
+              // CAUTION: this page is used for page table, not for common data page
+        set_page_ref(page, 1);       // (4) set page reference
+        uintptr_t pa = page2pa(page); // (5) get linear address of page
+        memset(KADDR(pa),0,PGSIZE);                  // (6) clear page content using memset
+        *pdep = pa | PTE_U | PTE_W | PTE_P;                  // (7) set page directory entry's permission
+    }
+    return &((pte_t *)KADDR(PDE_ADDR(*pdep)))[PTX(la)];          // (8) return page table entry
+
+}
+
+//get_page - get related Page struct for linear address la using PDT pgdir
+struct Page *
+get_page(pde_t *pgdir, uintptr_t la, pte_t **ptep_store) {
+    pte_t *ptep = get_pte(pgdir, la, 0);
+    if (ptep_store != NULL) {
+        *ptep_store = ptep;
+    }
+    if (ptep != NULL && *ptep & PTE_P) {
+        return pte2page(*ptep);
+    }
+    return NULL;
+}
+
+//page_remove_pte - free an Page sturct which is related linear address la
+//                - and clean(invalidate) pte which is related linear address la
+//note: PT is changed, so the TLB need to be invalidate 
+static inline void
+page_remove_pte(pde_t *pgdir, uintptr_t la, pte_t *ptep) {
+    /* LAB2 EXERCISE 3: YOUR CODE
+     *
+     * Please check if ptep is valid, and tlb must be manually updated if mapping is updated
+     *
+     * Maybe you want help comment, BELOW comments can help you finish the code
+     *
+     * Some Useful MACROs and DEFINEs, you can use them in below implementation.
+     * MACROs or Functions:
+     *   struct Page *page pte2page(*ptep): get the according page from the value of a ptep
+     *   free_page : free a page
+     *   page_ref_dec(page) : decrease page->ref. NOTICE: ff page->ref == 0 , then this page should be free.
+     *   tlb_invalidate(pde_t *pgdir, uintptr_t la) : Invalidate a TLB entry, but only if the page tables being
+     *                        edited are the ones currently in use by the processor.
+     * DEFINEs:
+     *   PTE_P           0x001                   // page table/directory entry flags bit : Present
+     */
+    if (*ptep & PTE_P) {
+        struct Page *page = pte2page(*ptep);
+        if (page_ref_dec(page) == 0) {
+            free_page(page);
+        }
+        *ptep = 0;
+        tlb_invalidate(pgdir, la);
+    }
+}
+
+void
+unmap_range(pde_t *pgdir, uintptr_t start, uintptr_t end) {
+    assert(start % PGSIZE == 0 && end % PGSIZE == 0);
+    assert(USER_ACCESS(start, end));
+
+    do {
+        pte_t *ptep = get_pte(pgdir, start, 0);
+        if (ptep == NULL) {
+            start = ROUNDDOWN(start + PTSIZE, PTSIZE);
+            continue ;
+        }
+        if (*ptep != 0) {
+            page_remove_pte(pgdir, start, ptep);
+        }
+        start += PGSIZE;
+    } while (start != 0 && start < end);
+}
+
+void
+exit_range(pde_t *pgdir, uintptr_t start, uintptr_t end) {
+    assert(start % PGSIZE == 0 && end % PGSIZE == 0);
+    assert(USER_ACCESS(start, end));
+
+    start = ROUNDDOWN(start, PTSIZE);
+    do {
+        int pde_idx = PDX(start);
+        if (pgdir[pde_idx] & PTE_P) {
+            free_page(pde2page(pgdir[pde_idx]));
+            pgdir[pde_idx] = 0;
+        }
+        start += PTSIZE;
+    } while (start != 0 && start < end);
+}
+/* copy_range - copy content of memory (start, end) of one process A to another process B
+ * @to:    the addr of process B's Page Directory
+ * @from:  the addr of process A's Page Directory
+ * @share: flags to indicate to dup OR share. We just use dup method, so it didn't be used.
+ *
+ * CALL GRAPH: copy_mm-->dup_mmap-->copy_range
+ */
+int
+copy_range(pde_t *to, pde_t *from, uintptr_t start, uintptr_t end, bool share) {
+    assert(start % PGSIZE == 0 && end % PGSIZE == 0);
+    assert(USER_ACCESS(start, end));
+    // copy content by page unit.
+    do {
+        //call get_pte to find process A's pte according to the addr start
+        pte_t *ptep = get_pte(from, start, 0), *nptep;
+        if (ptep == NULL) {
+            start = ROUNDDOWN(start + PTSIZE, PTSIZE);
+            continue ;
+        }
+        //call get_pte to find process B's pte according to the addr start. If pte is NULL, just alloc a PT
+        if (*ptep & PTE_P) {
+            if ((nptep = get_pte(to, start, 1)) == NULL) {
+                return -E_NO_MEM;
+            }
+            uint32_t perm = (*ptep & PTE_USER);
+            //get page from ptep
+            struct Page *page = pte2page(*ptep);
+            // alloc a page for process B
+            struct Page *npage=alloc_page();
+            assert(page!=NULL);
+            assert(npage!=NULL);
+            int ret=0;
+        /* LAB5:EXERCISE2 YOUR CODE
+         * replicate content of page to npage, build the map of phy addr of nage with the linear addr start
+         *
+         * Some Useful MACROs and DEFINEs, you can use them in below implementation.
+         * MACROs or Functions:
+         *    page2kva(struct Page *page): return the kernel vritual addr of memory which page managed (SEE pmm.h)
+         *    page_insert: build the map of phy addr of an Page with the linear addr la
+         *    memcpy: typical memory copy function
+         *
+         * (1) find src_kvaddr: the kernel virtual address of page
+         * (2) find dst_kvaddr: the kernel virtual address of npage
+         * (3) memory copy from src_kvaddr to dst_kvaddr, size is PGSIZE
+         * (4) build the map of phy addr of  nage with the linear addr start
+         */
+            char *src_kvaddr = page2kva(page); 
+            char *dst_kvaddr = page2kva(npage); 
+            memcpy(dst_kvaddr, src_kvaddr, PGSIZE); 
+            ret = page_insert(to, npage, start, perm); 
+            assert(ret == 0);
+        }
+        start += PGSIZE;
+    } while (start != 0 && start < end);
+    return 0;
+}
+
+//page_remove - free an Page which is related linear address la and has an validated pte
+void
+page_remove(pde_t *pgdir, uintptr_t la) {
+    pte_t *ptep = get_pte(pgdir, la, 0);
+    if (ptep != NULL) {
+        page_remove_pte(pgdir, la, ptep);
+    }
+}
+
+//page_insert - build the map of phy addr of an Page with the linear addr la
+// paramemters:
+//  pgdir: the kernel virtual base address of PDT
+//  page:  the Page which need to map
+//  la:    the linear address need to map
+//  perm:  the permission of this Page which is setted in related pte
+// return value: always 0
+//note: PT is changed, so the TLB need to be invalidate 
+int
+page_insert(pde_t *pgdir, struct Page *page, uintptr_t la, uint32_t perm) {
+    pte_t *ptep = get_pte(pgdir, la, 1);
+    if (ptep == NULL) {
+        return -E_NO_MEM;
+    }
+    page_ref_inc(page);
+    if (*ptep & PTE_P) {
+        struct Page *p = pte2page(*ptep);
+        if (p == page) {
+            page_ref_dec(page);
+        }
+        else {
+            page_remove_pte(pgdir, la, ptep);
+        }
+    }
+    *ptep = page2pa(page) | PTE_P | perm;
+    tlb_invalidate(pgdir, la);
+    return 0;
+}
+
+// invalidate a TLB entry, but only if the page tables being
+// edited are the ones currently in use by the processor.
+void
+tlb_invalidate(pde_t *pgdir, uintptr_t la) {
+    if (rcr3() == PADDR(pgdir)) {
+        invlpg((void *)la);
+    }
+}
+
+// pgdir_alloc_page - call alloc_page & page_insert functions to 
+//                  - allocate a page size memory & setup an addr map
+//                  - pa<->la with linear address la and the PDT pgdir
+struct Page *
+pgdir_alloc_page(pde_t *pgdir, uintptr_t la, uint32_t perm) {
+    struct Page *page = alloc_page();
+    if (page != NULL) {
+        if (page_insert(pgdir, page, la, perm) != 0) {
+            free_page(page);
+            return NULL;
+        }
+        if (swap_init_ok){
+            if(check_mm_struct!=NULL) {
+                swap_map_swappable(check_mm_struct, la, page, 0);
+                page->pra_vaddr=la;
+                assert(page_ref(page) == 1);
+                //cprintf("get No. %d  page: pra_vaddr %x, pra_link.prev %x, pra_link_next %x in pgdir_alloc_page\n", (page-pages), page->pra_vaddr,page->pra_page_link.prev, page->pra_page_link.next);
+            } 
+            else  {  //now current is existed, should fix it in the future
+                //swap_map_swappable(current->mm, la, page, 0);
+                //page->pra_vaddr=la;
+                //assert(page_ref(page) == 1);
+                //panic("pgdir_alloc_page: no pages. now current is existed, should fix it in the future\n");
+            }
+        }
+
+    }
+
+    return page;
+}
+
+static void
+check_alloc_page(void) {
+    pmm_manager->check();
+    cprintf("check_alloc_page() succeeded!\n");
+}
+
+static void
+check_pgdir(void) {
+    assert(npage <= KMEMSIZE / PGSIZE);
+    assert(boot_pgdir != NULL && (uint32_t)PGOFF(boot_pgdir) == 0);
+    assert(get_page(boot_pgdir, 0x0, NULL) == NULL);
+
+    struct Page *p1, *p2;
+    p1 = alloc_page();
+    assert(page_insert(boot_pgdir, p1, 0x0, 0) == 0);
+
+    pte_t *ptep;
+    assert((ptep = get_pte(boot_pgdir, 0x0, 0)) != NULL);
+    assert(pte2page(*ptep) == p1);
+    assert(page_ref(p1) == 1);
+
+    ptep = &((pte_t *)KADDR(PDE_ADDR(boot_pgdir[0])))[1];
+    assert(get_pte(boot_pgdir, PGSIZE, 0) == ptep);
+
+    p2 = alloc_page();
+    assert(page_insert(boot_pgdir, p2, PGSIZE, PTE_U | PTE_W) == 0);
+    assert((ptep = get_pte(boot_pgdir, PGSIZE, 0)) != NULL);
+    assert(*ptep & PTE_U);
+    assert(*ptep & PTE_W);
+    assert(boot_pgdir[0] & PTE_U);
+    assert(page_ref(p2) == 1);
+
+    assert(page_insert(boot_pgdir, p1, PGSIZE, 0) == 0);
+    assert(page_ref(p1) == 2);
+    assert(page_ref(p2) == 0);
+    assert((ptep = get_pte(boot_pgdir, PGSIZE, 0)) != NULL);
+    assert(pte2page(*ptep) == p1);
+    assert((*ptep & PTE_U) == 0);
+
+    page_remove(boot_pgdir, 0x0);
+    assert(page_ref(p1) == 1);
+    assert(page_ref(p2) == 0);
+
+    page_remove(boot_pgdir, PGSIZE);
+    assert(page_ref(p1) == 0);
+    assert(page_ref(p2) == 0);
+
+    assert(page_ref(pde2page(boot_pgdir[0])) == 1);
+    free_page(pde2page(boot_pgdir[0]));
+    boot_pgdir[0] = 0;
+
+    cprintf("check_pgdir() succeeded!\n");
+}
+
+static void
+check_boot_pgdir(void) {
+    pte_t *ptep;
+    int i;
+    for (i = 0; i < npage; i += PGSIZE) {
+        assert((ptep = get_pte(boot_pgdir, (uintptr_t)KADDR(i), 0)) != NULL);
+        assert(PTE_ADDR(*ptep) == i);
+    }
+
+    assert(PDE_ADDR(boot_pgdir[PDX(VPT)]) == PADDR(boot_pgdir));
+
+    assert(boot_pgdir[0] == 0);
+
+    struct Page *p;
+    p = alloc_page();
+    assert(page_insert(boot_pgdir, p, 0x100, PTE_W) == 0);
+    assert(page_ref(p) == 1);
+    assert(page_insert(boot_pgdir, p, 0x100 + PGSIZE, PTE_W) == 0);
+    assert(page_ref(p) == 2);
+
+    const char *str = "ucore: Hello world!!";
+    strcpy((void *)0x100, str);
+    assert(strcmp((void *)0x100, (void *)(0x100 + PGSIZE)) == 0);
+
+    *(char *)(page2kva(p) + 0x100) = '\0';
+    assert(strlen((const char *)0x100) == 0);
+
+    free_page(p);
+    free_page(pde2page(boot_pgdir[0]));
+    boot_pgdir[0] = 0;
+
+    cprintf("check_boot_pgdir() succeeded!\n");
+}
+
+//perm2str - use string 'u,r,w,-' to present the permission
+static const char *
+perm2str(int perm) {
+    static char str[4];
+    str[0] = (perm & PTE_U) ? 'u' : '-';
+    str[1] = 'r';
+    str[2] = (perm & PTE_W) ? 'w' : '-';
+    str[3] = '\0';
+    return str;
+}
+
+//get_pgtable_items - In [left, right] range of PDT or PT, find a continuous linear addr space
+//                  - (left_store*X_SIZE~right_store*X_SIZE) for PDT or PT
+//                  - X_SIZE=PTSIZE=4M, if PDT; X_SIZE=PGSIZE=4K, if PT
+// paramemters:
+//  left:        no use ???
+//  right:       the high side of table's range
+//  start:       the low side of table's range
+//  table:       the beginning addr of table
+//  left_store:  the pointer of the high side of table's next range
+//  right_store: the pointer of the low side of table's next range
+// return value: 0 - not a invalid item range, perm - a valid item range with perm permission 
+static int
+get_pgtable_items(size_t left, size_t right, size_t start, uintptr_t *table, size_t *left_store, size_t *right_store) {
+    if (start >= right) {
+        return 0;
+    }
+    while (start < right && !(table[start] & PTE_P)) {
+        start ++;
+    }
+    if (start < right) {
+        if (left_store != NULL) {
+            *left_store = start;
+        }
+        int perm = (table[start ++] & PTE_USER);
+        while (start < right && (table[start] & PTE_USER) == perm) {
+            start ++;
+        }
+        if (right_store != NULL) {
+            *right_store = start;
+        }
+        return perm;
+    }
+    return 0;
+}
+
+//print_pgdir - print the PDT&PT
+void
+print_pgdir(void) {
+    cprintf("-------------------- BEGIN --------------------\n");
+    size_t left, right = 0, perm;
+    while ((perm = get_pgtable_items(0, NPDEENTRY, right, vpd, &left, &right)) != 0) {
+        cprintf("PDE(%03x) %08x-%08x %08x %s\n", right - left,
+                left * PTSIZE, right * PTSIZE, (right - left) * PTSIZE, perm2str(perm));
+        size_t l, r = left * NPTEENTRY;
+        while ((perm = get_pgtable_items(left * NPTEENTRY, right * NPTEENTRY, r, vpt, &l, &r)) != 0) {
+            cprintf("  |-- PTE(%05x) %08x-%08x %08x %s\n", r - l,
+                    l * PGSIZE, r * PGSIZE, (r - l) * PGSIZE, perm2str(perm));
+        }
+    }
+    cprintf("--------------------- END ---------------------\n");
+}
diff -r -u -P lab6_origin/kern/mm/pmm.h lab6/kern/mm/pmm.h
--- lab6_origin/kern/mm/pmm.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/mm/pmm.h	2019-02-26 20:51:17.060878000 +0800
@@ -0,0 +1,147 @@
+#ifndef __KERN_MM_PMM_H__
+#define __KERN_MM_PMM_H__
+
+#include <defs.h>
+#include <mmu.h>
+#include <memlayout.h>
+#include <atomic.h>
+#include <assert.h>
+
+// pmm_manager is a physical memory management class. A special pmm manager - XXX_pmm_manager
+// only needs to implement the methods in pmm_manager class, then XXX_pmm_manager can be used
+// by ucore to manage the total physical memory space.
+struct pmm_manager {
+    const char *name;                                 // XXX_pmm_manager's name
+    void (*init)(void);                               // initialize internal description&management data structure
+                                                      // (free block list, number of free block) of XXX_pmm_manager 
+    void (*init_memmap)(struct Page *base, size_t n); // setup description&management data structcure according to
+                                                      // the initial free physical memory space 
+    struct Page *(*alloc_pages)(size_t n);            // allocate >=n pages, depend on the allocation algorithm 
+    void (*free_pages)(struct Page *base, size_t n);  // free >=n pages with "base" addr of Page descriptor structures(memlayout.h)
+    size_t (*nr_free_pages)(void);                    // return the number of free pages 
+    void (*check)(void);                              // check the correctness of XXX_pmm_manager 
+};
+
+extern const struct pmm_manager *pmm_manager;
+extern pde_t *boot_pgdir;
+extern uintptr_t boot_cr3;
+
+void pmm_init(void);
+
+struct Page *alloc_pages(size_t n);
+void free_pages(struct Page *base, size_t n);
+size_t nr_free_pages(void);
+
+#define alloc_page() alloc_pages(1)
+#define free_page(page) free_pages(page, 1)
+
+pte_t *get_pte(pde_t *pgdir, uintptr_t la, bool create);
+struct Page *get_page(pde_t *pgdir, uintptr_t la, pte_t **ptep_store);
+void page_remove(pde_t *pgdir, uintptr_t la);
+int page_insert(pde_t *pgdir, struct Page *page, uintptr_t la, uint32_t perm);
+
+void load_esp0(uintptr_t esp0);
+void tlb_invalidate(pde_t *pgdir, uintptr_t la);
+struct Page *pgdir_alloc_page(pde_t *pgdir, uintptr_t la, uint32_t perm);
+void unmap_range(pde_t *pgdir, uintptr_t start, uintptr_t end);
+void exit_range(pde_t *pgdir, uintptr_t start, uintptr_t end);
+int copy_range(pde_t *to, pde_t *from, uintptr_t start, uintptr_t end, bool share);
+
+void print_pgdir(void);
+
+/* *
+ * PADDR - takes a kernel virtual address (an address that points above KERNBASE),
+ * where the machine's maximum 256MB of physical memory is mapped and returns the
+ * corresponding physical address.  It panics if you pass it a non-kernel virtual address.
+ * */
+#define PADDR(kva) ({                                                   \
+            uintptr_t __m_kva = (uintptr_t)(kva);                       \
+            if (__m_kva < KERNBASE) {                                   \
+                panic("PADDR called with invalid kva %08lx", __m_kva);  \
+            }                                                           \
+            __m_kva - KERNBASE;                                         \
+        })
+
+/* *
+ * KADDR - takes a physical address and returns the corresponding kernel virtual
+ * address. It panics if you pass an invalid physical address.
+ * */
+#define KADDR(pa) ({                                                    \
+            uintptr_t __m_pa = (pa);                                    \
+            size_t __m_ppn = PPN(__m_pa);                               \
+            if (__m_ppn >= npage) {                                     \
+                panic("KADDR called with invalid pa %08lx", __m_pa);    \
+            }                                                           \
+            (void *) (__m_pa + KERNBASE);                               \
+        })
+
+extern struct Page *pages;
+extern size_t npage;
+
+static inline ppn_t
+page2ppn(struct Page *page) {
+    return page - pages;
+}
+
+static inline uintptr_t
+page2pa(struct Page *page) {
+    return page2ppn(page) << PGSHIFT;
+}
+
+static inline struct Page *
+pa2page(uintptr_t pa) {
+    if (PPN(pa) >= npage) {
+        panic("pa2page called with invalid pa");
+    }
+    return &pages[PPN(pa)];
+}
+
+static inline void *
+page2kva(struct Page *page) {
+    return KADDR(page2pa(page));
+}
+
+static inline struct Page *
+kva2page(void *kva) {
+    return pa2page(PADDR(kva));
+}
+
+static inline struct Page *
+pte2page(pte_t pte) {
+    if (!(pte & PTE_P)) {
+        panic("pte2page called with invalid pte");
+    }
+    return pa2page(PTE_ADDR(pte));
+}
+
+static inline struct Page *
+pde2page(pde_t pde) {
+    return pa2page(PDE_ADDR(pde));
+}
+
+static inline int
+page_ref(struct Page *page) {
+    return page->ref;
+}
+
+static inline void
+set_page_ref(struct Page *page, int val) {
+    page->ref = val;
+}
+
+static inline int
+page_ref_inc(struct Page *page) {
+    page->ref += 1;
+    return page->ref;
+}
+
+static inline int
+page_ref_dec(struct Page *page) {
+    page->ref -= 1;
+    return page->ref;
+}
+
+extern char bootstack[], bootstacktop[];
+
+#endif /* !__KERN_MM_PMM_H__ */
+
diff -r -u -P lab6_origin/kern/mm/swap.c lab6/kern/mm/swap.c
--- lab6_origin/kern/mm/swap.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/mm/swap.c	2019-02-26 20:51:17.061366100 +0800
@@ -0,0 +1,284 @@
+#include <swap.h>
+#include <swapfs.h>
+#include <swap_fifo.h>
+#include <stdio.h>
+#include <string.h>
+#include <memlayout.h>
+#include <pmm.h>
+#include <mmu.h>
+#include <default_pmm.h>
+#include <kdebug.h>
+
+// the valid vaddr for check is between 0~CHECK_VALID_VADDR-1
+#define CHECK_VALID_VIR_PAGE_NUM 5
+#define BEING_CHECK_VALID_VADDR 0X1000
+#define CHECK_VALID_VADDR (CHECK_VALID_VIR_PAGE_NUM+1)*0x1000
+// the max number of valid physical page for check
+#define CHECK_VALID_PHY_PAGE_NUM 4
+// the max access seq number
+#define MAX_SEQ_NO 10
+
+static struct swap_manager *sm;
+size_t max_swap_offset;
+
+volatile int swap_init_ok = 0;
+
+unsigned int swap_page[CHECK_VALID_VIR_PAGE_NUM];
+
+unsigned int swap_in_seq_no[MAX_SEQ_NO],swap_out_seq_no[MAX_SEQ_NO];
+
+static void check_swap(void);
+
+int
+swap_init(void)
+{
+     swapfs_init();
+
+     if (!(1024 <= max_swap_offset && max_swap_offset < MAX_SWAP_OFFSET_LIMIT))
+     {
+          panic("bad max_swap_offset %08x.\n", max_swap_offset);
+     }
+     
+
+     sm = &swap_manager_fifo;
+     int r = sm->init();
+     
+     if (r == 0)
+     {
+          swap_init_ok = 1;
+          cprintf("SWAP: manager = %s\n", sm->name);
+          check_swap();
+     }
+
+     return r;
+}
+
+int
+swap_init_mm(struct mm_struct *mm)
+{
+     return sm->init_mm(mm);
+}
+
+int
+swap_tick_event(struct mm_struct *mm)
+{
+     return sm->tick_event(mm);
+}
+
+int
+swap_map_swappable(struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in)
+{
+     return sm->map_swappable(mm, addr, page, swap_in);
+}
+
+int
+swap_set_unswappable(struct mm_struct *mm, uintptr_t addr)
+{
+     return sm->set_unswappable(mm, addr);
+}
+
+volatile unsigned int swap_out_num=0;
+
+int
+swap_out(struct mm_struct *mm, int n, int in_tick)
+{
+     int i;
+     for (i = 0; i != n; ++ i)
+     {
+          uintptr_t v;
+          //struct Page **ptr_page=NULL;
+          struct Page *page;
+          // cprintf("i %d, SWAP: call swap_out_victim\n",i);
+          int r = sm->swap_out_victim(mm, &page, in_tick);
+          if (r != 0) {
+                    cprintf("i %d, swap_out: call swap_out_victim failed\n",i);
+                  break;
+          }          
+          //assert(!PageReserved(page));
+
+          //cprintf("SWAP: choose victim page 0x%08x\n", page);
+          
+          v=page->pra_vaddr; 
+          pte_t *ptep = get_pte(mm->pgdir, v, 0);
+          assert((*ptep & PTE_P) != 0);
+
+          if (swapfs_write( (page->pra_vaddr/PGSIZE+1)<<8, page) != 0) {
+                    cprintf("SWAP: failed to save\n");
+                    sm->map_swappable(mm, v, page, 0);
+                    continue;
+          }
+          else {
+                    cprintf("swap_out: i %d, store page in vaddr 0x%x to disk swap entry %d\n", i, v, page->pra_vaddr/PGSIZE+1);
+                    *ptep = (page->pra_vaddr/PGSIZE+1)<<8;
+                    free_page(page);
+          }
+          
+          tlb_invalidate(mm->pgdir, v);
+     }
+     return i;
+}
+
+int
+swap_in(struct mm_struct *mm, uintptr_t addr, struct Page **ptr_result)
+{
+     struct Page *result = alloc_page();
+     assert(result!=NULL);
+
+     pte_t *ptep = get_pte(mm->pgdir, addr, 0);
+     // cprintf("SWAP: load ptep %x swap entry %d to vaddr 0x%08x, page %x, No %d\n", ptep, (*ptep)>>8, addr, result, (result-pages));
+    
+     int r;
+     if ((r = swapfs_read((*ptep), result)) != 0)
+     {
+        assert(r!=0);
+     }
+     cprintf("swap_in: load disk swap entry %d with swap_page in vadr 0x%x\n", (*ptep)>>8, addr);
+     *ptr_result=result;
+     return 0;
+}
+
+
+
+static inline void
+check_content_set(void)
+{
+     *(unsigned char *)0x1000 = 0x0a;
+     assert(pgfault_num==1);
+     *(unsigned char *)0x1010 = 0x0a;
+     assert(pgfault_num==1);
+     *(unsigned char *)0x2000 = 0x0b;
+     assert(pgfault_num==2);
+     *(unsigned char *)0x2010 = 0x0b;
+     assert(pgfault_num==2);
+     *(unsigned char *)0x3000 = 0x0c;
+     assert(pgfault_num==3);
+     *(unsigned char *)0x3010 = 0x0c;
+     assert(pgfault_num==3);
+     *(unsigned char *)0x4000 = 0x0d;
+     assert(pgfault_num==4);
+     *(unsigned char *)0x4010 = 0x0d;
+     assert(pgfault_num==4);
+}
+
+static inline int
+check_content_access(void)
+{
+    int ret = sm->check_swap();
+    return ret;
+}
+
+struct Page * check_rp[CHECK_VALID_PHY_PAGE_NUM];
+pte_t * check_ptep[CHECK_VALID_PHY_PAGE_NUM];
+unsigned int check_swap_addr[CHECK_VALID_VIR_PAGE_NUM];
+
+extern free_area_t free_area;
+
+#define free_list (free_area.free_list)
+#define nr_free (free_area.nr_free)
+
+static void
+check_swap(void)
+{
+    //backup mem env
+     int ret, count = 0, total = 0, i;
+     list_entry_t *le = &free_list;
+     while ((le = list_next(le)) != &free_list) {
+        struct Page *p = le2page(le, page_link);
+        assert(PageProperty(p));
+        count ++, total += p->property;
+     }
+     assert(total == nr_free_pages());
+     cprintf("BEGIN check_swap: count %d, total %d\n",count,total);
+     
+     //now we set the phy pages env     
+     struct mm_struct *mm = mm_create();
+     assert(mm != NULL);
+
+     extern struct mm_struct *check_mm_struct;
+     assert(check_mm_struct == NULL);
+
+     check_mm_struct = mm;
+
+     pde_t *pgdir = mm->pgdir = boot_pgdir;
+     assert(pgdir[0] == 0);
+
+     struct vma_struct *vma = vma_create(BEING_CHECK_VALID_VADDR, CHECK_VALID_VADDR, VM_WRITE | VM_READ);
+     assert(vma != NULL);
+
+     insert_vma_struct(mm, vma);
+
+     //setup the temp Page Table vaddr 0~4MB
+     cprintf("setup Page Table for vaddr 0X1000, so alloc a page\n");
+     pte_t *temp_ptep=NULL;
+     temp_ptep = get_pte(mm->pgdir, BEING_CHECK_VALID_VADDR, 1);
+     assert(temp_ptep!= NULL);
+     cprintf("setup Page Table vaddr 0~4MB OVER!\n");
+     
+     for (i=0;i<CHECK_VALID_PHY_PAGE_NUM;i++) {
+          check_rp[i] = alloc_page();
+          assert(check_rp[i] != NULL );
+          assert(!PageProperty(check_rp[i]));
+     }
+     list_entry_t free_list_store = free_list;
+     list_init(&free_list);
+     assert(list_empty(&free_list));
+     
+     //assert(alloc_page() == NULL);
+     
+     unsigned int nr_free_store = nr_free;
+     nr_free = 0;
+     for (i=0;i<CHECK_VALID_PHY_PAGE_NUM;i++) {
+        free_pages(check_rp[i],1);
+     }
+     assert(nr_free==CHECK_VALID_PHY_PAGE_NUM);
+     
+     cprintf("set up init env for check_swap begin!\n");
+     //setup initial vir_page<->phy_page environment for page relpacement algorithm 
+
+     
+     pgfault_num=0;
+     
+     check_content_set();
+     assert( nr_free == 0);         
+     for(i = 0; i<MAX_SEQ_NO ; i++) 
+         swap_out_seq_no[i]=swap_in_seq_no[i]=-1;
+     
+     for (i= 0;i<CHECK_VALID_PHY_PAGE_NUM;i++) {
+         check_ptep[i]=0;
+         check_ptep[i] = get_pte(pgdir, (i+1)*0x1000, 0);
+         //cprintf("i %d, check_ptep addr %x, value %x\n", i, check_ptep[i], *check_ptep[i]);
+         assert(check_ptep[i] != NULL);
+         assert(pte2page(*check_ptep[i]) == check_rp[i]);
+         assert((*check_ptep[i] & PTE_P));          
+     }
+     cprintf("set up init env for check_swap over!\n");
+     // now access the virt pages to test  page relpacement algorithm 
+     ret=check_content_access();
+     assert(ret==0);
+     
+     //restore kernel mem env
+     for (i=0;i<CHECK_VALID_PHY_PAGE_NUM;i++) {
+         free_pages(check_rp[i],1);
+     } 
+
+     //free_page(pte2page(*temp_ptep));
+    free_page(pde2page(pgdir[0]));
+     pgdir[0] = 0;
+     mm->pgdir = NULL;
+     mm_destroy(mm);
+     check_mm_struct = NULL;
+     
+     nr_free = nr_free_store;
+     free_list = free_list_store;
+
+     
+     le = &free_list;
+     while ((le = list_next(le)) != &free_list) {
+         struct Page *p = le2page(le, page_link);
+         count --, total -= p->property;
+     }
+     cprintf("count is %d, total is %d\n",count,total);
+     //assert(count == 0);
+     
+     cprintf("check_swap() succeeded!\n");
+}
diff -r -u -P lab6_origin/kern/mm/swap_fifo.c lab6/kern/mm/swap_fifo.c
--- lab6_origin/kern/mm/swap_fifo.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/mm/swap_fifo.c	2019-05-07 22:14:00.101808600 +0800
@@ -0,0 +1,150 @@
+#include <defs.h>
+#include <x86.h>
+#include <stdio.h>
+#include <string.h>
+#include <swap.h>
+#include <swap_fifo.h>
+#include <list.h>
+
+/* [wikipedia]The simplest Page Replacement Algorithm(PRA) is a FIFO algorithm. The first-in, first-out
+ * page replacement algorithm is a low-overhead algorithm that requires little book-keeping on
+ * the part of the operating system. The idea is obvious from the name - the operating system
+ * keeps track of all the pages in memory in a queue, with the most recent arrival at the back,
+ * and the earliest arrival in front. When a page needs to be replaced, the page at the front
+ * of the queue (the oldest page) is selected. While FIFO is cheap and intuitive, it performs
+ * poorly in practical application. Thus, it is rarely used in its unmodified form. This
+ * algorithm experiences Belady's anomaly.
+ *
+ * Details of FIFO PRA
+ * (1) Prepare: In order to implement FIFO PRA, we should manage all swappable pages, so we can
+ *              link these pages into pra_list_head according the time order. At first you should
+ *              be familiar to the struct list in list.h. struct list is a simple doubly linked list
+ *              implementation. You should know howto USE: list_init, list_add(list_add_after),
+ *              list_add_before, list_del, list_next, list_prev. Another tricky method is to transform
+ *              a general list struct to a special struct (such as struct page). You can find some MACRO:
+ *              le2page (in memlayout.h), (in future labs: le2vma (in vmm.h), le2proc (in proc.h),etc.
+ */
+
+list_entry_t pra_list_head;
+/*
+ * (2) _fifo_init_mm: init pra_list_head and let  mm->sm_priv point to the addr of pra_list_head.
+ *              Now, From the memory control struct mm_struct, we can access FIFO PRA
+ */
+static int
+_fifo_init_mm(struct mm_struct *mm)
+{     
+     list_init(&pra_list_head);
+     mm->sm_priv = &pra_list_head;
+     //cprintf(" mm->sm_priv %x in fifo_init_mm\n",mm->sm_priv);
+     return 0;
+}
+/*
+ * (3)_fifo_map_swappable: According FIFO PRA, we should link the most recent arrival page at the back of pra_list_head qeueue
+ */
+static int
+_fifo_map_swappable(struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in)
+{
+    list_entry_t *head=(list_entry_t*) mm->sm_priv;
+    list_entry_t *entry=&(page->pra_page_link);
+ 
+    assert(entry != NULL && head != NULL);
+    //record the page access situlation
+    /*LAB3 EXERCISE 2: YOUR CODE*/ 
+    //(1)link the most recent arrival page at the back of the pra_list_head qeueue.
+    list_add_before(head, entry);
+    return 0;
+}
+/*
+ *  (4)_fifo_swap_out_victim: According FIFO PRA, we should unlink the  earliest arrival page in front of pra_list_head qeueue,
+ *                            then assign the value of *ptr_page to the addr of this page.
+ */
+static int
+_fifo_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, int in_tick)
+{
+    list_entry_t *head=(list_entry_t*) mm->sm_priv;
+    assert(head != NULL);
+    assert(in_tick==0);
+    /* Select the victim */
+    /*LAB3 EXERCISE 2: YOUR CODE*/ 
+    //(1)  unlink the  earliest arrival page in front of pra_list_head qeueue
+    //(2)  assign the value of *ptr_page to the addr of this page
+    list_entry_t *le = list_next(head);
+    assert(le != NULL);
+    struct Page *p = le2page(le,pra_page_link);
+    list_del(le);
+    assert(p != NULL);
+    *ptr_page = p;     
+    return 0;
+}
+
+static int
+_fifo_check_swap(void) {
+    cprintf("write Virt Page c in fifo_check_swap\n");
+    *(unsigned char *)0x3000 = 0x0c;
+    assert(pgfault_num==4);
+    cprintf("write Virt Page a in fifo_check_swap\n");
+    *(unsigned char *)0x1000 = 0x0a;
+    assert(pgfault_num==4);
+    cprintf("write Virt Page d in fifo_check_swap\n");
+    *(unsigned char *)0x4000 = 0x0d;
+    assert(pgfault_num==4);
+    cprintf("write Virt Page b in fifo_check_swap\n");
+    *(unsigned char *)0x2000 = 0x0b;
+    assert(pgfault_num==4);
+    cprintf("write Virt Page e in fifo_check_swap\n");
+    *(unsigned char *)0x5000 = 0x0e;
+    assert(pgfault_num==5);
+    cprintf("write Virt Page b in fifo_check_swap\n");
+    *(unsigned char *)0x2000 = 0x0b;
+    assert(pgfault_num==5);
+    cprintf("write Virt Page a in fifo_check_swap\n");
+    *(unsigned char *)0x1000 = 0x0a;
+    assert(pgfault_num==6);
+    cprintf("write Virt Page b in fifo_check_swap\n");
+    *(unsigned char *)0x2000 = 0x0b;
+    assert(pgfault_num==7);
+    cprintf("write Virt Page c in fifo_check_swap\n");
+    *(unsigned char *)0x3000 = 0x0c;
+    assert(pgfault_num==8);
+    cprintf("write Virt Page d in fifo_check_swap\n");
+    *(unsigned char *)0x4000 = 0x0d;
+    assert(pgfault_num==9);
+    cprintf("write Virt Page e in fifo_check_swap\n");
+    *(unsigned char *)0x5000 = 0x0e;
+    assert(pgfault_num==10);
+    cprintf("write Virt Page a in fifo_check_swap\n");
+    assert(*(unsigned char *)0x1000 == 0x0a);
+    *(unsigned char *)0x1000 = 0x0a;
+    assert(pgfault_num==11);
+    return 0;
+}
+
+
+static int
+_fifo_init(void)
+{
+    return 0;
+}
+
+static int
+_fifo_set_unswappable(struct mm_struct *mm, uintptr_t addr)
+{
+    return 0;
+}
+
+static int
+_fifo_tick_event(struct mm_struct *mm)
+{ return 0; }
+
+
+struct swap_manager swap_manager_fifo =
+{
+     .name            = "fifo swap manager",
+     .init            = &_fifo_init,
+     .init_mm         = &_fifo_init_mm,
+     .tick_event      = &_fifo_tick_event,
+     .map_swappable   = &_fifo_map_swappable,
+     .set_unswappable = &_fifo_set_unswappable,
+     .swap_out_victim = &_fifo_swap_out_victim,
+     .check_swap      = &_fifo_check_swap,
+};
diff -r -u -P lab6_origin/kern/mm/swap_fifo.h lab6/kern/mm/swap_fifo.h
--- lab6_origin/kern/mm/swap_fifo.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/mm/swap_fifo.h	2019-02-26 20:51:17.063864200 +0800
@@ -0,0 +1,7 @@
+#ifndef __KERN_MM_SWAP_FIFO_H__
+#define __KERN_MM_SWAP_FIFO_H__
+
+#include <swap.h>
+extern struct swap_manager swap_manager_fifo;
+
+#endif
diff -r -u -P lab6_origin/kern/mm/swap.h lab6/kern/mm/swap.h
--- lab6_origin/kern/mm/swap.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/mm/swap.h	2019-02-26 20:51:17.062364800 +0800
@@ -0,0 +1,65 @@
+#ifndef __KERN_MM_SWAP_H__
+#define __KERN_MM_SWAP_H__
+
+#include <defs.h>
+#include <memlayout.h>
+#include <pmm.h>
+#include <vmm.h>
+
+/* *
+ * swap_entry_t
+ * --------------------------------------------
+ * |         offset        |   reserved   | 0 |
+ * --------------------------------------------
+ *           24 bits            7 bits    1 bit
+ * */
+
+#define MAX_SWAP_OFFSET_LIMIT                   (1 << 24)
+
+extern size_t max_swap_offset;
+
+/* *
+ * swap_offset - takes a swap_entry (saved in pte), and returns
+ * the corresponding offset in swap mem_map.
+ * */
+#define swap_offset(entry) ({                                       \
+               size_t __offset = (entry >> 8);                        \
+               if (!(__offset > 0 && __offset < max_swap_offset)) {    \
+                    panic("invalid swap_entry_t = %08x.\n", entry);    \
+               }                                                    \
+               __offset;                                            \
+          })
+
+struct swap_manager
+{
+     const char *name;
+     /* Global initialization for the swap manager */
+     int (*init)            (void);
+     /* Initialize the priv data inside mm_struct */
+     int (*init_mm)         (struct mm_struct *mm);
+     /* Called when tick interrupt occured */
+     int (*tick_event)      (struct mm_struct *mm);
+     /* Called when map a swappable page into the mm_struct */
+     int (*map_swappable)   (struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in);
+     /* When a page is marked as shared, this routine is called to
+      * delete the addr entry from the swap manager */
+     int (*set_unswappable) (struct mm_struct *mm, uintptr_t addr);
+     /* Try to swap out a page, return then victim */
+     int (*swap_out_victim) (struct mm_struct *mm, struct Page **ptr_page, int in_tick);
+     /* check the page relpacement algorithm */
+     int (*check_swap)(void);     
+};
+
+extern volatile int swap_init_ok;
+int swap_init(void);
+int swap_init_mm(struct mm_struct *mm);
+int swap_tick_event(struct mm_struct *mm);
+int swap_map_swappable(struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in);
+int swap_set_unswappable(struct mm_struct *mm, uintptr_t addr);
+int swap_out(struct mm_struct *mm, int n, int in_tick);
+int swap_in(struct mm_struct *mm, uintptr_t addr, struct Page **ptr_result);
+
+//#define MEMBER_OFFSET(m,t) ((int)(&((t *)0)->m))
+//#define FROM_MEMBER(m,t,a) ((t *)((char *)(a) - MEMBER_OFFSET(m,t)))
+
+#endif
diff -r -u -P lab6_origin/kern/mm/vmm.c lab6/kern/mm/vmm.c
--- lab6_origin/kern/mm/vmm.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/mm/vmm.c	2019-05-06 16:52:58.738286500 +0800
@@ -0,0 +1,541 @@
+#include <vmm.h>
+#include <sync.h>
+#include <string.h>
+#include <assert.h>
+#include <stdio.h>
+#include <error.h>
+#include <pmm.h>
+#include <x86.h>
+#include <swap.h>
+#include <kmalloc.h>
+
+/* 
+  vmm design include two parts: mm_struct (mm) & vma_struct (vma)
+  mm is the memory manager for the set of continuous virtual memory  
+  area which have the same PDT. vma is a continuous virtual memory area.
+  There a linear link list for vma & a redblack link list for vma in mm.
+---------------
+  mm related functions:
+   golbal functions
+     struct mm_struct * mm_create(void)
+     void mm_destroy(struct mm_struct *mm)
+     int do_pgfault(struct mm_struct *mm, uint32_t error_code, uintptr_t addr)
+--------------
+  vma related functions:
+   global functions
+     struct vma_struct * vma_create (uintptr_t vm_start, uintptr_t vm_end,...)
+     void insert_vma_struct(struct mm_struct *mm, struct vma_struct *vma)
+     struct vma_struct * find_vma(struct mm_struct *mm, uintptr_t addr)
+   local functions
+     inline void check_vma_overlap(struct vma_struct *prev, struct vma_struct *next)
+---------------
+   check correctness functions
+     void check_vmm(void);
+     void check_vma_struct(void);
+     void check_pgfault(void);
+*/
+
+static void check_vmm(void);
+static void check_vma_struct(void);
+static void check_pgfault(void);
+
+// mm_create -  alloc a mm_struct & initialize it.
+struct mm_struct *
+mm_create(void) {
+    struct mm_struct *mm = kmalloc(sizeof(struct mm_struct));
+
+    if (mm != NULL) {
+        list_init(&(mm->mmap_list));
+        mm->mmap_cache = NULL;
+        mm->pgdir = NULL;
+        mm->map_count = 0;
+
+        if (swap_init_ok) swap_init_mm(mm);
+        else mm->sm_priv = NULL;
+        
+        set_mm_count(mm, 0);
+        lock_init(&(mm->mm_lock));
+    }    
+    return mm;
+}
+
+// vma_create - alloc a vma_struct & initialize it. (addr range: vm_start~vm_end)
+struct vma_struct *
+vma_create(uintptr_t vm_start, uintptr_t vm_end, uint32_t vm_flags) {
+    struct vma_struct *vma = kmalloc(sizeof(struct vma_struct));
+
+    if (vma != NULL) {
+        vma->vm_start = vm_start;
+        vma->vm_end = vm_end;
+        vma->vm_flags = vm_flags;
+    }
+    return vma;
+}
+
+
+// find_vma - find a vma  (vma->vm_start <= addr <= vma_vm_end)
+struct vma_struct *
+find_vma(struct mm_struct *mm, uintptr_t addr) {
+    struct vma_struct *vma = NULL;
+    if (mm != NULL) {
+        vma = mm->mmap_cache;
+        if (!(vma != NULL && vma->vm_start <= addr && vma->vm_end > addr)) {
+                bool found = 0;
+                list_entry_t *list = &(mm->mmap_list), *le = list;
+                while ((le = list_next(le)) != list) {
+                    vma = le2vma(le, list_link);
+                    if (vma->vm_start<=addr && addr < vma->vm_end) {
+                        found = 1;
+                        break;
+                    }
+                }
+                if (!found) {
+                    vma = NULL;
+                }
+        }
+        if (vma != NULL) {
+            mm->mmap_cache = vma;
+        }
+    }
+    return vma;
+}
+
+
+// check_vma_overlap - check if vma1 overlaps vma2 ?
+static inline void
+check_vma_overlap(struct vma_struct *prev, struct vma_struct *next) {
+    assert(prev->vm_start < prev->vm_end);
+    assert(prev->vm_end <= next->vm_start);
+    assert(next->vm_start < next->vm_end);
+}
+
+
+// insert_vma_struct -insert vma in mm's list link
+void
+insert_vma_struct(struct mm_struct *mm, struct vma_struct *vma) {
+    assert(vma->vm_start < vma->vm_end);
+    list_entry_t *list = &(mm->mmap_list);
+    list_entry_t *le_prev = list, *le_next;
+
+        list_entry_t *le = list;
+        while ((le = list_next(le)) != list) {
+            struct vma_struct *mmap_prev = le2vma(le, list_link);
+            if (mmap_prev->vm_start > vma->vm_start) {
+                break;
+            }
+            le_prev = le;
+        }
+
+    le_next = list_next(le_prev);
+
+    /* check overlap */
+    if (le_prev != list) {
+        check_vma_overlap(le2vma(le_prev, list_link), vma);
+    }
+    if (le_next != list) {
+        check_vma_overlap(vma, le2vma(le_next, list_link));
+    }
+
+    vma->vm_mm = mm;
+    list_add_after(le_prev, &(vma->list_link));
+
+    mm->map_count ++;
+}
+
+// mm_destroy - free mm and mm internal fields
+void
+mm_destroy(struct mm_struct *mm) {
+    assert(mm_count(mm) == 0);
+
+    list_entry_t *list = &(mm->mmap_list), *le;
+    while ((le = list_next(list)) != list) {
+        list_del(le);
+        kfree(le2vma(le, list_link));  //kfree vma        
+    }
+    kfree(mm); //kfree mm
+    mm=NULL;
+}
+
+int
+mm_map(struct mm_struct *mm, uintptr_t addr, size_t len, uint32_t vm_flags,
+       struct vma_struct **vma_store) {
+    uintptr_t start = ROUNDDOWN(addr, PGSIZE), end = ROUNDUP(addr + len, PGSIZE);
+    if (!USER_ACCESS(start, end)) {
+        return -E_INVAL;
+    }
+
+    assert(mm != NULL);
+
+    int ret = -E_INVAL;
+
+    struct vma_struct *vma;
+    if ((vma = find_vma(mm, start)) != NULL && end > vma->vm_start) {
+        goto out;
+    }
+    ret = -E_NO_MEM;
+
+    if ((vma = vma_create(start, end, vm_flags)) == NULL) {
+        goto out;
+    }
+    insert_vma_struct(mm, vma);
+    if (vma_store != NULL) {
+        *vma_store = vma;
+    }
+    ret = 0;
+
+out:
+    return ret;
+}
+
+int
+dup_mmap(struct mm_struct *to, struct mm_struct *from) {
+    assert(to != NULL && from != NULL);
+    list_entry_t *list = &(from->mmap_list), *le = list;
+    while ((le = list_prev(le)) != list) {
+        struct vma_struct *vma, *nvma;
+        vma = le2vma(le, list_link);
+        nvma = vma_create(vma->vm_start, vma->vm_end, vma->vm_flags);
+        if (nvma == NULL) {
+            return -E_NO_MEM;
+        }
+
+        insert_vma_struct(to, nvma);
+
+        bool share = 0;
+        if (copy_range(to->pgdir, from->pgdir, vma->vm_start, vma->vm_end, share) != 0) {
+            return -E_NO_MEM;
+        }
+    }
+    return 0;
+}
+
+void
+exit_mmap(struct mm_struct *mm) {
+    assert(mm != NULL && mm_count(mm) == 0);
+    pde_t *pgdir = mm->pgdir;
+    list_entry_t *list = &(mm->mmap_list), *le = list;
+    while ((le = list_next(le)) != list) {
+        struct vma_struct *vma = le2vma(le, list_link);
+        unmap_range(pgdir, vma->vm_start, vma->vm_end);
+    }
+    while ((le = list_next(le)) != list) {
+        struct vma_struct *vma = le2vma(le, list_link);
+        exit_range(pgdir, vma->vm_start, vma->vm_end);
+    }
+}
+
+bool
+copy_from_user(struct mm_struct *mm, void *dst, const void *src, size_t len, bool writable) {
+    if (!user_mem_check(mm, (uintptr_t)src, len, writable)) {
+        return 0;
+    }
+    memcpy(dst, src, len);
+    return 1;
+}
+
+bool
+copy_to_user(struct mm_struct *mm, void *dst, const void *src, size_t len) {
+    if (!user_mem_check(mm, (uintptr_t)dst, len, 1)) {
+        return 0;
+    }
+    memcpy(dst, src, len);
+    return 1;
+}
+
+// vmm_init - initialize virtual memory management
+//          - now just call check_vmm to check correctness of vmm
+void
+vmm_init(void) {
+    check_vmm();
+}
+
+// check_vmm - check correctness of vmm
+static void
+check_vmm(void) {
+    size_t nr_free_pages_store = nr_free_pages();
+    
+    check_vma_struct();
+    check_pgfault();
+
+    cprintf("check_vmm() succeeded.\n");
+}
+
+static void
+check_vma_struct(void) {
+    size_t nr_free_pages_store = nr_free_pages();
+
+    struct mm_struct *mm = mm_create();
+    assert(mm != NULL);
+
+    int step1 = 10, step2 = step1 * 10;
+
+    int i;
+    for (i = step1; i >= 1; i --) {
+        struct vma_struct *vma = vma_create(i * 5, i * 5 + 2, 0);
+        assert(vma != NULL);
+        insert_vma_struct(mm, vma);
+    }
+
+    for (i = step1 + 1; i <= step2; i ++) {
+        struct vma_struct *vma = vma_create(i * 5, i * 5 + 2, 0);
+        assert(vma != NULL);
+        insert_vma_struct(mm, vma);
+    }
+
+    list_entry_t *le = list_next(&(mm->mmap_list));
+
+    for (i = 1; i <= step2; i ++) {
+        assert(le != &(mm->mmap_list));
+        struct vma_struct *mmap = le2vma(le, list_link);
+        assert(mmap->vm_start == i * 5 && mmap->vm_end == i * 5 + 2);
+        le = list_next(le);
+    }
+
+    for (i = 5; i <= 5 * step2; i +=5) {
+        struct vma_struct *vma1 = find_vma(mm, i);
+        assert(vma1 != NULL);
+        struct vma_struct *vma2 = find_vma(mm, i+1);
+        assert(vma2 != NULL);
+        struct vma_struct *vma3 = find_vma(mm, i+2);
+        assert(vma3 == NULL);
+        struct vma_struct *vma4 = find_vma(mm, i+3);
+        assert(vma4 == NULL);
+        struct vma_struct *vma5 = find_vma(mm, i+4);
+        assert(vma5 == NULL);
+
+        assert(vma1->vm_start == i  && vma1->vm_end == i  + 2);
+        assert(vma2->vm_start == i  && vma2->vm_end == i  + 2);
+    }
+
+    for (i =4; i>=0; i--) {
+        struct vma_struct *vma_below_5= find_vma(mm,i);
+        if (vma_below_5 != NULL ) {
+           cprintf("vma_below_5: i %x, start %x, end %x\n",i, vma_below_5->vm_start, vma_below_5->vm_end); 
+        }
+        assert(vma_below_5 == NULL);
+    }
+
+    mm_destroy(mm);
+
+    cprintf("check_vma_struct() succeeded!\n");
+}
+
+struct mm_struct *check_mm_struct;
+
+// check_pgfault - check correctness of pgfault handler
+static void
+check_pgfault(void) {
+    size_t nr_free_pages_store = nr_free_pages();
+
+    check_mm_struct = mm_create();
+    assert(check_mm_struct != NULL);
+
+    struct mm_struct *mm = check_mm_struct;
+    pde_t *pgdir = mm->pgdir = boot_pgdir;
+    assert(pgdir[0] == 0);
+
+    struct vma_struct *vma = vma_create(0, PTSIZE, VM_WRITE);
+    assert(vma != NULL);
+
+    insert_vma_struct(mm, vma);
+
+    uintptr_t addr = 0x100;
+    assert(find_vma(mm, addr) == vma);
+
+    int i, sum = 0;
+    for (i = 0; i < 100; i ++) {
+        *(char *)(addr + i) = i;
+        sum += i;
+    }
+    for (i = 0; i < 100; i ++) {
+        sum -= *(char *)(addr + i);
+    }
+    assert(sum == 0);
+
+    page_remove(pgdir, ROUNDDOWN(addr, PGSIZE));
+    free_page(pde2page(pgdir[0]));
+    pgdir[0] = 0;
+
+    mm->pgdir = NULL;
+    mm_destroy(mm);
+    check_mm_struct = NULL;
+
+    assert(nr_free_pages_store == nr_free_pages());
+
+    cprintf("check_pgfault() succeeded!\n");
+}
+//page fault number
+volatile unsigned int pgfault_num=0;
+
+/* do_pgfault - interrupt handler to process the page fault execption
+ * @mm         : the control struct for a set of vma using the same PDT
+ * @error_code : the error code recorded in trapframe->tf_err which is setted by x86 hardware
+ * @addr       : the addr which causes a memory access exception, (the contents of the CR2 register)
+ *
+ * CALL GRAPH: trap--> trap_dispatch-->pgfault_handler-->do_pgfault
+ * The processor provides ucore's do_pgfault function with two items of information to aid in diagnosing
+ * the exception and recovering from it.
+ *   (1) The contents of the CR2 register. The processor loads the CR2 register with the
+ *       32-bit linear address that generated the exception. The do_pgfault fun can
+ *       use this address to locate the corresponding page directory and page-table
+ *       entries.
+ *   (2) An error code on the kernel stack. The error code for a page fault has a format different from
+ *       that for other exceptions. The error code tells the exception handler three things:
+ *         -- The P flag   (bit 0) indicates whether the exception was due to a not-present page (0)
+ *            or to either an access rights violation or the use of a reserved bit (1).
+ *         -- The W/R flag (bit 1) indicates whether the memory access that caused the exception
+ *            was a read (0) or write (1).
+ *         -- The U/S flag (bit 2) indicates whether the processor was executing at user mode (1)
+ *            or supervisor mode (0) at the time of the exception.
+ */
+int
+do_pgfault(struct mm_struct *mm, uint32_t error_code, uintptr_t addr) {
+    int ret = -E_INVAL;
+    //try to find a vma which include addr
+    struct vma_struct *vma = find_vma(mm, addr);
+
+    pgfault_num++;
+    //If the addr is in the range of a mm's vma?
+    if (vma == NULL || vma->vm_start > addr) {
+        cprintf("not valid addr %x, and  can not find it in vma\n", addr);
+        goto failed;
+    }
+    //check the error_code
+    switch (error_code & 3) {
+    default:
+            /* error code flag : default is 3 ( W/R=1, P=1): write, present */
+    case 2: /* error code flag : (W/R=1, P=0): write, not present */
+        if (!(vma->vm_flags & VM_WRITE)) {
+            cprintf("do_pgfault failed: error code flag = write AND not present, but the addr's vma cannot write\n");
+            goto failed;
+        }
+        break;
+    case 1: /* error code flag : (W/R=0, P=1): read, present */
+        cprintf("do_pgfault failed: error code flag = read AND present\n");
+        goto failed;
+    case 0: /* error code flag : (W/R=0, P=0): read, not present */
+        if (!(vma->vm_flags & (VM_READ | VM_EXEC))) {
+            cprintf("do_pgfault failed: error code flag = read AND not present, but the addr's vma cannot read or exec\n");
+            goto failed;
+        }
+    }
+    /* IF (write an existed addr ) OR
+     *    (write an non_existed addr && addr is writable) OR
+     *    (read  an non_existed addr && addr is readable)
+     * THEN
+     *    continue process
+     */
+    uint32_t perm = PTE_U;
+    if (vma->vm_flags & VM_WRITE) {
+        perm |= PTE_W;
+    }
+    addr = ROUNDDOWN(addr, PGSIZE);
+
+    ret = -E_NO_MEM;
+
+    pte_t *ptep=NULL;
+    /*LAB3 EXERCISE 1: YOUR CODE
+    * Maybe you want help comment, BELOW comments can help you finish the code
+    *
+    * Some Useful MACROs and DEFINEs, you can use them in below implementation.
+    * MACROs or Functions:
+    *   get_pte : get an pte and return the kernel virtual address of this pte for la
+    *             if the PT contians this pte didn't exist, alloc a page for PT (notice the 3th parameter '1')
+    *   pgdir_alloc_page : call alloc_page & page_insert functions to allocate a page size memory & setup
+    *             an addr map pa<--->la with linear address la and the PDT pgdir
+    * DEFINES:
+    *   VM_WRITE  : If vma->vm_flags & VM_WRITE == 1/0, then the vma is writable/non writable
+    *   PTE_W           0x002                   // page table/directory entry flags bit : Writeable
+    *   PTE_U           0x004                   // page table/directory entry flags bit : User can access
+    * VARIABLES:
+    *   mm->pgdir : the PDT of these vma
+    *
+    */
+    ptep = get_pte(mm->pgdir, addr, 1);
+    if (ptep == NULL) {
+        cprintf("get_pte return a NULL.\n");
+        goto failed;
+    }
+    //(1) try to find a pte, if pte's PT(Page Table) isn't existed, then create a PT.
+    if (*ptep == 0) {
+        struct Page* page = pgdir_alloc_page(mm->pgdir, addr, perm); 
+        if(page == NULL) {
+            cprintf("pgdir_alloc_page return a NULL.\n");
+            goto failed;
+    //(2) if the phy addr isn't exist, then alloc a page & map the phy addr with logical addr
+        }
+    }
+    else {
+    /*LAB3 EXERCISE 2: YOUR CODE
+    * Now we think this pte is a  swap entry, we should load data from disk to a page with phy addr,
+    * and map the phy addr with logical addr, trigger swap manager to record the access situation of this page.
+    *
+    *  Some Useful MACROs and DEFINEs, you can use them in below implementation.
+    *  MACROs or Functions:
+    *    swap_in(mm, addr, &page) : alloc a memory page, then according to the swap entry in PTE for addr,
+    *                               find the addr of disk page, read the content of disk page into this memroy page
+    *    page_insert ： build the map of phy addr of an Page with the linear addr la
+    *    swap_map_swappable ： set the page swappable
+    */
+    /*
+     * LAB5 CHALLENGE ( the implmentation Copy on Write)
+        There are 2 situlations when code comes here.
+          1) *ptep & PTE_P == 1, it means one process try to write a readonly page. 
+             If the vma includes this addr is writable, then we can set the page writable by rewrite the *ptep.
+             This method could be used to implement the Copy on Write (COW) thchnology(a fast fork process method).
+          2) *ptep & PTE_P == 0 & but *ptep!=0, it means this pte is a  swap entry.
+             We should add the LAB3's results here.
+     */
+        if(swap_init_ok) {
+            struct Page *page=NULL;
+            ret = swap_in(mm, addr, &page);
+            if (ret != 0) {
+                cprintf("swap_in failed.\n");
+                goto failed;
+            }    
+//(1）According to the mm AND addr, try to load the content of right disk page
+//    into the memory which page man
+            page_insert(mm->pgdir, page, addr, perm);
+//(2) According to the mm, addr AND page, setup the map of phy addr <---> logical addr
+            swap_map_swappable(mm, addr, page, 1);
+//(3) make the page swappable.
+            page->pra_vaddr = addr;
+        }
+        else {
+            cprintf("no swap_init_ok but ptep is %x, failed\n",*ptep);
+            goto failed;
+        }
+   }
+
+   ret = 0;
+failed:
+    return ret;
+}
+
+bool
+user_mem_check(struct mm_struct *mm, uintptr_t addr, size_t len, bool write) {
+    if (mm != NULL) {
+        if (!USER_ACCESS(addr, addr + len)) {
+            return 0;
+        }
+        struct vma_struct *vma;
+        uintptr_t start = addr, end = addr + len;
+        while (start < end) {
+            if ((vma = find_vma(mm, start)) == NULL || start < vma->vm_start) {
+                return 0;
+            }
+            if (!(vma->vm_flags & ((write) ? VM_WRITE : VM_READ))) {
+                return 0;
+            }
+            if (write && (vma->vm_flags & VM_STACK)) {
+                if (start < vma->vm_start + PGSIZE) { //check stack start & size
+                    return 0;
+                }
+            }
+            start = vma->vm_end;
+        }
+        return 1;
+    }
+    return KERN_ACCESS(addr, addr + len);
+}
+
diff -r -u -P lab6_origin/kern/mm/vmm.h lab6/kern/mm/vmm.h
--- lab6_origin/kern/mm/vmm.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/mm/vmm.h	2019-02-26 20:51:17.064862500 +0800
@@ -0,0 +1,103 @@
+#ifndef __KERN_MM_VMM_H__
+#define __KERN_MM_VMM_H__
+
+#include <defs.h>
+#include <list.h>
+#include <memlayout.h>
+#include <sync.h>
+
+//pre define
+struct mm_struct;
+
+// the virtual continuous memory area(vma), [vm_start, vm_end), 
+// addr belong to a vma means  vma.vm_start<= addr <vma.vm_end 
+struct vma_struct {
+    struct mm_struct *vm_mm; // the set of vma using the same PDT 
+    uintptr_t vm_start;      // start addr of vma      
+    uintptr_t vm_end;        // end addr of vma, not include the vm_end itself
+    uint32_t vm_flags;       // flags of vma
+    list_entry_t list_link;  // linear list link which sorted by start addr of vma
+};
+
+#define le2vma(le, member)                  \
+    to_struct((le), struct vma_struct, member)
+
+#define VM_READ                 0x00000001
+#define VM_WRITE                0x00000002
+#define VM_EXEC                 0x00000004
+#define VM_STACK                0x00000008
+
+// the control struct for a set of vma using the same PDT
+struct mm_struct {
+    list_entry_t mmap_list;        // linear list link which sorted by start addr of vma
+    struct vma_struct *mmap_cache; // current accessed vma, used for speed purpose
+    pde_t *pgdir;                  // the PDT of these vma
+    int map_count;                 // the count of these vma
+    void *sm_priv;                 // the private data for swap manager
+    int mm_count;                  // the number ofprocess which shared the mm
+    lock_t mm_lock;                // mutex for using dup_mmap fun to duplicat the mm
+};
+
+struct vma_struct *find_vma(struct mm_struct *mm, uintptr_t addr);
+struct vma_struct *vma_create(uintptr_t vm_start, uintptr_t vm_end, uint32_t vm_flags);
+void insert_vma_struct(struct mm_struct *mm, struct vma_struct *vma);
+
+struct mm_struct *mm_create(void);
+void mm_destroy(struct mm_struct *mm);
+
+void vmm_init(void);
+int mm_map(struct mm_struct *mm, uintptr_t addr, size_t len, uint32_t vm_flags,
+           struct vma_struct **vma_store);
+int do_pgfault(struct mm_struct *mm, uint32_t error_code, uintptr_t addr);
+
+int mm_unmap(struct mm_struct *mm, uintptr_t addr, size_t len);
+int dup_mmap(struct mm_struct *to, struct mm_struct *from);
+void exit_mmap(struct mm_struct *mm);
+uintptr_t get_unmapped_area(struct mm_struct *mm, size_t len);
+int mm_brk(struct mm_struct *mm, uintptr_t addr, size_t len);
+
+extern volatile unsigned int pgfault_num;
+extern struct mm_struct *check_mm_struct;
+
+bool user_mem_check(struct mm_struct *mm, uintptr_t start, size_t len, bool write);
+bool copy_from_user(struct mm_struct *mm, void *dst, const void *src, size_t len, bool writable);
+bool copy_to_user(struct mm_struct *mm, void *dst, const void *src, size_t len);
+
+static inline int
+mm_count(struct mm_struct *mm) {
+    return mm->mm_count;
+}
+
+static inline void
+set_mm_count(struct mm_struct *mm, int val) {
+    mm->mm_count = val;
+}
+
+static inline int
+mm_count_inc(struct mm_struct *mm) {
+    mm->mm_count += 1;
+    return mm->mm_count;
+}
+
+static inline int
+mm_count_dec(struct mm_struct *mm) {
+    mm->mm_count -= 1;
+    return mm->mm_count;
+}
+
+static inline void
+lock_mm(struct mm_struct *mm) {
+    if (mm != NULL) {
+        lock(&(mm->mm_lock));
+    }
+}
+
+static inline void
+unlock_mm(struct mm_struct *mm) {
+    if (mm != NULL) {
+        unlock(&(mm->mm_lock));
+    }
+}
+
+#endif /* !__KERN_MM_VMM_H__ */
+
diff -r -u -P lab6_origin/kern/process/entry.S lab6/kern/process/entry.S
--- lab6_origin/kern/process/entry.S	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/process/entry.S	2019-02-26 20:51:17.065860800 +0800
@@ -0,0 +1,10 @@
+.text
+.globl kernel_thread_entry
+kernel_thread_entry:        # void kernel_thread(void)
+
+    pushl %edx              # push arg
+    call *%ebx              # call fn
+
+    pushl %eax              # save the return value of fn(arg)
+    call do_exit            # call do_exit to terminate current thread
+
diff -r -u -P lab6_origin/kern/process/proc.c lab6/kern/process/proc.c
--- lab6_origin/kern/process/proc.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/process/proc.c	2019-05-13 17:41:10.068746300 +0800
@@ -0,0 +1,919 @@
+#include <proc.h>
+#include <kmalloc.h>
+#include <string.h>
+#include <sync.h>
+#include <pmm.h>
+#include <error.h>
+#include <sched.h>
+#include <elf.h>
+#include <vmm.h>
+#include <trap.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <unistd.h>
+
+/* ------------- process/thread mechanism design&implementation -------------
+(an simplified Linux process/thread mechanism )
+introduction:
+  ucore implements a simple process/thread mechanism. process contains the independent memory sapce, at least one threads
+for execution, the kernel data(for management), processor state (for context switch), files(in lab6), etc. ucore needs to
+manage all these details efficiently. In ucore, a thread is just a special kind of process(share process's memory).
+------------------------------
+process state       :     meaning               -- reason
+    PROC_UNINIT     :   uninitialized           -- alloc_proc
+    PROC_SLEEPING   :   sleeping                -- try_free_pages, do_wait, do_sleep
+    PROC_RUNNABLE   :   runnable(maybe running) -- proc_init, wakeup_proc, 
+    PROC_ZOMBIE     :   almost dead             -- do_exit
+
+-----------------------------
+process state changing:
+                                            
+  alloc_proc                                 RUNNING
+      +                                   +--<----<--+
+      +                                   + proc_run +
+      V                                   +-->---->--+ 
+PROC_UNINIT -- proc_init/wakeup_proc --> PROC_RUNNABLE -- try_free_pages/do_wait/do_sleep --> PROC_SLEEPING --
+                                           A      +                                                           +
+                                           |      +--- do_exit --> PROC_ZOMBIE                                +
+                                           +                                                                  + 
+                                           -----------------------wakeup_proc----------------------------------
+-----------------------------
+process relations
+parent:           proc->parent  (proc is children)
+children:         proc->cptr    (proc is parent)
+older sibling:    proc->optr    (proc is younger sibling)
+younger sibling:  proc->yptr    (proc is older sibling)
+-----------------------------
+related syscall for process:
+SYS_exit        : process exit,                           -->do_exit
+SYS_fork        : create child process, dup mm            -->do_fork-->wakeup_proc
+SYS_wait        : wait process                            -->do_wait
+SYS_exec        : after fork, process execute a program   -->load a program and refresh the mm
+SYS_clone       : create child thread                     -->do_fork-->wakeup_proc
+SYS_yield       : process flag itself need resecheduling, -- proc->need_sched=1, then scheduler will rescheule this process
+SYS_sleep       : process sleep                           -->do_sleep 
+SYS_kill        : kill process                            -->do_kill-->proc->flags |= PF_EXITING
+                                                                 -->wakeup_proc-->do_wait-->do_exit   
+SYS_getpid      : get the process's pid
+
+*/
+
+// the process set's list
+list_entry_t proc_list;
+
+#define HASH_SHIFT          10
+#define HASH_LIST_SIZE      (1 << HASH_SHIFT)
+#define pid_hashfn(x)       (hash32(x, HASH_SHIFT))
+
+// has list for process set based on pid
+static list_entry_t hash_list[HASH_LIST_SIZE];
+
+// idle proc
+struct proc_struct *idleproc = NULL;
+// init proc
+struct proc_struct *initproc = NULL;
+// current proc
+struct proc_struct *current = NULL;
+
+static int nr_process = 0;
+
+void kernel_thread_entry(void);
+void forkrets(struct trapframe *tf);
+void switch_to(struct context *from, struct context *to);
+
+// alloc_proc - alloc a proc_struct and init all fields of proc_struct
+static struct proc_struct *
+alloc_proc(void) {
+    struct proc_struct *proc = kmalloc(sizeof(struct proc_struct));
+    if (proc != NULL) {
+    //LAB4:EXERCISE1 YOUR CODE
+    /*
+     * below fields in proc_struct need to be initialized
+     *       enum proc_state state;                      // Process state
+     *       int pid;                                    // Process ID
+     *       int runs;                                   // the running times of Proces
+     *       uintptr_t kstack;                           // Process kernel stack
+     *       volatile bool need_resched;                 // bool value: need to be rescheduled to release CPU?
+     *       struct proc_struct *parent;                 // the parent process
+     *       struct mm_struct *mm;                       // Process's memory management field
+     *       struct context context;                     // Switch here to run process
+     *       struct trapframe *tf;                       // Trap frame for current interrupt
+     *       uintptr_t cr3;                              // CR3 register: the base addr of Page Directroy Table(PDT)
+     *       uint32_t flags;                             // Process flag
+     *       char name[PROC_NAME_LEN + 1];               // Process name
+     */
+        proc->state = PROC_UNINIT;
+        proc->pid = -1;
+        proc->cr3 = boot_cr3;
+       
+        proc->runs = 0;
+        proc->kstack = 0;
+        proc->need_resched = 0;
+        proc->parent = NULL;
+        proc->mm = NULL;
+        memset(&proc->context, 0, sizeof(struct context)); 
+        proc->tf = NULL;
+        proc->flags = 0;
+        memset(proc->name, 0, PROC_NAME_LEN);         
+     //LAB5 YOUR CODE : (update LAB4 steps)
+    /*
+     * below fields(add in LAB5) in proc_struct need to be initialized  
+     *       uint32_t wait_state;                        // waiting state
+     *       struct proc_struct *cptr, *yptr, *optr;     // relations between processes
+   */
+        proc->wait_state = 0;
+        proc->cptr = proc->optr = proc->yptr = NULL;
+    //LAB6 YOUR CODE : (update LAB5 steps)
+    /*
+     * below fields(add in LAB6) in proc_struct need to be initialized
+     *     struct run_queue *rq;                       // running queue contains Process
+     *     list_entry_t run_link;                      // the entry linked in run queue
+     *     int time_slice;                             // time slice for occupying the CPU
+     *     skew_heap_entry_t lab6_run_pool;            // FOR LAB6 ONLY: the entry in the run pool
+     *     uint32_t lab6_stride;                       // FOR LAB6 ONLY: the current stride of the process
+     *     uint32_t lab6_priority;                     // FOR LAB6 ONLY: the priority of process, set by lab6_set_priority(uint32_t)
+     */
+        proc->rq = NULL;
+        memset(&proc->run_link, 0, sizeof(list_entry_t));
+        proc->time_slice = 0;
+        memset(&proc->lab6_run_pool,0,sizeof(skew_heap_entry_t));
+	proc->lab6_stride=0;
+	proc->lab6_priority=1;
+    }
+    return proc;
+}
+
+// set_proc_name - set the name of proc
+char *
+set_proc_name(struct proc_struct *proc, const char *name) {
+    memset(proc->name, 0, sizeof(proc->name));
+    return memcpy(proc->name, name, PROC_NAME_LEN);
+}
+
+// get_proc_name - get the name of proc
+char *
+get_proc_name(struct proc_struct *proc) {
+    static char name[PROC_NAME_LEN + 1];
+    memset(name, 0, sizeof(name));
+    return memcpy(name, proc->name, PROC_NAME_LEN);
+}
+
+// set_links - set the relation links of process
+static void
+set_links(struct proc_struct *proc) {
+    list_add(&proc_list, &(proc->list_link));
+    proc->yptr = NULL;
+    if ((proc->optr = proc->parent->cptr) != NULL) {
+        proc->optr->yptr = proc;
+    }
+    proc->parent->cptr = proc;
+    nr_process ++;
+}
+
+// remove_links - clean the relation links of process
+static void
+remove_links(struct proc_struct *proc) {
+    list_del(&(proc->list_link));
+    if (proc->optr != NULL) {
+        proc->optr->yptr = proc->yptr;
+    }
+    if (proc->yptr != NULL) {
+        proc->yptr->optr = proc->optr;
+    }
+    else {
+       proc->parent->cptr = proc->optr;
+    }
+    nr_process --;
+}
+
+// get_pid - alloc a unique pid for process
+static int
+get_pid(void) {
+    static_assert(MAX_PID > MAX_PROCESS);
+    struct proc_struct *proc;
+    list_entry_t *list = &proc_list, *le;
+    static int next_safe = MAX_PID, last_pid = MAX_PID;
+    if (++ last_pid >= MAX_PID) {
+        last_pid = 1;
+        goto inside;
+    }
+    if (last_pid >= next_safe) {
+    inside:
+        next_safe = MAX_PID;
+    repeat:
+        le = list;
+        while ((le = list_next(le)) != list) {
+            proc = le2proc(le, list_link);
+            if (proc->pid == last_pid) {
+                if (++ last_pid >= next_safe) {
+                    if (last_pid >= MAX_PID) {
+                        last_pid = 1;
+                    }
+                    next_safe = MAX_PID;
+                    goto repeat;
+                }
+            }
+            else if (proc->pid > last_pid && next_safe > proc->pid) {
+                next_safe = proc->pid;
+            }
+        }
+    }
+    return last_pid;
+}
+
+// proc_run - make process "proc" running on cpu
+// NOTE: before call switch_to, should load  base addr of "proc"'s new PDT
+void
+proc_run(struct proc_struct *proc) {
+    if (proc != current) {
+        bool intr_flag;
+        struct proc_struct *prev = current, *next = proc;
+        local_intr_save(intr_flag);
+        {
+            current = proc;
+            load_esp0(next->kstack + KSTACKSIZE);
+            lcr3(next->cr3);
+            switch_to(&(prev->context), &(next->context));
+        }
+        local_intr_restore(intr_flag);
+    }
+}
+
+// forkret -- the first kernel entry point of a new thread/process
+// NOTE: the addr of forkret is setted in copy_thread function
+//       after switch_to, the current proc will execute here.
+static void
+forkret(void) {
+    forkrets(current->tf);
+}
+
+// hash_proc - add proc into proc hash_list
+static void
+hash_proc(struct proc_struct *proc) {
+    list_add(hash_list + pid_hashfn(proc->pid), &(proc->hash_link));
+}
+
+// unhash_proc - delete proc from proc hash_list
+static void
+unhash_proc(struct proc_struct *proc) {
+    list_del(&(proc->hash_link));
+}
+
+// find_proc - find proc frome proc hash_list according to pid
+struct proc_struct *
+find_proc(int pid) {
+    if (0 < pid && pid < MAX_PID) {
+        list_entry_t *list = hash_list + pid_hashfn(pid), *le = list;
+        while ((le = list_next(le)) != list) {
+            struct proc_struct *proc = le2proc(le, hash_link);
+            if (proc->pid == pid) {
+                return proc;
+            }
+        }
+    }
+    return NULL;
+}
+
+// kernel_thread - create a kernel thread using "fn" function
+// NOTE: the contents of temp trapframe tf will be copied to 
+//       proc->tf in do_fork-->copy_thread function
+int
+kernel_thread(int (*fn)(void *), void *arg, uint32_t clone_flags) {
+    struct trapframe tf;
+    memset(&tf, 0, sizeof(struct trapframe));
+    tf.tf_cs = KERNEL_CS;
+    tf.tf_ds = tf.tf_es = tf.tf_ss = KERNEL_DS;
+    tf.tf_regs.reg_ebx = (uint32_t)fn;
+    tf.tf_regs.reg_edx = (uint32_t)arg;
+    tf.tf_eip = (uint32_t)kernel_thread_entry;
+    return do_fork(clone_flags | CLONE_VM, 0, &tf);
+}
+
+// setup_kstack - alloc pages with size KSTACKPAGE as process kernel stack
+static int
+setup_kstack(struct proc_struct *proc) {
+    struct Page *page = alloc_pages(KSTACKPAGE);
+    if (page != NULL) {
+        proc->kstack = (uintptr_t)page2kva(page);
+        return 0;
+    }
+    return -E_NO_MEM;
+}
+
+// put_kstack - free the memory space of process kernel stack
+static void
+put_kstack(struct proc_struct *proc) {
+    free_pages(kva2page((void *)(proc->kstack)), KSTACKPAGE);
+}
+
+// setup_pgdir - alloc one page as PDT
+static int
+setup_pgdir(struct mm_struct *mm) {
+    struct Page *page;
+    if ((page = alloc_page()) == NULL) {
+        return -E_NO_MEM;
+    }
+    pde_t *pgdir = page2kva(page);
+    memcpy(pgdir, boot_pgdir, PGSIZE);
+    pgdir[PDX(VPT)] = PADDR(pgdir) | PTE_P | PTE_W;
+    mm->pgdir = pgdir;
+    return 0;
+}
+
+// put_pgdir - free the memory space of PDT
+static void
+put_pgdir(struct mm_struct *mm) {
+    free_page(kva2page(mm->pgdir));
+}
+
+// copy_mm - process "proc" duplicate OR share process "current"'s mm according clone_flags
+//         - if clone_flags & CLONE_VM, then "share" ; else "duplicate"
+static int
+copy_mm(uint32_t clone_flags, struct proc_struct *proc) {
+    struct mm_struct *mm, *oldmm = current->mm;
+
+    /* current is a kernel thread */
+    if (oldmm == NULL) {
+        return 0;
+    }
+    if (clone_flags & CLONE_VM) {
+        mm = oldmm;
+        goto good_mm;
+    }
+
+    int ret = -E_NO_MEM;
+    if ((mm = mm_create()) == NULL) {
+        goto bad_mm;
+    }
+    if (setup_pgdir(mm) != 0) {
+        goto bad_pgdir_cleanup_mm;
+    }
+
+    lock_mm(oldmm);
+    {
+        ret = dup_mmap(mm, oldmm);
+    }
+    unlock_mm(oldmm);
+
+    if (ret != 0) {
+        goto bad_dup_cleanup_mmap;
+    }
+
+good_mm:
+    mm_count_inc(mm);
+    proc->mm = mm;
+    proc->cr3 = PADDR(mm->pgdir);
+    return 0;
+bad_dup_cleanup_mmap:
+    exit_mmap(mm);
+    put_pgdir(mm);
+bad_pgdir_cleanup_mm:
+    mm_destroy(mm);
+bad_mm:
+    return ret;
+}
+
+// copy_thread - setup the trapframe on the  process's kernel stack top and
+//             - setup the kernel entry point and stack of process
+static void
+copy_thread(struct proc_struct *proc, uintptr_t esp, struct trapframe *tf) {
+    proc->tf = (struct trapframe *)(proc->kstack + KSTACKSIZE) - 1;
+    *(proc->tf) = *tf;
+    proc->tf->tf_regs.reg_eax = 0;
+    proc->tf->tf_esp = esp;
+    proc->tf->tf_eflags |= FL_IF;
+
+    proc->context.eip = (uintptr_t)forkret;
+    proc->context.esp = (uintptr_t)(proc->tf);
+}
+
+/* do_fork -     parent process for a new child process
+ * @clone_flags: used to guide how to clone the child process
+ * @stack:       the parent's user stack pointer. if stack==0, It means to fork a kernel thread.
+ * @tf:          the trapframe info, which will be copied to child process's proc->tf
+ */
+int
+do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) {
+    int ret = -E_NO_FREE_PROC;
+    struct proc_struct *proc;
+    if (nr_process >= MAX_PROCESS) {
+        goto fork_out;
+    }
+    ret = -E_NO_MEM;
+    //LAB4:EXERCISE2 YOUR CODE
+    /*
+     * Some Useful MACROs, Functions and DEFINEs, you can use them in below implementation.
+     * MACROs or Functions:
+     *   alloc_proc:   create a proc struct and init fields (lab4:exercise1)
+     *   setup_kstack: alloc pages with size KSTACKPAGE as process kernel stack
+     *   copy_mm:      process "proc" duplicate OR share process "current"'s mm according clone_flags
+     *                 if clone_flags & CLONE_VM, then "share" ; else "duplicate"
+     *   copy_thread:  setup the trapframe on the  process's kernel stack top and
+     *                 setup the kernel entry point and stack of process
+     *   hash_proc:    add proc into proc hash_list
+     *   get_pid:      alloc a unique pid for process
+     *   wakeup_proc:  set proc->state = PROC_RUNNABLE
+     * VARIABLES:
+     *   proc_list:    the process set's list
+     *   nr_process:   the number of process set
+     */
+
+    //    1. call alloc_proc to allocate a proc_struct
+    //    2. call setup_kstack to allocate a kernel stack for child process
+    //    3. call copy_mm to dup OR share mm according clone_flag
+    //    4. call copy_thread to setup tf & context in proc_struct
+    //    5. insert proc_struct into hash_list && proc_list
+    //    6. call wakeup_proc to make the new child process RUNNABLE
+    //    7. set ret vaule using child proc's pid
+    proc = alloc_proc();
+    if(proc == NULL)
+        goto fork_out;    
+    //    2. call setup_kstack to allocate a kernel stack for child process
+    proc->parent = current;
+    assert(current->wait_state == 0);
+
+    int status = setup_kstack(proc);
+    if(status != 0)
+        goto bad_fork_cleanup_kstack;
+    //    3. call copy_mm to dup OR share mm according clone_flag
+    status = copy_mm(clone_flags, proc);
+    if(status != 0)
+        goto bad_fork_cleanup_proc;
+    //    4. call copy_thread to setup tf & context in proc_struct
+    copy_thread(proc, stack, tf);
+    //    5. insert proc_struct into hash_list && proc_list
+    
+    proc->pid = get_pid();
+    hash_proc(proc);
+    set_links(proc);
+    //nr_process ++;
+    //list_add(&proc_list, &proc->list_link);
+    //    6. call wakeup_proc to make the new child process RUNNABLE
+    wakeup_proc(proc);
+    //    7. set ret vaule using child proc's pid
+    ret = proc->pid;
+	
+fork_out:
+    return ret;
+
+bad_fork_cleanup_kstack:
+    put_kstack(proc);
+bad_fork_cleanup_proc:
+    kfree(proc);
+    goto fork_out;
+}
+
+// do_exit - called by sys_exit
+//   1. call exit_mmap & put_pgdir & mm_destroy to free the almost all memory space of process
+//   2. set process' state as PROC_ZOMBIE, then call wakeup_proc(parent) to ask parent reclaim itself.
+//   3. call scheduler to switch to other process
+int
+do_exit(int error_code) {
+    if (current == idleproc) {
+        panic("idleproc exit.\n");
+    }
+    if (current == initproc) {
+        panic("initproc exit.\n");
+    }
+    
+    struct mm_struct *mm = current->mm;
+    if (mm != NULL) {
+        lcr3(boot_cr3);
+        if (mm_count_dec(mm) == 0) {
+            exit_mmap(mm);
+            put_pgdir(mm);
+            mm_destroy(mm);
+        }
+        current->mm = NULL;
+    }
+    current->state = PROC_ZOMBIE;
+    current->exit_code = error_code;
+    
+    bool intr_flag;
+    struct proc_struct *proc;
+    local_intr_save(intr_flag);
+    {
+        proc = current->parent;
+        if (proc->wait_state == WT_CHILD) {
+            wakeup_proc(proc);
+        }
+        while (current->cptr != NULL) {
+            proc = current->cptr;
+            current->cptr = proc->optr;
+    
+            proc->yptr = NULL;
+            if ((proc->optr = initproc->cptr) != NULL) {
+                initproc->cptr->yptr = proc;
+            }
+            proc->parent = initproc;
+            initproc->cptr = proc;
+            if (proc->state == PROC_ZOMBIE) {
+                if (initproc->wait_state == WT_CHILD) {
+                    wakeup_proc(initproc);
+                }
+            }
+        }
+    }
+    local_intr_restore(intr_flag);
+    
+    schedule();
+    panic("do_exit will not return!! %d.\n", current->pid);
+}
+
+/* load_icode - load the content of binary program(ELF format) as the new content of current process
+ * @binary:  the memory addr of the content of binary program
+ * @size:  the size of the content of binary program
+ */
+static int
+load_icode(unsigned char *binary, size_t size) {
+    if (current->mm != NULL) {
+        panic("load_icode: current->mm must be empty.\n");
+    }
+
+    int ret = -E_NO_MEM;
+    struct mm_struct *mm;
+    //(1) create a new mm for current process
+    if ((mm = mm_create()) == NULL) {
+        goto bad_mm;
+    }
+    //(2) create a new PDT, and mm->pgdir= kernel virtual addr of PDT
+    if (setup_pgdir(mm) != 0) {
+        goto bad_pgdir_cleanup_mm;
+    }
+    //(3) copy TEXT/DATA section, build BSS parts in binary to memory space of process
+    struct Page *page;
+    //(3.1) get the file header of the bianry program (ELF format)
+    struct elfhdr *elf = (struct elfhdr *)binary;
+    //(3.2) get the entry of the program section headers of the bianry program (ELF format)
+    struct proghdr *ph = (struct proghdr *)(binary + elf->e_phoff);
+    //(3.3) This program is valid?
+    if (elf->e_magic != ELF_MAGIC) {
+        ret = -E_INVAL_ELF;
+        goto bad_elf_cleanup_pgdir;
+    }
+
+    uint32_t vm_flags, perm;
+    struct proghdr *ph_end = ph + elf->e_phnum;
+    for (; ph < ph_end; ph ++) {
+    //(3.4) find every program section headers
+        if (ph->p_type != ELF_PT_LOAD) {
+            continue ;
+        }
+        if (ph->p_filesz > ph->p_memsz) {
+            ret = -E_INVAL_ELF;
+            goto bad_cleanup_mmap;
+        }
+        if (ph->p_filesz == 0) {
+            continue ;
+        }
+    //(3.5) call mm_map fun to setup the new vma ( ph->p_va, ph->p_memsz)
+        vm_flags = 0, perm = PTE_U;
+        if (ph->p_flags & ELF_PF_X) vm_flags |= VM_EXEC;
+        if (ph->p_flags & ELF_PF_W) vm_flags |= VM_WRITE;
+        if (ph->p_flags & ELF_PF_R) vm_flags |= VM_READ;
+        if (vm_flags & VM_WRITE) perm |= PTE_W;
+        if ((ret = mm_map(mm, ph->p_va, ph->p_memsz, vm_flags, NULL)) != 0) {
+            goto bad_cleanup_mmap;
+        }
+        unsigned char *from = binary + ph->p_offset;
+        size_t off, size;
+        uintptr_t start = ph->p_va, end, la = ROUNDDOWN(start, PGSIZE);
+
+        ret = -E_NO_MEM;
+
+     //(3.6) alloc memory, and  copy the contents of every program section (from, from+end) to process's memory (la, la+end)
+        end = ph->p_va + ph->p_filesz;
+     //(3.6.1) copy TEXT/DATA section of bianry program
+        while (start < end) {
+            if ((page = pgdir_alloc_page(mm->pgdir, la, perm)) == NULL) {
+                goto bad_cleanup_mmap;
+            }
+            off = start - la, size = PGSIZE - off, la += PGSIZE;
+            if (end < la) {
+                size -= la - end;
+            }
+            memcpy(page2kva(page) + off, from, size);
+            start += size, from += size;
+        }
+
+      //(3.6.2) build BSS section of binary program
+        end = ph->p_va + ph->p_memsz;
+        if (start < la) {
+            /* ph->p_memsz == ph->p_filesz */
+            if (start == end) {
+                continue ;
+            }
+            off = start + PGSIZE - la, size = PGSIZE - off;
+            if (end < la) {
+                size -= la - end;
+            }
+            memset(page2kva(page) + off, 0, size);
+            start += size;
+            assert((end < la && start == end) || (end >= la && start == la));
+        }
+        while (start < end) {
+            if ((page = pgdir_alloc_page(mm->pgdir, la, perm)) == NULL) {
+                goto bad_cleanup_mmap;
+            }
+            off = start - la, size = PGSIZE - off, la += PGSIZE;
+            if (end < la) {
+                size -= la - end;
+            }
+            memset(page2kva(page) + off, 0, size);
+            start += size;
+        }
+    }
+    //(4) build user stack memory
+    vm_flags = VM_READ | VM_WRITE | VM_STACK;
+    if ((ret = mm_map(mm, USTACKTOP - USTACKSIZE, USTACKSIZE, vm_flags, NULL)) != 0) {
+        goto bad_cleanup_mmap;
+    }
+    assert(pgdir_alloc_page(mm->pgdir, USTACKTOP-PGSIZE , PTE_USER) != NULL);
+    assert(pgdir_alloc_page(mm->pgdir, USTACKTOP-2*PGSIZE , PTE_USER) != NULL);
+    assert(pgdir_alloc_page(mm->pgdir, USTACKTOP-3*PGSIZE , PTE_USER) != NULL);
+    assert(pgdir_alloc_page(mm->pgdir, USTACKTOP-4*PGSIZE , PTE_USER) != NULL);
+    
+    //(5) set current process's mm, sr3, and set CR3 reg = physical addr of Page Directory
+    mm_count_inc(mm);
+    current->mm = mm;
+    current->cr3 = PADDR(mm->pgdir);
+    lcr3(PADDR(mm->pgdir));
+
+    //(6) setup trapframe for user environment
+    struct trapframe *tf = current->tf;
+    memset(tf, 0, sizeof(struct trapframe));
+    /* LAB5:EXERCISE1 YOUR CODE
+     * should set tf_cs,tf_ds,tf_es,tf_ss,tf_esp,tf_eip,tf_eflags
+     * NOTICE: If we set trapframe correctly, then the user level process can return to USER MODE from kernel. So
+     *          tf_cs should be USER_CS segment (see memlayout.h)
+     *          tf_ds=tf_es=tf_ss should be USER_DS segment
+     *          tf_esp should be the top addr of user stack (USTACKTOP)
+     *          tf_eip should be the entry point of this binary program (elf->e_entry)
+     *          tf_eflags should be set to enable computer to produce Interrupt
+     */
+    tf->tf_cs = USER_CS;
+    tf->tf_ds = tf->tf_es = tf->tf_ss = USER_DS;
+    tf->tf_esp = USTACKTOP;
+    tf->tf_eip = elf->e_entry;
+    tf->tf_eflags = 0x00000002 | FL_IF; // to enable interrupt
+    //tf->tf_eflags = FL_IF; // to enable interrupt
+    ret = 0;
+out:
+    return ret;
+bad_cleanup_mmap:
+    exit_mmap(mm);
+bad_elf_cleanup_pgdir:
+    put_pgdir(mm);
+bad_pgdir_cleanup_mm:
+    mm_destroy(mm);
+bad_mm:
+    goto out;
+}
+
+// do_execve - call exit_mmap(mm)&put_pgdir(mm) to reclaim memory space of current process
+//           - call load_icode to setup new memory space accroding binary prog.
+int
+do_execve(const char *name, size_t len, unsigned char *binary, size_t size) {
+    struct mm_struct *mm = current->mm;
+    if (!user_mem_check(mm, (uintptr_t)name, len, 0)) {
+        return -E_INVAL;
+    }
+    if (len > PROC_NAME_LEN) {
+        len = PROC_NAME_LEN;
+    }
+
+    char local_name[PROC_NAME_LEN + 1];
+    memset(local_name, 0, sizeof(local_name));
+    memcpy(local_name, name, len);
+
+    if (mm != NULL) {
+        lcr3(boot_cr3);
+        if (mm_count_dec(mm) == 0) {
+            exit_mmap(mm);
+            put_pgdir(mm);
+            mm_destroy(mm);
+        }
+        current->mm = NULL;
+    }
+    int ret;
+    if ((ret = load_icode(binary, size)) != 0) {
+        goto execve_exit;
+    }
+    set_proc_name(current, local_name);
+    return 0;
+
+execve_exit:
+    do_exit(ret);
+    panic("already exit: %e.\n", ret);
+}
+
+// do_yield - ask the scheduler to reschedule
+int
+do_yield(void) {
+    current->need_resched = 1;
+    return 0;
+}
+
+// do_wait - wait one OR any children with PROC_ZOMBIE state, and free memory space of kernel stack
+//         - proc struct of this child.
+// NOTE: only after do_wait function, all resources of the child proces are free.
+int
+do_wait(int pid, int *code_store) {
+    struct mm_struct *mm = current->mm;
+    if (code_store != NULL) {
+        if (!user_mem_check(mm, (uintptr_t)code_store, sizeof(int), 1)) {
+            return -E_INVAL;
+        }
+    }
+
+    struct proc_struct *proc;
+    bool intr_flag, haskid;
+repeat:
+    haskid = 0;
+    if (pid != 0) {
+        proc = find_proc(pid);
+        if (proc != NULL && proc->parent == current) {
+            haskid = 1;
+            if (proc->state == PROC_ZOMBIE) {
+                goto found;
+            }
+        }
+    }
+    else {
+        proc = current->cptr;
+        for (; proc != NULL; proc = proc->optr) {
+            haskid = 1;
+            if (proc->state == PROC_ZOMBIE) {
+                goto found;
+            }
+        }
+    }
+    if (haskid) {
+        current->state = PROC_SLEEPING;
+        current->wait_state = WT_CHILD;
+        schedule();
+        if (current->flags & PF_EXITING) {
+            do_exit(-E_KILLED);
+        }
+        goto repeat;
+    }
+    return -E_BAD_PROC;
+
+found:
+    if (proc == idleproc || proc == initproc) {
+        panic("wait idleproc or initproc.\n");
+    }
+    if (code_store != NULL) {
+        *code_store = proc->exit_code;
+    }
+    local_intr_save(intr_flag);
+    {
+        unhash_proc(proc);
+        remove_links(proc);
+    }
+    local_intr_restore(intr_flag);
+    put_kstack(proc);
+    kfree(proc);
+    return 0;
+}
+
+// do_kill - kill process with pid by set this process's flags with PF_EXITING
+int
+do_kill(int pid) {
+    struct proc_struct *proc;
+    if ((proc = find_proc(pid)) != NULL) {
+        if (!(proc->flags & PF_EXITING)) {
+            proc->flags |= PF_EXITING;
+            if (proc->wait_state & WT_INTERRUPTED) {
+                wakeup_proc(proc);
+            }
+            return 0;
+        }
+        return -E_KILLED;
+    }
+    return -E_INVAL;
+}
+
+// kernel_execve - do SYS_exec syscall to exec a user program called by user_main kernel_thread
+static int
+kernel_execve(const char *name, unsigned char *binary, size_t size) {
+    int ret, len = strlen(name);
+    asm volatile (
+        "int %1;"
+        : "=a" (ret)
+        : "i" (T_SYSCALL), "0" (SYS_exec), "d" (name), "c" (len), "b" (binary), "D" (size)
+        : "memory");
+    return ret;
+}
+
+#define __KERNEL_EXECVE(name, binary, size) ({                          \
+            cprintf("kernel_execve: pid = %d, name = \"%s\".\n",        \
+                    current->pid, name);                                \
+            kernel_execve(name, binary, (size_t)(size));                \
+        })
+
+#define KERNEL_EXECVE(x) ({                                             \
+            extern unsigned char _binary_obj___user_##x##_out_start[],  \
+                _binary_obj___user_##x##_out_size[];                    \
+            __KERNEL_EXECVE(#x, _binary_obj___user_##x##_out_start,     \
+                            _binary_obj___user_##x##_out_size);         \
+        })
+
+#define __KERNEL_EXECVE2(x, xstart, xsize) ({                           \
+            extern unsigned char xstart[], xsize[];                     \
+            __KERNEL_EXECVE(#x, xstart, (size_t)xsize);                 \
+        })
+
+#define KERNEL_EXECVE2(x, xstart, xsize)        __KERNEL_EXECVE2(x, xstart, xsize)
+
+// user_main - kernel thread used to exec a user program
+static int
+user_main(void *arg) {
+#ifdef TEST
+    KERNEL_EXECVE2(TEST, TESTSTART, TESTSIZE);
+#else
+    KERNEL_EXECVE(exit);
+#endif
+    panic("user_main execve failed.\n");
+}
+
+// init_main - the second kernel thread used to create user_main kernel threads
+static int
+init_main(void *arg) {
+    size_t nr_free_pages_store = nr_free_pages();
+    size_t kernel_allocated_store = kallocated();
+
+    int pid = kernel_thread(user_main, NULL, 0);
+    if (pid <= 0) {
+        panic("create user_main failed.\n");
+    }
+
+    while (do_wait(0, NULL) == 0) {
+        schedule();
+    }
+
+    cprintf("all user-mode processes have quit.\n");
+    assert(initproc->cptr == NULL && initproc->yptr == NULL && initproc->optr == NULL);
+    assert(nr_process == 2);
+    assert(list_next(&proc_list) == &(initproc->list_link));
+    assert(list_prev(&proc_list) == &(initproc->list_link));
+
+    cprintf("init check memory pass.\n");
+    return 0;
+}
+
+// proc_init - set up the first kernel thread idleproc "idle" by itself and 
+//           - create the second kernel thread init_main
+void
+proc_init(void) {
+    int i;
+
+    list_init(&proc_list);
+    for (i = 0; i < HASH_LIST_SIZE; i ++) {
+        list_init(hash_list + i);
+    }
+
+    if ((idleproc = alloc_proc()) == NULL) {
+        panic("cannot alloc idleproc.\n");
+    }
+
+    idleproc->pid = 0;
+    idleproc->state = PROC_RUNNABLE;
+    idleproc->kstack = (uintptr_t)bootstack;
+    idleproc->need_resched = 1;
+    set_proc_name(idleproc, "idle");
+    nr_process ++;
+
+    current = idleproc;
+
+    int pid = kernel_thread(init_main, NULL, 0);
+    if (pid <= 0) {
+        panic("create init_main failed.\n");
+    }
+
+    initproc = find_proc(pid);
+    set_proc_name(initproc, "init");
+
+    assert(idleproc != NULL && idleproc->pid == 0);
+    assert(initproc != NULL && initproc->pid == 1);
+}
+
+// cpu_idle - at the end of kern_init, the first kernel thread idleproc will do below works
+void
+cpu_idle(void) {
+    while (1) {
+        if (current->need_resched) {
+            schedule();
+        }
+    }
+}
+
+//FOR LAB6, set the process's priority (bigger value will get more CPU time) 
+void
+lab6_set_priority(uint32_t priority)
+{
+    if (priority == 0)
+        current->lab6_priority = 1;
+    else current->lab6_priority = priority;
+}
diff -r -u -P lab6_origin/kern/process/proc.h lab6/kern/process/proc.h
--- lab6_origin/kern/process/proc.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/process/proc.h	2019-02-26 20:51:17.067357900 +0800
@@ -0,0 +1,99 @@
+#ifndef __KERN_PROCESS_PROC_H__
+#define __KERN_PROCESS_PROC_H__
+
+#include <defs.h>
+#include <list.h>
+#include <trap.h>
+#include <memlayout.h>
+#include <skew_heap.h>
+
+
+// process's state in his life cycle
+enum proc_state {
+    PROC_UNINIT = 0,  // uninitialized
+    PROC_SLEEPING,    // sleeping
+    PROC_RUNNABLE,    // runnable(maybe running)
+    PROC_ZOMBIE,      // almost dead, and wait parent proc to reclaim his resource
+};
+
+// Saved registers for kernel context switches.
+// Don't need to save all the %fs etc. segment registers,
+// because they are constant across kernel contexts.
+// Save all the regular registers so we don't need to care
+// which are caller save, but not the return register %eax.
+// (Not saving %eax just simplifies the switching code.)
+// The layout of context must match code in switch.S.
+struct context {
+    uint32_t eip;
+    uint32_t esp;
+    uint32_t ebx;
+    uint32_t ecx;
+    uint32_t edx;
+    uint32_t esi;
+    uint32_t edi;
+    uint32_t ebp;
+};
+
+#define PROC_NAME_LEN               15
+#define MAX_PROCESS                 4096
+#define MAX_PID                     (MAX_PROCESS * 2)
+
+extern list_entry_t proc_list;
+
+struct proc_struct {
+    enum proc_state state;                      // Process state
+    int pid;                                    // Process ID
+    int runs;                                   // the running times of Proces
+    uintptr_t kstack;                           // Process kernel stack
+    volatile bool need_resched;                 // bool value: need to be rescheduled to release CPU?
+    struct proc_struct *parent;                 // the parent process
+    struct mm_struct *mm;                       // Process's memory management field
+    struct context context;                     // Switch here to run process
+    struct trapframe *tf;                       // Trap frame for current interrupt
+    uintptr_t cr3;                              // CR3 register: the base addr of Page Directroy Table(PDT)
+    uint32_t flags;                             // Process flag
+    char name[PROC_NAME_LEN + 1];               // Process name
+    list_entry_t list_link;                     // Process link list 
+    list_entry_t hash_link;                     // Process hash list
+    int exit_code;                              // exit code (be sent to parent proc)
+    uint32_t wait_state;                        // waiting state
+    struct proc_struct *cptr, *yptr, *optr;     // relations between processes
+    struct run_queue *rq;                       // running queue contains Process
+    list_entry_t run_link;                      // the entry linked in run queue
+    int time_slice;                             // time slice for occupying the CPU
+    skew_heap_entry_t lab6_run_pool;            // FOR LAB6 ONLY: the entry in the run pool
+    uint32_t lab6_stride;                       // FOR LAB6 ONLY: the current stride of the process 
+    uint32_t lab6_priority;                     // FOR LAB6 ONLY: the priority of process, set by lab6_set_priority(uint32_t)
+};
+
+#define PF_EXITING                  0x00000001      // getting shutdown
+
+#define WT_CHILD                    (0x00000001 | WT_INTERRUPTED)
+#define WT_INTERRUPTED               0x80000000                    // the wait state could be interrupted
+
+
+#define le2proc(le, member)         \
+    to_struct((le), struct proc_struct, member)
+
+extern struct proc_struct *idleproc, *initproc, *current;
+
+void proc_init(void);
+void proc_run(struct proc_struct *proc);
+int kernel_thread(int (*fn)(void *), void *arg, uint32_t clone_flags);
+
+char *set_proc_name(struct proc_struct *proc, const char *name);
+char *get_proc_name(struct proc_struct *proc);
+void cpu_idle(void) __attribute__((noreturn));
+
+struct proc_struct *find_proc(int pid);
+int do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf);
+int do_exit(int error_code);
+int do_yield(void);
+int do_execve(const char *name, size_t len, unsigned char *binary, size_t size);
+int do_wait(int pid, int *code_store);
+int do_kill(int pid);
+//FOR LAB6, set the process's priority (bigger value will get more CPU time) 
+void lab6_set_priority(uint32_t priority);
+
+#endif /* !__KERN_PROCESS_PROC_H__ */
+
diff -r -u -P lab6_origin/kern/process/switch.S lab6/kern/process/switch.S
--- lab6_origin/kern/process/switch.S	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/process/switch.S	2019-02-26 20:51:17.067856800 +0800
@@ -0,0 +1,30 @@
+.text
+.globl switch_to
+switch_to:                      # switch_to(from, to)
+
+    # save from's registers
+    movl 4(%esp), %eax          # eax points to from
+    popl 0(%eax)                # save eip !popl
+    movl %esp, 4(%eax)
+    movl %ebx, 8(%eax)
+    movl %ecx, 12(%eax)
+    movl %edx, 16(%eax)
+    movl %esi, 20(%eax)
+    movl %edi, 24(%eax)
+    movl %ebp, 28(%eax)
+
+    # restore to's registers
+    movl 4(%esp), %eax          # not 8(%esp): popped return address already
+                                # eax now points to to
+    movl 28(%eax), %ebp
+    movl 24(%eax), %edi
+    movl 20(%eax), %esi
+    movl 16(%eax), %edx
+    movl 12(%eax), %ecx
+    movl 8(%eax), %ebx
+    movl 4(%eax), %esp
+
+    pushl 0(%eax)               # push eip
+
+    ret
+
diff -r -u -P lab6_origin/kern/schedule/default_sched.c lab6/kern/schedule/default_sched.c
--- lab6_origin/kern/schedule/default_sched.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/schedule/default_sched.c	2019-05-12 16:18:00.230845000 +0800
@@ -0,0 +1,58 @@
+#include <defs.h>
+#include <list.h>
+#include <proc.h>
+#include <assert.h>
+#include <default_sched.h>
+
+static void
+RR_init(struct run_queue *rq) {
+    list_init(&(rq->run_list));
+    rq->proc_num = 0;
+}
+
+static void
+RR_enqueue(struct run_queue *rq, struct proc_struct *proc) {
+    assert(list_empty(&(proc->run_link)));
+    list_add_before(&(rq->run_list), &(proc->run_link));
+    if (proc->time_slice == 0 || proc->time_slice > rq->max_time_slice) {
+        proc->time_slice = rq->max_time_slice;
+    }
+    proc->rq = rq;
+    rq->proc_num ++;
+}
+
+static void
+RR_dequeue(struct run_queue *rq, struct proc_struct *proc) {
+    assert(!list_empty(&(proc->run_link)) && proc->rq == rq);
+    list_del_init(&(proc->run_link));
+    rq->proc_num --;
+}
+
+static struct proc_struct *
+RR_pick_next(struct run_queue *rq) {
+    list_entry_t *le = list_next(&(rq->run_list));
+    if (le != &(rq->run_list)) {
+        return le2proc(le, run_link);
+    }
+    return NULL;
+}
+
+static void
+RR_proc_tick(struct run_queue *rq, struct proc_struct *proc) {
+    if (proc->time_slice > 0) {
+        proc->time_slice --;
+    }
+    if (proc->time_slice == 0) {
+        proc->need_resched = 1;
+    }
+}
+/*
+struct sched_class default_sched_class = {
+    .name = "RR_scheduler",
+    .init = RR_init,
+    .enqueue = RR_enqueue,
+    .dequeue = RR_dequeue,
+    .pick_next = RR_pick_next,
+    .proc_tick = RR_proc_tick,
+};
+*/
diff -r -u -P lab6_origin/kern/schedule/default_sched.h lab6/kern/schedule/default_sched.h
--- lab6_origin/kern/schedule/default_sched.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/schedule/default_sched.h	2019-05-12 16:12:58.707443600 +0800
@@ -0,0 +1,9 @@
+#ifndef __KERN_SCHEDULE_SCHED_RR_H__
+#define __KERN_SCHEDULE_SCHED_RR_H__
+
+#include <sched.h>
+
+extern struct sched_class default_sched_class;
+
+#endif /* !__KERN_SCHEDULE_SCHED_RR_H__ */
+
diff -r -u -P lab6_origin/kern/schedule/default_sched_stride.c lab6/kern/schedule/default_sched_stride.c
--- lab6_origin/kern/schedule/default_sched_stride.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/schedule/default_sched_stride.c	2019-05-13 22:07:12.605427500 +0800
@@ -0,0 +1,155 @@
+#include <defs.h>
+#include <list.h>
+#include <proc.h>
+#include <assert.h>
+#include <default_sched.h>
+
+#define USE_SKEW_HEAP 1
+
+/* You should define the BigStride constant here*/
+/* LAB6: YOUR CODE */
+#define BIG_STRIDE ((uint32_t)(1<<31)-2)   /* you should give a value, and is ??? */
+
+/* The compare function for two skew_heap_node_t's and the
+ * corresponding procs*/
+static int
+proc_stride_comp_f(void *a, void *b)
+{
+     struct proc_struct *p = le2proc(a, lab6_run_pool);
+     struct proc_struct *q = le2proc(b, lab6_run_pool);
+     int32_t c = p->lab6_stride - q->lab6_stride;
+     if (c > 0) return 1;
+     else if (c == 0) return 0;
+     else return -1;
+}
+
+/*
+ * stride_init initializes the run-queue rq with correct assignment for
+ * member variables, including:
+ *
+ *   - run_list: should be a empty list after initialization.
+ *   - lab6_run_pool: NULL
+ *   - proc_num: 0
+ *   - max_time_slice: no need here, the variable would be assigned by the caller.
+ *
+ * hint: see libs/list.h for routines of the list structures.
+ */
+static void
+stride_init(struct run_queue *rq) {
+     /* LAB6: YOUR CODE 
+      * (1) init the ready process list: rq->run_list
+      * (2) init the run pool: rq->lab6_run_pool
+      * (3) set number of process: rq->proc_num to 0       
+      */
+      list_init(&rq->run_list); 
+      rq->lab6_run_pool = NULL;
+      rq->proc_num = 0;
+}
+
+/*
+ * stride_enqueue inserts the process ``proc'' into the run-queue
+ * ``rq''. The procedure should verify/initialize the relevant members
+ * of ``proc'', and then put the ``lab6_run_pool'' node into the
+ * queue(since we use priority queue here). The procedure should also
+ * update the meta date in ``rq'' structure.
+ *
+ * proc->time_slice denotes the time slices allocation for the
+ * process, which should set to rq->max_time_slice.
+ * 
+ * hint: see libs/skew_heap.h for routines of the priority
+ * queue structures.
+ */
+static void
+stride_enqueue(struct run_queue *rq, struct proc_struct *proc) {
+     /* LAB6: YOUR CODE 
+      * (1) insert the proc into rq correctly
+      * NOTICE: you can use skew_heap or list. Important functions
+      *         skew_heap_insert: insert a entry into skew_heap
+      *         list_add_before: insert  a entry into the last of list   
+      * (2) recalculate proc->time_slice
+      * (3) set proc->rq pointer to rq
+      * (4) increase rq->proc_num
+      */
+      rq->lab6_run_pool = skew_heap_insert(rq->lab6_run_pool, &proc->lab6_run_pool, proc_stride_comp_f);
+      if(proc->time_slice == 0 || proc->time_slice > rq->max_time_slice) {
+          proc->time_slice = rq->max_time_slice;
+      }
+      proc->rq = rq;
+      rq->proc_num ++;
+}
+
+/*
+ * stride_dequeue removes the process ``proc'' from the run-queue
+ * ``rq'', the operation would be finished by the skew_heap_remove
+ * operations. Remember to update the ``rq'' structure.
+ *
+ * hint: see libs/skew_heap.h for routines of the priority
+ * queue structures.
+ */
+static void
+stride_dequeue(struct run_queue *rq, struct proc_struct *proc) {
+     /* LAB6: YOUR CODE 
+      * (1) remove the proc from rq correctly
+      * NOTICE: you can use skew_heap or list. Important functions
+      *         skew_heap_remove: remove a entry from skew_heap
+      *         list_del_init: remove a entry from the  list
+      */
+      rq->lab6_run_pool = skew_heap_remove(rq->lab6_run_pool, &proc->lab6_run_pool, proc_stride_comp_f);
+      rq->proc_num --;
+}
+/*
+ * stride_pick_next pick the element from the ``run-queue'', with the
+ * minimum value of stride, and returns the corresponding process
+ * pointer. The process pointer would be calculated by macro le2proc,
+ * see kern/process/proc.h for definition. Return NULL if
+ * there is no process in the queue.
+ *
+ * When one proc structure is selected, remember to update the stride
+ * property of the proc. (stride += BIG_STRIDE / priority)
+ *
+ * hint: see libs/skew_heap.h for routines of the priority
+ * queue structures.
+ */
+static struct proc_struct *
+stride_pick_next(struct run_queue *rq) {
+     /* LAB6: YOUR CODE 
+      * (1) get a  proc_struct pointer p  with the minimum value of stride
+             (1.1) If using skew_heap, we can use le2proc get the p from rq->lab6_run_poll
+             (1.2) If using list, we have to search list to find the p with minimum stride value
+      * (2) update p;s stride value: p->lab6_stride
+      * (3) return p
+      */ 
+      if (rq->lab6_run_pool == NULL) 
+          return NULL; 
+      struct proc_struct *p = le2proc(rq->lab6_run_pool, lab6_run_pool);
+      p->lab6_stride += BIG_STRIDE/p->lab6_priority;
+      return p;
+}
+
+/*
+ * stride_proc_tick works with the tick event of current process. You
+ * should check whether the time slices for current process is
+ * exhausted and update the proc struct ``proc''. proc->time_slice
+ * denotes the time slices left for current
+ * process. proc->need_resched is the flag variable for process
+ * switching.
+ */
+static void
+stride_proc_tick(struct run_queue *rq, struct proc_struct *proc) {
+     /* LAB6: YOUR CODE */
+	if (proc->time_slice > 0) {
+		proc->time_slice --;
+	}
+	if (proc->time_slice == 0) {
+		proc->need_resched = 1;
+	}
+}
+
+struct sched_class default_sched_class = {
+     .name = "stride_scheduler",
+     .init = stride_init,
+     .enqueue = stride_enqueue,
+     .dequeue = stride_dequeue,
+     .pick_next = stride_pick_next,
+     .proc_tick = stride_proc_tick,
+};
diff -r -u -P lab6_origin/kern/schedule/sched.c lab6/kern/schedule/sched.c
--- lab6_origin/kern/schedule/sched.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/schedule/sched.c	2019-05-13 17:39:08.545667500 +0800
@@ -0,0 +1,100 @@
+#include <list.h>
+#include <sync.h>
+#include <proc.h>
+#include <sched.h>
+#include <stdio.h>
+#include <assert.h>
+#include <default_sched.h>
+
+// the list of timer
+static list_entry_t timer_list;
+
+static struct sched_class *sched_class;
+
+static struct run_queue *rq;
+
+static inline void
+sched_class_enqueue(struct proc_struct *proc) {
+    if (proc != idleproc) {
+        sched_class->enqueue(rq, proc);
+    }
+}
+
+static inline void
+sched_class_dequeue(struct proc_struct *proc) {
+    sched_class->dequeue(rq, proc);
+}
+
+static inline struct proc_struct *
+sched_class_pick_next(void) {
+    return sched_class->pick_next(rq);
+}
+
+void
+sched_class_proc_tick(struct proc_struct *proc) {
+    if (proc != idleproc) {
+        sched_class->proc_tick(rq, proc);
+    }
+    else {
+        proc->need_resched = 1;
+    }
+}
+
+static struct run_queue __rq;
+
+void
+sched_init(void) {
+    list_init(&timer_list);
+
+    sched_class = &default_sched_class;
+
+    rq = &__rq;
+    rq->max_time_slice = MAX_TIME_SLICE;
+    sched_class->init(rq);
+
+    cprintf("sched class: %s\n", sched_class->name);
+}
+
+void
+wakeup_proc(struct proc_struct *proc) {
+    assert(proc->state != PROC_ZOMBIE);
+    bool intr_flag;
+    local_intr_save(intr_flag);
+    {
+        if (proc->state != PROC_RUNNABLE) {
+            proc->state = PROC_RUNNABLE;
+            proc->wait_state = 0;
+            if (proc != current) {
+                sched_class_enqueue(proc);
+            }
+        }
+        else {
+            warn("wakeup runnable process.\n");
+        }
+    }
+    local_intr_restore(intr_flag);
+}
+
+void
+schedule(void) {
+    bool intr_flag;
+    struct proc_struct *next;
+    local_intr_save(intr_flag);
+    {
+        current->need_resched = 0;
+        if (current->state == PROC_RUNNABLE) {
+            sched_class_enqueue(current);
+        }
+        if ((next = sched_class_pick_next()) != NULL) {
+            sched_class_dequeue(next);
+        }
+        if (next == NULL) {
+            next = idleproc;
+        }
+        next->runs ++;
+        if (next != current) {
+            proc_run(next);
+        }
+    }
+    local_intr_restore(intr_flag);
+}
diff -r -u -P lab6_origin/kern/schedule/sched.h lab6/kern/schedule/sched.h
--- lab6_origin/kern/schedule/sched.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/schedule/sched.h	2019-02-26 20:51:17.072846300 +0800
@@ -0,0 +1,53 @@
+#ifndef __KERN_SCHEDULE_SCHED_H__
+#define __KERN_SCHEDULE_SCHED_H__
+
+#include <defs.h>
+#include <list.h>
+#include <skew_heap.h>
+
+#define MAX_TIME_SLICE 5
+
+struct proc_struct;
+
+struct run_queue;
+
+// The introduction of scheduling classes is borrrowed from Linux, and makes the 
+// core scheduler quite extensible. These classes (the scheduler modules) encapsulate 
+// the scheduling policies. 
+struct sched_class {
+    // the name of sched_class
+    const char *name;
+    // Init the run queue
+    void (*init)(struct run_queue *rq);
+    // put the proc into runqueue, and this function must be called with rq_lock
+    void (*enqueue)(struct run_queue *rq, struct proc_struct *proc);
+    // get the proc out runqueue, and this function must be called with rq_lock
+    void (*dequeue)(struct run_queue *rq, struct proc_struct *proc);
+    // choose the next runnable task
+    struct proc_struct *(*pick_next)(struct run_queue *rq);
+    // dealer of the time-tick
+    void (*proc_tick)(struct run_queue *rq, struct proc_struct *proc);
+    /* for SMP support in the future
+     *  load_balance
+     *     void (*load_balance)(struct rq* rq);
+     *  get some proc from this rq, used in load_balance,
+     *  return value is the num of gotten proc
+     *  int (*get_proc)(struct rq* rq, struct proc* procs_moved[]);
+     */
+};
+
+struct run_queue {
+    list_entry_t run_list;
+    unsigned int proc_num;
+    int max_time_slice;
+    // For LAB6 ONLY
+    skew_heap_entry_t *lab6_run_pool;
+};
+
+void sched_init(void);
+void wakeup_proc(struct proc_struct *proc);
+void schedule(void);
+void sched_class_proc_tick(struct proc_struct *proc);
+
+#endif /* !__KERN_SCHEDULE_SCHED_H__ */
+
diff -r -u -P lab6_origin/kern/sync/sync.h lab6/kern/sync/sync.h
--- lab6_origin/kern/sync/sync.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/sync/sync.h	2019-02-26 20:51:17.073843200 +0800
@@ -0,0 +1,57 @@
+#ifndef __KERN_SYNC_SYNC_H__
+#define __KERN_SYNC_SYNC_H__
+
+#include <x86.h>
+#include <intr.h>
+#include <mmu.h>
+#include <assert.h>
+#include <atomic.h>
+#include <sched.h>
+
+static inline bool
+__intr_save(void) {
+    if (read_eflags() & FL_IF) {
+        intr_disable();
+        return 1;
+    }
+    return 0;
+}
+
+static inline void
+__intr_restore(bool flag) {
+    if (flag) {
+        intr_enable();
+    }
+}
+
+#define local_intr_save(x)      do { x = __intr_save(); } while (0)
+#define local_intr_restore(x)   __intr_restore(x);
+
+typedef volatile bool lock_t;
+
+static inline void
+lock_init(lock_t *lock) {
+    *lock = 0;
+}
+
+static inline bool
+try_lock(lock_t *lock) {
+    return !test_and_set_bit(0, lock);
+}
+
+static inline void
+lock(lock_t *lock) {
+    while (!try_lock(lock)) {
+        schedule();
+    }
+}
+
+static inline void
+unlock(lock_t *lock) {
+    if (!test_and_clear_bit(0, lock)) {
+        panic("Unlock failed.\n");
+    }
+}
+
+#endif /* !__KERN_SYNC_SYNC_H__ */
+
diff -r -u -P lab6_origin/kern/syscall/syscall.c lab6/kern/syscall/syscall.c
--- lab6_origin/kern/syscall/syscall.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/syscall/syscall.c	2019-02-26 20:51:17.074844600 +0800
@@ -0,0 +1,116 @@
+#include <unistd.h>
+#include <proc.h>
+#include <syscall.h>
+#include <trap.h>
+#include <stdio.h>
+#include <pmm.h>
+#include <assert.h>
+#include <clock.h>
+
+static int
+sys_exit(uint32_t arg[]) {
+    int error_code = (int)arg[0];
+    return do_exit(error_code);
+}
+
+static int
+sys_fork(uint32_t arg[]) {
+    struct trapframe *tf = current->tf;
+    uintptr_t stack = tf->tf_esp;
+    return do_fork(0, stack, tf);
+}
+
+static int
+sys_wait(uint32_t arg[]) {
+    int pid = (int)arg[0];
+    int *store = (int *)arg[1];
+    return do_wait(pid, store);
+}
+
+static int
+sys_exec(uint32_t arg[]) {
+    const char *name = (const char *)arg[0];
+    size_t len = (size_t)arg[1];
+    unsigned char *binary = (unsigned char *)arg[2];
+    size_t size = (size_t)arg[3];
+    return do_execve(name, len, binary, size);
+}
+
+static int
+sys_yield(uint32_t arg[]) {
+    return do_yield();
+}
+
+static int
+sys_kill(uint32_t arg[]) {
+    int pid = (int)arg[0];
+    return do_kill(pid);
+}
+
+static int
+sys_getpid(uint32_t arg[]) {
+    return current->pid;
+}
+
+static int
+sys_putc(uint32_t arg[]) {
+    int c = (int)arg[0];
+    cputchar(c);
+    return 0;
+}
+
+static int
+sys_pgdir(uint32_t arg[]) {
+    print_pgdir();
+    return 0;
+}
+
+static int
+sys_gettime(uint32_t arg[]) {
+    return (int)ticks;
+}
+static int
+sys_lab6_set_priority(uint32_t arg[])
+{
+    uint32_t priority = (uint32_t)arg[0];
+    lab6_set_priority(priority);
+    return 0;
+}
+
+static int (*syscalls[])(uint32_t arg[]) = {
+    [SYS_exit]              sys_exit,
+    [SYS_fork]              sys_fork,
+    [SYS_wait]              sys_wait,
+    [SYS_exec]              sys_exec,
+    [SYS_yield]             sys_yield,
+    [SYS_kill]              sys_kill,
+    [SYS_getpid]            sys_getpid,
+    [SYS_putc]              sys_putc,
+    [SYS_pgdir]             sys_pgdir,
+    [SYS_gettime]           sys_gettime,
+    [SYS_lab6_set_priority] sys_lab6_set_priority,
+};
+
+#define NUM_SYSCALLS        ((sizeof(syscalls)) / (sizeof(syscalls[0])))
+
+void
+syscall(void) {
+    struct trapframe *tf = current->tf;
+    uint32_t arg[5];
+    int num = tf->tf_regs.reg_eax;
+    if (num >= 0 && num < NUM_SYSCALLS) {
+        if (syscalls[num] != NULL) {
+            arg[0] = tf->tf_regs.reg_edx;
+            arg[1] = tf->tf_regs.reg_ecx;
+            arg[2] = tf->tf_regs.reg_ebx;
+            arg[3] = tf->tf_regs.reg_edi;
+            arg[4] = tf->tf_regs.reg_esi;
+            tf->tf_regs.reg_eax = syscalls[num](arg);
+            return ;
+        }
+    }
+    print_trapframe(tf);
+    panic("undefined syscall %d, pid = %d, name = %s.\n",
+            num, current->pid, current->name);
+}
+
diff -r -u -P lab6_origin/kern/syscall/syscall.h lab6/kern/syscall/syscall.h
--- lab6_origin/kern/syscall/syscall.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/syscall/syscall.h	2019-02-26 20:51:17.075840200 +0800
@@ -0,0 +1,7 @@
+#ifndef __KERN_SYSCALL_SYSCALL_H__
+#define __KERN_SYSCALL_SYSCALL_H__
+
+void syscall(void);
+
+#endif /* !__KERN_SYSCALL_SYSCALL_H__ */
+
diff -r -u -P lab6_origin/kern/trap/trap.c lab6/kern/trap/trap.c
--- lab6_origin/kern/trap/trap.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/trap/trap.c	2019-05-13 17:36:33.036676800 +0800
@@ -0,0 +1,312 @@
+#include <defs.h>
+#include <mmu.h>
+#include <memlayout.h>
+#include <clock.h>
+#include <trap.h>
+#include <x86.h>
+#include <stdio.h>
+#include <assert.h>
+#include <console.h>
+#include <vmm.h>
+#include <swap.h>
+#include <kdebug.h>
+#include <unistd.h>
+#include <syscall.h>
+#include <error.h>
+#include <sched.h>
+#include <sync.h>
+#include <proc.h>
+
+#define TICK_NUM 100
+
+static void print_ticks() {
+    cprintf("%d ticks\n",TICK_NUM);
+#ifdef DEBUG_GRADE
+    cprintf("End of Test.\n");
+    panic("EOT: kernel seems ok.");
+#endif
+}
+
+/* *
+ * Interrupt descriptor table:
+ *
+ * Must be built at run time because shifted function addresses can't
+ * be represented in relocation records.
+ * */
+static struct gatedesc idt[256] = {{0}};
+
+static struct pseudodesc idt_pd = {
+    sizeof(idt) - 1, (uintptr_t)idt
+};
+
+/* idt_init - initialize IDT to each of the entry points in kern/trap/vectors.S */
+void
+idt_init(void) {
+     /* LAB1 YOUR CODE : STEP 2 */
+     /* (1) Where are the entry addrs of each Interrupt Service Routine (ISR)?
+      *     All ISR's entry addrs are stored in __vectors. where is uintptr_t __vectors[] ?
+      *     __vectors[] is in kern/trap/vector.S which is produced by tools/vector.c
+      *     (try "make" command in lab1, then you will find vector.S in kern/trap DIR)
+      *     You can use  "extern uintptr_t __vectors[];" to define this extern variable which will be used later.
+      * (2) Now you should setup the entries of ISR in Interrupt Description Table (IDT).
+      *     Can you see idt[256] in this file? Yes, it's IDT! you can use SETGATE macro to setup each item of IDT
+      * (3) After setup the contents of IDT, you will let CPU know where is the IDT by using 'lidt' instruction.
+      *     You don't know the meaning of this instruction? just google it! and check the libs/x86.h to know more.
+      *     Notice: the argument of lidt is idt_pd. try to find it!
+      */
+    extern uintptr_t __vectors[];
+    int i;
+//    for(i=0;i<256;i++)
+        for(i=0;i< sizeof(idt) / sizeof(struct gatedesc); i++){
+            SETGATE(idt[i],0,GD_KTEXT,__vectors[i],DPL_KERNEL);
+    }
+//  SETGATE(idt[T_SWITCH_TOK], 0, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER);
+    SETGATE(idt[T_SYSCALL], 1, GD_KTEXT, __vectors[T_SYSCALL], DPL_USER);
+    lidt(&idt_pd);   
+     /* LAB5 YOUR CODE */ 
+     //you should update your lab1 code (just add ONE or TWO lines of code), let user app to use syscall to get the service of ucore
+     //so you should setup the syscall interrupt gate in here
+}
+
+static const char *
+trapname(int trapno) {
+    static const char * const excnames[] = {
+        "Divide error",
+        "Debug",
+        "Non-Maskable Interrupt",
+        "Breakpoint",
+        "Overflow",
+        "BOUND Range Exceeded",
+        "Invalid Opcode",
+        "Device Not Available",
+        "Double Fault",
+        "Coprocessor Segment Overrun",
+        "Invalid TSS",
+        "Segment Not Present",
+        "Stack Fault",
+        "General Protection",
+        "Page Fault",
+        "(unknown trap)",
+        "x87 FPU Floating-Point Error",
+        "Alignment Check",
+        "Machine-Check",
+        "SIMD Floating-Point Exception"
+    };
+
+    if (trapno < sizeof(excnames)/sizeof(const char * const)) {
+        return excnames[trapno];
+    }
+    if (trapno >= IRQ_OFFSET && trapno < IRQ_OFFSET + 16) {
+        return "Hardware Interrupt";
+    }
+    return "(unknown trap)";
+}
+
+/* trap_in_kernel - test if trap happened in kernel */
+bool
+trap_in_kernel(struct trapframe *tf) {
+    return (tf->tf_cs == (uint16_t)KERNEL_CS);
+}
+
+static const char *IA32flags[] = {
+    "CF", NULL, "PF", NULL, "AF", NULL, "ZF", "SF",
+    "TF", "IF", "DF", "OF", NULL, NULL, "NT", NULL,
+    "RF", "VM", "AC", "VIF", "VIP", "ID", NULL, NULL,
+};
+
+void
+print_trapframe(struct trapframe *tf) {
+    cprintf("trapframe at %p\n", tf);
+    print_regs(&tf->tf_regs);
+    cprintf("  ds   0x----%04x\n", tf->tf_ds);
+    cprintf("  es   0x----%04x\n", tf->tf_es);
+    cprintf("  fs   0x----%04x\n", tf->tf_fs);
+    cprintf("  gs   0x----%04x\n", tf->tf_gs);
+    cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
+    cprintf("  err  0x%08x\n", tf->tf_err);
+    cprintf("  eip  0x%08x\n", tf->tf_eip);
+    cprintf("  cs   0x----%04x\n", tf->tf_cs);
+    cprintf("  flag 0x%08x ", tf->tf_eflags);
+
+    int i, j;
+    for (i = 0, j = 1; i < sizeof(IA32flags) / sizeof(IA32flags[0]); i ++, j <<= 1) {
+        if ((tf->tf_eflags & j) && IA32flags[i] != NULL) {
+            cprintf("%s,", IA32flags[i]);
+        }
+    }
+    cprintf("IOPL=%d\n", (tf->tf_eflags & FL_IOPL_MASK) >> 12);
+
+    if (!trap_in_kernel(tf)) {
+        cprintf("  esp  0x%08x\n", tf->tf_esp);
+        cprintf("  ss   0x----%04x\n", tf->tf_ss);
+    }
+}
+
+void
+print_regs(struct pushregs *regs) {
+    cprintf("  edi  0x%08x\n", regs->reg_edi);
+    cprintf("  esi  0x%08x\n", regs->reg_esi);
+    cprintf("  ebp  0x%08x\n", regs->reg_ebp);
+    cprintf("  oesp 0x%08x\n", regs->reg_oesp);
+    cprintf("  ebx  0x%08x\n", regs->reg_ebx);
+    cprintf("  edx  0x%08x\n", regs->reg_edx);
+    cprintf("  ecx  0x%08x\n", regs->reg_ecx);
+    cprintf("  eax  0x%08x\n", regs->reg_eax);
+}
+
+static inline void
+print_pgfault(struct trapframe *tf) {
+    /* error_code:
+     * bit 0 == 0 means no page found, 1 means protection fault
+     * bit 1 == 0 means read, 1 means write
+     * bit 2 == 0 means kernel, 1 means user
+     * */
+    cprintf("page fault at 0x%08x: %c/%c [%s].\n", rcr2(),
+            (tf->tf_err & 4) ? 'U' : 'K',
+            (tf->tf_err & 2) ? 'W' : 'R',
+            (tf->tf_err & 1) ? "protection fault" : "no page found");
+}
+
+static int
+pgfault_handler(struct trapframe *tf) {
+    extern struct mm_struct *check_mm_struct;
+    if(check_mm_struct !=NULL) { //used for test check_swap
+            print_pgfault(tf);
+        }
+    struct mm_struct *mm;
+    if (check_mm_struct != NULL) {
+        assert(current == idleproc);
+        mm = check_mm_struct;
+    }
+    else {
+        if (current == NULL) {
+            print_trapframe(tf);
+            print_pgfault(tf);
+            panic("unhandled page fault.\n");
+        }
+        mm = current->mm;
+    }
+    return do_pgfault(mm, tf->tf_err, rcr2());
+}
+
+static volatile int in_swap_tick_event = 0;
+extern struct mm_struct *check_mm_struct;
+
+static void
+trap_dispatch(struct trapframe *tf) {
+    char c;
+
+    int ret=0;
+
+    switch (tf->tf_trapno) {
+    case T_PGFLT:  //page fault
+        if ((ret = pgfault_handler(tf)) != 0) {
+            print_trapframe(tf);
+            if (current == NULL) {
+                panic("handle pgfault failed. ret=%d\n", ret);
+            }
+            else {
+                if (trap_in_kernel(tf)) {
+                    panic("handle pgfault failed in kernel mode. ret=%d\n", ret);
+                }
+                cprintf("killed by kernel.\n");
+                panic("handle user mode pgfault failed. ret=%d\n", ret); 
+                do_exit(-E_KILLED);
+            }
+        }
+        break;
+    case T_SYSCALL:
+        syscall();
+        break;
+    case IRQ_OFFSET + IRQ_TIMER:
+#if 0
+    LAB3 : If some page replacement algorithm(such as CLOCK PRA) need tick to change the priority of pages,
+    then you can add code here. 
+#endif
+        /* LAB1 YOUR CODE : STEP 3 */
+        /* handle the timer interrupt */
+        /* (1) After a timer interrupt, you should record this event using a global variable (increase it), such as ticks in kern/driver/clock.c
+         * (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks().
+         * (3) Too Simple? Yes, I think so!
+         */
+           assert(current != NULL);
+           ticks++;
+           sched_class_proc_tick(current);
+	   //if(ticks>=TICK_NUM){
+           // assert(current != NULL);
+           //current->need_resched = 1;
+           //print_ticks();
+           // ticks=0;
+        //}    
+        /* LAB5 YOUR CODE */
+        /* you should upate you lab1 code (just add ONE or TWO lines of code):
+         *    Every TICK_NUM cycle, you should set current process's current->need_resched = 1
+         */
+        /* LAB6 YOUR CODE */
+        /* you should upate you lab5 code
+         * IMPORTANT FUNCTIONS:
+	     * sched_class_proc_tick
+         */
+        break;
+    case IRQ_OFFSET + IRQ_COM1:
+        c = cons_getc();
+        cprintf("serial [%03d] %c\n", c, c);
+        break;
+    case IRQ_OFFSET + IRQ_KBD:
+        c = cons_getc();
+        cprintf("kbd [%03d] %c\n", c, c);
+        break;
+    //LAB1 CHALLENGE 1 : YOUR CODE you should modify below codes.
+    case T_SWITCH_TOU:
+    case T_SWITCH_TOK:
+        panic("T_SWITCH_** ??\n");
+        break;
+    case IRQ_OFFSET + IRQ_IDE1:
+    case IRQ_OFFSET + IRQ_IDE2:
+        /* do nothing */
+        break;
+    default:
+        print_trapframe(tf);
+        if (current != NULL) {
+            cprintf("unhandled trap.\n");
+            do_exit(-E_KILLED);
+        }
+        // in kernel, it must be a mistake
+        panic("unexpected trap in kernel.\n");
+
+    }
+}
+
+/* *
+ * trap - handles or dispatches an exception/interrupt. if and when trap() returns,
+ * the code in kern/trap/trapentry.S restores the old CPU state saved in the
+ * trapframe and then uses the iret instruction to return from the exception.
+ * */
+void
+trap(struct trapframe *tf) {
+    // dispatch based on what type of trap occurred
+    // used for previous projects
+    if (current == NULL) {
+        trap_dispatch(tf);
+    }
+    else {
+        // keep a trapframe chain in stack
+        struct trapframe *otf = current->tf;
+        current->tf = tf;
+    
+        bool in_kernel = trap_in_kernel(tf);
+    
+        trap_dispatch(tf);
+    
+        current->tf = otf;
+        if (!in_kernel) {
+            if (current->flags & PF_EXITING) {
+                do_exit(-E_KILLED);
+            }
+            if (current->need_resched) {
+                schedule();
+            }
+        }
+    }
+}
+
diff -r -u -P lab6_origin/kern/trap/trapentry.S lab6/kern/trap/trapentry.S
--- lab6_origin/kern/trap/trapentry.S	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/trap/trapentry.S	2019-02-26 20:51:17.078336900 +0800
@@ -0,0 +1,49 @@
+#include <memlayout.h>
+
+# vectors.S sends all traps here.
+.text
+.globl __alltraps
+__alltraps:
+    # push registers to build a trap frame
+    # therefore make the stack look like a struct trapframe
+    pushl %ds
+    pushl %es
+    pushl %fs
+    pushl %gs
+    pushal
+
+    # load GD_KDATA into %ds and %es to set up data segments for kernel
+    movl $GD_KDATA, %eax
+    movw %ax, %ds
+    movw %ax, %es
+
+    # push %esp to pass a pointer to the trapframe as an argument to trap()
+    pushl %esp
+
+    # call trap(tf), where tf=%esp
+    call trap
+
+    # pop the pushed stack pointer
+    popl %esp
+
+    # return falls through to trapret...
+.globl __trapret
+__trapret:
+    # restore registers from stack
+    popal
+
+    # restore %ds, %es, %fs and %gs
+    popl %gs
+    popl %fs
+    popl %es
+    popl %ds
+
+    # get rid of the trap number and error code
+    addl $0x8, %esp
+    iret
+
+.globl forkrets
+forkrets:
+    # set stack to this new process's trapframe
+    movl 4(%esp), %esp
+    jmp __trapret
diff -r -u -P lab6_origin/kern/trap/trap.h lab6/kern/trap/trap.h
--- lab6_origin/kern/trap/trap.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/trap/trap.h	2019-02-26 20:51:17.077837600 +0800
@@ -0,0 +1,89 @@
+#ifndef __KERN_TRAP_TRAP_H__
+#define __KERN_TRAP_TRAP_H__
+
+#include <defs.h>
+
+/* Trap Numbers */
+
+/* Processor-defined: */
+#define T_DIVIDE                0   // divide error
+#define T_DEBUG                 1   // debug exception
+#define T_NMI                   2   // non-maskable interrupt
+#define T_BRKPT                 3   // breakpoint
+#define T_OFLOW                 4   // overflow
+#define T_BOUND                 5   // bounds check
+#define T_ILLOP                 6   // illegal opcode
+#define T_DEVICE                7   // device not available
+#define T_DBLFLT                8   // double fault
+// #define T_COPROC             9   // reserved (not used since 486)
+#define T_TSS                   10  // invalid task switch segment
+#define T_SEGNP                 11  // segment not present
+#define T_STACK                 12  // stack exception
+#define T_GPFLT                 13  // general protection fault
+#define T_PGFLT                 14  // page fault
+// #define T_RES                15  // reserved
+#define T_FPERR                 16  // floating point error
+#define T_ALIGN                 17  // aligment check
+#define T_MCHK                  18  // machine check
+#define T_SIMDERR               19  // SIMD floating point error
+
+/* Hardware IRQ numbers. We receive these as (IRQ_OFFSET + IRQ_xx) */
+#define IRQ_OFFSET              32  // IRQ 0 corresponds to int IRQ_OFFSET
+
+#define IRQ_TIMER               0
+#define IRQ_KBD                 1
+#define IRQ_COM1                4
+#define IRQ_IDE1                14
+#define IRQ_IDE2                15
+#define IRQ_ERROR               19
+#define IRQ_SPURIOUS            31
+
+/* *
+ * These are arbitrarily chosen, but with care not to overlap
+ * processor defined exceptions or interrupt vectors.
+ * */
+#define T_SWITCH_TOU                120    // user/kernel switch
+#define T_SWITCH_TOK                121    // user/kernel switch
+
+/* registers as pushed by pushal */
+struct pushregs {
+    uint32_t reg_edi;
+    uint32_t reg_esi;
+    uint32_t reg_ebp;
+    uint32_t reg_oesp;          /* Useless */
+    uint32_t reg_ebx;
+    uint32_t reg_edx;
+    uint32_t reg_ecx;
+    uint32_t reg_eax;
+};
+
+struct trapframe {
+    struct pushregs tf_regs;
+    uint16_t tf_gs;
+    uint16_t tf_padding0;
+    uint16_t tf_fs;
+    uint16_t tf_padding1;
+    uint16_t tf_es;
+    uint16_t tf_padding2;
+    uint16_t tf_ds;
+    uint16_t tf_padding3;
+    uint32_t tf_trapno;
+    /* below here defined by x86 hardware */
+    uint32_t tf_err;
+    uintptr_t tf_eip;
+    uint16_t tf_cs;
+    uint16_t tf_padding4;
+    uint32_t tf_eflags;
+    /* below here only when crossing rings, such as from user to kernel */
+    uintptr_t tf_esp;
+    uint16_t tf_ss;
+    uint16_t tf_padding5;
+} __attribute__((packed));
+
+void idt_init(void);
+void print_trapframe(struct trapframe *tf);
+void print_regs(struct pushregs *regs);
+bool trap_in_kernel(struct trapframe *tf);
+
+#endif /* !__KERN_TRAP_TRAP_H__ */
+
diff -r -u -P lab6_origin/kern/trap/vectors.S lab6/kern/trap/vectors.S
--- lab6_origin/kern/trap/vectors.S	1970-01-01 08:00:00.000000000 +0800
+++ lab6/kern/trap/vectors.S	2019-02-26 20:51:17.078836300 +0800
@@ -0,0 +1,1537 @@
+# handler
+.text
+.globl __alltraps
+.globl vector0
+vector0:
+  pushl $0
+  pushl $0
+  jmp __alltraps
+.globl vector1
+vector1:
+  pushl $0
+  pushl $1
+  jmp __alltraps
+.globl vector2
+vector2:
+  pushl $0
+  pushl $2
+  jmp __alltraps
+.globl vector3
+vector3:
+  pushl $0
+  pushl $3
+  jmp __alltraps
+.globl vector4
+vector4:
+  pushl $0
+  pushl $4
+  jmp __alltraps
+.globl vector5
+vector5:
+  pushl $0
+  pushl $5
+  jmp __alltraps
+.globl vector6
+vector6:
+  pushl $0
+  pushl $6
+  jmp __alltraps
+.globl vector7
+vector7:
+  pushl $0
+  pushl $7
+  jmp __alltraps
+.globl vector8
+vector8:
+  pushl $8
+  jmp __alltraps
+.globl vector9
+vector9:
+  pushl $0
+  pushl $9
+  jmp __alltraps
+.globl vector10
+vector10:
+  pushl $10
+  jmp __alltraps
+.globl vector11
+vector11:
+  pushl $11
+  jmp __alltraps
+.globl vector12
+vector12:
+  pushl $12
+  jmp __alltraps
+.globl vector13
+vector13:
+  pushl $13
+  jmp __alltraps
+.globl vector14
+vector14:
+  pushl $14
+  jmp __alltraps
+.globl vector15
+vector15:
+  pushl $0
+  pushl $15
+  jmp __alltraps
+.globl vector16
+vector16:
+  pushl $0
+  pushl $16
+  jmp __alltraps
+.globl vector17
+vector17:
+  pushl $17
+  jmp __alltraps
+.globl vector18
+vector18:
+  pushl $0
+  pushl $18
+  jmp __alltraps
+.globl vector19
+vector19:
+  pushl $0
+  pushl $19
+  jmp __alltraps
+.globl vector20
+vector20:
+  pushl $0
+  pushl $20
+  jmp __alltraps
+.globl vector21
+vector21:
+  pushl $0
+  pushl $21
+  jmp __alltraps
+.globl vector22
+vector22:
+  pushl $0
+  pushl $22
+  jmp __alltraps
+.globl vector23
+vector23:
+  pushl $0
+  pushl $23
+  jmp __alltraps
+.globl vector24
+vector24:
+  pushl $0
+  pushl $24
+  jmp __alltraps
+.globl vector25
+vector25:
+  pushl $0
+  pushl $25
+  jmp __alltraps
+.globl vector26
+vector26:
+  pushl $0
+  pushl $26
+  jmp __alltraps
+.globl vector27
+vector27:
+  pushl $0
+  pushl $27
+  jmp __alltraps
+.globl vector28
+vector28:
+  pushl $0
+  pushl $28
+  jmp __alltraps
+.globl vector29
+vector29:
+  pushl $0
+  pushl $29
+  jmp __alltraps
+.globl vector30
+vector30:
+  pushl $0
+  pushl $30
+  jmp __alltraps
+.globl vector31
+vector31:
+  pushl $0
+  pushl $31
+  jmp __alltraps
+.globl vector32
+vector32:
+  pushl $0
+  pushl $32
+  jmp __alltraps
+.globl vector33
+vector33:
+  pushl $0
+  pushl $33
+  jmp __alltraps
+.globl vector34
+vector34:
+  pushl $0
+  pushl $34
+  jmp __alltraps
+.globl vector35
+vector35:
+  pushl $0
+  pushl $35
+  jmp __alltraps
+.globl vector36
+vector36:
+  pushl $0
+  pushl $36
+  jmp __alltraps
+.globl vector37
+vector37:
+  pushl $0
+  pushl $37
+  jmp __alltraps
+.globl vector38
+vector38:
+  pushl $0
+  pushl $38
+  jmp __alltraps
+.globl vector39
+vector39:
+  pushl $0
+  pushl $39
+  jmp __alltraps
+.globl vector40
+vector40:
+  pushl $0
+  pushl $40
+  jmp __alltraps
+.globl vector41
+vector41:
+  pushl $0
+  pushl $41
+  jmp __alltraps
+.globl vector42
+vector42:
+  pushl $0
+  pushl $42
+  jmp __alltraps
+.globl vector43
+vector43:
+  pushl $0
+  pushl $43
+  jmp __alltraps
+.globl vector44
+vector44:
+  pushl $0
+  pushl $44
+  jmp __alltraps
+.globl vector45
+vector45:
+  pushl $0
+  pushl $45
+  jmp __alltraps
+.globl vector46
+vector46:
+  pushl $0
+  pushl $46
+  jmp __alltraps
+.globl vector47
+vector47:
+  pushl $0
+  pushl $47
+  jmp __alltraps
+.globl vector48
+vector48:
+  pushl $0
+  pushl $48
+  jmp __alltraps
+.globl vector49
+vector49:
+  pushl $0
+  pushl $49
+  jmp __alltraps
+.globl vector50
+vector50:
+  pushl $0
+  pushl $50
+  jmp __alltraps
+.globl vector51
+vector51:
+  pushl $0
+  pushl $51
+  jmp __alltraps
+.globl vector52
+vector52:
+  pushl $0
+  pushl $52
+  jmp __alltraps
+.globl vector53
+vector53:
+  pushl $0
+  pushl $53
+  jmp __alltraps
+.globl vector54
+vector54:
+  pushl $0
+  pushl $54
+  jmp __alltraps
+.globl vector55
+vector55:
+  pushl $0
+  pushl $55
+  jmp __alltraps
+.globl vector56
+vector56:
+  pushl $0
+  pushl $56
+  jmp __alltraps
+.globl vector57
+vector57:
+  pushl $0
+  pushl $57
+  jmp __alltraps
+.globl vector58
+vector58:
+  pushl $0
+  pushl $58
+  jmp __alltraps
+.globl vector59
+vector59:
+  pushl $0
+  pushl $59
+  jmp __alltraps
+.globl vector60
+vector60:
+  pushl $0
+  pushl $60
+  jmp __alltraps
+.globl vector61
+vector61:
+  pushl $0
+  pushl $61
+  jmp __alltraps
+.globl vector62
+vector62:
+  pushl $0
+  pushl $62
+  jmp __alltraps
+.globl vector63
+vector63:
+  pushl $0
+  pushl $63
+  jmp __alltraps
+.globl vector64
+vector64:
+  pushl $0
+  pushl $64
+  jmp __alltraps
+.globl vector65
+vector65:
+  pushl $0
+  pushl $65
+  jmp __alltraps
+.globl vector66
+vector66:
+  pushl $0
+  pushl $66
+  jmp __alltraps
+.globl vector67
+vector67:
+  pushl $0
+  pushl $67
+  jmp __alltraps
+.globl vector68
+vector68:
+  pushl $0
+  pushl $68
+  jmp __alltraps
+.globl vector69
+vector69:
+  pushl $0
+  pushl $69
+  jmp __alltraps
+.globl vector70
+vector70:
+  pushl $0
+  pushl $70
+  jmp __alltraps
+.globl vector71
+vector71:
+  pushl $0
+  pushl $71
+  jmp __alltraps
+.globl vector72
+vector72:
+  pushl $0
+  pushl $72
+  jmp __alltraps
+.globl vector73
+vector73:
+  pushl $0
+  pushl $73
+  jmp __alltraps
+.globl vector74
+vector74:
+  pushl $0
+  pushl $74
+  jmp __alltraps
+.globl vector75
+vector75:
+  pushl $0
+  pushl $75
+  jmp __alltraps
+.globl vector76
+vector76:
+  pushl $0
+  pushl $76
+  jmp __alltraps
+.globl vector77
+vector77:
+  pushl $0
+  pushl $77
+  jmp __alltraps
+.globl vector78
+vector78:
+  pushl $0
+  pushl $78
+  jmp __alltraps
+.globl vector79
+vector79:
+  pushl $0
+  pushl $79
+  jmp __alltraps
+.globl vector80
+vector80:
+  pushl $0
+  pushl $80
+  jmp __alltraps
+.globl vector81
+vector81:
+  pushl $0
+  pushl $81
+  jmp __alltraps
+.globl vector82
+vector82:
+  pushl $0
+  pushl $82
+  jmp __alltraps
+.globl vector83
+vector83:
+  pushl $0
+  pushl $83
+  jmp __alltraps
+.globl vector84
+vector84:
+  pushl $0
+  pushl $84
+  jmp __alltraps
+.globl vector85
+vector85:
+  pushl $0
+  pushl $85
+  jmp __alltraps
+.globl vector86
+vector86:
+  pushl $0
+  pushl $86
+  jmp __alltraps
+.globl vector87
+vector87:
+  pushl $0
+  pushl $87
+  jmp __alltraps
+.globl vector88
+vector88:
+  pushl $0
+  pushl $88
+  jmp __alltraps
+.globl vector89
+vector89:
+  pushl $0
+  pushl $89
+  jmp __alltraps
+.globl vector90
+vector90:
+  pushl $0
+  pushl $90
+  jmp __alltraps
+.globl vector91
+vector91:
+  pushl $0
+  pushl $91
+  jmp __alltraps
+.globl vector92
+vector92:
+  pushl $0
+  pushl $92
+  jmp __alltraps
+.globl vector93
+vector93:
+  pushl $0
+  pushl $93
+  jmp __alltraps
+.globl vector94
+vector94:
+  pushl $0
+  pushl $94
+  jmp __alltraps
+.globl vector95
+vector95:
+  pushl $0
+  pushl $95
+  jmp __alltraps
+.globl vector96
+vector96:
+  pushl $0
+  pushl $96
+  jmp __alltraps
+.globl vector97
+vector97:
+  pushl $0
+  pushl $97
+  jmp __alltraps
+.globl vector98
+vector98:
+  pushl $0
+  pushl $98
+  jmp __alltraps
+.globl vector99
+vector99:
+  pushl $0
+  pushl $99
+  jmp __alltraps
+.globl vector100
+vector100:
+  pushl $0
+  pushl $100
+  jmp __alltraps
+.globl vector101
+vector101:
+  pushl $0
+  pushl $101
+  jmp __alltraps
+.globl vector102
+vector102:
+  pushl $0
+  pushl $102
+  jmp __alltraps
+.globl vector103
+vector103:
+  pushl $0
+  pushl $103
+  jmp __alltraps
+.globl vector104
+vector104:
+  pushl $0
+  pushl $104
+  jmp __alltraps
+.globl vector105
+vector105:
+  pushl $0
+  pushl $105
+  jmp __alltraps
+.globl vector106
+vector106:
+  pushl $0
+  pushl $106
+  jmp __alltraps
+.globl vector107
+vector107:
+  pushl $0
+  pushl $107
+  jmp __alltraps
+.globl vector108
+vector108:
+  pushl $0
+  pushl $108
+  jmp __alltraps
+.globl vector109
+vector109:
+  pushl $0
+  pushl $109
+  jmp __alltraps
+.globl vector110
+vector110:
+  pushl $0
+  pushl $110
+  jmp __alltraps
+.globl vector111
+vector111:
+  pushl $0
+  pushl $111
+  jmp __alltraps
+.globl vector112
+vector112:
+  pushl $0
+  pushl $112
+  jmp __alltraps
+.globl vector113
+vector113:
+  pushl $0
+  pushl $113
+  jmp __alltraps
+.globl vector114
+vector114:
+  pushl $0
+  pushl $114
+  jmp __alltraps
+.globl vector115
+vector115:
+  pushl $0
+  pushl $115
+  jmp __alltraps
+.globl vector116
+vector116:
+  pushl $0
+  pushl $116
+  jmp __alltraps
+.globl vector117
+vector117:
+  pushl $0
+  pushl $117
+  jmp __alltraps
+.globl vector118
+vector118:
+  pushl $0
+  pushl $118
+  jmp __alltraps
+.globl vector119
+vector119:
+  pushl $0
+  pushl $119
+  jmp __alltraps
+.globl vector120
+vector120:
+  pushl $0
+  pushl $120
+  jmp __alltraps
+.globl vector121
+vector121:
+  pushl $0
+  pushl $121
+  jmp __alltraps
+.globl vector122
+vector122:
+  pushl $0
+  pushl $122
+  jmp __alltraps
+.globl vector123
+vector123:
+  pushl $0
+  pushl $123
+  jmp __alltraps
+.globl vector124
+vector124:
+  pushl $0
+  pushl $124
+  jmp __alltraps
+.globl vector125
+vector125:
+  pushl $0
+  pushl $125
+  jmp __alltraps
+.globl vector126
+vector126:
+  pushl $0
+  pushl $126
+  jmp __alltraps
+.globl vector127
+vector127:
+  pushl $0
+  pushl $127
+  jmp __alltraps
+.globl vector128
+vector128:
+  pushl $0
+  pushl $128
+  jmp __alltraps
+.globl vector129
+vector129:
+  pushl $0
+  pushl $129
+  jmp __alltraps
+.globl vector130
+vector130:
+  pushl $0
+  pushl $130
+  jmp __alltraps
+.globl vector131
+vector131:
+  pushl $0
+  pushl $131
+  jmp __alltraps
+.globl vector132
+vector132:
+  pushl $0
+  pushl $132
+  jmp __alltraps
+.globl vector133
+vector133:
+  pushl $0
+  pushl $133
+  jmp __alltraps
+.globl vector134
+vector134:
+  pushl $0
+  pushl $134
+  jmp __alltraps
+.globl vector135
+vector135:
+  pushl $0
+  pushl $135
+  jmp __alltraps
+.globl vector136
+vector136:
+  pushl $0
+  pushl $136
+  jmp __alltraps
+.globl vector137
+vector137:
+  pushl $0
+  pushl $137
+  jmp __alltraps
+.globl vector138
+vector138:
+  pushl $0
+  pushl $138
+  jmp __alltraps
+.globl vector139
+vector139:
+  pushl $0
+  pushl $139
+  jmp __alltraps
+.globl vector140
+vector140:
+  pushl $0
+  pushl $140
+  jmp __alltraps
+.globl vector141
+vector141:
+  pushl $0
+  pushl $141
+  jmp __alltraps
+.globl vector142
+vector142:
+  pushl $0
+  pushl $142
+  jmp __alltraps
+.globl vector143
+vector143:
+  pushl $0
+  pushl $143
+  jmp __alltraps
+.globl vector144
+vector144:
+  pushl $0
+  pushl $144
+  jmp __alltraps
+.globl vector145
+vector145:
+  pushl $0
+  pushl $145
+  jmp __alltraps
+.globl vector146
+vector146:
+  pushl $0
+  pushl $146
+  jmp __alltraps
+.globl vector147
+vector147:
+  pushl $0
+  pushl $147
+  jmp __alltraps
+.globl vector148
+vector148:
+  pushl $0
+  pushl $148
+  jmp __alltraps
+.globl vector149
+vector149:
+  pushl $0
+  pushl $149
+  jmp __alltraps
+.globl vector150
+vector150:
+  pushl $0
+  pushl $150
+  jmp __alltraps
+.globl vector151
+vector151:
+  pushl $0
+  pushl $151
+  jmp __alltraps
+.globl vector152
+vector152:
+  pushl $0
+  pushl $152
+  jmp __alltraps
+.globl vector153
+vector153:
+  pushl $0
+  pushl $153
+  jmp __alltraps
+.globl vector154
+vector154:
+  pushl $0
+  pushl $154
+  jmp __alltraps
+.globl vector155
+vector155:
+  pushl $0
+  pushl $155
+  jmp __alltraps
+.globl vector156
+vector156:
+  pushl $0
+  pushl $156
+  jmp __alltraps
+.globl vector157
+vector157:
+  pushl $0
+  pushl $157
+  jmp __alltraps
+.globl vector158
+vector158:
+  pushl $0
+  pushl $158
+  jmp __alltraps
+.globl vector159
+vector159:
+  pushl $0
+  pushl $159
+  jmp __alltraps
+.globl vector160
+vector160:
+  pushl $0
+  pushl $160
+  jmp __alltraps
+.globl vector161
+vector161:
+  pushl $0
+  pushl $161
+  jmp __alltraps
+.globl vector162
+vector162:
+  pushl $0
+  pushl $162
+  jmp __alltraps
+.globl vector163
+vector163:
+  pushl $0
+  pushl $163
+  jmp __alltraps
+.globl vector164
+vector164:
+  pushl $0
+  pushl $164
+  jmp __alltraps
+.globl vector165
+vector165:
+  pushl $0
+  pushl $165
+  jmp __alltraps
+.globl vector166
+vector166:
+  pushl $0
+  pushl $166
+  jmp __alltraps
+.globl vector167
+vector167:
+  pushl $0
+  pushl $167
+  jmp __alltraps
+.globl vector168
+vector168:
+  pushl $0
+  pushl $168
+  jmp __alltraps
+.globl vector169
+vector169:
+  pushl $0
+  pushl $169
+  jmp __alltraps
+.globl vector170
+vector170:
+  pushl $0
+  pushl $170
+  jmp __alltraps
+.globl vector171
+vector171:
+  pushl $0
+  pushl $171
+  jmp __alltraps
+.globl vector172
+vector172:
+  pushl $0
+  pushl $172
+  jmp __alltraps
+.globl vector173
+vector173:
+  pushl $0
+  pushl $173
+  jmp __alltraps
+.globl vector174
+vector174:
+  pushl $0
+  pushl $174
+  jmp __alltraps
+.globl vector175
+vector175:
+  pushl $0
+  pushl $175
+  jmp __alltraps
+.globl vector176
+vector176:
+  pushl $0
+  pushl $176
+  jmp __alltraps
+.globl vector177
+vector177:
+  pushl $0
+  pushl $177
+  jmp __alltraps
+.globl vector178
+vector178:
+  pushl $0
+  pushl $178
+  jmp __alltraps
+.globl vector179
+vector179:
+  pushl $0
+  pushl $179
+  jmp __alltraps
+.globl vector180
+vector180:
+  pushl $0
+  pushl $180
+  jmp __alltraps
+.globl vector181
+vector181:
+  pushl $0
+  pushl $181
+  jmp __alltraps
+.globl vector182
+vector182:
+  pushl $0
+  pushl $182
+  jmp __alltraps
+.globl vector183
+vector183:
+  pushl $0
+  pushl $183
+  jmp __alltraps
+.globl vector184
+vector184:
+  pushl $0
+  pushl $184
+  jmp __alltraps
+.globl vector185
+vector185:
+  pushl $0
+  pushl $185
+  jmp __alltraps
+.globl vector186
+vector186:
+  pushl $0
+  pushl $186
+  jmp __alltraps
+.globl vector187
+vector187:
+  pushl $0
+  pushl $187
+  jmp __alltraps
+.globl vector188
+vector188:
+  pushl $0
+  pushl $188
+  jmp __alltraps
+.globl vector189
+vector189:
+  pushl $0
+  pushl $189
+  jmp __alltraps
+.globl vector190
+vector190:
+  pushl $0
+  pushl $190
+  jmp __alltraps
+.globl vector191
+vector191:
+  pushl $0
+  pushl $191
+  jmp __alltraps
+.globl vector192
+vector192:
+  pushl $0
+  pushl $192
+  jmp __alltraps
+.globl vector193
+vector193:
+  pushl $0
+  pushl $193
+  jmp __alltraps
+.globl vector194
+vector194:
+  pushl $0
+  pushl $194
+  jmp __alltraps
+.globl vector195
+vector195:
+  pushl $0
+  pushl $195
+  jmp __alltraps
+.globl vector196
+vector196:
+  pushl $0
+  pushl $196
+  jmp __alltraps
+.globl vector197
+vector197:
+  pushl $0
+  pushl $197
+  jmp __alltraps
+.globl vector198
+vector198:
+  pushl $0
+  pushl $198
+  jmp __alltraps
+.globl vector199
+vector199:
+  pushl $0
+  pushl $199
+  jmp __alltraps
+.globl vector200
+vector200:
+  pushl $0
+  pushl $200
+  jmp __alltraps
+.globl vector201
+vector201:
+  pushl $0
+  pushl $201
+  jmp __alltraps
+.globl vector202
+vector202:
+  pushl $0
+  pushl $202
+  jmp __alltraps
+.globl vector203
+vector203:
+  pushl $0
+  pushl $203
+  jmp __alltraps
+.globl vector204
+vector204:
+  pushl $0
+  pushl $204
+  jmp __alltraps
+.globl vector205
+vector205:
+  pushl $0
+  pushl $205
+  jmp __alltraps
+.globl vector206
+vector206:
+  pushl $0
+  pushl $206
+  jmp __alltraps
+.globl vector207
+vector207:
+  pushl $0
+  pushl $207
+  jmp __alltraps
+.globl vector208
+vector208:
+  pushl $0
+  pushl $208
+  jmp __alltraps
+.globl vector209
+vector209:
+  pushl $0
+  pushl $209
+  jmp __alltraps
+.globl vector210
+vector210:
+  pushl $0
+  pushl $210
+  jmp __alltraps
+.globl vector211
+vector211:
+  pushl $0
+  pushl $211
+  jmp __alltraps
+.globl vector212
+vector212:
+  pushl $0
+  pushl $212
+  jmp __alltraps
+.globl vector213
+vector213:
+  pushl $0
+  pushl $213
+  jmp __alltraps
+.globl vector214
+vector214:
+  pushl $0
+  pushl $214
+  jmp __alltraps
+.globl vector215
+vector215:
+  pushl $0
+  pushl $215
+  jmp __alltraps
+.globl vector216
+vector216:
+  pushl $0
+  pushl $216
+  jmp __alltraps
+.globl vector217
+vector217:
+  pushl $0
+  pushl $217
+  jmp __alltraps
+.globl vector218
+vector218:
+  pushl $0
+  pushl $218
+  jmp __alltraps
+.globl vector219
+vector219:
+  pushl $0
+  pushl $219
+  jmp __alltraps
+.globl vector220
+vector220:
+  pushl $0
+  pushl $220
+  jmp __alltraps
+.globl vector221
+vector221:
+  pushl $0
+  pushl $221
+  jmp __alltraps
+.globl vector222
+vector222:
+  pushl $0
+  pushl $222
+  jmp __alltraps
+.globl vector223
+vector223:
+  pushl $0
+  pushl $223
+  jmp __alltraps
+.globl vector224
+vector224:
+  pushl $0
+  pushl $224
+  jmp __alltraps
+.globl vector225
+vector225:
+  pushl $0
+  pushl $225
+  jmp __alltraps
+.globl vector226
+vector226:
+  pushl $0
+  pushl $226
+  jmp __alltraps
+.globl vector227
+vector227:
+  pushl $0
+  pushl $227
+  jmp __alltraps
+.globl vector228
+vector228:
+  pushl $0
+  pushl $228
+  jmp __alltraps
+.globl vector229
+vector229:
+  pushl $0
+  pushl $229
+  jmp __alltraps
+.globl vector230
+vector230:
+  pushl $0
+  pushl $230
+  jmp __alltraps
+.globl vector231
+vector231:
+  pushl $0
+  pushl $231
+  jmp __alltraps
+.globl vector232
+vector232:
+  pushl $0
+  pushl $232
+  jmp __alltraps
+.globl vector233
+vector233:
+  pushl $0
+  pushl $233
+  jmp __alltraps
+.globl vector234
+vector234:
+  pushl $0
+  pushl $234
+  jmp __alltraps
+.globl vector235
+vector235:
+  pushl $0
+  pushl $235
+  jmp __alltraps
+.globl vector236
+vector236:
+  pushl $0
+  pushl $236
+  jmp __alltraps
+.globl vector237
+vector237:
+  pushl $0
+  pushl $237
+  jmp __alltraps
+.globl vector238
+vector238:
+  pushl $0
+  pushl $238
+  jmp __alltraps
+.globl vector239
+vector239:
+  pushl $0
+  pushl $239
+  jmp __alltraps
+.globl vector240
+vector240:
+  pushl $0
+  pushl $240
+  jmp __alltraps
+.globl vector241
+vector241:
+  pushl $0
+  pushl $241
+  jmp __alltraps
+.globl vector242
+vector242:
+  pushl $0
+  pushl $242
+  jmp __alltraps
+.globl vector243
+vector243:
+  pushl $0
+  pushl $243
+  jmp __alltraps
+.globl vector244
+vector244:
+  pushl $0
+  pushl $244
+  jmp __alltraps
+.globl vector245
+vector245:
+  pushl $0
+  pushl $245
+  jmp __alltraps
+.globl vector246
+vector246:
+  pushl $0
+  pushl $246
+  jmp __alltraps
+.globl vector247
+vector247:
+  pushl $0
+  pushl $247
+  jmp __alltraps
+.globl vector248
+vector248:
+  pushl $0
+  pushl $248
+  jmp __alltraps
+.globl vector249
+vector249:
+  pushl $0
+  pushl $249
+  jmp __alltraps
+.globl vector250
+vector250:
+  pushl $0
+  pushl $250
+  jmp __alltraps
+.globl vector251
+vector251:
+  pushl $0
+  pushl $251
+  jmp __alltraps
+.globl vector252
+vector252:
+  pushl $0
+  pushl $252
+  jmp __alltraps
+.globl vector253
+vector253:
+  pushl $0
+  pushl $253
+  jmp __alltraps
+.globl vector254
+vector254:
+  pushl $0
+  pushl $254
+  jmp __alltraps
+.globl vector255
+vector255:
+  pushl $0
+  pushl $255
+  jmp __alltraps
+
+# vector table
+.data
+.globl __vectors
+__vectors:
+  .long vector0
+  .long vector1
+  .long vector2
+  .long vector3
+  .long vector4
+  .long vector5
+  .long vector6
+  .long vector7
+  .long vector8
+  .long vector9
+  .long vector10
+  .long vector11
+  .long vector12
+  .long vector13
+  .long vector14
+  .long vector15
+  .long vector16
+  .long vector17
+  .long vector18
+  .long vector19
+  .long vector20
+  .long vector21
+  .long vector22
+  .long vector23
+  .long vector24
+  .long vector25
+  .long vector26
+  .long vector27
+  .long vector28
+  .long vector29
+  .long vector30
+  .long vector31
+  .long vector32
+  .long vector33
+  .long vector34
+  .long vector35
+  .long vector36
+  .long vector37
+  .long vector38
+  .long vector39
+  .long vector40
+  .long vector41
+  .long vector42
+  .long vector43
+  .long vector44
+  .long vector45
+  .long vector46
+  .long vector47
+  .long vector48
+  .long vector49
+  .long vector50
+  .long vector51
+  .long vector52
+  .long vector53
+  .long vector54
+  .long vector55
+  .long vector56
+  .long vector57
+  .long vector58
+  .long vector59
+  .long vector60
+  .long vector61
+  .long vector62
+  .long vector63
+  .long vector64
+  .long vector65
+  .long vector66
+  .long vector67
+  .long vector68
+  .long vector69
+  .long vector70
+  .long vector71
+  .long vector72
+  .long vector73
+  .long vector74
+  .long vector75
+  .long vector76
+  .long vector77
+  .long vector78
+  .long vector79
+  .long vector80
+  .long vector81
+  .long vector82
+  .long vector83
+  .long vector84
+  .long vector85
+  .long vector86
+  .long vector87
+  .long vector88
+  .long vector89
+  .long vector90
+  .long vector91
+  .long vector92
+  .long vector93
+  .long vector94
+  .long vector95
+  .long vector96
+  .long vector97
+  .long vector98
+  .long vector99
+  .long vector100
+  .long vector101
+  .long vector102
+  .long vector103
+  .long vector104
+  .long vector105
+  .long vector106
+  .long vector107
+  .long vector108
+  .long vector109
+  .long vector110
+  .long vector111
+  .long vector112
+  .long vector113
+  .long vector114
+  .long vector115
+  .long vector116
+  .long vector117
+  .long vector118
+  .long vector119
+  .long vector120
+  .long vector121
+  .long vector122
+  .long vector123
+  .long vector124
+  .long vector125
+  .long vector126
+  .long vector127
+  .long vector128
+  .long vector129
+  .long vector130
+  .long vector131
+  .long vector132
+  .long vector133
+  .long vector134
+  .long vector135
+  .long vector136
+  .long vector137
+  .long vector138
+  .long vector139
+  .long vector140
+  .long vector141
+  .long vector142
+  .long vector143
+  .long vector144
+  .long vector145
+  .long vector146
+  .long vector147
+  .long vector148
+  .long vector149
+  .long vector150
+  .long vector151
+  .long vector152
+  .long vector153
+  .long vector154
+  .long vector155
+  .long vector156
+  .long vector157
+  .long vector158
+  .long vector159
+  .long vector160
+  .long vector161
+  .long vector162
+  .long vector163
+  .long vector164
+  .long vector165
+  .long vector166
+  .long vector167
+  .long vector168
+  .long vector169
+  .long vector170
+  .long vector171
+  .long vector172
+  .long vector173
+  .long vector174
+  .long vector175
+  .long vector176
+  .long vector177
+  .long vector178
+  .long vector179
+  .long vector180
+  .long vector181
+  .long vector182
+  .long vector183
+  .long vector184
+  .long vector185
+  .long vector186
+  .long vector187
+  .long vector188
+  .long vector189
+  .long vector190
+  .long vector191
+  .long vector192
+  .long vector193
+  .long vector194
+  .long vector195
+  .long vector196
+  .long vector197
+  .long vector198
+  .long vector199
+  .long vector200
+  .long vector201
+  .long vector202
+  .long vector203
+  .long vector204
+  .long vector205
+  .long vector206
+  .long vector207
+  .long vector208
+  .long vector209
+  .long vector210
+  .long vector211
+  .long vector212
+  .long vector213
+  .long vector214
+  .long vector215
+  .long vector216
+  .long vector217
+  .long vector218
+  .long vector219
+  .long vector220
+  .long vector221
+  .long vector222
+  .long vector223
+  .long vector224
+  .long vector225
+  .long vector226
+  .long vector227
+  .long vector228
+  .long vector229
+  .long vector230
+  .long vector231
+  .long vector232
+  .long vector233
+  .long vector234
+  .long vector235
+  .long vector236
+  .long vector237
+  .long vector238
+  .long vector239
+  .long vector240
+  .long vector241
+  .long vector242
+  .long vector243
+  .long vector244
+  .long vector245
+  .long vector246
+  .long vector247
+  .long vector248
+  .long vector249
+  .long vector250
+  .long vector251
+  .long vector252
+  .long vector253
+  .long vector254
+  .long vector255
diff -r -u -P lab6_origin/libs/atomic.h lab6/libs/atomic.h
--- lab6_origin/libs/atomic.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/libs/atomic.h	2019-02-26 20:51:17.080835000 +0800
@@ -0,0 +1,81 @@
+#ifndef __LIBS_ATOMIC_H__
+#define __LIBS_ATOMIC_H__
+
+/* Atomic operations that C can't guarantee us. Useful for resource counting etc.. */
+
+static inline void set_bit(int nr, volatile void *addr) __attribute__((always_inline));
+static inline void clear_bit(int nr, volatile void *addr) __attribute__((always_inline));
+static inline void change_bit(int nr, volatile void *addr) __attribute__((always_inline));
+static inline bool test_bit(int nr, volatile void *addr) __attribute__((always_inline));
+
+/* *
+ * set_bit - Atomically set a bit in memory
+ * @nr:     the bit to set
+ * @addr:   the address to start counting from
+ *
+ * Note that @nr may be almost arbitrarily large; this function is not
+ * restricted to acting on a single-word quantity.
+ * */
+static inline void
+set_bit(int nr, volatile void *addr) {
+    asm volatile ("btsl %1, %0" :"=m" (*(volatile long *)addr) : "Ir" (nr));
+}
+
+/* *
+ * clear_bit - Atomically clears a bit in memory
+ * @nr:     the bit to clear
+ * @addr:   the address to start counting from
+ * */
+static inline void
+clear_bit(int nr, volatile void *addr) {
+    asm volatile ("btrl %1, %0" :"=m" (*(volatile long *)addr) : "Ir" (nr));
+}
+
+/* *
+ * change_bit - Atomically toggle a bit in memory
+ * @nr:     the bit to change
+ * @addr:   the address to start counting from
+ * */
+static inline void
+change_bit(int nr, volatile void *addr) {
+    asm volatile ("btcl %1, %0" :"=m" (*(volatile long *)addr) : "Ir" (nr));
+}
+
+/* *
+ * test_bit - Determine whether a bit is set
+ * @nr:     the bit to test
+ * @addr:   the address to count from
+ * */
+static inline bool
+test_bit(int nr, volatile void *addr) {
+    int oldbit;
+    asm volatile ("btl %2, %1; sbbl %0,%0" : "=r" (oldbit) : "m" (*(volatile long *)addr), "Ir" (nr));
+    return oldbit != 0;
+}
+
+/* *
+ * test_and_set_bit - Atomically set a bit and return its old value
+ * @nr:     the bit to set
+ * @addr:   the address to count from
+ * */
+static inline bool
+test_and_set_bit(int nr, volatile void *addr) {
+    int oldbit;
+    asm volatile ("btsl %2, %1; sbbl %0, %0" : "=r" (oldbit), "=m" (*(volatile long *)addr) : "Ir" (nr) : "memory");
+    return oldbit != 0;
+}
+
+/* *
+ * test_and_clear_bit - Atomically clear a bit and return its old value
+ * @nr:     the bit to clear
+ * @addr:   the address to count from
+ * */
+static inline bool
+test_and_clear_bit(int nr, volatile void *addr) {
+    int oldbit;
+    asm volatile ("btrl %2, %1; sbbl %0, %0" : "=r" (oldbit), "=m" (*(volatile long *)addr) : "Ir" (nr) : "memory");
+    return oldbit != 0;
+}
+
+#endif /* !__LIBS_ATOMIC_H__ */
+
diff -r -u -P lab6_origin/libs/defs.h lab6/libs/defs.h
--- lab6_origin/libs/defs.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/libs/defs.h	2019-02-26 20:51:17.081331300 +0800
@@ -0,0 +1,68 @@
+#ifndef __LIBS_DEFS_H__
+#define __LIBS_DEFS_H__
+
+#ifndef NULL
+#define NULL ((void *)0)
+#endif
+
+#define __always_inline inline __attribute__((always_inline))
+#define __noinline __attribute__((noinline))
+#define __noreturn __attribute__((noreturn))
+
+/* Represents true-or-false values */
+typedef int bool;
+
+/* Explicitly-sized versions of integer types */
+typedef char int8_t;
+typedef unsigned char uint8_t;
+typedef short int16_t;
+typedef unsigned short uint16_t;
+typedef int int32_t;
+typedef unsigned int uint32_t;
+typedef long long int64_t;
+typedef unsigned long long uint64_t;
+
+/* *
+ * Pointers and addresses are 32 bits long.
+ * We use pointer types to represent addresses,
+ * uintptr_t to represent the numerical values of addresses.
+ * */
+typedef int32_t intptr_t;
+typedef uint32_t uintptr_t;
+
+/* size_t is used for memory object sizes */
+typedef uintptr_t size_t;
+
+/* used for page numbers */
+typedef size_t ppn_t;
+
+/* *
+ * Rounding operations (efficient when n is a power of 2)
+ * Round down to the nearest multiple of n
+ * */
+#define ROUNDDOWN(a, n) ({                                          \
+            size_t __a = (size_t)(a);                               \
+            (typeof(a))(__a - __a % (n));                           \
+        })
+
+/* Round up to the nearest multiple of n */
+#define ROUNDUP(a, n) ({                                            \
+            size_t __n = (size_t)(n);                               \
+            (typeof(a))(ROUNDDOWN((size_t)(a) + __n - 1, __n));     \
+        })
+
+/* Return the offset of 'member' relative to the beginning of a struct type */
+#define offsetof(type, member)                                      \
+    ((size_t)(&((type *)0)->member))
+
+/* *
+ * to_struct - get the struct from a ptr
+ * @ptr:    a struct pointer of member
+ * @type:   the type of the struct this is embedded in
+ * @member: the name of the member within the struct
+ * */
+#define to_struct(ptr, type, member)                               \
+    ((type *)((char *)(ptr) - offsetof(type, member)))
+
+#endif /* !__LIBS_DEFS_H__ */
+
diff -r -u -P lab6_origin/libs/elf.h lab6/libs/elf.h
--- lab6_origin/libs/elf.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/libs/elf.h	2019-02-26 20:51:17.081831100 +0800
@@ -0,0 +1,48 @@
+#ifndef __LIBS_ELF_H__
+#define __LIBS_ELF_H__
+
+#include <defs.h>
+
+#define ELF_MAGIC   0x464C457FU         // "\x7FELF" in little endian
+
+/* file header */
+struct elfhdr {
+    uint32_t e_magic;     // must equal ELF_MAGIC
+    uint8_t e_elf[12];
+    uint16_t e_type;      // 1=relocatable, 2=executable, 3=shared object, 4=core image
+    uint16_t e_machine;   // 3=x86, 4=68K, etc.
+    uint32_t e_version;   // file version, always 1
+    uint32_t e_entry;     // entry point if executable
+    uint32_t e_phoff;     // file position of program header or 0
+    uint32_t e_shoff;     // file position of section header or 0
+    uint32_t e_flags;     // architecture-specific flags, usually 0
+    uint16_t e_ehsize;    // size of this elf header
+    uint16_t e_phentsize; // size of an entry in program header
+    uint16_t e_phnum;     // number of entries in program header or 0
+    uint16_t e_shentsize; // size of an entry in section header
+    uint16_t e_shnum;     // number of entries in section header or 0
+    uint16_t e_shstrndx;  // section number that contains section name strings
+};
+
+/* program section header */
+struct proghdr {
+    uint32_t p_type;   // loadable code or data, dynamic linking info,etc.
+    uint32_t p_offset; // file offset of segment
+    uint32_t p_va;     // virtual address to map segment
+    uint32_t p_pa;     // physical address, not used
+    uint32_t p_filesz; // size of segment in file
+    uint32_t p_memsz;  // size of segment in memory (bigger if contains bss）
+    uint32_t p_flags;  // read/write/execute bits
+    uint32_t p_align;  // required alignment, invariably hardware page size
+};
+
+/* values for Proghdr::p_type */
+#define ELF_PT_LOAD                     1
+
+/* flag bits for Proghdr::p_flags */
+#define ELF_PF_X                        1
+#define ELF_PF_W                        2
+#define ELF_PF_R                        4
+
+#endif /* !__LIBS_ELF_H__ */
+
diff -r -u -P lab6_origin/libs/error.h lab6/libs/error.h
--- lab6_origin/libs/error.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/libs/error.h	2019-02-26 20:51:17.082828900 +0800
@@ -0,0 +1,33 @@
+#ifndef __LIBS_ERROR_H__
+#define __LIBS_ERROR_H__
+
+/* kernel error codes -- keep in sync with list in lib/printfmt.c */
+#define E_UNSPECIFIED       1   // Unspecified or unknown problem
+#define E_BAD_PROC          2   // Process doesn't exist or otherwise
+#define E_INVAL             3   // Invalid parameter
+#define E_NO_MEM            4   // Request failed due to memory shortage
+#define E_NO_FREE_PROC      5   // Attempt to create a new process beyond
+#define E_FAULT             6   // Memory fault
+#define E_SWAP_FAULT        7   // SWAP READ/WRITE fault
+#define E_INVAL_ELF         8   // Invalid elf file
+#define E_KILLED            9   // Process is killed
+#define E_PANIC             10  // Panic Failure
+#define E_TIMEOUT           11  // Timeout
+#define E_TOO_BIG           12  // Argument is Too Big
+#define E_NO_DEV            13  // No such Device
+#define E_NA_DEV            14  // Device Not Available
+#define E_BUSY              15  // Device/File is Busy
+#define E_NOENT             16  // No Such File or Directory
+#define E_ISDIR             17  // Is a Directory
+#define E_NOTDIR            18  // Not a Directory
+#define E_XDEV              19  // Cross Device-Link
+#define E_UNIMP             20  // Unimplemented Feature
+#define E_SEEK              21  // Illegal Seek
+#define E_MAX_OPEN          22  // Too Many Files are Open
+#define E_EXISTS            23  // File/Directory Already Exists
+#define E_NOTEMPTY          24  // Directory is Not Empty
+/* the maximum allowed */
+#define MAXERROR            24
+
+#endif /* !__LIBS_ERROR_H__ */
+
diff -r -u -P lab6_origin/libs/hash.c lab6/libs/hash.c
--- lab6_origin/libs/hash.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/libs/hash.c	2019-02-26 20:51:17.083327800 +0800
@@ -0,0 +1,18 @@
+#include <stdlib.h>
+
+/* 2^31 + 2^29 - 2^25 + 2^22 - 2^19 - 2^16 + 1 */
+#define GOLDEN_RATIO_PRIME_32       0x9e370001UL
+
+/* *
+ * hash32 - generate a hash value in the range [0, 2^@bits - 1]
+ * @val:    the input value
+ * @bits:   the number of bits in a return value
+ *
+ * High bits are more random, so we use them.
+ * */
+uint32_t
+hash32(uint32_t val, unsigned int bits) {
+    uint32_t hash = val * GOLDEN_RATIO_PRIME_32;
+    return (hash >> (32 - bits));
+}
+
diff -r -u -P lab6_origin/libs/list.h lab6/libs/list.h
--- lab6_origin/libs/list.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/libs/list.h	2019-02-26 20:51:17.084326900 +0800
@@ -0,0 +1,163 @@
+#ifndef __LIBS_LIST_H__
+#define __LIBS_LIST_H__
+
+#ifndef __ASSEMBLER__
+
+#include <defs.h>
+
+/* *
+ * Simple doubly linked list implementation.
+ *
+ * Some of the internal functions ("__xxx") are useful when manipulating
+ * whole lists rather than single entries, as sometimes we already know
+ * the next/prev entries and we can generate better code by using them
+ * directly rather than using the generic single-entry routines.
+ * */
+
+struct list_entry {
+    struct list_entry *prev, *next;
+};
+
+typedef struct list_entry list_entry_t;
+
+static inline void list_init(list_entry_t *elm) __attribute__((always_inline));
+static inline void list_add(list_entry_t *listelm, list_entry_t *elm) __attribute__((always_inline));
+static inline void list_add_before(list_entry_t *listelm, list_entry_t *elm) __attribute__((always_inline));
+static inline void list_add_after(list_entry_t *listelm, list_entry_t *elm) __attribute__((always_inline));
+static inline void list_del(list_entry_t *listelm) __attribute__((always_inline));
+static inline void list_del_init(list_entry_t *listelm) __attribute__((always_inline));
+static inline bool list_empty(list_entry_t *list) __attribute__((always_inline));
+static inline list_entry_t *list_next(list_entry_t *listelm) __attribute__((always_inline));
+static inline list_entry_t *list_prev(list_entry_t *listelm) __attribute__((always_inline));
+
+static inline void __list_add(list_entry_t *elm, list_entry_t *prev, list_entry_t *next) __attribute__((always_inline));
+static inline void __list_del(list_entry_t *prev, list_entry_t *next) __attribute__((always_inline));
+
+/* *
+ * list_init - initialize a new entry
+ * @elm:        new entry to be initialized
+ * */
+static inline void
+list_init(list_entry_t *elm) {
+    elm->prev = elm->next = elm;
+}
+
+/* *
+ * list_add - add a new entry
+ * @listelm:    list head to add after
+ * @elm:        new entry to be added
+ *
+ * Insert the new element @elm *after* the element @listelm which
+ * is already in the list.
+ * */
+static inline void
+list_add(list_entry_t *listelm, list_entry_t *elm) {
+    list_add_after(listelm, elm);
+}
+
+/* *
+ * list_add_before - add a new entry
+ * @listelm:    list head to add before
+ * @elm:        new entry to be added
+ *
+ * Insert the new element @elm *before* the element @listelm which
+ * is already in the list.
+ * */
+static inline void
+list_add_before(list_entry_t *listelm, list_entry_t *elm) {
+    __list_add(elm, listelm->prev, listelm);
+}
+
+/* *
+ * list_add_after - add a new entry
+ * @listelm:    list head to add after
+ * @elm:        new entry to be added
+ *
+ * Insert the new element @elm *after* the element @listelm which
+ * is already in the list.
+ * */
+static inline void
+list_add_after(list_entry_t *listelm, list_entry_t *elm) {
+    __list_add(elm, listelm, listelm->next);
+}
+
+/* *
+ * list_del - deletes entry from list
+ * @listelm:    the element to delete from the list
+ *
+ * Note: list_empty() on @listelm does not return true after this, the entry is
+ * in an undefined state.
+ * */
+static inline void
+list_del(list_entry_t *listelm) {
+    __list_del(listelm->prev, listelm->next);
+}
+
+/* *
+ * list_del_init - deletes entry from list and reinitialize it.
+ * @listelm:    the element to delete from the list.
+ *
+ * Note: list_empty() on @listelm returns true after this.
+ * */
+static inline void
+list_del_init(list_entry_t *listelm) {
+    list_del(listelm);
+    list_init(listelm);
+}
+
+/* *
+ * list_empty - tests whether a list is empty
+ * @list:       the list to test.
+ * */
+static inline bool
+list_empty(list_entry_t *list) {
+    return list->next == list;
+}
+
+/* *
+ * list_next - get the next entry
+ * @listelm:    the list head
+ **/
+static inline list_entry_t *
+list_next(list_entry_t *listelm) {
+    return listelm->next;
+}
+
+/* *
+ * list_prev - get the previous entry
+ * @listelm:    the list head
+ **/
+static inline list_entry_t *
+list_prev(list_entry_t *listelm) {
+    return listelm->prev;
+}
+
+/* *
+ * Insert a new entry between two known consecutive entries.
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ * */
+static inline void
+__list_add(list_entry_t *elm, list_entry_t *prev, list_entry_t *next) {
+    prev->next = next->prev = elm;
+    elm->next = next;
+    elm->prev = prev;
+}
+
+/* *
+ * Delete a list entry by making the prev/next entries point to each other.
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ * */
+static inline void
+__list_del(list_entry_t *prev, list_entry_t *next) {
+    prev->next = next;
+    next->prev = prev;
+}
+
+#endif /* !__ASSEMBLER__ */
+
+#endif /* !__LIBS_LIST_H__ */
+
diff -r -u -P lab6_origin/libs/printfmt.c lab6/libs/printfmt.c
--- lab6_origin/libs/printfmt.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/libs/printfmt.c	2019-02-26 20:51:17.084826300 +0800
@@ -0,0 +1,343 @@
+#include <defs.h>
+#include <x86.h>
+#include <error.h>
+#include <stdio.h>
+#include <string.h>
+
+/* *
+ * Space or zero padding and a field width are supported for the numeric
+ * formats only.
+ *
+ * The special format %e takes an integer error code
+ * and prints a string describing the error.
+ * The integer may be positive or negative,
+ * so that -E_NO_MEM and E_NO_MEM are equivalent.
+ * */
+
+static const char * const error_string[MAXERROR + 1] = {
+    [0]                     NULL,
+    [E_UNSPECIFIED]         "unspecified error",
+    [E_BAD_PROC]            "bad process",
+    [E_INVAL]               "invalid parameter",
+    [E_NO_MEM]              "out of memory",
+    [E_NO_FREE_PROC]        "out of processes",
+    [E_FAULT]               "segmentation fault",
+    [E_INVAL_ELF]           "invalid elf file",
+    [E_KILLED]              "process is killed",
+    [E_PANIC]               "panic failure",
+};
+
+/* *
+ * printnum - print a number (base <= 16) in reverse order
+ * @putch:      specified putch function, print a single character
+ * @putdat:     used by @putch function
+ * @num:        the number will be printed
+ * @base:       base for print, must be in [1, 16]
+ * @width:      maximum number of digits, if the actual width is less than @width, use @padc instead
+ * @padc:       character that padded on the left if the actual width is less than @width
+ * */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+        unsigned long long num, unsigned base, int width, int padc) {
+    unsigned long long result = num;
+    unsigned mod = do_div(result, base);
+
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+        printnum(putch, putdat, result, base, width - 1, padc);
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+            putch(padc, putdat);
+    }
+    // then print this (the least significant) digit
+    putch("0123456789abcdef"[mod], putdat);
+}
+
+/* *
+ * getuint - get an unsigned int of various possible sizes from a varargs list
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static unsigned long long
+getuint(va_list *ap, int lflag) {
+    if (lflag >= 2) {
+        return va_arg(*ap, unsigned long long);
+    }
+    else if (lflag) {
+        return va_arg(*ap, unsigned long);
+    }
+    else {
+        return va_arg(*ap, unsigned int);
+    }
+}
+
+/* *
+ * getint - same as getuint but signed, we can't use getuint because of sign extension
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static long long
+getint(va_list *ap, int lflag) {
+    if (lflag >= 2) {
+        return va_arg(*ap, long long);
+    }
+    else if (lflag) {
+        return va_arg(*ap, long);
+    }
+    else {
+        return va_arg(*ap, int);
+    }
+}
+
+/* *
+ * printfmt - format a string and print it by using putch
+ * @putch:      specified putch function, print a single character
+ * @putdat:     used by @putch function
+ * @fmt:        the format string to use
+ * */
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...) {
+    va_list ap;
+
+    va_start(ap, fmt);
+    vprintfmt(putch, putdat, fmt, ap);
+    va_end(ap);
+}
+
+/* *
+ * vprintfmt - format a string and print it by using putch, it's called with a va_list
+ * instead of a variable number of arguments
+ * @putch:      specified putch function, print a single character
+ * @putdat:     used by @putch function
+ * @fmt:        the format string to use
+ * @ap:         arguments for the format string
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want printfmt() instead.
+ * */
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap) {
+    register const char *p;
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+            if (ch == '\0') {
+                return;
+            }
+            putch(ch, putdat);
+        }
+
+        // Process a %-escape sequence
+        char padc = ' ';
+        width = precision = -1;
+        lflag = altflag = 0;
+
+    reswitch:
+        switch (ch = *(unsigned char *)fmt ++) {
+
+        // flag to pad on the right
+        case '-':
+            padc = '-';
+            goto reswitch;
+
+        // flag to pad with 0's instead of spaces
+        case '0':
+            padc = '0';
+            goto reswitch;
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+                precision = precision * 10 + ch - '0';
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+            goto process_precision;
+
+        case '*':
+            precision = va_arg(ap, int);
+            goto process_precision;
+
+        case '.':
+            if (width < 0)
+                width = 0;
+            goto reswitch;
+
+        case '#':
+            altflag = 1;
+            goto reswitch;
+
+        process_precision:
+            if (width < 0)
+                width = precision, precision = -1;
+            goto reswitch;
+
+        // long flag (doubled for long long)
+        case 'l':
+            lflag ++;
+            goto reswitch;
+
+        // character
+        case 'c':
+            putch(va_arg(ap, int), putdat);
+            break;
+
+        // error message
+        case 'e':
+            err = va_arg(ap, int);
+            if (err < 0) {
+                err = -err;
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+                printfmt(putch, putdat, "error %d", err);
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+            }
+            break;
+
+        // string
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+                p = "(null)";
+            }
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+                if (altflag && (ch < ' ' || ch > '~')) {
+                    putch('?', putdat);
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+                putch(' ', putdat);
+            }
+            break;
+
+        // (signed) decimal
+        case 'd':
+            num = getint(&ap, lflag);
+            if ((long long)num < 0) {
+                putch('-', putdat);
+                num = -(long long)num;
+            }
+            base = 10;
+            goto number;
+
+        // unsigned decimal
+        case 'u':
+            num = getuint(&ap, lflag);
+            base = 10;
+            goto number;
+
+        // (unsigned) octal
+        case 'o':
+            num = getuint(&ap, lflag);
+            base = 8;
+            goto number;
+
+        // pointer
+        case 'p':
+            putch('0', putdat);
+            putch('x', putdat);
+            num = (unsigned long long)(uintptr_t)va_arg(ap, void *);
+            base = 16;
+            goto number;
+
+        // (unsigned) hexadecimal
+        case 'x':
+            num = getuint(&ap, lflag);
+            base = 16;
+        number:
+            printnum(putch, putdat, num, base, width, padc);
+            break;
+
+        // escaped '%' character
+        case '%':
+            putch(ch, putdat);
+            break;
+
+        // unrecognized escape sequence - just print it literally
+        default:
+            putch('%', putdat);
+            for (fmt --; fmt[-1] != '%'; fmt --)
+                /* do nothing */;
+            break;
+        }
+    }
+}
+
+/* sprintbuf is used to save enough information of a buffer */
+struct sprintbuf {
+    char *buf;          // address pointer points to the first unused memory
+    char *ebuf;         // points the end of the buffer
+    int cnt;            // the number of characters that have been placed in this buffer
+};
+
+/* *
+ * sprintputch - 'print' a single character in a buffer
+ * @ch:         the character will be printed
+ * @b:          the buffer to place the character @ch
+ * */
+static void
+sprintputch(int ch, struct sprintbuf *b) {
+    b->cnt ++;
+    if (b->buf < b->ebuf) {
+        *b->buf ++ = ch;
+    }
+}
+
+/* *
+ * snprintf - format a string and place it in a buffer
+ * @str:        the buffer to place the result into
+ * @size:       the size of buffer, including the trailing null space
+ * @fmt:        the format string to use
+ * */
+int
+snprintf(char *str, size_t size, const char *fmt, ...) {
+    va_list ap;
+    int cnt;
+    va_start(ap, fmt);
+    cnt = vsnprintf(str, size, fmt, ap);
+    va_end(ap);
+    return cnt;
+}
+
+/* *
+ * vsnprintf - format a string and place it in a buffer, it's called with a va_list
+ * instead of a variable number of arguments
+ * @str:        the buffer to place the result into
+ * @size:       the size of buffer, including the trailing null space
+ * @fmt:        the format string to use
+ * @ap:         arguments for the format string
+ *
+ * The return value is the number of characters which would be generated for the
+ * given input, excluding the trailing '\0'.
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want snprintf() instead.
+ * */
+int
+vsnprintf(char *str, size_t size, const char *fmt, va_list ap) {
+    struct sprintbuf b = {str, str + size - 1, 0};
+    if (str == NULL || b.buf > b.ebuf) {
+        return -E_INVAL;
+    }
+    // print the string to the buffer
+    vprintfmt((void*)sprintputch, &b, fmt, ap);
+    // null terminate the buffer
+    *b.buf = '\0';
+    return b.cnt;
+}
+
diff -r -u -P lab6_origin/libs/rand.c lab6/libs/rand.c
--- lab6_origin/libs/rand.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/libs/rand.c	2019-02-26 20:51:17.085324300 +0800
@@ -0,0 +1,26 @@
+#include <x86.h>
+#include <stdlib.h>
+
+static unsigned long long next = 1;
+
+/* *
+ * rand - returns a pseudo-random integer
+ *
+ * The rand() function return a value in the range [0, RAND_MAX].
+ * */
+int
+rand(void) {
+    next = (next * 0x5DEECE66DLL + 0xBLL) & ((1LL << 48) - 1);
+    unsigned long long result = (next >> 12);
+    return (int)do_div(result, RAND_MAX + 1);
+}
+
+/* *
+ * srand - seed the random number generator with the given number
+ * @seed:   the required seed number
+ * */
+void
+srand(unsigned int seed) {
+    next = seed;
+}
+
diff -r -u -P lab6_origin/libs/skew_heap.h lab6/libs/skew_heap.h
--- lab6_origin/libs/skew_heap.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/libs/skew_heap.h	2019-02-26 20:51:17.086322500 +0800
@@ -0,0 +1,87 @@
+#ifndef __LIBS_SKEW_HEAP_H__
+#define __LIBS_SKEW_HEAP_H__
+
+struct skew_heap_entry {
+     struct skew_heap_entry *parent, *left, *right;
+};
+
+typedef struct skew_heap_entry skew_heap_entry_t;
+
+typedef int(*compare_f)(void *a, void *b);
+
+static inline void skew_heap_init(skew_heap_entry_t *a) __attribute__((always_inline));
+static inline skew_heap_entry_t *skew_heap_merge(
+     skew_heap_entry_t *a, skew_heap_entry_t *b,
+     compare_f comp);
+static inline skew_heap_entry_t *skew_heap_insert(
+     skew_heap_entry_t *a, skew_heap_entry_t *b,
+     compare_f comp) __attribute__((always_inline));
+static inline skew_heap_entry_t *skew_heap_remove(
+     skew_heap_entry_t *a, skew_heap_entry_t *b,
+     compare_f comp) __attribute__((always_inline));
+
+static inline void
+skew_heap_init(skew_heap_entry_t *a)
+{
+     a->left = a->right = a->parent = NULL;
+}
+
+static inline skew_heap_entry_t *
+skew_heap_merge(skew_heap_entry_t *a, skew_heap_entry_t *b,
+                compare_f comp)
+{
+     if (a == NULL) return b;
+     else if (b == NULL) return a;
+     
+     skew_heap_entry_t *l, *r;
+     if (comp(a, b) == -1)
+     {
+          r = a->left;
+          l = skew_heap_merge(a->right, b, comp);
+          
+          a->left = l;
+          a->right = r;
+          if (l) l->parent = a;
+
+          return a;
+     }
+     else
+     {
+          r = b->left;
+          l = skew_heap_merge(a, b->right, comp);
+          
+          b->left = l;
+          b->right = r;
+          if (l) l->parent = b;
+
+          return b;
+     }
+}
+
+static inline skew_heap_entry_t *
+skew_heap_insert(skew_heap_entry_t *a, skew_heap_entry_t *b,
+                 compare_f comp)
+{
+     skew_heap_init(b);
+     return skew_heap_merge(a, b, comp);
+}
+
+static inline skew_heap_entry_t *
+skew_heap_remove(skew_heap_entry_t *a, skew_heap_entry_t *b,
+                 compare_f comp)
+{
+     skew_heap_entry_t *p   = b->parent;
+     skew_heap_entry_t *rep = skew_heap_merge(b->left, b->right, comp);
+     if (rep) rep->parent = p;
+     
+     if (p)
+     {
+          if (p->left == b)
+               p->left = rep;
+          else p->right = rep;
+          return a;
+     }
+     else return rep;
+}
+
+#endif    /* !__LIBS_SKEW_HEAP_H__ */
diff -r -u -P lab6_origin/libs/stdarg.h lab6/libs/stdarg.h
--- lab6_origin/libs/stdarg.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/libs/stdarg.h	2019-02-26 20:51:17.086821500 +0800
@@ -0,0 +1,12 @@
+#ifndef __LIBS_STDARG_H__
+#define __LIBS_STDARG_H__
+
+/* compiler provides size of save area */
+typedef __builtin_va_list va_list;
+
+#define va_start(ap, last)              (__builtin_va_start(ap, last))
+#define va_arg(ap, type)                (__builtin_va_arg(ap, type))
+#define va_end(ap)                      /*nothing*/
+
+#endif /* !__LIBS_STDARG_H__ */
+
diff -r -u -P lab6_origin/libs/stdio.h lab6/libs/stdio.h
--- lab6_origin/libs/stdio.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/libs/stdio.h	2019-02-26 20:51:17.087318600 +0800
@@ -0,0 +1,24 @@
+#ifndef __LIBS_STDIO_H__
+#define __LIBS_STDIO_H__
+
+#include <defs.h>
+#include <stdarg.h>
+
+/* kern/libs/stdio.c */
+int cprintf(const char *fmt, ...);
+int vcprintf(const char *fmt, va_list ap);
+void cputchar(int c);
+int cputs(const char *str);
+int getchar(void);
+
+/* kern/libs/readline.c */
+char *readline(const char *prompt);
+
+/* libs/printfmt.c */
+void printfmt(void (*putch)(int, void *), void *putdat, const char *fmt, ...);
+void vprintfmt(void (*putch)(int, void *), void *putdat, const char *fmt, va_list ap);
+int snprintf(char *str, size_t size, const char *fmt, ...);
+int vsnprintf(char *str, size_t size, const char *fmt, va_list ap);
+
+#endif /* !__LIBS_STDIO_H__ */
+
diff -r -u -P lab6_origin/libs/stdlib.h lab6/libs/stdlib.h
--- lab6_origin/libs/stdlib.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/libs/stdlib.h	2019-02-26 20:51:17.088319500 +0800
@@ -0,0 +1,17 @@
+#ifndef __LIBS_STDLIB_H__
+#define __LIBS_STDLIB_H__
+
+#include <defs.h>
+
+/* the largest number rand will return */
+#define RAND_MAX    2147483647UL
+
+/* libs/rand.c */
+int rand(void);
+void srand(unsigned int seed);
+
+/* libs/hash.c */
+uint32_t hash32(uint32_t val, unsigned int bits);
+
+#endif /* !__LIBS_RAND_H__ */
+
diff -r -u -P lab6_origin/libs/string.c lab6/libs/string.c
--- lab6_origin/libs/string.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/libs/string.c	2019-02-26 20:51:17.089314600 +0800
@@ -0,0 +1,367 @@
+#include <string.h>
+#include <x86.h>
+
+/* *
+ * strlen - calculate the length of the string @s, not including
+ * the terminating '\0' character.
+ * @s:      the input string
+ *
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+    size_t cnt = 0;
+    while (*s ++ != '\0') {
+        cnt ++;
+    }
+    return cnt;
+}
+
+/* *
+ * strnlen - calculate the length of the string @s, not including
+ * the terminating '\0' char acter, but at most @len.
+ * @s:      the input string
+ * @len:    the max-length that function will scan
+ *
+ * Note that, this function looks only at the first @len characters
+ * at @s, and never beyond @s + @len.
+ *
+ * The return value is strlen(s), if that is less than @len, or
+ * @len if there is no '\0' character among the first @len characters
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+    size_t cnt = 0;
+    while (cnt < len && *s ++ != '\0') {
+        cnt ++;
+    }
+    return cnt;
+}
+
+/* *
+ * strcpy - copies the string pointed by @src into the array pointed by @dst,
+ * including the terminating null character.
+ * @dst:    pointer to the destination array where the content is to be copied
+ * @src:    string to be copied
+ *
+ * The return value is @dst.
+ *
+ * To avoid overflows, the size of array pointed by @dst should be long enough to
+ * contain the same string as @src (including the terminating null character), and
+ * should not overlap in memory with @src.
+ * */
+char *
+strcpy(char *dst, const char *src) {
+#ifdef __HAVE_ARCH_STRCPY
+    return __strcpy(dst, src);
+#else
+    char *p = dst;
+    while ((*p ++ = *src ++) != '\0')
+        /* nothing */;
+    return dst;
+#endif /* __HAVE_ARCH_STRCPY */
+}
+
+/* *
+ * strncpy - copies the first @len characters of @src to @dst. If the end of string @src
+ * if found before @len characters have been copied, @dst is padded with '\0' until a
+ * total of @len characters have been written to it.
+ * @dst:    pointer to the destination array where the content is to be copied
+ * @src:    string to be copied
+ * @len:    maximum number of characters to be copied from @src
+ *
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+    char *p = dst;
+    while (len > 0) {
+        if ((*p = *src) != '\0') {
+            src ++;
+        }
+        p ++, len --;
+    }
+    return dst;
+}
+
+/* *
+ * strcmp - compares the string @s1 and @s2
+ * @s1:     string to be compared
+ * @s2:     string to be compared
+ *
+ * This function starts comparing the first character of each string. If
+ * they are equal to each other, it continues with the following pairs until
+ * the characters differ or until a terminanting null-character is reached.
+ *
+ * Returns an integral value indicating the relationship between the strings:
+ * - A zero value indicates that both strings are equal;
+ * - A value greater than zero indicates that the first character that does
+ *   not match has a greater value in @s1 than in @s2;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+strcmp(const char *s1, const char *s2) {
+#ifdef __HAVE_ARCH_STRCMP
+    return __strcmp(s1, s2);
+#else
+    while (*s1 != '\0' && *s1 == *s2) {
+        s1 ++, s2 ++;
+    }
+    return (int)((unsigned char)*s1 - (unsigned char)*s2);
+#endif /* __HAVE_ARCH_STRCMP */
+}
+
+/* *
+ * strncmp - compares up to @n characters of the string @s1 to those of the string @s2
+ * @s1:     string to be compared
+ * @s2:     string to be compared
+ * @n:      maximum number of characters to compare
+ *
+ * This function starts comparing the first character of each string. If
+ * they are equal to each other, it continues with the following pairs until
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+        n --, s1 ++, s2 ++;
+    }
+    return (n == 0) ? 0 : (int)((unsigned char)*s1 - (unsigned char)*s2);
+}
+
+/* *
+ * strchr - locates first occurrence of character in string
+ * @s:      the input string
+ * @c:      character to be located
+ *
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+    while (*s != '\0') {
+        if (*s == c) {
+            return (char *)s;
+        }
+        s ++;
+    }
+    return NULL;
+}
+
+/* *
+ * strfind - locates first occurrence of character in string
+ * @s:      the input string
+ * @c:      character to be located
+ *
+ * The strfind() function is like strchr() except that if @c is
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+    while (*s != '\0') {
+        if (*s == c) {
+            break;
+        }
+        s ++;
+    }
+    return (char *)s;
+}
+
+/* *
+ * strtol - converts string to long integer
+ * @s:      the input string that contains the representation of an integer number
+ * @endptr: reference to an object of type char *, whose value is set by the
+ *          function to the next character in @s after the numerical value. This
+ *          parameter can also be a null pointer, in which case it is not used.
+ * @base:   x
+ *
+ * The function first discards as many whitespace characters as necessary until
+ * the first non-whitespace character is found. Then, starting from this character,
+ * takes as many characters as possible that are valid following a syntax that
+ * depends on the base parameter, and interprets them as a numerical value. Finally,
+ * a pointer to the first character following the integer representation in @s
+ * is stored in the object pointed by @endptr.
+ *
+ * If the value of base is zero, the syntax expected is similar to that of
+ * integer constants, which is formed by a succession of:
+ * - An optional plus or minus sign;
+ * - An optional prefix indicating octal or hexadecimal base ("0" or "0x" respectively)
+ * - A sequence of decimal digits (if no base prefix was specified) or either octal
+ *   or hexadecimal digits if a specific prefix is present
+ *
+ * If the base value is between 2 and 36, the format expected for the integral number
+ * is a succession of the valid digits and/or letters needed to represent integers of
+ * the specified radix (starting from '0' and up to 'z'/'Z' for radix 36). The
+ * sequence may optionally be preceded by a plus or minus sign and, if base is 16,
+ * an optional "0x" or "0X" prefix.
+ *
+ * The strtol() function returns the converted integral number as a long int value.
+ * */
+long
+strtol(const char *s, char **endptr, int base) {
+    int neg = 0;
+    long val = 0;
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+        s ++;
+    }
+
+    // plus/minus sign
+    if (*s == '+') {
+        s ++;
+    }
+    else if (*s == '-') {
+        s ++, neg = 1;
+    }
+
+    // hex or octal base prefix
+    if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x')) {
+        s += 2, base = 16;
+    }
+    else if (base == 0 && s[0] == '0') {
+        s ++, base = 8;
+    }
+    else if (base == 0) {
+        base = 10;
+    }
+
+    // digits
+    while (1) {
+        int dig;
+
+        if (*s >= '0' && *s <= '9') {
+            dig = *s - '0';
+        }
+        else if (*s >= 'a' && *s <= 'z') {
+            dig = *s - 'a' + 10;
+        }
+        else if (*s >= 'A' && *s <= 'Z') {
+            dig = *s - 'A' + 10;
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+            break;
+        }
+        s ++, val = (val * base) + dig;
+        // we don't properly detect overflow!
+    }
+
+    if (endptr) {
+        *endptr = (char *) s;
+    }
+    return (neg ? -val : val);
+}
+
+/* *
+ * memset - sets the first @n bytes of the memory area pointed by @s
+ * to the specified value @c.
+ * @s:      pointer the the memory area to fill
+ * @c:      value to set
+ * @n:      number of bytes to be set to the value
+ *
+ * The memset() function returns @s.
+ * */
+void *
+memset(void *s, char c, size_t n) {
+#ifdef __HAVE_ARCH_MEMSET
+    return __memset(s, c, n);
+#else
+    char *p = s;
+    while (n -- > 0) {
+        *p ++ = c;
+    }
+    return s;
+#endif /* __HAVE_ARCH_MEMSET */
+}
+
+/* *
+ * memmove - copies the values of @n bytes from the location pointed by @src to
+ * the memory area pointed by @dst. @src and @dst are allowed to overlap.
+ * @dst     pointer to the destination array where the content is to be copied
+ * @src     pointer to the source of data to by copied
+ * @n:      number of bytes to copy
+ *
+ * The memmove() function returns @dst.
+ * */
+void *
+memmove(void *dst, const void *src, size_t n) {
+#ifdef __HAVE_ARCH_MEMMOVE
+    return __memmove(dst, src, n);
+#else
+    const char *s = src;
+    char *d = dst;
+    if (s < d && s + n > d) {
+        s += n, d += n;
+        while (n -- > 0) {
+            *-- d = *-- s;
+        }
+    } else {
+        while (n -- > 0) {
+            *d ++ = *s ++;
+        }
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMMOVE */
+}
+
+/* *
+ * memcpy - copies the value of @n bytes from the location pointed by @src to
+ * the memory area pointed by @dst.
+ * @dst     pointer to the destination array where the content is to be copied
+ * @src     pointer to the source of data to by copied
+ * @n:      number of bytes to copy
+ *
+ * The memcpy() returns @dst.
+ *
+ * Note that, the function does not check any terminating null character in @src,
+ * it always copies exactly @n bytes. To avoid overflows, the size of arrays pointed
+ * by both @src and @dst, should be at least @n bytes, and should not overlap
+ * (for overlapping memory area, memmove is a safer approach).
+ * */
+void *
+memcpy(void *dst, const void *src, size_t n) {
+#ifdef __HAVE_ARCH_MEMCPY
+    return __memcpy(dst, src, n);
+#else
+    const char *s = src;
+    char *d = dst;
+    while (n -- > 0) {
+        *d ++ = *s ++;
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMCPY */
+}
+
+/* *
+ * memcmp - compares two blocks of memory
+ * @v1:     pointer to block of memory
+ * @v2:     pointer to block of memory
+ * @n:      number of bytes to compare
+ *
+ * The memcmp() functions returns an integral value indicating the
+ * relationship between the content of the memory blocks:
+ * - A zero value indicates that the contents of both memory blocks are equal;
+ * - A value greater than zero indicates that the first byte that does not
+ *   match in both memory blocks has a greater value in @v1 than in @v2
+ *   as if evaluated as unsigned char values;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+    const char *s1 = (const char *)v1;
+    const char *s2 = (const char *)v2;
+    while (n -- > 0) {
+        if (*s1 != *s2) {
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+        }
+        s1 ++, s2 ++;
+    }
+    return 0;
+}
+
diff -r -u -P lab6_origin/libs/string.h lab6/libs/string.h
--- lab6_origin/libs/string.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/libs/string.h	2019-02-26 20:51:17.090314200 +0800
@@ -0,0 +1,25 @@
+#ifndef __LIBS_STRING_H__
+#define __LIBS_STRING_H__
+
+#include <defs.h>
+
+size_t strlen(const char *s);
+size_t strnlen(const char *s, size_t len);
+
+char *strcpy(char *dst, const char *src);
+char *strncpy(char *dst, const char *src, size_t len);
+
+int strcmp(const char *s1, const char *s2);
+int strncmp(const char *s1, const char *s2, size_t n);
+
+char *strchr(const char *s, char c);
+char *strfind(const char *s, char c);
+long strtol(const char *s, char **endptr, int base);
+
+void *memset(void *s, char c, size_t n);
+void *memmove(void *dst, const void *src, size_t n);
+void *memcpy(void *dst, const void *src, size_t n);
+int memcmp(const void *v1, const void *v2, size_t n);
+
+#endif /* !__LIBS_STRING_H__ */
+
diff -r -u -P lab6_origin/libs/unistd.h lab6/libs/unistd.h
--- lab6_origin/libs/unistd.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/libs/unistd.h	2019-02-26 20:51:17.091312500 +0800
@@ -0,0 +1,31 @@
+#ifndef __LIBS_UNISTD_H__
+#define __LIBS_UNISTD_H__
+
+#define T_SYSCALL           0x80
+
+/* syscall number */
+#define SYS_exit            1
+#define SYS_fork            2
+#define SYS_wait            3
+#define SYS_exec            4
+#define SYS_clone           5
+#define SYS_yield           10
+#define SYS_sleep           11
+#define SYS_kill            12
+#define SYS_gettime         17
+#define SYS_getpid          18
+#define SYS_brk             19
+#define SYS_mmap            20
+#define SYS_munmap          21
+#define SYS_shmem           22
+#define SYS_putc            30
+#define SYS_pgdir           31
+/* OLNY FOR LAB6 */
+#define SYS_lab6_set_priority 255
+
+/* SYS_fork flags */
+#define CLONE_VM            0x00000100  // set if VM shared between processes
+#define CLONE_THREAD        0x00000200  // thread group
+
+#endif /* !__LIBS_UNISTD_H__ */
+
diff -r -u -P lab6_origin/libs/x86.h lab6/libs/x86.h
--- lab6_origin/libs/x86.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/libs/x86.h	2019-02-26 20:51:17.092310300 +0800
@@ -0,0 +1,302 @@
+#ifndef __LIBS_X86_H__
+#define __LIBS_X86_H__
+
+#include <defs.h>
+
+#define do_div(n, base) ({                                          \
+            unsigned long __upper, __low, __high, __mod, __base;    \
+            __base = (base);                                        \
+            asm ("" : "=a" (__low), "=d" (__high) : "A" (n));       \
+            __upper = __high;                                       \
+            if (__high != 0) {                                      \
+                __upper = __high % __base;                          \
+                __high = __high / __base;                           \
+            }                                                       \
+            asm ("divl %2" : "=a" (__low), "=d" (__mod)             \
+                : "rm" (__base), "0" (__low), "1" (__upper));       \
+            asm ("" : "=A" (n) : "a" (__low), "d" (__high));        \
+            __mod;                                                  \
+        })
+
+#define barrier() __asm__ __volatile__ ("" ::: "memory")
+
+static inline uint8_t inb(uint16_t port) __attribute__((always_inline));
+static inline void insl(uint32_t port, void *addr, int cnt) __attribute__((always_inline));
+static inline void outb(uint16_t port, uint8_t data) __attribute__((always_inline));
+static inline void outw(uint16_t port, uint16_t data) __attribute__((always_inline));
+static inline void outsl(uint32_t port, const void *addr, int cnt) __attribute__((always_inline));
+static inline uint32_t read_ebp(void) __attribute__((always_inline));
+static inline void breakpoint(void) __attribute__((always_inline));
+static inline uint32_t read_dr(unsigned regnum) __attribute__((always_inline));
+static inline void write_dr(unsigned regnum, uint32_t value) __attribute__((always_inline));
+
+/* Pseudo-descriptors used for LGDT, LLDT(not used) and LIDT instructions. */
+struct pseudodesc {
+    uint16_t pd_lim;        // Limit
+    uintptr_t pd_base;      // Base address
+} __attribute__ ((packed));
+
+static inline void lidt(struct pseudodesc *pd) __attribute__((always_inline));
+static inline void sti(void) __attribute__((always_inline));
+static inline void cli(void) __attribute__((always_inline));
+static inline void ltr(uint16_t sel) __attribute__((always_inline));
+static inline uint32_t read_eflags(void) __attribute__((always_inline));
+static inline void write_eflags(uint32_t eflags) __attribute__((always_inline));
+static inline void lcr0(uintptr_t cr0) __attribute__((always_inline));
+static inline void lcr3(uintptr_t cr3) __attribute__((always_inline));
+static inline uintptr_t rcr0(void) __attribute__((always_inline));
+static inline uintptr_t rcr1(void) __attribute__((always_inline));
+static inline uintptr_t rcr2(void) __attribute__((always_inline));
+static inline uintptr_t rcr3(void) __attribute__((always_inline));
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+    return data;
+}
+
+static inline void
+insl(uint32_t port, void *addr, int cnt) {
+    asm volatile (
+        "cld;"
+        "repne; insl;"
+        : "=D" (addr), "=c" (cnt)
+        : "d" (port), "0" (addr), "1" (cnt)
+        : "memory", "cc");
+}
+
+static inline void
+outb(uint16_t port, uint8_t data) {
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
+}
+
+static inline void
+outw(uint16_t port, uint16_t data) {
+    asm volatile ("outw %0, %1" :: "a" (data), "d" (port) : "memory");
+}
+
+static inline void
+outsl(uint32_t port, const void *addr, int cnt) {
+    asm volatile (
+        "cld;"
+        "repne; outsl;"
+        : "=S" (addr), "=c" (cnt)
+        : "d" (port), "0" (addr), "1" (cnt)
+        : "memory", "cc");
+}
+
+static inline uint32_t
+read_ebp(void) {
+    uint32_t ebp;
+    asm volatile ("movl %%ebp, %0" : "=r" (ebp));
+    return ebp;
+}
+
+static inline void
+breakpoint(void) {
+    asm volatile ("int $3");
+}
+
+static inline uint32_t
+read_dr(unsigned regnum) {
+    uint32_t value = 0;
+    switch (regnum) {
+    case 0: asm volatile ("movl %%db0, %0" : "=r" (value)); break;
+    case 1: asm volatile ("movl %%db1, %0" : "=r" (value)); break;
+    case 2: asm volatile ("movl %%db2, %0" : "=r" (value)); break;
+    case 3: asm volatile ("movl %%db3, %0" : "=r" (value)); break;
+    case 6: asm volatile ("movl %%db6, %0" : "=r" (value)); break;
+    case 7: asm volatile ("movl %%db7, %0" : "=r" (value)); break;
+    }
+    return value;
+}
+
+static void
+write_dr(unsigned regnum, uint32_t value) {
+    switch (regnum) {
+    case 0: asm volatile ("movl %0, %%db0" :: "r" (value)); break;
+    case 1: asm volatile ("movl %0, %%db1" :: "r" (value)); break;
+    case 2: asm volatile ("movl %0, %%db2" :: "r" (value)); break;
+    case 3: asm volatile ("movl %0, %%db3" :: "r" (value)); break;
+    case 6: asm volatile ("movl %0, %%db6" :: "r" (value)); break;
+    case 7: asm volatile ("movl %0, %%db7" :: "r" (value)); break;
+    }
+}
+
+static inline void
+lidt(struct pseudodesc *pd) {
+    asm volatile ("lidt (%0)" :: "r" (pd) : "memory");
+}
+
+static inline void
+sti(void) {
+    asm volatile ("sti");
+}
+
+static inline void
+cli(void) {
+    asm volatile ("cli" ::: "memory");
+}
+
+static inline void
+ltr(uint16_t sel) {
+    asm volatile ("ltr %0" :: "r" (sel) : "memory");
+}
+
+static inline uint32_t
+read_eflags(void) {
+    uint32_t eflags;
+    asm volatile ("pushfl; popl %0" : "=r" (eflags));
+    return eflags;
+}
+
+static inline void
+write_eflags(uint32_t eflags) {
+    asm volatile ("pushl %0; popfl" :: "r" (eflags));
+}
+
+static inline void
+lcr0(uintptr_t cr0) {
+    asm volatile ("mov %0, %%cr0" :: "r" (cr0) : "memory");
+}
+
+static inline void
+lcr3(uintptr_t cr3) {
+    asm volatile ("mov %0, %%cr3" :: "r" (cr3) : "memory");
+}
+
+static inline uintptr_t
+rcr0(void) {
+    uintptr_t cr0;
+    asm volatile ("mov %%cr0, %0" : "=r" (cr0) :: "memory");
+    return cr0;
+}
+
+static inline uintptr_t
+rcr1(void) {
+    uintptr_t cr1;
+    asm volatile ("mov %%cr1, %0" : "=r" (cr1) :: "memory");
+    return cr1;
+}
+
+static inline uintptr_t
+rcr2(void) {
+    uintptr_t cr2;
+    asm volatile ("mov %%cr2, %0" : "=r" (cr2) :: "memory");
+    return cr2;
+}
+
+static inline uintptr_t
+rcr3(void) {
+    uintptr_t cr3;
+    asm volatile ("mov %%cr3, %0" : "=r" (cr3) :: "memory");
+    return cr3;
+}
+
+static inline void
+invlpg(void *addr) {
+    asm volatile ("invlpg (%0)" :: "r" (addr) : "memory");
+}
+
+static inline int __strcmp(const char *s1, const char *s2) __attribute__((always_inline));
+static inline char *__strcpy(char *dst, const char *src) __attribute__((always_inline));
+static inline void *__memset(void *s, char c, size_t n) __attribute__((always_inline));
+static inline void *__memmove(void *dst, const void *src, size_t n) __attribute__((always_inline));
+static inline void *__memcpy(void *dst, const void *src, size_t n) __attribute__((always_inline));
+
+#ifndef __HAVE_ARCH_STRCMP
+#define __HAVE_ARCH_STRCMP
+static inline int
+__strcmp(const char *s1, const char *s2) {
+    int d0, d1, ret;
+    asm volatile (
+        "1: lodsb;"
+        "scasb;"
+        "jne 2f;"
+        "testb %%al, %%al;"
+        "jne 1b;"
+        "xorl %%eax, %%eax;"
+        "jmp 3f;"
+        "2: sbbl %%eax, %%eax;"
+        "orb $1, %%al;"
+        "3:"
+        : "=a" (ret), "=&S" (d0), "=&D" (d1)
+        : "1" (s1), "2" (s2)
+        : "memory");
+    return ret;
+}
+
+#endif /* __HAVE_ARCH_STRCMP */
+
+#ifndef __HAVE_ARCH_STRCPY
+#define __HAVE_ARCH_STRCPY
+static inline char *
+__strcpy(char *dst, const char *src) {
+    int d0, d1, d2;
+    asm volatile (
+        "1: lodsb;"
+        "stosb;"
+        "testb %%al, %%al;"
+        "jne 1b;"
+        : "=&S" (d0), "=&D" (d1), "=&a" (d2)
+        : "0" (src), "1" (dst) : "memory");
+    return dst;
+}
+#endif /* __HAVE_ARCH_STRCPY */
+
+#ifndef __HAVE_ARCH_MEMSET
+#define __HAVE_ARCH_MEMSET
+static inline void *
+__memset(void *s, char c, size_t n) {
+    int d0, d1;
+    asm volatile (
+        "rep; stosb;"
+        : "=&c" (d0), "=&D" (d1)
+        : "0" (n), "a" (c), "1" (s)
+        : "memory");
+    return s;
+}
+#endif /* __HAVE_ARCH_MEMSET */
+
+#ifndef __HAVE_ARCH_MEMMOVE
+#define __HAVE_ARCH_MEMMOVE
+static inline void *
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+        return __memcpy(dst, src, n);
+    }
+    int d0, d1, d2;
+    asm volatile (
+        "std;"
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+        : "memory");
+    return dst;
+}
+#endif /* __HAVE_ARCH_MEMMOVE */
+
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+        "rep; movsl;"
+        "movl %4, %%ecx;"
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+}
+#endif /* __HAVE_ARCH_MEMCPY */
+
+#endif /* !__LIBS_X86_H__ */
+
diff -r -u -P lab6_origin/Makefile lab6/Makefile
--- lab6_origin/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ lab6/Makefile	2019-02-26 20:51:17.028427300 +0800
@@ -0,0 +1,343 @@
+PROJ	:= 6
+EMPTY	:=
+SPACE	:= $(EMPTY) $(EMPTY)
+SLASH	:= /
+
+V       := @
+#need llvm/cang-3.5+
+#USELLVM := 1
+# try to infer the correct GCCPREFX
+ifndef GCCPREFIX
+GCCPREFIX := $(shell if i386-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
+	then echo 'i386-elf-'; \
+	elif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \
+	then echo ''; \
+	else echo "***" 1>&2; \
+	echo "*** Error: Couldn't find an i386-elf version of GCC/binutils." 1>&2; \
+	echo "*** Is the directory with i386-elf-gcc in your PATH?" 1>&2; \
+	echo "*** If your i386-elf toolchain is installed with a command" 1>&2; \
+	echo "*** prefix other than 'i386-elf-', set your GCCPREFIX" 1>&2; \
+	echo "*** environment variable to that prefix and run 'make' again." 1>&2; \
+	echo "*** To turn off this error, run 'gmake GCCPREFIX= ...'." 1>&2; \
+	echo "***" 1>&2; exit 1; fi)
+endif
+
+# try to infer the correct QEMU
+ifndef QEMU
+QEMU := $(shell if which qemu-system-i386 > /dev/null; \
+	then echo 'qemu-system-i386'; exit; \
+	elif which i386-elf-qemu > /dev/null; \
+	then echo 'i386-elf-qemu'; exit; \
+	elif which qemu > /dev/null; \
+	then echo 'qemu'; exit; \
+	else \
+	echo "***" 1>&2; \
+	echo "*** Error: Couldn't find a working QEMU executable." 1>&2; \
+	echo "*** Is the directory containing the qemu binary in your PATH" 1>&2; \
+	echo "***" 1>&2; exit 1; fi)
+endif
+
+# eliminate default suffix rules
+.SUFFIXES: .c .S .h
+
+# delete target files if there is an error (or make is interrupted)
+.DELETE_ON_ERROR:
+
+# define compiler and flags
+ifndef  USELLVM
+HOSTCC		:= gcc
+HOSTCFLAGS	:= -g -Wall -O2
+CC		:= $(GCCPREFIX)gcc
+CFLAGS	:= -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc $(DEFS)
+CFLAGS	+= $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+else
+HOSTCC		:= clang
+HOSTCFLAGS	:= -g -Wall -O2
+CC		:= clang
+CFLAGS	:= -fno-builtin -Wall -g -m32 -mno-sse -nostdinc $(DEFS)
+CFLAGS	+= $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+endif
+
+GDB		:= $(GCCPREFIX)gdb
+CTYPE	:= c S
+
+LD      := $(GCCPREFIX)ld
+LDFLAGS	:= -m $(shell $(LD) -V | grep elf_i386 2>/dev/null)
+LDFLAGS	+= -nostdlib
+
+OBJCOPY := $(GCCPREFIX)objcopy
+OBJDUMP := $(GCCPREFIX)objdump
+
+COPY	:= cp
+MKDIR   := mkdir -p
+MV		:= mv
+RM		:= rm -f
+AWK		:= awk
+SED		:= sed
+SH		:= sh
+TR		:= tr
+TOUCH	:= touch -c
+
+OBJDIR	:= obj
+BINDIR	:= bin
+
+ALLOBJS	:=
+ALLDEPS	:=
+TARGETS	:=
+
+include tools/function.mk
+
+listf_cc = $(call listf,$(1),$(CTYPE))
+
+USER_PREFIX	:= __user_
+
+# for cc
+add_files_cc = $(call add_files,$(1),$(CC),$(CFLAGS) $(3),$(2),$(4))
+create_target_cc = $(call create_target,$(1),$(2),$(3),$(CC),$(CFLAGS))
+
+# for hostcc
+add_files_host = $(call add_files,$(1),$(HOSTCC),$(HOSTCFLAGS),$(2),$(3))
+create_target_host = $(call create_target,$(1),$(2),$(3),$(HOSTCC),$(HOSTCFLAGS))
+
+cgtype = $(patsubst %.$(2),%.$(3),$(1))
+objfile = $(call toobj,$(1))
+asmfile = $(call cgtype,$(call toobj,$(1)),o,asm)
+outfile = $(call cgtype,$(call toobj,$(1)),o,out)
+symfile = $(call cgtype,$(call toobj,$(1)),o,sym)
+filename = $(basename $(notdir $(1)))
+ubinfile = $(call outfile,$(addprefix $(USER_PREFIX),$(call filename,$(1))))
+
+# for match pattern
+match = $(shell echo $(2) | $(AWK) '{for(i=1;i<=NF;i++){if(match("$(1)","^"$$(i)"$$")){exit 1;}}}'; echo $$?)
+
+# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+# include kernel/user
+
+INCLUDE	+= libs/
+
+CFLAGS	+= $(addprefix -I,$(INCLUDE))
+
+LIBDIR	+= libs
+
+$(call add_files_cc,$(call listf_cc,$(LIBDIR)),libs,)
+
+# -------------------------------------------------------------------
+# user programs
+
+UINCLUDE	+= user/include/ \
+			   user/libs/
+
+USRCDIR		+= user
+
+ULIBDIR		+= user/libs
+
+UCFLAGS		+= $(addprefix -I,$(UINCLUDE))
+USER_BINS	:=
+
+$(call add_files_cc,$(call listf_cc,$(ULIBDIR)),ulibs,$(UCFLAGS))
+$(call add_files_cc,$(call listf_cc,$(USRCDIR)),uprog,$(UCFLAGS))
+
+UOBJS	:= $(call read_packet,ulibs libs)
+
+define uprog_ld
+__user_bin__ := $$(call ubinfile,$(1))
+USER_BINS += $$(__user_bin__)
+$$(__user_bin__): tools/user.ld
+$$(__user_bin__): $$(UOBJS)
+$$(__user_bin__): $(1) | $$$$(dir $$$$@)
+	$(V)$(LD) $(LDFLAGS) -T tools/user.ld -o $$@ $$(UOBJS) $(1)
+	@$(OBJDUMP) -S $$@ > $$(call cgtype,$$<,o,asm)
+	@$(OBJDUMP) -t $$@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$$$/d' > $$(call cgtype,$$<,o,sym)
+endef
+
+$(foreach p,$(call read_packet,uprog),$(eval $(call uprog_ld,$(p))))
+
+# -------------------------------------------------------------------
+# kernel
+
+KINCLUDE	+= kern/debug/ \
+			   kern/driver/ \
+			   kern/trap/ \
+			   kern/mm/ \
+			   kern/libs/ \
+			   kern/sync/ \
+			   kern/fs/    \
+			   kern/process \
+			   kern/schedule \
+			   kern/syscall
+
+KSRCDIR		+= kern/init \
+			   kern/libs \
+			   kern/debug \
+			   kern/driver \
+			   kern/trap \
+			   kern/mm \
+			   kern/sync \
+			   kern/fs    \
+			   kern/process \
+			   kern/schedule \
+			   kern/syscall
+
+KCFLAGS		+= $(addprefix -I,$(KINCLUDE))
+
+$(call add_files_cc,$(call listf_cc,$(KSRCDIR)),kernel,$(KCFLAGS))
+
+KOBJS	= $(call read_packet,kernel libs)
+
+# create kernel target
+kernel = $(call totarget,kernel)
+
+$(kernel): tools/kernel.ld
+
+$(kernel): $(KOBJS) $(USER_BINS)
+	@echo + ld $@
+	$(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o $@ $(KOBJS) -b binary $(USER_BINS)
+	@$(OBJDUMP) -S $@ > $(call asmfile,kernel)
+	@$(OBJDUMP) -t $@ | $(SED) '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $(call symfile,kernel)
+
+$(call create_target,kernel)
+
+# -------------------------------------------------------------------
+
+# create bootblock
+bootfiles = $(call listf_cc,boot)
+$(foreach f,$(bootfiles),$(call cc_compile,$(f),$(CC),$(CFLAGS) -Os -nostdinc))
+
+bootblock = $(call totarget,bootblock)
+
+$(bootblock): $(call toobj,boot/bootasm.S) $(call toobj,$(bootfiles)) | $(call totarget,sign)
+	@echo + ld $@
+	$(V)$(LD) $(LDFLAGS) -N -T tools/boot.ld $^ -o $(call toobj,bootblock)
+	@$(OBJDUMP) -S $(call objfile,bootblock) > $(call asmfile,bootblock)
+	@$(OBJCOPY) -S -O binary $(call objfile,bootblock) $(call outfile,bootblock)
+	@$(call totarget,sign) $(call outfile,bootblock) $(bootblock)
+
+$(call create_target,bootblock)
+
+# -------------------------------------------------------------------
+
+# create 'sign' tools
+$(call add_files_host,tools/sign.c,sign,sign)
+$(call create_target_host,sign,sign)
+
+# -------------------------------------------------------------------
+
+# create ucore.img
+UCOREIMG	:= $(call totarget,ucore.img)
+
+$(UCOREIMG): $(kernel) $(bootblock)
+	$(V)dd if=/dev/zero of=$@ count=10000
+	$(V)dd if=$(bootblock) of=$@ conv=notrunc
+	$(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc
+
+$(call create_target,ucore.img)
+
+# -------------------------------------------------------------------
+
+# create swap.img
+SWAPIMG		:= $(call totarget,swap.img)
+
+$(SWAPIMG):
+	$(V)dd if=/dev/zero of=$@ bs=1024k count=128
+
+$(call create_target,swap.img)
+
+# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+
+$(call finish_all)
+
+IGNORE_ALLDEPS	= clean \
+				  dist-clean \
+				  grade \
+				  touch \
+				  print-.+ \
+				  run-.+ \
+				  build-.+ \
+				  handin
+
+ifeq ($(call match,$(MAKECMDGOALS),$(IGNORE_ALLDEPS)),0)
+-include $(ALLDEPS)
+endif
+
+# files for grade script
+
+TARGETS: $(TARGETS)
+
+.DEFAULT_GOAL := TARGETS
+
+QEMUOPTS = -hda $(UCOREIMG) -drive file=$(SWAPIMG),media=disk,cache=writeback
+
+.PHONY: qemu qemu-nox debug debug-nox
+qemu-mon: $(UCOREIMG) $(SWAPIMG)
+	$(V)$(QEMU)  -no-reboot -monitor stdio $(QEMUOPTS) -serial null
+qemu: $(UCOREIMG) $(SWAPIMG)
+	$(V)$(QEMU)  -no-reboot -parallel stdio $(QEMUOPTS) -serial null
+
+qemu-nox: $(UCOREIMG) $(SWAPIMG)
+	$(V)$(QEMU)  -no-reboot -serial mon:stdio $(QEMUOPTS) -nographic
+
+TERMINAL := gnome-terminal
+
+debug: $(UCOREIMG) $(SWAPIMG)
+	$(V)$(QEMU) -S -s -parallel stdio $(QEMUOPTS) -serial null &
+	$(V)sleep 2
+	$(V)$(TERMINAL) -e "$(GDB) -q -x tools/gdbinit"
+
+debug-nox: $(UCOREIMG) $(SWAPIMG)
+	$(V)$(QEMU) -S -s -serial mon:stdio $(QEMUOPTS) -nographic &
+	$(V)sleep 2
+	$(V)$(TERMINAL) -e "$(GDB) -q -x tools/gdbinit"
+
+RUN_PREFIX	:= _binary_$(OBJDIR)_$(USER_PREFIX)
+MAKEOPTS	:= --quiet --no-print-directory
+
+run-%: build-%
+	$(V)$(QEMU) -parallel stdio $(QEMUOPTS) -serial null
+
+run-nox-%: build-%
+	$(V)$(QEMU) -serial mon:stdio $(QEMUOPTS) -nographic
+
+build-%: touch
+	$(V)$(MAKE) $(MAKEOPTS) "DEFS+=-DTEST=$* -DTESTSTART=$(RUN_PREFIX)$*_out_start -DTESTSIZE=$(RUN_PREFIX)$*_out_size"
+
+.PHONY: grade touch
+
+GRADE_GDB_IN	:= .gdb.in
+GRADE_QEMU_OUT	:= .qemu.out
+HANDIN			:= lab$(PROJ)-handin.tar.gz
+
+TOUCH_FILES		:= kern/process/proc.c
+
+MAKEOPTS		:= --quiet --no-print-directory
+
+grade:
+	$(V)$(MAKE) $(MAKEOPTS) clean
+	$(V)$(SH) tools/grade.sh
+
+touch:
+	$(V)$(foreach f,$(TOUCH_FILES),$(TOUCH) $(f))
+
+print-%:
+	@echo $($(shell echo $(patsubst print-%,%,$@) | $(TR) [a-z] [A-Z]))
+
+.PHONY: clean dist-clean handin packall tags
+clean:
+	$(V)$(RM) $(GRADE_GDB_IN) $(GRADE_QEMU_OUT) cscope* tags
+	-$(RM) -r $(OBJDIR) $(BINDIR)
+
+dist-clean: clean
+	-$(RM) $(HANDIN)
+
+handin: packall
+	@echo Please visit http://learn.tsinghua.edu.cn and upload $(HANDIN). Thanks!
+
+packall: clean
+	@$(RM) -f $(HANDIN)
+	@tar -czf $(HANDIN) `find . -type f -o -type d | grep -v '^\.*$$' | grep -vF '$(HANDIN)'`
+
+tags:
+	@echo TAGS ALL
+	$(V)rm -f cscope.files cscope.in.out cscope.out cscope.po.out tags
+	$(V)find . -type f -name "*.[chS]" >cscope.files
+	$(V)cscope -bq 
+	$(V)ctags -L cscope.files
diff -r -u -P lab6_origin/.matrix.log lab6/.matrix.log
--- lab6_origin/.matrix.log	1970-01-01 08:00:00.000000000 +0800
+++ lab6/.matrix.log	2019-05-13 17:41:09.408124800 +0800
@@ -0,0 +1,154 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc010b8ec (phys)
+  edata  0xc01b0000 (phys)
+  end    0xc01b3178 (phys)
+Kernel executable memory footprint: 717KB
+ebp:0xc012bf48 eip:0xc0100b65 args:0x00010094 0x00010094 0xc012bf78 0xc01000d1 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc012bf58 eip:0xc0100e65 args:0x00000000 0x00000000 0x00000000 0xc012bfc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc012bf78 eip:0xc01000d1 args:0x00000000 0xc012bfa0 0xffff0000 0xc012bfa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc012bf98 eip:0xc01000f3 args:0x00000000 0xffff0000 0xc012bfc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc012bfb8 eip:0xc0100110 args:0x00000000 0xc0100036 0xffff0000 0xc0100079 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc012bfd8 eip:0xc0100131 args:0x00000000 0x00000000 0x00000000 0xc010b900 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc012bff8 eip:0xc0100086 args:0xc010bafc 0xc010bb04 0xc0100dee 0xc010bb23 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 31818, total 31818
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 5, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+kernel_execve: pid = 2, name = "matrix".
+fork ok.
+pid 3 is running (1000 times)!.
+pid 5 is running (1100 times)!.
+pid 4 is running (1000 times)!.
+pid 7 is running (4600 times)!.
+pid 9 is running (20600 times)!.
+pid 11 is running (2600 times)!.
+pid 13 is running (37100 times)!.
+pid 15 is running (23500 times)!.
+pid 17 is running (23500 times)!.
+pid 19 is running (33400 times)!.
+pid 21 is running (2600 times)!.
+pid 22 is running (26600 times)!.
+pid 6 is running (1900 times)!.
+pid 8 is running (11000 times)!.
+pid 10 is running (37100 times)!.
+pid 12 is running (13100 times)!.
+pid 14 is running (4600 times)!.
+pid 16 is running (2600 times)!.
+pid 18 is running (4600 times)!.
+pid 20 is running (13100 times)!.
+pid 23 is running (13100 times)!.
+pid 6 done!.
+pid 4 done!.
+pid 3 done!.
+pid 5 done!.
+pid 11 done!.
+pid 21 done!.
+pid 16 done!.
+pid 14 done!.
+pid 7 done!.
+pid 18 done!.
+pid 8 done!.
+pid 20 done!.
+pid 12 done!.
+pid 23 done!.
+pid 9 done!.
+pid 15 done!.
+pid 17 done!.
+pid 22 done!.
+pid 19 done!.
+pid 10 done!.
+pid 13 done!.
+matrix pass.
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:477:
+    initproc exit.
+
+stack trackback:
+ebp:0xc0395f98 eip:0xc0100b65 args:0x00000018 0x00000000 0x00000000 0xc0395fcc 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc0395fb8 eip:0xc0100461 args:0xc010d994 0x000001dd 0xc010d9e6 0x00000000 
+    kern/debug/panic.c:27: __panic+107
+ebp:0xc0395fe8 eip:0xc0109511 args:0x00000000 0x00000000 0x00000000 0x00000010 
+    kern/process/proc.c:477: do_exit+81
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -r -u -P lab6_origin/note.md lab6/note.md
--- lab6_origin/note.md	1970-01-01 08:00:00.000000000 +0800
+++ lab6/note.md	2019-05-06 22:06:11.974276700 +0800
@@ -0,0 +1,167 @@
+# 处理机调度
+## 处理机调度概念
+进程切换是CPU资源的当前占用者的切换，保存当前进程在PCB中的执行上下文（CPU状态），恢复下一个进程的执行上下文。
+
+处理机调度是从就绪队列中找一个占用CPU的进程，从多个可用CPU中挑选就绪进程可使用的CPU资源。
+
+## 调度准则
+### 调度时机
+操作系统维护进程的状态序列。进程从运行状态切换到等待状态，这样CPU就空闲了，或者进程被终结了，CPU又空闲了。这两种情况对应着非抢占系统，当前进程主动放弃CPU。对可抢占系统，中断请求被服务例程响应完成，或当前进程因为时间片用完时会被抢占，进程从等待切换到就绪，这时更急迫的想占用CPU，也会发生抢占。
+
+### 调度策略
+进程在CPU计算和IO操作间交替，在时间片机制下，进程可能在结束当前CPU计算之前就被迫放弃CPU。
+
+CPU使用率：CPU处于忙状态的时间百分比。
+
+吞吐率：单位时间内完成的进程数量
+
+周转时间：进程从初始化到结束（包括等待）的时间
+
+等待时间：进程在就绪队列中的时间
+
+响应时间：从提交请求到产生相应所花费的时间
+
+调度算法希望“更快”的服务。
+
+响应时间目标：
+- 减少相应时间，及时处理输入请求
+- 减少平均响应时间的波动，提高可预测性
+- 低延迟调度改善了交互体验
+
+吞吐量目标：
+- 增加吞吐量，减少开销（操作系统开销，上下文切换）
+- 系统资源的高效利用（CPU、IO）
+- 减少等待时间，提高响应性能和吞吐量性能
+- 吞吐量是系统的计算带宽
+
+公平性目标：
+- 保证每个进程占用相同的CPU时间
+- 公平通常会增加响应时间
+
+## 先来先服务、短进程优先和最高响应比优先调度算法
+### 先来先服务
+按照就绪队列的先后顺序排列，进程进入等待或结束状态时，就绪队列中的下一个进程占用CPU。
+
+周转时间：每个进程的平均总时间（等待+执行）
+
+优点：简单，排队依据容易获得。
+
+缺点： 平均等待时间波动大，排队位置对算法影响大，IO和CPU资源利用效率低。
+
+### 短进程优先
+考虑进程的特征，选择就绪队列中执行时间最短进程占用CPU进入运行状态。它具有最好的平均周转时间。
+
+但可能导致饥饿，连续的短进程会使长进程无法获得CPU资源。且需要预知未来，可以用历史执行时间预估未来的执行时间。
+
+### 最高响应比优先
+考虑进程在就绪队列中的等待时间。选择就绪队列中响应比R最高的进程。`R = (w + s) / s`，w是等待时间，s是执行时间。这种算法基于短进程优先算法，不可抢占，关注了进程等待时间，以防止无限等待。
+
+## 时间片轮转、多级反馈队列、公平共享调度算法和ucore调度框架
+### 时间片轮转
+时间片是分配处理机资源的基本时间单元，各个进程占用一个时间片，仍按照先来先服务策略，时间片结束时按照先来先服务切换到下一个就绪进程，每隔(n-1)个时间片进程执行一个时间片。
+
+时间片太大的话，等待时间过长，退化成先来先服务；若太短，产生了大量上下文切换，影响系统吞吐量。
+
+这时需要选择一个合适的时间片长度。
+
+### 多级反馈队列
+就绪队列排成多个子队列，不同队列可以有不同算法，进程可以在队列之间转换。队列间的调度可以采用时间片方法。
+
+多级反馈队列：进程在不同队列间移动的多级队列算法。时间片大小随优先级级别增加而增加，如进程在当前的时间片没有完成，则降到下一个优先级。CPU密集型的进程优先级下降很快，这样时间片会增大，IO密集型的则优先级上升。
+
+### 公平共享调度算法
+注重资源访问的公平，一些用户比另一些用户重要，保证不重要的组无法垄断资源。未使用的资源按照比例分配，没有达到资源使用率目标的组获得更高的优先级。
+
+### uCore的调度队列run_queue
+```
+struct run_queue{
+	list_entry_t run_list;
+	unsigned int proc_num;
+	int max_time_slice;
+	list_entry_t rq_link;
+}
+```
+
+## 实时调度和多处理器调度
+实时调度对时间有要求，实时操作系统的正确性以来其时间和功能两方面，其性能指标是时间约束的及时性。
+
+周期实时任务：一系列相似任务，任务有规律的重复，周期p=任务请求时间间隔，执行时间e=最大执行时间，使用率U=e/p。
+
+硬实时是指错过任务时限会导致灾难性或非常严重的后果，必须验证，在最坏情况下能满足时限。软实时是指尽量满足任务时限。
+
+可调度性：一个实时操作系统能满足任务时限要求。需要确定实时任务的执行顺序。静态/动态优先级调度。
+
+速率单调调度算法（静态）：通过周期安排优先级，周期越短优先级越高，执行周期最短的任务；
+
+最早截止时间优先算法（动态）：截止时间越早优先级越高，执行截止时间最早的任务。
+
+### 多处理器调度
+针对多个处理机，一条系统总线连接多个物理CPU，一个CPU可能有几个逻辑CPU，处理机之间可以负载共享。
+
+对阵多处理机（SMP）调度：每个处理器运行自己的调度程序，调度程序对共享资源的访问需要同步。
+
+静态进程分配：进程开始执行到结束都被分配到一个固定的处理机上，每个处理机都有自己的就绪队列，调度开销小，但各个处理机可能忙闲不均。
+
+动态进程分配：进程在执行中可以分配到任意空闲处理机执行，所有处理机共享一个公共的就绪队列，调度开销大，各个处理机的负载是均衡的。
+
+## 优先级反置
+操作系统中出现高优先级进程长时间等待低优先级进程所占用的资源，而导致高优先级进程长时间等待的现象。
+
+优先级继承：占用资源的低优先级进程继承申请资源的高优先级进程的优先级。只有占有资源的低优先级进程被阻塞时才能提高占有资源进程的优先级。
+
+优先级天花板协议：占有资源进程的优先级和所有可能申请该资源的进程的最高优先级相同，不管是否发生等待，都提升占有资源进程的优先级。优先级高于系统中所有被锁定的资源的优先级上限，任务执行临界区就不会被阻塞。
+
+# 实验六 调度器
+## 16.1 总体介绍和调度过程
+在lab5中，完成了用户进程的管理。lab6中完成了调度的初始化和调度过程。
+实现一个调度类，绑定调度类（类似于多态或重载），设定调度点，触发调度时间，调整调度参数和调用调度算法，实现选择新进程和完成进程切换。
+
+把当前进程放到就绪队列中，在就绪队列中选取一个适合的进程，出队然后完成切换。
+
+## 16.2 调度算法支撑框架
+调度点：出发做调度相关的工作
+
+位置|原因
+---|---
+proc.c:do_exit|用户线程执行结束，主动放弃CPU
+proc.c:do_wait|用户线程等待着子进程结束，主动放弃CPU
+proc.c:init_main|Init_porc内核线程等待所有用户进程结束；所有用户进程结束后回收系统资源
+proc.c:cpu_idle|idleproc内核线程等待处于就绪态的进程或线程，如果有选择一个并切换
+sync.h:lock|进程无法得到锁，则主动放弃CPU
+trap.c:trap|修改当前进程时间片，若时间片用完，则设置need_resched为1，让当前进程放弃CPU
+
+进入/离开就绪队列的机制：
+- 抽象数据结构，可以不是队列；
+- 可根据调度算法的需求采用多种数据结构
+
+schedule是一个总控函数，如果当前进程是 RUNNABLE会调用sched_class_enqueue，放到就绪队列中。
+
+## 16.3 时间片轮转调度算法（RR调度算法）
+前边介绍完成一个sched_class，
+
+RR_init{
+	list_init;
+	run_queue->proc_num = 0;
+}
+
+在产生时钟中断时调用
+RR_proc_tick{
+	if(proc->time_slice > 0)
+		proc->time_slice --;
+	if(proc->time_slice == 0)
+		proc->need_resched = 1;
+}
+一旦标志位为1，则说明需要调度了
+
+当有一个进程需要进队列，则调用list_add_before，如果要选择一个进程，则选择一个尾list_next
+
+## 16.4 Stride调度算法
+如果有三个进程，每个进程有2个属性，stride表示现在执行到什么地方，数字大小表示执行进度；pass表示一次前进的步数。
+
+选择当前步长最小的一个进程，执行目标是当前步长加path。
+
+它是基于优先级的且每一步的调度策略是特定的。
+
+可以使用priority_queue实现，又可以用Skew heap（斜堆）的优先队列实现。
+
+stride在不停累加下如何正确判断最大最小？uint32_t！
\ No newline at end of file
diff -r -u -P lab6_origin/obj/boot/bootasm.d lab6/obj/boot/bootasm.d
--- lab6_origin/obj/boot/bootasm.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/boot/bootasm.d	2019-05-13 17:39:38.558942500 +0800
@@ -0,0 +1 @@
+obj/boot/bootasm.o obj/boot/bootasm.d: boot/bootasm.S boot/asm.h
Binary files lab6_origin/obj/boot/bootasm.o and lab6/obj/boot/bootasm.o differ
diff -r -u -P lab6_origin/obj/boot/bootmain.d lab6/obj/boot/bootmain.d
--- lab6_origin/obj/boot/bootmain.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/boot/bootmain.d	2019-05-13 17:39:38.514967500 +0800
@@ -0,0 +1,2 @@
+obj/boot/bootmain.o obj/boot/bootmain.d: boot/bootmain.c libs/defs.h \
+ libs/x86.h libs/elf.h
Binary files lab6_origin/obj/boot/bootmain.o and lab6/obj/boot/bootmain.o differ
diff -r -u -P lab6_origin/obj/bootblock.asm lab6/obj/bootblock.asm
--- lab6_origin/obj/bootblock.asm	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/bootblock.asm	2019-05-13 17:39:48.134475400 +0800
@@ -0,0 +1,406 @@
+
+obj/bootblock.o:     file format elf32-i386
+
+
+Disassembly of section .startup:
+
+00007c00 <start>:
+
+# start address should be 0:7c00, in real mode, the beginning address of the running bootloader
+.globl start
+start:
+.code16                                             # Assemble for 16-bit mode
+    cli                                             # Disable interrupts
+    7c00:	fa                   	cli    
+    cld                                             # String operations increment
+    7c01:	fc                   	cld    
+
+    # Set up the important data segment registers (DS, ES, SS).
+    xorw %ax, %ax                                   # Segment number zero
+    7c02:	31 c0                	xor    %eax,%eax
+    movw %ax, %ds                                   # -> Data Segment
+    7c04:	8e d8                	mov    %eax,%ds
+    movw %ax, %es                                   # -> Extra Segment
+    7c06:	8e c0                	mov    %eax,%es
+    movw %ax, %ss                                   # -> Stack Segment
+    7c08:	8e d0                	mov    %eax,%ss
+
+00007c0a <seta20.1>:
+    # Enable A20:
+    #  For backwards compatibility with the earliest PCs, physical
+    #  address line 20 is tied low, so that addresses higher than
+    #  1MB wrap around to zero by default. This code undoes this.
+seta20.1:
+    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
+    7c0a:	e4 64                	in     $0x64,%al
+    testb $0x2, %al
+    7c0c:	a8 02                	test   $0x2,%al
+    jnz seta20.1
+    7c0e:	75 fa                	jne    7c0a <seta20.1>
+
+    movb $0xd1, %al                                 # 0xd1 -> port 0x64
+    7c10:	b0 d1                	mov    $0xd1,%al
+    outb %al, $0x64                                 # 0xd1 means: write data to 8042's P2 port
+    7c12:	e6 64                	out    %al,$0x64
+
+00007c14 <seta20.2>:
+
+seta20.2:
+    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
+    7c14:	e4 64                	in     $0x64,%al
+    testb $0x2, %al
+    7c16:	a8 02                	test   $0x2,%al
+    jnz seta20.2
+    7c18:	75 fa                	jne    7c14 <seta20.2>
+
+    movb $0xdf, %al                                 # 0xdf -> port 0x60
+    7c1a:	b0 df                	mov    $0xdf,%al
+    outb %al, $0x60                                 # 0xdf = 11011111, means set P2's A20 bit(the 1 bit) to 1
+    7c1c:	e6 60                	out    %al,$0x60
+
+00007c1e <probe_memory>:
+
+probe_memory:
+    movl $0, 0x8000
+    7c1e:	66 c7 06 00 80       	movw   $0x8000,(%esi)
+    7c23:	00 00                	add    %al,(%eax)
+    7c25:	00 00                	add    %al,(%eax)
+    xorl %ebx, %ebx
+    7c27:	66 31 db             	xor    %bx,%bx
+    movw $0x8004, %di
+    7c2a:	bf                   	.byte 0xbf
+    7c2b:	04 80                	add    $0x80,%al
+
+00007c2d <start_probe>:
+start_probe:
+    movl $0xE820, %eax
+    7c2d:	66 b8 20 e8          	mov    $0xe820,%ax
+    7c31:	00 00                	add    %al,(%eax)
+    movl $20, %ecx
+    7c33:	66 b9 14 00          	mov    $0x14,%cx
+    7c37:	00 00                	add    %al,(%eax)
+    movl $SMAP, %edx
+    7c39:	66 ba 50 41          	mov    $0x4150,%dx
+    7c3d:	4d                   	dec    %ebp
+    7c3e:	53                   	push   %ebx
+    int $0x15
+    7c3f:	cd 15                	int    $0x15
+    jnc cont
+    7c41:	73 08                	jae    7c4b <cont>
+    movw $12345, 0x8000
+    7c43:	c7 06 00 80 39 30    	movl   $0x30398000,(%esi)
+    jmp finish_probe
+    7c49:	eb 0e                	jmp    7c59 <finish_probe>
+
+00007c4b <cont>:
+cont:
+    addw $20, %di
+    7c4b:	83 c7 14             	add    $0x14,%edi
+    incl 0x8000
+    7c4e:	66 ff 06             	incw   (%esi)
+    7c51:	00 80 66 83 fb 00    	add    %al,0xfb8366(%eax)
+    cmpl $0, %ebx
+    jnz start_probe
+    7c57:	75 d4                	jne    7c2d <start_probe>
+
+00007c59 <finish_probe>:
+
+    # Switch from real to protected mode, using a bootstrap GDT
+    # and segment translation that makes virtual addresses
+    # identical to physical addresses, so that the
+    # effective memory map does not change during the switch.
+    lgdt gdtdesc
+    7c59:	0f 01 16             	lgdtl  (%esi)
+    7c5c:	b4 7d                	mov    $0x7d,%ah
+    movl %cr0, %eax
+    7c5e:	0f 20 c0             	mov    %cr0,%eax
+    orl $CR0_PE_ON, %eax
+    7c61:	66 83 c8 01          	or     $0x1,%ax
+    movl %eax, %cr0
+    7c65:	0f 22 c0             	mov    %eax,%cr0
+
+    # Jump to next instruction, but in 32-bit code segment.
+    # Switches processor into 32-bit mode.
+    ljmp $PROT_MODE_CSEG, $protcseg
+    7c68:	ea                   	.byte 0xea
+    7c69:	6d                   	insl   (%dx),%es:(%edi)
+    7c6a:	7c 08                	jl     7c74 <protcseg+0x7>
+	...
+
+00007c6d <protcseg>:
+
+.code32                                             # Assemble for 32-bit mode
+protcseg:
+    # Set up the protected-mode data segment registers
+    movw $PROT_MODE_DSEG, %ax                       # Our data segment selector
+    7c6d:	66 b8 10 00          	mov    $0x10,%ax
+    movw %ax, %ds                                   # -> DS: Data Segment
+    7c71:	8e d8                	mov    %eax,%ds
+    movw %ax, %es                                   # -> ES: Extra Segment
+    7c73:	8e c0                	mov    %eax,%es
+    movw %ax, %fs                                   # -> FS
+    7c75:	8e e0                	mov    %eax,%fs
+    movw %ax, %gs                                   # -> GS
+    7c77:	8e e8                	mov    %eax,%gs
+    movw %ax, %ss                                   # -> SS: Stack Segment
+    7c79:	8e d0                	mov    %eax,%ss
+
+    # Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00)
+    movl $0x0, %ebp
+    7c7b:	bd 00 00 00 00       	mov    $0x0,%ebp
+    movl $start, %esp
+    7c80:	bc 00 7c 00 00       	mov    $0x7c00,%esp
+    call bootmain
+    7c85:	e8 9d 00 00 00       	call   7d27 <bootmain>
+
+00007c8a <spin>:
+
+    # If bootmain returns (it shouldn't), loop.
+spin:
+    jmp spin
+    7c8a:	eb fe                	jmp    7c8a <spin>
+
+Disassembly of section .text:
+
+00007c8c <readseg>:
+/* *
+ * readseg - read @count bytes at @offset from kernel into virtual address @va,
+ * might copy more than asked.
+ * */
+static void
+readseg(uintptr_t va, uint32_t count, uint32_t offset) {
+    7c8c:	55                   	push   %ebp
+    7c8d:	89 e5                	mov    %esp,%ebp
+    7c8f:	57                   	push   %edi
+    uintptr_t end_va = va + count;
+    7c90:	8d 3c 10             	lea    (%eax,%edx,1),%edi
+
+    // round down to sector boundary
+    va -= offset % SECTSIZE;
+    7c93:	89 ca                	mov    %ecx,%edx
+
+    // translate from bytes to sectors; kernel starts at sector 1
+    uint32_t secno = (offset / SECTSIZE) + 1;
+    7c95:	c1 e9 09             	shr    $0x9,%ecx
+/* *
+ * readseg - read @count bytes at @offset from kernel into virtual address @va,
+ * might copy more than asked.
+ * */
+static void
+readseg(uintptr_t va, uint32_t count, uint32_t offset) {
+    7c98:	56                   	push   %esi
+    uintptr_t end_va = va + count;
+
+    // round down to sector boundary
+    va -= offset % SECTSIZE;
+    7c99:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
+
+    // translate from bytes to sectors; kernel starts at sector 1
+    uint32_t secno = (offset / SECTSIZE) + 1;
+    7c9f:	8d 71 01             	lea    0x1(%ecx),%esi
+/* *
+ * readseg - read @count bytes at @offset from kernel into virtual address @va,
+ * might copy more than asked.
+ * */
+static void
+readseg(uintptr_t va, uint32_t count, uint32_t offset) {
+    7ca2:	53                   	push   %ebx
+    uintptr_t end_va = va + count;
+
+    // round down to sector boundary
+    va -= offset % SECTSIZE;
+    7ca3:	29 d0                	sub    %edx,%eax
+/* *
+ * readseg - read @count bytes at @offset from kernel into virtual address @va,
+ * might copy more than asked.
+ * */
+static void
+readseg(uintptr_t va, uint32_t count, uint32_t offset) {
+    7ca5:	53                   	push   %ebx
+    uintptr_t end_va = va + count;
+    7ca6:	89 7d f0             	mov    %edi,-0x10(%ebp)
+
+    // round down to sector boundary
+    va -= offset % SECTSIZE;
+    7ca9:	89 c3                	mov    %eax,%ebx
+    uint32_t secno = (offset / SECTSIZE) + 1;
+
+    // If this is too slow, we could read lots of sectors at a time.
+    // We'd write more to memory than asked, but it doesn't matter --
+    // we load in increasing order.
+    for (; va < end_va; va += SECTSIZE, secno ++) {
+    7cab:	3b 5d f0             	cmp    -0x10(%ebp),%ebx
+    7cae:	73 71                	jae    7d21 <readseg+0x95>
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+    7cb0:	ba f7 01 00 00       	mov    $0x1f7,%edx
+    7cb5:	ec                   	in     (%dx),%al
+#define ELFHDR          ((struct elfhdr *)0x10000)      // scratch space
+
+/* waitdisk - wait for disk ready */
+static void
+waitdisk(void) {
+    while ((inb(0x1F7) & 0xC0) != 0x40)
+    7cb6:	83 e0 c0             	and    $0xffffffc0,%eax
+    7cb9:	3c 40                	cmp    $0x40,%al
+    7cbb:	75 f3                	jne    7cb0 <readseg+0x24>
+        : "memory", "cc");
+}
+
+static inline void
+outb(uint16_t port, uint8_t data) {
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
+    7cbd:	ba f2 01 00 00       	mov    $0x1f2,%edx
+    7cc2:	b0 01                	mov    $0x1,%al
+    7cc4:	ee                   	out    %al,(%dx)
+    7cc5:	ba f3 01 00 00       	mov    $0x1f3,%edx
+    7cca:	89 f0                	mov    %esi,%eax
+    7ccc:	ee                   	out    %al,(%dx)
+    7ccd:	89 f0                	mov    %esi,%eax
+    7ccf:	ba f4 01 00 00       	mov    $0x1f4,%edx
+    7cd4:	c1 e8 08             	shr    $0x8,%eax
+    7cd7:	ee                   	out    %al,(%dx)
+    7cd8:	89 f0                	mov    %esi,%eax
+    7cda:	ba f5 01 00 00       	mov    $0x1f5,%edx
+    7cdf:	c1 e8 10             	shr    $0x10,%eax
+    7ce2:	ee                   	out    %al,(%dx)
+    7ce3:	89 f0                	mov    %esi,%eax
+    7ce5:	ba f6 01 00 00       	mov    $0x1f6,%edx
+    7cea:	c1 e8 18             	shr    $0x18,%eax
+    7ced:	83 e0 0f             	and    $0xf,%eax
+    7cf0:	83 c8 e0             	or     $0xffffffe0,%eax
+    7cf3:	ee                   	out    %al,(%dx)
+    7cf4:	b0 20                	mov    $0x20,%al
+    7cf6:	ba f7 01 00 00       	mov    $0x1f7,%edx
+    7cfb:	ee                   	out    %al,(%dx)
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+    7cfc:	ba f7 01 00 00       	mov    $0x1f7,%edx
+    7d01:	ec                   	in     (%dx),%al
+    7d02:	83 e0 c0             	and    $0xffffffc0,%eax
+    7d05:	3c 40                	cmp    $0x40,%al
+    7d07:	75 f3                	jne    7cfc <readseg+0x70>
+    return data;
+}
+
+static inline void
+insl(uint32_t port, void *addr, int cnt) {
+    asm volatile (
+    7d09:	89 df                	mov    %ebx,%edi
+    7d0b:	b9 80 00 00 00       	mov    $0x80,%ecx
+    7d10:	ba f0 01 00 00       	mov    $0x1f0,%edx
+    7d15:	fc                   	cld    
+    7d16:	f2 6d                	repnz insl (%dx),%es:(%edi)
+    uint32_t secno = (offset / SECTSIZE) + 1;
+
+    // If this is too slow, we could read lots of sectors at a time.
+    // We'd write more to memory than asked, but it doesn't matter --
+    // we load in increasing order.
+    for (; va < end_va; va += SECTSIZE, secno ++) {
+    7d18:	81 c3 00 02 00 00    	add    $0x200,%ebx
+    7d1e:	46                   	inc    %esi
+    7d1f:	eb 8a                	jmp    7cab <readseg+0x1f>
+        readsect((void *)va, secno);
+    }
+}
+    7d21:	58                   	pop    %eax
+    7d22:	5b                   	pop    %ebx
+    7d23:	5e                   	pop    %esi
+    7d24:	5f                   	pop    %edi
+    7d25:	5d                   	pop    %ebp
+    7d26:	c3                   	ret    
+
+00007d27 <bootmain>:
+
+/* bootmain - the entry of bootloader */
+void
+bootmain(void) {
+    7d27:	55                   	push   %ebp
+    // read the 1st page off disk
+    readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);
+    7d28:	31 c9                	xor    %ecx,%ecx
+    7d2a:	ba 00 10 00 00       	mov    $0x1000,%edx
+    7d2f:	b8 00 00 01 00       	mov    $0x10000,%eax
+    }
+}
+
+/* bootmain - the entry of bootloader */
+void
+bootmain(void) {
+    7d34:	89 e5                	mov    %esp,%ebp
+    7d36:	56                   	push   %esi
+    7d37:	53                   	push   %ebx
+    // read the 1st page off disk
+    readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);
+    7d38:	e8 4f ff ff ff       	call   7c8c <readseg>
+
+    // is this a valid ELF?
+    if (ELFHDR->e_magic != ELF_MAGIC) {
+    7d3d:	81 3d 00 00 01 00 7f 	cmpl   $0x464c457f,0x10000
+    7d44:	45 4c 46 
+    7d47:	75 3f                	jne    7d88 <bootmain+0x61>
+    }
+
+    struct proghdr *ph, *eph;
+
+    // load each program segment (ignores ph flags)
+    ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR->e_phoff);
+    7d49:	a1 1c 00 01 00       	mov    0x1001c,%eax
+    eph = ph + ELFHDR->e_phnum;
+    7d4e:	0f b7 35 2c 00 01 00 	movzwl 0x1002c,%esi
+    }
+
+    struct proghdr *ph, *eph;
+
+    // load each program segment (ignores ph flags)
+    ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR->e_phoff);
+    7d55:	8d 98 00 00 01 00    	lea    0x10000(%eax),%ebx
+    eph = ph + ELFHDR->e_phnum;
+    7d5b:	c1 e6 05             	shl    $0x5,%esi
+    7d5e:	01 de                	add    %ebx,%esi
+    for (; ph < eph; ph ++) {
+    7d60:	39 f3                	cmp    %esi,%ebx
+    7d62:	73 18                	jae    7d7c <bootmain+0x55>
+        readseg(ph->p_va & 0xFFFFFF, ph->p_memsz, ph->p_offset);
+    7d64:	8b 43 08             	mov    0x8(%ebx),%eax
+    7d67:	8b 4b 04             	mov    0x4(%ebx),%ecx
+    struct proghdr *ph, *eph;
+
+    // load each program segment (ignores ph flags)
+    ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR->e_phoff);
+    eph = ph + ELFHDR->e_phnum;
+    for (; ph < eph; ph ++) {
+    7d6a:	83 c3 20             	add    $0x20,%ebx
+        readseg(ph->p_va & 0xFFFFFF, ph->p_memsz, ph->p_offset);
+    7d6d:	8b 53 f4             	mov    -0xc(%ebx),%edx
+    7d70:	25 ff ff ff 00       	and    $0xffffff,%eax
+    7d75:	e8 12 ff ff ff       	call   7c8c <readseg>
+    7d7a:	eb e4                	jmp    7d60 <bootmain+0x39>
+    }
+
+    // call the entry point from the ELF header
+    // note: does not return
+    ((void (*)(void))(ELFHDR->e_entry & 0xFFFFFF))();
+    7d7c:	a1 18 00 01 00       	mov    0x10018,%eax
+    7d81:	25 ff ff ff 00       	and    $0xffffff,%eax
+    7d86:	ff d0                	call   *%eax
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
+}
+
+static inline void
+outw(uint16_t port, uint16_t data) {
+    asm volatile ("outw %0, %1" :: "a" (data), "d" (port) : "memory");
+    7d88:	ba 00 8a ff ff       	mov    $0xffff8a00,%edx
+    7d8d:	89 d0                	mov    %edx,%eax
+    7d8f:	66 ef                	out    %ax,(%dx)
+    7d91:	b8 00 8e ff ff       	mov    $0xffff8e00,%eax
+    7d96:	66 ef                	out    %ax,(%dx)
+    7d98:	eb fe                	jmp    7d98 <bootmain+0x71>
Binary files lab6_origin/obj/bootblock.o and lab6/obj/bootblock.o differ
Binary files lab6_origin/obj/bootblock.out and lab6/obj/bootblock.out differ
diff -r -u -P lab6_origin/obj/kern/debug/kdebug.d lab6/obj/kern/debug/kdebug.d
--- lab6_origin/obj/kern/debug/kdebug.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/kern/debug/kdebug.d	2019-05-13 17:39:38.010257600 +0800
@@ -0,0 +1,6 @@
+obj/kern/debug/kdebug.o obj/kern/debug/kdebug.d: kern/debug/kdebug.c \
+ libs/defs.h libs/x86.h kern/debug/stab.h libs/stdio.h libs/stdarg.h \
+ libs/string.h kern/mm/memlayout.h libs/atomic.h libs/list.h \
+ kern/sync/sync.h kern/driver/intr.h kern/mm/mmu.h kern/debug/assert.h \
+ kern/schedule/sched.h libs/skew_heap.h kern/mm/vmm.h kern/process/proc.h \
+ kern/trap/trap.h kern/debug/kdebug.h kern/debug/kmonitor.h
Binary files lab6_origin/obj/kern/debug/kdebug.o and lab6/obj/kern/debug/kdebug.o differ
diff -r -u -P lab6_origin/obj/kern/debug/kmonitor.d lab6/obj/kern/debug/kmonitor.d
--- lab6_origin/obj/kern/debug/kmonitor.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/kern/debug/kmonitor.d	2019-05-13 17:39:37.909315600 +0800
@@ -0,0 +1,4 @@
+obj/kern/debug/kmonitor.o obj/kern/debug/kmonitor.d: \
+ kern/debug/kmonitor.c libs/stdio.h libs/defs.h libs/stdarg.h \
+ libs/string.h kern/mm/mmu.h kern/trap/trap.h kern/debug/kmonitor.h \
+ kern/debug/kdebug.h
Binary files lab6_origin/obj/kern/debug/kmonitor.o and lab6/obj/kern/debug/kmonitor.o differ
diff -r -u -P lab6_origin/obj/kern/debug/panic.d lab6/obj/kern/debug/panic.d
--- lab6_origin/obj/kern/debug/panic.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/kern/debug/panic.d	2019-05-13 17:39:38.289097300 +0800
@@ -0,0 +1,3 @@
+obj/kern/debug/panic.o obj/kern/debug/panic.d: kern/debug/panic.c \
+ libs/defs.h libs/stdio.h libs/stdarg.h kern/driver/intr.h \
+ kern/debug/kmonitor.h kern/trap/trap.h
Binary files lab6_origin/obj/kern/debug/panic.o and lab6/obj/kern/debug/panic.o differ
diff -r -u -P lab6_origin/obj/kern/driver/clock.d lab6/obj/kern/driver/clock.d
--- lab6_origin/obj/kern/driver/clock.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/kern/driver/clock.d	2019-05-13 17:39:38.067224600 +0800
@@ -0,0 +1,3 @@
+obj/kern/driver/clock.o obj/kern/driver/clock.d: kern/driver/clock.c \
+ libs/x86.h libs/defs.h kern/trap/trap.h libs/stdio.h libs/stdarg.h \
+ kern/driver/picirq.h
Binary files lab6_origin/obj/kern/driver/clock.o and lab6/obj/kern/driver/clock.o differ
diff -r -u -P lab6_origin/obj/kern/driver/console.d lab6/obj/kern/driver/console.d
--- lab6_origin/obj/kern/driver/console.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/kern/driver/console.d	2019-05-13 17:39:37.788384900 +0800
@@ -0,0 +1,6 @@
+obj/kern/driver/console.o obj/kern/driver/console.d: \
+ kern/driver/console.c libs/defs.h libs/x86.h libs/stdio.h libs/stdarg.h \
+ libs/string.h kern/driver/kbdreg.h kern/driver/picirq.h kern/trap/trap.h \
+ kern/mm/memlayout.h libs/atomic.h libs/list.h kern/sync/sync.h \
+ kern/driver/intr.h kern/mm/mmu.h kern/debug/assert.h \
+ kern/schedule/sched.h libs/skew_heap.h
Binary files lab6_origin/obj/kern/driver/console.o and lab6/obj/kern/driver/console.o differ
diff -r -u -P lab6_origin/obj/kern/driver/ide.d lab6/obj/kern/driver/ide.d
--- lab6_origin/obj/kern/driver/ide.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/kern/driver/ide.d	2019-05-13 17:39:38.034243400 +0800
@@ -0,0 +1,4 @@
+obj/kern/driver/ide.o obj/kern/driver/ide.d: kern/driver/ide.c \
+ libs/defs.h libs/stdio.h libs/stdarg.h kern/trap/trap.h \
+ kern/driver/picirq.h kern/fs/fs.h kern/mm/mmu.h kern/driver/ide.h \
+ libs/x86.h kern/debug/assert.h
Binary files lab6_origin/obj/kern/driver/ide.o and lab6/obj/kern/driver/ide.o differ
diff -r -u -P lab6_origin/obj/kern/driver/intr.d lab6/obj/kern/driver/intr.d
--- lab6_origin/obj/kern/driver/intr.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/kern/driver/intr.d	2019-05-13 17:39:38.022250500 +0800
@@ -0,0 +1,2 @@
+obj/kern/driver/intr.o obj/kern/driver/intr.d: kern/driver/intr.c \
+ libs/x86.h libs/defs.h kern/driver/intr.h
Binary files lab6_origin/obj/kern/driver/intr.o and lab6/obj/kern/driver/intr.o differ
diff -r -u -P lab6_origin/obj/kern/driver/picirq.d lab6/obj/kern/driver/picirq.d
--- lab6_origin/obj/kern/driver/picirq.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/kern/driver/picirq.d	2019-05-13 17:39:38.210142800 +0800
@@ -0,0 +1,2 @@
+obj/kern/driver/picirq.o obj/kern/driver/picirq.d: kern/driver/picirq.c \
+ libs/defs.h libs/x86.h kern/driver/picirq.h
Binary files lab6_origin/obj/kern/driver/picirq.o and lab6/obj/kern/driver/picirq.o differ
diff -r -u -P lab6_origin/obj/kern/fs/swapfs.d lab6/obj/kern/fs/swapfs.d
--- lab6_origin/obj/kern/fs/swapfs.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/kern/fs/swapfs.d	2019-05-13 17:39:38.207144900 +0800
@@ -0,0 +1,5 @@
+obj/kern/fs/swapfs.o obj/kern/fs/swapfs.d: kern/fs/swapfs.c \
+ kern/mm/swap.h libs/defs.h kern/mm/memlayout.h libs/atomic.h libs/list.h \
+ kern/mm/pmm.h kern/mm/mmu.h kern/debug/assert.h kern/mm/vmm.h \
+ kern/sync/sync.h libs/x86.h kern/driver/intr.h kern/schedule/sched.h \
+ libs/skew_heap.h kern/fs/swapfs.h kern/fs/fs.h kern/driver/ide.h
Binary files lab6_origin/obj/kern/fs/swapfs.o and lab6/obj/kern/fs/swapfs.o differ
diff -r -u -P lab6_origin/obj/kern/init/entry.d lab6/obj/kern/init/entry.d
--- lab6_origin/obj/kern/init/entry.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/kern/init/entry.d	2019-05-13 17:39:38.423020500 +0800
@@ -0,0 +1,2 @@
+obj/kern/init/entry.o obj/kern/init/entry.d: kern/init/entry.S \
+ kern/mm/mmu.h kern/mm/memlayout.h
Binary files lab6_origin/obj/kern/init/entry.o and lab6/obj/kern/init/entry.o differ
diff -r -u -P lab6_origin/obj/kern/init/init.d lab6/obj/kern/init/init.d
--- lab6_origin/obj/kern/init/init.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/kern/init/init.d	2019-05-13 17:39:38.067224600 +0800
@@ -0,0 +1,8 @@
+obj/kern/init/init.o obj/kern/init/init.d: kern/init/init.c libs/defs.h \
+ libs/stdio.h libs/stdarg.h libs/string.h kern/driver/console.h \
+ kern/debug/kdebug.h kern/trap/trap.h kern/driver/picirq.h \
+ kern/driver/clock.h kern/driver/intr.h kern/mm/pmm.h kern/mm/mmu.h \
+ kern/mm/memlayout.h libs/atomic.h libs/list.h kern/debug/assert.h \
+ kern/mm/vmm.h kern/sync/sync.h libs/x86.h kern/schedule/sched.h \
+ libs/skew_heap.h kern/driver/ide.h kern/mm/swap.h kern/process/proc.h \
+ kern/debug/kmonitor.h
Binary files lab6_origin/obj/kern/init/init.o and lab6/obj/kern/init/init.o differ
diff -r -u -P lab6_origin/obj/kern/libs/readline.d lab6/obj/kern/libs/readline.d
--- lab6_origin/obj/kern/libs/readline.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/kern/libs/readline.d	2019-05-13 17:39:38.082215800 +0800
@@ -0,0 +1,2 @@
+obj/kern/libs/readline.o obj/kern/libs/readline.d: kern/libs/readline.c \
+ libs/stdio.h libs/defs.h libs/stdarg.h
Binary files lab6_origin/obj/kern/libs/readline.o and lab6/obj/kern/libs/readline.o differ
diff -r -u -P lab6_origin/obj/kern/libs/stdio.d lab6/obj/kern/libs/stdio.d
--- lab6_origin/obj/kern/libs/stdio.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/kern/libs/stdio.d	2019-05-13 17:39:38.188155300 +0800
@@ -0,0 +1,2 @@
+obj/kern/libs/stdio.o obj/kern/libs/stdio.d: kern/libs/stdio.c \
+ libs/defs.h libs/stdio.h libs/stdarg.h kern/driver/console.h
Binary files lab6_origin/obj/kern/libs/stdio.o and lab6/obj/kern/libs/stdio.o differ
diff -r -u -P lab6_origin/obj/kern/mm/default_pmm.d lab6/obj/kern/mm/default_pmm.d
--- lab6_origin/obj/kern/mm/default_pmm.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/kern/mm/default_pmm.d	2019-05-13 17:39:37.767397000 +0800
@@ -0,0 +1,4 @@
+obj/kern/mm/default_pmm.o obj/kern/mm/default_pmm.d: \
+ kern/mm/default_pmm.c kern/mm/pmm.h libs/defs.h kern/mm/mmu.h \
+ kern/mm/memlayout.h libs/atomic.h libs/list.h kern/debug/assert.h \
+ libs/string.h kern/mm/default_pmm.h
Binary files lab6_origin/obj/kern/mm/default_pmm.o and lab6/obj/kern/mm/default_pmm.o differ
diff -r -u -P lab6_origin/obj/kern/mm/kmalloc.d lab6/obj/kern/mm/kmalloc.d
--- lab6_origin/obj/kern/mm/kmalloc.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/kern/mm/kmalloc.d	2019-05-13 17:39:38.189154500 +0800
@@ -0,0 +1,5 @@
+obj/kern/mm/kmalloc.o obj/kern/mm/kmalloc.d: kern/mm/kmalloc.c \
+ libs/defs.h libs/list.h kern/mm/memlayout.h libs/atomic.h \
+ kern/debug/assert.h kern/mm/kmalloc.h kern/sync/sync.h libs/x86.h \
+ kern/driver/intr.h kern/mm/mmu.h kern/schedule/sched.h libs/skew_heap.h \
+ kern/mm/pmm.h libs/stdio.h libs/stdarg.h
Binary files lab6_origin/obj/kern/mm/kmalloc.o and lab6/obj/kern/mm/kmalloc.o differ
diff -r -u -P lab6_origin/obj/kern/mm/pmm.d lab6/obj/kern/mm/pmm.d
--- lab6_origin/obj/kern/mm/pmm.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/kern/mm/pmm.d	2019-05-13 17:39:38.260114000 +0800
@@ -0,0 +1,6 @@
+obj/kern/mm/pmm.o obj/kern/mm/pmm.d: kern/mm/pmm.c libs/defs.h libs/x86.h \
+ libs/stdio.h libs/stdarg.h libs/string.h kern/mm/mmu.h \
+ kern/mm/memlayout.h libs/atomic.h libs/list.h kern/mm/pmm.h \
+ kern/debug/assert.h kern/mm/default_pmm.h kern/sync/sync.h \
+ kern/driver/intr.h kern/schedule/sched.h libs/skew_heap.h libs/error.h \
+ kern/mm/swap.h kern/mm/vmm.h kern/mm/kmalloc.h
Binary files lab6_origin/obj/kern/mm/pmm.o and lab6/obj/kern/mm/pmm.o differ
diff -r -u -P lab6_origin/obj/kern/mm/swap.d lab6/obj/kern/mm/swap.d
--- lab6_origin/obj/kern/mm/swap.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/kern/mm/swap.d	2019-05-13 17:39:37.685443700 +0800
@@ -0,0 +1,6 @@
+obj/kern/mm/swap.o obj/kern/mm/swap.d: kern/mm/swap.c kern/mm/swap.h \
+ libs/defs.h kern/mm/memlayout.h libs/atomic.h libs/list.h kern/mm/pmm.h \
+ kern/mm/mmu.h kern/debug/assert.h kern/mm/vmm.h kern/sync/sync.h \
+ libs/x86.h kern/driver/intr.h kern/schedule/sched.h libs/skew_heap.h \
+ kern/fs/swapfs.h kern/mm/swap_fifo.h libs/stdio.h libs/stdarg.h \
+ libs/string.h kern/mm/default_pmm.h kern/debug/kdebug.h kern/trap/trap.h
diff -r -u -P lab6_origin/obj/kern/mm/swap_fifo.d lab6/obj/kern/mm/swap_fifo.d
--- lab6_origin/obj/kern/mm/swap_fifo.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/kern/mm/swap_fifo.d	2019-05-13 17:39:37.740412400 +0800
@@ -0,0 +1,6 @@
+obj/kern/mm/swap_fifo.o obj/kern/mm/swap_fifo.d: kern/mm/swap_fifo.c \
+ libs/defs.h libs/x86.h libs/stdio.h libs/stdarg.h libs/string.h \
+ kern/mm/swap.h kern/mm/memlayout.h libs/atomic.h libs/list.h \
+ kern/mm/pmm.h kern/mm/mmu.h kern/debug/assert.h kern/mm/vmm.h \
+ kern/sync/sync.h kern/driver/intr.h kern/schedule/sched.h \
+ libs/skew_heap.h kern/mm/swap_fifo.h
Binary files lab6_origin/obj/kern/mm/swap_fifo.o and lab6/obj/kern/mm/swap_fifo.o differ
Binary files lab6_origin/obj/kern/mm/swap.o and lab6/obj/kern/mm/swap.o differ
diff -r -u -P lab6_origin/obj/kern/mm/vmm.d lab6/obj/kern/mm/vmm.d
--- lab6_origin/obj/kern/mm/vmm.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/kern/mm/vmm.d	2019-05-13 17:39:37.718425000 +0800
@@ -0,0 +1,6 @@
+obj/kern/mm/vmm.o obj/kern/mm/vmm.d: kern/mm/vmm.c kern/mm/vmm.h \
+ libs/defs.h libs/list.h kern/mm/memlayout.h libs/atomic.h \
+ kern/sync/sync.h libs/x86.h kern/driver/intr.h kern/mm/mmu.h \
+ kern/debug/assert.h kern/schedule/sched.h libs/skew_heap.h libs/string.h \
+ libs/stdio.h libs/stdarg.h libs/error.h kern/mm/pmm.h kern/mm/swap.h \
+ kern/mm/kmalloc.h
Binary files lab6_origin/obj/kern/mm/vmm.o and lab6/obj/kern/mm/vmm.o differ
diff -r -u -P lab6_origin/obj/kern/process/entry.d lab6/obj/kern/process/entry.d
--- lab6_origin/obj/kern/process/entry.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/kern/process/entry.d	2019-05-13 17:39:38.471992100 +0800
@@ -0,0 +1 @@
+obj/kern/process/entry.o obj/kern/process/entry.d: kern/process/entry.S
Binary files lab6_origin/obj/kern/process/entry.o and lab6/obj/kern/process/entry.o differ
diff -r -u -P lab6_origin/obj/kern/process/proc.d lab6/obj/kern/process/proc.d
--- lab6_origin/obj/kern/process/proc.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/kern/process/proc.d	2019-05-13 17:41:10.360578100 +0800
@@ -0,0 +1,7 @@
+obj/kern/process/proc.o obj/kern/process/proc.d: kern/process/proc.c \
+ kern/process/proc.h libs/defs.h libs/list.h kern/trap/trap.h \
+ kern/mm/memlayout.h libs/atomic.h libs/skew_heap.h kern/mm/kmalloc.h \
+ libs/string.h kern/sync/sync.h libs/x86.h kern/driver/intr.h \
+ kern/mm/mmu.h kern/debug/assert.h kern/schedule/sched.h kern/mm/pmm.h \
+ libs/error.h libs/elf.h kern/mm/vmm.h libs/stdio.h libs/stdarg.h \
+ libs/stdlib.h libs/unistd.h
Binary files lab6_origin/obj/kern/process/proc.o and lab6/obj/kern/process/proc.o differ
diff -r -u -P lab6_origin/obj/kern/process/switch.d lab6/obj/kern/process/switch.d
--- lab6_origin/obj/kern/process/switch.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/kern/process/switch.d	2019-05-13 17:39:38.533956200 +0800
@@ -0,0 +1,2 @@
+obj/kern/process/switch.o obj/kern/process/switch.d: \
+ kern/process/switch.S
Binary files lab6_origin/obj/kern/process/switch.o and lab6/obj/kern/process/switch.o differ
diff -r -u -P lab6_origin/obj/kern/schedule/default_sched.d lab6/obj/kern/schedule/default_sched.d
--- lab6_origin/obj/kern/schedule/default_sched.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/kern/schedule/default_sched.d	2019-05-13 17:39:38.430016400 +0800
@@ -0,0 +1,5 @@
+obj/kern/schedule/default_sched.o obj/kern/schedule/default_sched.d: \
+ kern/schedule/default_sched.c libs/defs.h libs/list.h \
+ kern/process/proc.h kern/trap/trap.h kern/mm/memlayout.h libs/atomic.h \
+ libs/skew_heap.h kern/debug/assert.h kern/schedule/default_sched.h \
+ kern/schedule/sched.h
Binary files lab6_origin/obj/kern/schedule/default_sched.o and lab6/obj/kern/schedule/default_sched.o differ
diff -r -u -P lab6_origin/obj/kern/schedule/default_sched_stride.d lab6/obj/kern/schedule/default_sched_stride.d
--- lab6_origin/obj/kern/schedule/default_sched_stride.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/kern/schedule/default_sched_stride.d	2019-05-13 17:39:38.504973400 +0800
@@ -0,0 +1,5 @@
+obj/kern/schedule/default_sched_stride.o obj/kern/schedule/default_sched_stride.d: \
+ kern/schedule/default_sched_stride.c libs/defs.h libs/list.h \
+ kern/process/proc.h kern/trap/trap.h kern/mm/memlayout.h libs/atomic.h \
+ libs/skew_heap.h kern/debug/assert.h kern/schedule/default_sched.h \
+ kern/schedule/sched.h
Binary files lab6_origin/obj/kern/schedule/default_sched_stride.o and lab6/obj/kern/schedule/default_sched_stride.o differ
diff -r -u -P lab6_origin/obj/kern/schedule/sched.d lab6/obj/kern/schedule/sched.d
--- lab6_origin/obj/kern/schedule/sched.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/kern/schedule/sched.d	2019-05-13 17:39:38.479987600 +0800
@@ -0,0 +1,6 @@
+obj/kern/schedule/sched.o obj/kern/schedule/sched.d: \
+ kern/schedule/sched.c libs/list.h libs/defs.h kern/sync/sync.h \
+ libs/x86.h kern/driver/intr.h kern/mm/mmu.h kern/debug/assert.h \
+ libs/atomic.h kern/schedule/sched.h libs/skew_heap.h kern/process/proc.h \
+ kern/trap/trap.h kern/mm/memlayout.h libs/stdio.h libs/stdarg.h \
+ kern/schedule/default_sched.h
Binary files lab6_origin/obj/kern/schedule/sched.o and lab6/obj/kern/schedule/sched.o differ
diff -r -u -P lab6_origin/obj/kern/syscall/syscall.d lab6/obj/kern/syscall/syscall.d
--- lab6_origin/obj/kern/syscall/syscall.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/kern/syscall/syscall.d	2019-05-13 17:39:38.113198300 +0800
@@ -0,0 +1,5 @@
+obj/kern/syscall/syscall.o obj/kern/syscall/syscall.d: \
+ kern/syscall/syscall.c libs/unistd.h kern/process/proc.h libs/defs.h \
+ libs/list.h kern/trap/trap.h kern/mm/memlayout.h libs/atomic.h \
+ libs/skew_heap.h kern/syscall/syscall.h libs/stdio.h libs/stdarg.h \
+ kern/mm/pmm.h kern/mm/mmu.h kern/debug/assert.h kern/driver/clock.h
Binary files lab6_origin/obj/kern/syscall/syscall.o and lab6/obj/kern/syscall/syscall.o differ
diff -r -u -P lab6_origin/obj/kern/trap/trap.d lab6/obj/kern/trap/trap.d
--- lab6_origin/obj/kern/trap/trap.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/kern/trap/trap.d	2019-05-13 17:39:38.607914500 +0800
@@ -0,0 +1,7 @@
+obj/kern/trap/trap.o obj/kern/trap/trap.d: kern/trap/trap.c libs/defs.h \
+ kern/mm/mmu.h kern/mm/memlayout.h libs/atomic.h libs/list.h \
+ kern/driver/clock.h kern/trap/trap.h libs/x86.h libs/stdio.h \
+ libs/stdarg.h kern/debug/assert.h kern/driver/console.h kern/mm/vmm.h \
+ kern/sync/sync.h kern/driver/intr.h kern/schedule/sched.h \
+ libs/skew_heap.h kern/mm/swap.h kern/mm/pmm.h kern/debug/kdebug.h \
+ libs/unistd.h kern/syscall/syscall.h libs/error.h kern/process/proc.h
diff -r -u -P lab6_origin/obj/kern/trap/trapentry.d lab6/obj/kern/trap/trapentry.d
--- lab6_origin/obj/kern/trap/trapentry.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/kern/trap/trapentry.d	2019-05-13 17:39:38.593922500 +0800
@@ -0,0 +1,2 @@
+obj/kern/trap/trapentry.o obj/kern/trap/trapentry.d: \
+ kern/trap/trapentry.S kern/mm/memlayout.h
Binary files lab6_origin/obj/kern/trap/trapentry.o and lab6/obj/kern/trap/trapentry.o differ
Binary files lab6_origin/obj/kern/trap/trap.o and lab6/obj/kern/trap/trap.o differ
diff -r -u -P lab6_origin/obj/kern/trap/vectors.d lab6/obj/kern/trap/vectors.d
--- lab6_origin/obj/kern/trap/vectors.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/kern/trap/vectors.d	2019-05-13 17:39:38.589924500 +0800
@@ -0,0 +1 @@
+obj/kern/trap/vectors.o obj/kern/trap/vectors.d: kern/trap/vectors.S
Binary files lab6_origin/obj/kern/trap/vectors.o and lab6/obj/kern/trap/vectors.o differ
diff -r -u -P lab6_origin/obj/kernel.asm lab6/obj/kernel.asm
--- lab6_origin/obj/kernel.asm	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/kernel.asm	2019-05-13 17:41:10.909262500 +0800
@@ -0,0 +1,24463 @@
+
+bin/kernel:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+c0100000 <kern_entry>:
+
+.text
+.globl kern_entry
+kern_entry:
+    # load pa of boot pgdir
+    movl $REALLOC(__boot_pgdir), %eax
+c0100000:	b8 00 e0 1a 00       	mov    $0x1ae000,%eax
+    movl %eax, %cr3
+c0100005:	0f 22 d8             	mov    %eax,%cr3
+
+    # enable paging
+    movl %cr0, %eax
+c0100008:	0f 20 c0             	mov    %cr0,%eax
+    orl $(CR0_PE | CR0_PG | CR0_AM | CR0_WP | CR0_NE | CR0_TS | CR0_EM | CR0_MP), %eax
+c010000b:	0d 2f 00 05 80       	or     $0x8005002f,%eax
+    andl $~(CR0_TS | CR0_EM), %eax
+c0100010:	83 e0 f3             	and    $0xfffffff3,%eax
+    movl %eax, %cr0
+c0100013:	0f 22 c0             	mov    %eax,%cr0
+
+    # update eip
+    # now, eip = 0x1.....
+    leal next, %eax
+c0100016:	8d 05 1e 00 10 c0    	lea    0xc010001e,%eax
+    # set eip = KERNBASE + 0x1.....
+    jmp *%eax
+c010001c:	ff e0                	jmp    *%eax
+
+c010001e <next>:
+next:
+
+    # unmap va 0 ~ 4M, it's temporary mapping
+    xorl %eax, %eax
+c010001e:	31 c0                	xor    %eax,%eax
+    movl %eax, __boot_pgdir
+c0100020:	a3 00 e0 1a c0       	mov    %eax,0xc01ae000
+
+    # set ebp, esp
+    movl $0x0, %ebp
+c0100025:	bd 00 00 00 00       	mov    $0x0,%ebp
+    # the kernel stack region is from bootstack -- bootstacktop,
+    # the kernel stack size is KSTACKSIZE (8KB)defined in memlayout.h
+    movl $bootstacktop, %esp
+c010002a:	bc 00 c0 12 c0       	mov    $0xc012c000,%esp
+    # now kernel stack is ready , call the first C function
+    call kern_init
+c010002f:	e8 02 00 00 00       	call   c0100036 <kern_init>
+
+c0100034 <spin>:
+
+# should never get here
+spin:
+    jmp spin
+c0100034:	eb fe                	jmp    c0100034 <spin>
+
+c0100036 <kern_init>:
+int kern_init(void) __attribute__((noreturn));
+void grade_backtrace(void);
+static void lab1_switch_test(void);
+
+int
+kern_init(void) {
+c0100036:	55                   	push   %ebp
+c0100037:	89 e5                	mov    %esp,%ebp
+c0100039:	83 ec 18             	sub    $0x18,%esp
+    extern char edata[], end[];
+    memset(edata, 0, end - edata);
+c010003c:	ba 78 31 1b c0       	mov    $0xc01b3178,%edx
+c0100041:	b8 00 00 1b c0       	mov    $0xc01b0000,%eax
+c0100046:	29 c2                	sub    %eax,%edx
+c0100048:	89 d0                	mov    %edx,%eax
+c010004a:	83 ec 04             	sub    $0x4,%esp
+c010004d:	50                   	push   %eax
+c010004e:	6a 00                	push   $0x0
+c0100050:	68 00 00 1b c0       	push   $0xc01b0000
+c0100055:	e8 fe af 00 00       	call   c010b058 <memset>
+c010005a:	83 c4 10             	add    $0x10,%esp
+
+    cons_init();                // init the console
+c010005d:	e8 95 1e 00 00       	call   c0101ef7 <cons_init>
+
+    const char *message = "(THU.CST) os is loading ...";
+c0100062:	c7 45 f4 00 b9 10 c0 	movl   $0xc010b900,-0xc(%ebp)
+    cprintf("%s\n\n", message);
+c0100069:	83 ec 08             	sub    $0x8,%esp
+c010006c:	ff 75 f4             	pushl  -0xc(%ebp)
+c010006f:	68 1c b9 10 c0       	push   $0xc010b91c
+c0100074:	e8 16 02 00 00       	call   c010028f <cprintf>
+c0100079:	83 c4 10             	add    $0x10,%esp
+
+    print_kerninfo();
+c010007c:	e8 84 09 00 00       	call   c0100a05 <print_kerninfo>
+
+    grade_backtrace();
+c0100081:	e8 90 00 00 00       	call   c0100116 <grade_backtrace>
+
+    pmm_init();                 // init physical memory management
+c0100086:	e8 dd 3c 00 00       	call   c0103d68 <pmm_init>
+
+    pic_init();                 // init interrupt controller
+c010008b:	e8 d9 1f 00 00       	call   c0102069 <pic_init>
+    idt_init();                 // init interrupt descriptor table
+c0100090:	e8 5b 21 00 00       	call   c01021f0 <idt_init>
+
+    vmm_init();                 // init virtual memory management
+c0100095:	e8 cb 5b 00 00       	call   c0105c65 <vmm_init>
+    sched_init();               // init scheduler
+c010009a:	e8 9d a3 00 00       	call   c010a43c <sched_init>
+    proc_init();                // init process table
+c010009f:	e8 d1 a0 00 00       	call   c010a175 <proc_init>
+    
+    ide_init();                 // init ide devices
+c01000a4:	e8 1d 0e 00 00       	call   c0100ec6 <ide_init>
+    swap_init();                // init swap
+c01000a9:	e8 fc 6c 00 00       	call   c0106daa <swap_init>
+
+    clock_init();               // init clock interrupt
+c01000ae:	e8 eb 15 00 00       	call   c010169e <clock_init>
+    intr_enable();              // enable irq interrupt
+c01000b3:	e8 ee 20 00 00       	call   c01021a6 <intr_enable>
+
+    //LAB1: CAHLLENGE 1 If you try to do it, uncomment lab1_switch_test()
+    // user/kernel mode switch test
+    //lab1_switch_test();
+    
+    cpu_idle();                 // run idle process
+c01000b8:	e8 55 a2 00 00       	call   c010a312 <cpu_idle>
+
+c01000bd <grade_backtrace2>:
+}
+
+void __attribute__((noinline))
+grade_backtrace2(int arg0, int arg1, int arg2, int arg3) {
+c01000bd:	55                   	push   %ebp
+c01000be:	89 e5                	mov    %esp,%ebp
+c01000c0:	83 ec 08             	sub    $0x8,%esp
+    mon_backtrace(0, NULL, NULL);
+c01000c3:	83 ec 04             	sub    $0x4,%esp
+c01000c6:	6a 00                	push   $0x0
+c01000c8:	6a 00                	push   $0x0
+c01000ca:	6a 00                	push   $0x0
+c01000cc:	e8 89 0d 00 00       	call   c0100e5a <mon_backtrace>
+c01000d1:	83 c4 10             	add    $0x10,%esp
+}
+c01000d4:	90                   	nop
+c01000d5:	c9                   	leave  
+c01000d6:	c3                   	ret    
+
+c01000d7 <grade_backtrace1>:
+
+void __attribute__((noinline))
+grade_backtrace1(int arg0, int arg1) {
+c01000d7:	55                   	push   %ebp
+c01000d8:	89 e5                	mov    %esp,%ebp
+c01000da:	53                   	push   %ebx
+c01000db:	83 ec 04             	sub    $0x4,%esp
+    grade_backtrace2(arg0, (int)&arg0, arg1, (int)&arg1);
+c01000de:	8d 4d 0c             	lea    0xc(%ebp),%ecx
+c01000e1:	8b 55 0c             	mov    0xc(%ebp),%edx
+c01000e4:	8d 5d 08             	lea    0x8(%ebp),%ebx
+c01000e7:	8b 45 08             	mov    0x8(%ebp),%eax
+c01000ea:	51                   	push   %ecx
+c01000eb:	52                   	push   %edx
+c01000ec:	53                   	push   %ebx
+c01000ed:	50                   	push   %eax
+c01000ee:	e8 ca ff ff ff       	call   c01000bd <grade_backtrace2>
+c01000f3:	83 c4 10             	add    $0x10,%esp
+}
+c01000f6:	90                   	nop
+c01000f7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+c01000fa:	c9                   	leave  
+c01000fb:	c3                   	ret    
+
+c01000fc <grade_backtrace0>:
+
+void __attribute__((noinline))
+grade_backtrace0(int arg0, int arg1, int arg2) {
+c01000fc:	55                   	push   %ebp
+c01000fd:	89 e5                	mov    %esp,%ebp
+c01000ff:	83 ec 08             	sub    $0x8,%esp
+    grade_backtrace1(arg0, arg2);
+c0100102:	83 ec 08             	sub    $0x8,%esp
+c0100105:	ff 75 10             	pushl  0x10(%ebp)
+c0100108:	ff 75 08             	pushl  0x8(%ebp)
+c010010b:	e8 c7 ff ff ff       	call   c01000d7 <grade_backtrace1>
+c0100110:	83 c4 10             	add    $0x10,%esp
+}
+c0100113:	90                   	nop
+c0100114:	c9                   	leave  
+c0100115:	c3                   	ret    
+
+c0100116 <grade_backtrace>:
+
+void
+grade_backtrace(void) {
+c0100116:	55                   	push   %ebp
+c0100117:	89 e5                	mov    %esp,%ebp
+c0100119:	83 ec 08             	sub    $0x8,%esp
+    grade_backtrace0(0, (int)kern_init, 0xffff0000);
+c010011c:	b8 36 00 10 c0       	mov    $0xc0100036,%eax
+c0100121:	83 ec 04             	sub    $0x4,%esp
+c0100124:	68 00 00 ff ff       	push   $0xffff0000
+c0100129:	50                   	push   %eax
+c010012a:	6a 00                	push   $0x0
+c010012c:	e8 cb ff ff ff       	call   c01000fc <grade_backtrace0>
+c0100131:	83 c4 10             	add    $0x10,%esp
+}
+c0100134:	90                   	nop
+c0100135:	c9                   	leave  
+c0100136:	c3                   	ret    
+
+c0100137 <lab1_print_cur_status>:
+
+static void
+lab1_print_cur_status(void) {
+c0100137:	55                   	push   %ebp
+c0100138:	89 e5                	mov    %esp,%ebp
+c010013a:	83 ec 18             	sub    $0x18,%esp
+    static int round = 0;
+    uint16_t reg1, reg2, reg3, reg4;
+    asm volatile (
+c010013d:	8c 4d f6             	mov    %cs,-0xa(%ebp)
+c0100140:	8c 5d f4             	mov    %ds,-0xc(%ebp)
+c0100143:	8c 45 f2             	mov    %es,-0xe(%ebp)
+c0100146:	8c 55 f0             	mov    %ss,-0x10(%ebp)
+            "mov %%cs, %0;"
+            "mov %%ds, %1;"
+            "mov %%es, %2;"
+            "mov %%ss, %3;"
+            : "=m"(reg1), "=m"(reg2), "=m"(reg3), "=m"(reg4));
+    cprintf("%d: @ring %d\n", round, reg1 & 3);
+c0100149:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+c010014d:	0f b7 c0             	movzwl %ax,%eax
+c0100150:	83 e0 03             	and    $0x3,%eax
+c0100153:	89 c2                	mov    %eax,%edx
+c0100155:	a1 00 00 1b c0       	mov    0xc01b0000,%eax
+c010015a:	83 ec 04             	sub    $0x4,%esp
+c010015d:	52                   	push   %edx
+c010015e:	50                   	push   %eax
+c010015f:	68 21 b9 10 c0       	push   $0xc010b921
+c0100164:	e8 26 01 00 00       	call   c010028f <cprintf>
+c0100169:	83 c4 10             	add    $0x10,%esp
+    cprintf("%d:  cs = %x\n", round, reg1);
+c010016c:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+c0100170:	0f b7 d0             	movzwl %ax,%edx
+c0100173:	a1 00 00 1b c0       	mov    0xc01b0000,%eax
+c0100178:	83 ec 04             	sub    $0x4,%esp
+c010017b:	52                   	push   %edx
+c010017c:	50                   	push   %eax
+c010017d:	68 2f b9 10 c0       	push   $0xc010b92f
+c0100182:	e8 08 01 00 00       	call   c010028f <cprintf>
+c0100187:	83 c4 10             	add    $0x10,%esp
+    cprintf("%d:  ds = %x\n", round, reg2);
+c010018a:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
+c010018e:	0f b7 d0             	movzwl %ax,%edx
+c0100191:	a1 00 00 1b c0       	mov    0xc01b0000,%eax
+c0100196:	83 ec 04             	sub    $0x4,%esp
+c0100199:	52                   	push   %edx
+c010019a:	50                   	push   %eax
+c010019b:	68 3d b9 10 c0       	push   $0xc010b93d
+c01001a0:	e8 ea 00 00 00       	call   c010028f <cprintf>
+c01001a5:	83 c4 10             	add    $0x10,%esp
+    cprintf("%d:  es = %x\n", round, reg3);
+c01001a8:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
+c01001ac:	0f b7 d0             	movzwl %ax,%edx
+c01001af:	a1 00 00 1b c0       	mov    0xc01b0000,%eax
+c01001b4:	83 ec 04             	sub    $0x4,%esp
+c01001b7:	52                   	push   %edx
+c01001b8:	50                   	push   %eax
+c01001b9:	68 4b b9 10 c0       	push   $0xc010b94b
+c01001be:	e8 cc 00 00 00       	call   c010028f <cprintf>
+c01001c3:	83 c4 10             	add    $0x10,%esp
+    cprintf("%d:  ss = %x\n", round, reg4);
+c01001c6:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
+c01001ca:	0f b7 d0             	movzwl %ax,%edx
+c01001cd:	a1 00 00 1b c0       	mov    0xc01b0000,%eax
+c01001d2:	83 ec 04             	sub    $0x4,%esp
+c01001d5:	52                   	push   %edx
+c01001d6:	50                   	push   %eax
+c01001d7:	68 59 b9 10 c0       	push   $0xc010b959
+c01001dc:	e8 ae 00 00 00       	call   c010028f <cprintf>
+c01001e1:	83 c4 10             	add    $0x10,%esp
+    round ++;
+c01001e4:	a1 00 00 1b c0       	mov    0xc01b0000,%eax
+c01001e9:	83 c0 01             	add    $0x1,%eax
+c01001ec:	a3 00 00 1b c0       	mov    %eax,0xc01b0000
+}
+c01001f1:	90                   	nop
+c01001f2:	c9                   	leave  
+c01001f3:	c3                   	ret    
+
+c01001f4 <lab1_switch_to_user>:
+
+static void
+lab1_switch_to_user(void) {
+c01001f4:	55                   	push   %ebp
+c01001f5:	89 e5                	mov    %esp,%ebp
+    //LAB1 CHALLENGE 1 : TODO
+}
+c01001f7:	90                   	nop
+c01001f8:	5d                   	pop    %ebp
+c01001f9:	c3                   	ret    
+
+c01001fa <lab1_switch_to_kernel>:
+
+static void
+lab1_switch_to_kernel(void) {
+c01001fa:	55                   	push   %ebp
+c01001fb:	89 e5                	mov    %esp,%ebp
+    //LAB1 CHALLENGE 1 :  TODO
+}
+c01001fd:	90                   	nop
+c01001fe:	5d                   	pop    %ebp
+c01001ff:	c3                   	ret    
+
+c0100200 <lab1_switch_test>:
+
+static void
+lab1_switch_test(void) {
+c0100200:	55                   	push   %ebp
+c0100201:	89 e5                	mov    %esp,%ebp
+c0100203:	83 ec 08             	sub    $0x8,%esp
+    lab1_print_cur_status();
+c0100206:	e8 2c ff ff ff       	call   c0100137 <lab1_print_cur_status>
+    cprintf("+++ switch to  user  mode +++\n");
+c010020b:	83 ec 0c             	sub    $0xc,%esp
+c010020e:	68 68 b9 10 c0       	push   $0xc010b968
+c0100213:	e8 77 00 00 00       	call   c010028f <cprintf>
+c0100218:	83 c4 10             	add    $0x10,%esp
+    lab1_switch_to_user();
+c010021b:	e8 d4 ff ff ff       	call   c01001f4 <lab1_switch_to_user>
+    lab1_print_cur_status();
+c0100220:	e8 12 ff ff ff       	call   c0100137 <lab1_print_cur_status>
+    cprintf("+++ switch to kernel mode +++\n");
+c0100225:	83 ec 0c             	sub    $0xc,%esp
+c0100228:	68 88 b9 10 c0       	push   $0xc010b988
+c010022d:	e8 5d 00 00 00       	call   c010028f <cprintf>
+c0100232:	83 c4 10             	add    $0x10,%esp
+    lab1_switch_to_kernel();
+c0100235:	e8 c0 ff ff ff       	call   c01001fa <lab1_switch_to_kernel>
+    lab1_print_cur_status();
+c010023a:	e8 f8 fe ff ff       	call   c0100137 <lab1_print_cur_status>
+}
+c010023f:	90                   	nop
+c0100240:	c9                   	leave  
+c0100241:	c3                   	ret    
+
+c0100242 <cputch>:
+/* *
+ * cputch - writes a single character @c to stdout, and it will
+ * increace the value of counter pointed by @cnt.
+ * */
+static void
+cputch(int c, int *cnt) {
+c0100242:	55                   	push   %ebp
+c0100243:	89 e5                	mov    %esp,%ebp
+c0100245:	83 ec 08             	sub    $0x8,%esp
+    cons_putc(c);
+c0100248:	83 ec 0c             	sub    $0xc,%esp
+c010024b:	ff 75 08             	pushl  0x8(%ebp)
+c010024e:	e8 d5 1c 00 00       	call   c0101f28 <cons_putc>
+c0100253:	83 c4 10             	add    $0x10,%esp
+    (*cnt) ++;
+c0100256:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0100259:	8b 00                	mov    (%eax),%eax
+c010025b:	8d 50 01             	lea    0x1(%eax),%edx
+c010025e:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0100261:	89 10                	mov    %edx,(%eax)
+}
+c0100263:	90                   	nop
+c0100264:	c9                   	leave  
+c0100265:	c3                   	ret    
+
+c0100266 <vcprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want cprintf() instead.
+ * */
+int
+vcprintf(const char *fmt, va_list ap) {
+c0100266:	55                   	push   %ebp
+c0100267:	89 e5                	mov    %esp,%ebp
+c0100269:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+c010026c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    vprintfmt((void*)cputch, &cnt, fmt, ap);
+c0100273:	ff 75 0c             	pushl  0xc(%ebp)
+c0100276:	ff 75 08             	pushl  0x8(%ebp)
+c0100279:	8d 45 f4             	lea    -0xc(%ebp),%eax
+c010027c:	50                   	push   %eax
+c010027d:	68 42 02 10 c0       	push   $0xc0100242
+c0100282:	e8 07 b1 00 00       	call   c010b38e <vprintfmt>
+c0100287:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+c010028a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+c010028d:	c9                   	leave  
+c010028e:	c3                   	ret    
+
+c010028f <cprintf>:
+ *
+ * The return value is the number of characters which would be
+ * written to stdout.
+ * */
+int
+cprintf(const char *fmt, ...) {
+c010028f:	55                   	push   %ebp
+c0100290:	89 e5                	mov    %esp,%ebp
+c0100292:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    int cnt;
+    va_start(ap, fmt);
+c0100295:	8d 45 0c             	lea    0xc(%ebp),%eax
+c0100298:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    cnt = vcprintf(fmt, ap);
+c010029b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010029e:	83 ec 08             	sub    $0x8,%esp
+c01002a1:	50                   	push   %eax
+c01002a2:	ff 75 08             	pushl  0x8(%ebp)
+c01002a5:	e8 bc ff ff ff       	call   c0100266 <vcprintf>
+c01002aa:	83 c4 10             	add    $0x10,%esp
+c01002ad:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+    return cnt;
+c01002b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+c01002b3:	c9                   	leave  
+c01002b4:	c3                   	ret    
+
+c01002b5 <cputchar>:
+
+/* cputchar - writes a single character to stdout */
+void
+cputchar(int c) {
+c01002b5:	55                   	push   %ebp
+c01002b6:	89 e5                	mov    %esp,%ebp
+c01002b8:	83 ec 08             	sub    $0x8,%esp
+    cons_putc(c);
+c01002bb:	83 ec 0c             	sub    $0xc,%esp
+c01002be:	ff 75 08             	pushl  0x8(%ebp)
+c01002c1:	e8 62 1c 00 00       	call   c0101f28 <cons_putc>
+c01002c6:	83 c4 10             	add    $0x10,%esp
+}
+c01002c9:	90                   	nop
+c01002ca:	c9                   	leave  
+c01002cb:	c3                   	ret    
+
+c01002cc <cputs>:
+/* *
+ * cputs- writes the string pointed by @str to stdout and
+ * appends a newline character.
+ * */
+int
+cputs(const char *str) {
+c01002cc:	55                   	push   %ebp
+c01002cd:	89 e5                	mov    %esp,%ebp
+c01002cf:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+c01002d2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    char c;
+    while ((c = *str ++) != '\0') {
+c01002d9:	eb 14                	jmp    c01002ef <cputs+0x23>
+        cputch(c, &cnt);
+c01002db:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
+c01002df:	83 ec 08             	sub    $0x8,%esp
+c01002e2:	8d 55 f0             	lea    -0x10(%ebp),%edx
+c01002e5:	52                   	push   %edx
+c01002e6:	50                   	push   %eax
+c01002e7:	e8 56 ff ff ff       	call   c0100242 <cputch>
+c01002ec:	83 c4 10             	add    $0x10,%esp
+ * */
+int
+cputs(const char *str) {
+    int cnt = 0;
+    char c;
+    while ((c = *str ++) != '\0') {
+c01002ef:	8b 45 08             	mov    0x8(%ebp),%eax
+c01002f2:	8d 50 01             	lea    0x1(%eax),%edx
+c01002f5:	89 55 08             	mov    %edx,0x8(%ebp)
+c01002f8:	0f b6 00             	movzbl (%eax),%eax
+c01002fb:	88 45 f7             	mov    %al,-0x9(%ebp)
+c01002fe:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
+c0100302:	75 d7                	jne    c01002db <cputs+0xf>
+        cputch(c, &cnt);
+    }
+    cputch('\n', &cnt);
+c0100304:	83 ec 08             	sub    $0x8,%esp
+c0100307:	8d 45 f0             	lea    -0x10(%ebp),%eax
+c010030a:	50                   	push   %eax
+c010030b:	6a 0a                	push   $0xa
+c010030d:	e8 30 ff ff ff       	call   c0100242 <cputch>
+c0100312:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+c0100315:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+c0100318:	c9                   	leave  
+c0100319:	c3                   	ret    
+
+c010031a <getchar>:
+
+/* getchar - reads a single non-zero character from stdin */
+int
+getchar(void) {
+c010031a:	55                   	push   %ebp
+c010031b:	89 e5                	mov    %esp,%ebp
+c010031d:	83 ec 18             	sub    $0x18,%esp
+    int c;
+    while ((c = cons_getc()) == 0)
+c0100320:	e8 4c 1c 00 00       	call   c0101f71 <cons_getc>
+c0100325:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0100328:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c010032c:	74 f2                	je     c0100320 <getchar+0x6>
+        /* do nothing */;
+    return c;
+c010032e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+c0100331:	c9                   	leave  
+c0100332:	c3                   	ret    
+
+c0100333 <readline>:
+ * The readline() function returns the text of the line read. If some errors
+ * are happened, NULL is returned. The return value is a global variable,
+ * thus it should be copied before it is used.
+ * */
+char *
+readline(const char *prompt) {
+c0100333:	55                   	push   %ebp
+c0100334:	89 e5                	mov    %esp,%ebp
+c0100336:	83 ec 18             	sub    $0x18,%esp
+    if (prompt != NULL) {
+c0100339:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c010033d:	74 13                	je     c0100352 <readline+0x1f>
+        cprintf("%s", prompt);
+c010033f:	83 ec 08             	sub    $0x8,%esp
+c0100342:	ff 75 08             	pushl  0x8(%ebp)
+c0100345:	68 a7 b9 10 c0       	push   $0xc010b9a7
+c010034a:	e8 40 ff ff ff       	call   c010028f <cprintf>
+c010034f:	83 c4 10             	add    $0x10,%esp
+    }
+    int i = 0, c;
+c0100352:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    while (1) {
+        c = getchar();
+c0100359:	e8 bc ff ff ff       	call   c010031a <getchar>
+c010035e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+        if (c < 0) {
+c0100361:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c0100365:	79 0a                	jns    c0100371 <readline+0x3e>
+            return NULL;
+c0100367:	b8 00 00 00 00       	mov    $0x0,%eax
+c010036c:	e9 82 00 00 00       	jmp    c01003f3 <readline+0xc0>
+        }
+        else if (c >= ' ' && i < BUFSIZE - 1) {
+c0100371:	83 7d f0 1f          	cmpl   $0x1f,-0x10(%ebp)
+c0100375:	7e 2b                	jle    c01003a2 <readline+0x6f>
+c0100377:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
+c010037e:	7f 22                	jg     c01003a2 <readline+0x6f>
+            cputchar(c);
+c0100380:	83 ec 0c             	sub    $0xc,%esp
+c0100383:	ff 75 f0             	pushl  -0x10(%ebp)
+c0100386:	e8 2a ff ff ff       	call   c01002b5 <cputchar>
+c010038b:	83 c4 10             	add    $0x10,%esp
+            buf[i ++] = c;
+c010038e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100391:	8d 50 01             	lea    0x1(%eax),%edx
+c0100394:	89 55 f4             	mov    %edx,-0xc(%ebp)
+c0100397:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c010039a:	88 90 20 00 1b c0    	mov    %dl,-0x3fe4ffe0(%eax)
+c01003a0:	eb 4c                	jmp    c01003ee <readline+0xbb>
+        }
+        else if (c == '\b' && i > 0) {
+c01003a2:	83 7d f0 08          	cmpl   $0x8,-0x10(%ebp)
+c01003a6:	75 1a                	jne    c01003c2 <readline+0x8f>
+c01003a8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c01003ac:	7e 14                	jle    c01003c2 <readline+0x8f>
+            cputchar(c);
+c01003ae:	83 ec 0c             	sub    $0xc,%esp
+c01003b1:	ff 75 f0             	pushl  -0x10(%ebp)
+c01003b4:	e8 fc fe ff ff       	call   c01002b5 <cputchar>
+c01003b9:	83 c4 10             	add    $0x10,%esp
+            i --;
+c01003bc:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+c01003c0:	eb 2c                	jmp    c01003ee <readline+0xbb>
+        }
+        else if (c == '\n' || c == '\r') {
+c01003c2:	83 7d f0 0a          	cmpl   $0xa,-0x10(%ebp)
+c01003c6:	74 06                	je     c01003ce <readline+0x9b>
+c01003c8:	83 7d f0 0d          	cmpl   $0xd,-0x10(%ebp)
+c01003cc:	75 8b                	jne    c0100359 <readline+0x26>
+            cputchar(c);
+c01003ce:	83 ec 0c             	sub    $0xc,%esp
+c01003d1:	ff 75 f0             	pushl  -0x10(%ebp)
+c01003d4:	e8 dc fe ff ff       	call   c01002b5 <cputchar>
+c01003d9:	83 c4 10             	add    $0x10,%esp
+            buf[i] = '\0';
+c01003dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01003df:	05 20 00 1b c0       	add    $0xc01b0020,%eax
+c01003e4:	c6 00 00             	movb   $0x0,(%eax)
+            return buf;
+c01003e7:	b8 20 00 1b c0       	mov    $0xc01b0020,%eax
+c01003ec:	eb 05                	jmp    c01003f3 <readline+0xc0>
+        }
+    }
+c01003ee:	e9 66 ff ff ff       	jmp    c0100359 <readline+0x26>
+}
+c01003f3:	c9                   	leave  
+c01003f4:	c3                   	ret    
+
+c01003f5 <__panic>:
+/* *
+ * __panic - __panic is called on unresolvable fatal errors. it prints
+ * "panic: 'message'", and then enters the kernel monitor.
+ * */
+void
+__panic(const char *file, int line, const char *fmt, ...) {
+c01003f5:	55                   	push   %ebp
+c01003f6:	89 e5                	mov    %esp,%ebp
+c01003f8:	83 ec 18             	sub    $0x18,%esp
+    if (is_panic) {
+c01003fb:	a1 20 04 1b c0       	mov    0xc01b0420,%eax
+c0100400:	85 c0                	test   %eax,%eax
+c0100402:	75 5f                	jne    c0100463 <__panic+0x6e>
+        goto panic_dead;
+    }
+    is_panic = 1;
+c0100404:	c7 05 20 04 1b c0 01 	movl   $0x1,0xc01b0420
+c010040b:	00 00 00 
+
+    // print the 'message'
+    va_list ap;
+    va_start(ap, fmt);
+c010040e:	8d 45 14             	lea    0x14(%ebp),%eax
+c0100411:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("kernel panic at %s:%d:\n    ", file, line);
+c0100414:	83 ec 04             	sub    $0x4,%esp
+c0100417:	ff 75 0c             	pushl  0xc(%ebp)
+c010041a:	ff 75 08             	pushl  0x8(%ebp)
+c010041d:	68 aa b9 10 c0       	push   $0xc010b9aa
+c0100422:	e8 68 fe ff ff       	call   c010028f <cprintf>
+c0100427:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+c010042a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010042d:	83 ec 08             	sub    $0x8,%esp
+c0100430:	50                   	push   %eax
+c0100431:	ff 75 10             	pushl  0x10(%ebp)
+c0100434:	e8 2d fe ff ff       	call   c0100266 <vcprintf>
+c0100439:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+c010043c:	83 ec 0c             	sub    $0xc,%esp
+c010043f:	68 c6 b9 10 c0       	push   $0xc010b9c6
+c0100444:	e8 46 fe ff ff       	call   c010028f <cprintf>
+c0100449:	83 c4 10             	add    $0x10,%esp
+    
+    cprintf("stack trackback:\n");
+c010044c:	83 ec 0c             	sub    $0xc,%esp
+c010044f:	68 c8 b9 10 c0       	push   $0xc010b9c8
+c0100454:	e8 36 fe ff ff       	call   c010028f <cprintf>
+c0100459:	83 c4 10             	add    $0x10,%esp
+    print_stackframe();
+c010045c:	e8 ee 06 00 00       	call   c0100b4f <print_stackframe>
+c0100461:	eb 01                	jmp    c0100464 <__panic+0x6f>
+ * "panic: 'message'", and then enters the kernel monitor.
+ * */
+void
+__panic(const char *file, int line, const char *fmt, ...) {
+    if (is_panic) {
+        goto panic_dead;
+c0100463:	90                   	nop
+    print_stackframe();
+    
+    va_end(ap);
+
+panic_dead:
+    intr_disable();
+c0100464:	e8 44 1d 00 00       	call   c01021ad <intr_disable>
+    while (1) {
+        kmonitor(NULL);
+c0100469:	83 ec 0c             	sub    $0xc,%esp
+c010046c:	6a 00                	push   $0x0
+c010046e:	e8 0d 09 00 00       	call   c0100d80 <kmonitor>
+c0100473:	83 c4 10             	add    $0x10,%esp
+    }
+c0100476:	eb f1                	jmp    c0100469 <__panic+0x74>
+
+c0100478 <__warn>:
+}
+
+/* __warn - like panic, but don't */
+void
+__warn(const char *file, int line, const char *fmt, ...) {
+c0100478:	55                   	push   %ebp
+c0100479:	89 e5                	mov    %esp,%ebp
+c010047b:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    va_start(ap, fmt);
+c010047e:	8d 45 14             	lea    0x14(%ebp),%eax
+c0100481:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("kernel warning at %s:%d:\n    ", file, line);
+c0100484:	83 ec 04             	sub    $0x4,%esp
+c0100487:	ff 75 0c             	pushl  0xc(%ebp)
+c010048a:	ff 75 08             	pushl  0x8(%ebp)
+c010048d:	68 da b9 10 c0       	push   $0xc010b9da
+c0100492:	e8 f8 fd ff ff       	call   c010028f <cprintf>
+c0100497:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+c010049a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010049d:	83 ec 08             	sub    $0x8,%esp
+c01004a0:	50                   	push   %eax
+c01004a1:	ff 75 10             	pushl  0x10(%ebp)
+c01004a4:	e8 bd fd ff ff       	call   c0100266 <vcprintf>
+c01004a9:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+c01004ac:	83 ec 0c             	sub    $0xc,%esp
+c01004af:	68 c6 b9 10 c0       	push   $0xc010b9c6
+c01004b4:	e8 d6 fd ff ff       	call   c010028f <cprintf>
+c01004b9:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+c01004bc:	90                   	nop
+c01004bd:	c9                   	leave  
+c01004be:	c3                   	ret    
+
+c01004bf <is_kernel_panic>:
+
+bool
+is_kernel_panic(void) {
+c01004bf:	55                   	push   %ebp
+c01004c0:	89 e5                	mov    %esp,%ebp
+    return is_panic;
+c01004c2:	a1 20 04 1b c0       	mov    0xc01b0420,%eax
+}
+c01004c7:	5d                   	pop    %ebp
+c01004c8:	c3                   	ret    
+
+c01004c9 <stab_binsearch>:
+ *      stab_binsearch(stabs, &left, &right, N_SO, 0xf0100184);
+ * will exit setting left = 118, right = 554.
+ * */
+static void
+stab_binsearch(const struct stab *stabs, int *region_left, int *region_right,
+           int type, uintptr_t addr) {
+c01004c9:	55                   	push   %ebp
+c01004ca:	89 e5                	mov    %esp,%ebp
+c01004cc:	83 ec 20             	sub    $0x20,%esp
+    int l = *region_left, r = *region_right, any_matches = 0;
+c01004cf:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01004d2:	8b 00                	mov    (%eax),%eax
+c01004d4:	89 45 fc             	mov    %eax,-0x4(%ebp)
+c01004d7:	8b 45 10             	mov    0x10(%ebp),%eax
+c01004da:	8b 00                	mov    (%eax),%eax
+c01004dc:	89 45 f8             	mov    %eax,-0x8(%ebp)
+c01004df:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+
+    while (l <= r) {
+c01004e6:	e9 d2 00 00 00       	jmp    c01005bd <stab_binsearch+0xf4>
+        int true_m = (l + r) / 2, m = true_m;
+c01004eb:	8b 55 fc             	mov    -0x4(%ebp),%edx
+c01004ee:	8b 45 f8             	mov    -0x8(%ebp),%eax
+c01004f1:	01 d0                	add    %edx,%eax
+c01004f3:	89 c2                	mov    %eax,%edx
+c01004f5:	c1 ea 1f             	shr    $0x1f,%edx
+c01004f8:	01 d0                	add    %edx,%eax
+c01004fa:	d1 f8                	sar    %eax
+c01004fc:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c01004ff:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0100502:	89 45 f0             	mov    %eax,-0x10(%ebp)
+
+        // search for earliest stab with right type
+        while (m >= l && stabs[m].n_type != type) {
+c0100505:	eb 04                	jmp    c010050b <stab_binsearch+0x42>
+            m --;
+c0100507:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
+
+    while (l <= r) {
+        int true_m = (l + r) / 2, m = true_m;
+
+        // search for earliest stab with right type
+        while (m >= l && stabs[m].n_type != type) {
+c010050b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010050e:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+c0100511:	7c 1f                	jl     c0100532 <stab_binsearch+0x69>
+c0100513:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c0100516:	89 d0                	mov    %edx,%eax
+c0100518:	01 c0                	add    %eax,%eax
+c010051a:	01 d0                	add    %edx,%eax
+c010051c:	c1 e0 02             	shl    $0x2,%eax
+c010051f:	89 c2                	mov    %eax,%edx
+c0100521:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100524:	01 d0                	add    %edx,%eax
+c0100526:	0f b6 40 04          	movzbl 0x4(%eax),%eax
+c010052a:	0f b6 c0             	movzbl %al,%eax
+c010052d:	3b 45 14             	cmp    0x14(%ebp),%eax
+c0100530:	75 d5                	jne    c0100507 <stab_binsearch+0x3e>
+            m --;
+        }
+        if (m < l) {    // no match in [l, m]
+c0100532:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0100535:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+c0100538:	7d 0b                	jge    c0100545 <stab_binsearch+0x7c>
+            l = true_m + 1;
+c010053a:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010053d:	83 c0 01             	add    $0x1,%eax
+c0100540:	89 45 fc             	mov    %eax,-0x4(%ebp)
+            continue;
+c0100543:	eb 78                	jmp    c01005bd <stab_binsearch+0xf4>
+        }
+
+        // actual binary search
+        any_matches = 1;
+c0100545:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
+        if (stabs[m].n_value < addr) {
+c010054c:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c010054f:	89 d0                	mov    %edx,%eax
+c0100551:	01 c0                	add    %eax,%eax
+c0100553:	01 d0                	add    %edx,%eax
+c0100555:	c1 e0 02             	shl    $0x2,%eax
+c0100558:	89 c2                	mov    %eax,%edx
+c010055a:	8b 45 08             	mov    0x8(%ebp),%eax
+c010055d:	01 d0                	add    %edx,%eax
+c010055f:	8b 40 08             	mov    0x8(%eax),%eax
+c0100562:	3b 45 18             	cmp    0x18(%ebp),%eax
+c0100565:	73 13                	jae    c010057a <stab_binsearch+0xb1>
+            *region_left = m;
+c0100567:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010056a:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c010056d:	89 10                	mov    %edx,(%eax)
+            l = true_m + 1;
+c010056f:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0100572:	83 c0 01             	add    $0x1,%eax
+c0100575:	89 45 fc             	mov    %eax,-0x4(%ebp)
+c0100578:	eb 43                	jmp    c01005bd <stab_binsearch+0xf4>
+        } else if (stabs[m].n_value > addr) {
+c010057a:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c010057d:	89 d0                	mov    %edx,%eax
+c010057f:	01 c0                	add    %eax,%eax
+c0100581:	01 d0                	add    %edx,%eax
+c0100583:	c1 e0 02             	shl    $0x2,%eax
+c0100586:	89 c2                	mov    %eax,%edx
+c0100588:	8b 45 08             	mov    0x8(%ebp),%eax
+c010058b:	01 d0                	add    %edx,%eax
+c010058d:	8b 40 08             	mov    0x8(%eax),%eax
+c0100590:	3b 45 18             	cmp    0x18(%ebp),%eax
+c0100593:	76 16                	jbe    c01005ab <stab_binsearch+0xe2>
+            *region_right = m - 1;
+c0100595:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0100598:	8d 50 ff             	lea    -0x1(%eax),%edx
+c010059b:	8b 45 10             	mov    0x10(%ebp),%eax
+c010059e:	89 10                	mov    %edx,(%eax)
+            r = m - 1;
+c01005a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01005a3:	83 e8 01             	sub    $0x1,%eax
+c01005a6:	89 45 f8             	mov    %eax,-0x8(%ebp)
+c01005a9:	eb 12                	jmp    c01005bd <stab_binsearch+0xf4>
+        } else {
+            // exact match for 'addr', but continue loop to find
+            // *region_right
+            *region_left = m;
+c01005ab:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01005ae:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c01005b1:	89 10                	mov    %edx,(%eax)
+            l = m;
+c01005b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01005b6:	89 45 fc             	mov    %eax,-0x4(%ebp)
+            addr ++;
+c01005b9:	83 45 18 01          	addl   $0x1,0x18(%ebp)
+static void
+stab_binsearch(const struct stab *stabs, int *region_left, int *region_right,
+           int type, uintptr_t addr) {
+    int l = *region_left, r = *region_right, any_matches = 0;
+
+    while (l <= r) {
+c01005bd:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c01005c0:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+c01005c3:	0f 8e 22 ff ff ff    	jle    c01004eb <stab_binsearch+0x22>
+            l = m;
+            addr ++;
+        }
+    }
+
+    if (!any_matches) {
+c01005c9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c01005cd:	75 0f                	jne    c01005de <stab_binsearch+0x115>
+        *region_right = *region_left - 1;
+c01005cf:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01005d2:	8b 00                	mov    (%eax),%eax
+c01005d4:	8d 50 ff             	lea    -0x1(%eax),%edx
+c01005d7:	8b 45 10             	mov    0x10(%ebp),%eax
+c01005da:	89 10                	mov    %edx,(%eax)
+        l = *region_right;
+        for (; l > *region_left && stabs[l].n_type != type; l --)
+            /* do nothing */;
+        *region_left = l;
+    }
+}
+c01005dc:	eb 3f                	jmp    c010061d <stab_binsearch+0x154>
+    if (!any_matches) {
+        *region_right = *region_left - 1;
+    }
+    else {
+        // find rightmost region containing 'addr'
+        l = *region_right;
+c01005de:	8b 45 10             	mov    0x10(%ebp),%eax
+c01005e1:	8b 00                	mov    (%eax),%eax
+c01005e3:	89 45 fc             	mov    %eax,-0x4(%ebp)
+        for (; l > *region_left && stabs[l].n_type != type; l --)
+c01005e6:	eb 04                	jmp    c01005ec <stab_binsearch+0x123>
+c01005e8:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
+c01005ec:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01005ef:	8b 00                	mov    (%eax),%eax
+c01005f1:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+c01005f4:	7d 1f                	jge    c0100615 <stab_binsearch+0x14c>
+c01005f6:	8b 55 fc             	mov    -0x4(%ebp),%edx
+c01005f9:	89 d0                	mov    %edx,%eax
+c01005fb:	01 c0                	add    %eax,%eax
+c01005fd:	01 d0                	add    %edx,%eax
+c01005ff:	c1 e0 02             	shl    $0x2,%eax
+c0100602:	89 c2                	mov    %eax,%edx
+c0100604:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100607:	01 d0                	add    %edx,%eax
+c0100609:	0f b6 40 04          	movzbl 0x4(%eax),%eax
+c010060d:	0f b6 c0             	movzbl %al,%eax
+c0100610:	3b 45 14             	cmp    0x14(%ebp),%eax
+c0100613:	75 d3                	jne    c01005e8 <stab_binsearch+0x11f>
+            /* do nothing */;
+        *region_left = l;
+c0100615:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0100618:	8b 55 fc             	mov    -0x4(%ebp),%edx
+c010061b:	89 10                	mov    %edx,(%eax)
+    }
+}
+c010061d:	90                   	nop
+c010061e:	c9                   	leave  
+c010061f:	c3                   	ret    
+
+c0100620 <debuginfo_eip>:
+ * the specified instruction address, @addr.  Returns 0 if information
+ * was found, and negative if not.  But even if it returns negative it
+ * has stored some information into '*info'.
+ * */
+int
+debuginfo_eip(uintptr_t addr, struct eipdebuginfo *info) {
+c0100620:	55                   	push   %ebp
+c0100621:	89 e5                	mov    %esp,%ebp
+c0100623:	83 ec 38             	sub    $0x38,%esp
+    const struct stab *stabs, *stab_end;
+    const char *stabstr, *stabstr_end;
+
+    info->eip_file = "<unknown>";
+c0100626:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0100629:	c7 00 f8 b9 10 c0    	movl   $0xc010b9f8,(%eax)
+    info->eip_line = 0;
+c010062f:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0100632:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
+    info->eip_fn_name = "<unknown>";
+c0100639:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010063c:	c7 40 08 f8 b9 10 c0 	movl   $0xc010b9f8,0x8(%eax)
+    info->eip_fn_namelen = 9;
+c0100643:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0100646:	c7 40 0c 09 00 00 00 	movl   $0x9,0xc(%eax)
+    info->eip_fn_addr = addr;
+c010064d:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0100650:	8b 55 08             	mov    0x8(%ebp),%edx
+c0100653:	89 50 10             	mov    %edx,0x10(%eax)
+    info->eip_fn_narg = 0;
+c0100656:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0100659:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
+
+    // find the relevant set of stabs
+    if (addr >= KERNBASE) {
+c0100660:	81 7d 08 ff ff ff bf 	cmpl   $0xbfffffff,0x8(%ebp)
+c0100667:	76 21                	jbe    c010068a <debuginfo_eip+0x6a>
+        stabs = __STAB_BEGIN__;
+c0100669:	c7 45 f4 80 e1 10 c0 	movl   $0xc010e180,-0xc(%ebp)
+        stab_end = __STAB_END__;
+c0100670:	c7 45 f0 54 39 12 c0 	movl   $0xc0123954,-0x10(%ebp)
+        stabstr = __STABSTR_BEGIN__;
+c0100677:	c7 45 ec 55 39 12 c0 	movl   $0xc0123955,-0x14(%ebp)
+        stabstr_end = __STABSTR_END__;
+c010067e:	c7 45 e8 33 9b 12 c0 	movl   $0xc0129b33,-0x18(%ebp)
+c0100685:	e9 c3 00 00 00       	jmp    c010074d <debuginfo_eip+0x12d>
+    }
+    else {
+        // user-program linker script, tools/user.ld puts the information about the
+        // program's stabs (included __STAB_BEGIN__, __STAB_END__, __STABSTR_BEGIN__,
+        // and __STABSTR_END__) in a structure located at virtual address USTAB.
+        const struct userstabdata *usd = (struct userstabdata *)USTAB;
+c010068a:	c7 45 e4 00 00 20 00 	movl   $0x200000,-0x1c(%ebp)
+
+        // make sure that debugger (current process) can access this memory
+        struct mm_struct *mm;
+        if (current == NULL || (mm = current->mm) == NULL) {
+c0100691:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c0100696:	85 c0                	test   %eax,%eax
+c0100698:	74 11                	je     c01006ab <debuginfo_eip+0x8b>
+c010069a:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c010069f:	8b 40 18             	mov    0x18(%eax),%eax
+c01006a2:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c01006a5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+c01006a9:	75 0a                	jne    c01006b5 <debuginfo_eip+0x95>
+            return -1;
+c01006ab:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+c01006b0:	e9 4e 03 00 00       	jmp    c0100a03 <debuginfo_eip+0x3e3>
+        }
+        if (!user_mem_check(mm, (uintptr_t)usd, sizeof(struct userstabdata), 0)) {
+c01006b5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01006b8:	6a 00                	push   $0x0
+c01006ba:	6a 10                	push   $0x10
+c01006bc:	50                   	push   %eax
+c01006bd:	ff 75 e0             	pushl  -0x20(%ebp)
+c01006c0:	e8 e3 5d 00 00       	call   c01064a8 <user_mem_check>
+c01006c5:	83 c4 10             	add    $0x10,%esp
+c01006c8:	85 c0                	test   %eax,%eax
+c01006ca:	75 0a                	jne    c01006d6 <debuginfo_eip+0xb6>
+            return -1;
+c01006cc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+c01006d1:	e9 2d 03 00 00       	jmp    c0100a03 <debuginfo_eip+0x3e3>
+        }
+
+        stabs = usd->stabs;
+c01006d6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01006d9:	8b 00                	mov    (%eax),%eax
+c01006db:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        stab_end = usd->stab_end;
+c01006de:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01006e1:	8b 40 04             	mov    0x4(%eax),%eax
+c01006e4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+        stabstr = usd->stabstr;
+c01006e7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01006ea:	8b 40 08             	mov    0x8(%eax),%eax
+c01006ed:	89 45 ec             	mov    %eax,-0x14(%ebp)
+        stabstr_end = usd->stabstr_end;
+c01006f0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01006f3:	8b 40 0c             	mov    0xc(%eax),%eax
+c01006f6:	89 45 e8             	mov    %eax,-0x18(%ebp)
+
+        // make sure the STABS and string table memory is valid
+        if (!user_mem_check(mm, (uintptr_t)stabs, (uintptr_t)stab_end - (uintptr_t)stabs, 0)) {
+c01006f9:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c01006fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01006ff:	29 c2                	sub    %eax,%edx
+c0100701:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100704:	6a 00                	push   $0x0
+c0100706:	52                   	push   %edx
+c0100707:	50                   	push   %eax
+c0100708:	ff 75 e0             	pushl  -0x20(%ebp)
+c010070b:	e8 98 5d 00 00       	call   c01064a8 <user_mem_check>
+c0100710:	83 c4 10             	add    $0x10,%esp
+c0100713:	85 c0                	test   %eax,%eax
+c0100715:	75 0a                	jne    c0100721 <debuginfo_eip+0x101>
+            return -1;
+c0100717:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+c010071c:	e9 e2 02 00 00       	jmp    c0100a03 <debuginfo_eip+0x3e3>
+        }
+        if (!user_mem_check(mm, (uintptr_t)stabstr, stabstr_end - stabstr, 0)) {
+c0100721:	8b 55 e8             	mov    -0x18(%ebp),%edx
+c0100724:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0100727:	29 c2                	sub    %eax,%edx
+c0100729:	89 d0                	mov    %edx,%eax
+c010072b:	89 c2                	mov    %eax,%edx
+c010072d:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0100730:	6a 00                	push   $0x0
+c0100732:	52                   	push   %edx
+c0100733:	50                   	push   %eax
+c0100734:	ff 75 e0             	pushl  -0x20(%ebp)
+c0100737:	e8 6c 5d 00 00       	call   c01064a8 <user_mem_check>
+c010073c:	83 c4 10             	add    $0x10,%esp
+c010073f:	85 c0                	test   %eax,%eax
+c0100741:	75 0a                	jne    c010074d <debuginfo_eip+0x12d>
+            return -1;
+c0100743:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+c0100748:	e9 b6 02 00 00       	jmp    c0100a03 <debuginfo_eip+0x3e3>
+        }
+    }
+
+    // String table validity checks
+    if (stabstr_end <= stabstr || stabstr_end[-1] != 0) {
+c010074d:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0100750:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+c0100753:	76 0d                	jbe    c0100762 <debuginfo_eip+0x142>
+c0100755:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0100758:	83 e8 01             	sub    $0x1,%eax
+c010075b:	0f b6 00             	movzbl (%eax),%eax
+c010075e:	84 c0                	test   %al,%al
+c0100760:	74 0a                	je     c010076c <debuginfo_eip+0x14c>
+        return -1;
+c0100762:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+c0100767:	e9 97 02 00 00       	jmp    c0100a03 <debuginfo_eip+0x3e3>
+    // 'eip'.  First, we find the basic source file containing 'eip'.
+    // Then, we look in that source file for the function.  Then we look
+    // for the line number.
+
+    // Search the entire set of stabs for the source file (type N_SO).
+    int lfile = 0, rfile = (stab_end - stabs) - 1;
+c010076c:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+c0100773:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c0100776:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100779:	29 c2                	sub    %eax,%edx
+c010077b:	89 d0                	mov    %edx,%eax
+c010077d:	c1 f8 02             	sar    $0x2,%eax
+c0100780:	69 c0 ab aa aa aa    	imul   $0xaaaaaaab,%eax,%eax
+c0100786:	83 e8 01             	sub    $0x1,%eax
+c0100789:	89 45 d8             	mov    %eax,-0x28(%ebp)
+    stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
+c010078c:	83 ec 0c             	sub    $0xc,%esp
+c010078f:	ff 75 08             	pushl  0x8(%ebp)
+c0100792:	6a 64                	push   $0x64
+c0100794:	8d 45 d8             	lea    -0x28(%ebp),%eax
+c0100797:	50                   	push   %eax
+c0100798:	8d 45 dc             	lea    -0x24(%ebp),%eax
+c010079b:	50                   	push   %eax
+c010079c:	ff 75 f4             	pushl  -0xc(%ebp)
+c010079f:	e8 25 fd ff ff       	call   c01004c9 <stab_binsearch>
+c01007a4:	83 c4 20             	add    $0x20,%esp
+    if (lfile == 0)
+c01007a7:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c01007aa:	85 c0                	test   %eax,%eax
+c01007ac:	75 0a                	jne    c01007b8 <debuginfo_eip+0x198>
+        return -1;
+c01007ae:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+c01007b3:	e9 4b 02 00 00       	jmp    c0100a03 <debuginfo_eip+0x3e3>
+
+    // Search within that file's stabs for the function definition
+    // (N_FUN).
+    int lfun = lfile, rfun = rfile;
+c01007b8:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c01007bb:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+c01007be:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c01007c1:	89 45 d0             	mov    %eax,-0x30(%ebp)
+    int lline, rline;
+    stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
+c01007c4:	83 ec 0c             	sub    $0xc,%esp
+c01007c7:	ff 75 08             	pushl  0x8(%ebp)
+c01007ca:	6a 24                	push   $0x24
+c01007cc:	8d 45 d0             	lea    -0x30(%ebp),%eax
+c01007cf:	50                   	push   %eax
+c01007d0:	8d 45 d4             	lea    -0x2c(%ebp),%eax
+c01007d3:	50                   	push   %eax
+c01007d4:	ff 75 f4             	pushl  -0xc(%ebp)
+c01007d7:	e8 ed fc ff ff       	call   c01004c9 <stab_binsearch>
+c01007dc:	83 c4 20             	add    $0x20,%esp
+
+    if (lfun <= rfun) {
+c01007df:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c01007e2:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c01007e5:	39 c2                	cmp    %eax,%edx
+c01007e7:	7f 7c                	jg     c0100865 <debuginfo_eip+0x245>
+        // stabs[lfun] points to the function name
+        // in the string table, but check bounds just in case.
+        if (stabs[lfun].n_strx < stabstr_end - stabstr) {
+c01007e9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c01007ec:	89 c2                	mov    %eax,%edx
+c01007ee:	89 d0                	mov    %edx,%eax
+c01007f0:	01 c0                	add    %eax,%eax
+c01007f2:	01 d0                	add    %edx,%eax
+c01007f4:	c1 e0 02             	shl    $0x2,%eax
+c01007f7:	89 c2                	mov    %eax,%edx
+c01007f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01007fc:	01 d0                	add    %edx,%eax
+c01007fe:	8b 00                	mov    (%eax),%eax
+c0100800:	8b 4d e8             	mov    -0x18(%ebp),%ecx
+c0100803:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c0100806:	29 d1                	sub    %edx,%ecx
+c0100808:	89 ca                	mov    %ecx,%edx
+c010080a:	39 d0                	cmp    %edx,%eax
+c010080c:	73 22                	jae    c0100830 <debuginfo_eip+0x210>
+            info->eip_fn_name = stabstr + stabs[lfun].n_strx;
+c010080e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c0100811:	89 c2                	mov    %eax,%edx
+c0100813:	89 d0                	mov    %edx,%eax
+c0100815:	01 c0                	add    %eax,%eax
+c0100817:	01 d0                	add    %edx,%eax
+c0100819:	c1 e0 02             	shl    $0x2,%eax
+c010081c:	89 c2                	mov    %eax,%edx
+c010081e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100821:	01 d0                	add    %edx,%eax
+c0100823:	8b 10                	mov    (%eax),%edx
+c0100825:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0100828:	01 c2                	add    %eax,%edx
+c010082a:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010082d:	89 50 08             	mov    %edx,0x8(%eax)
+        }
+        info->eip_fn_addr = stabs[lfun].n_value;
+c0100830:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c0100833:	89 c2                	mov    %eax,%edx
+c0100835:	89 d0                	mov    %edx,%eax
+c0100837:	01 c0                	add    %eax,%eax
+c0100839:	01 d0                	add    %edx,%eax
+c010083b:	c1 e0 02             	shl    $0x2,%eax
+c010083e:	89 c2                	mov    %eax,%edx
+c0100840:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100843:	01 d0                	add    %edx,%eax
+c0100845:	8b 50 08             	mov    0x8(%eax),%edx
+c0100848:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010084b:	89 50 10             	mov    %edx,0x10(%eax)
+        addr -= info->eip_fn_addr;
+c010084e:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0100851:	8b 40 10             	mov    0x10(%eax),%eax
+c0100854:	29 45 08             	sub    %eax,0x8(%ebp)
+        // Search within the function definition for the line number.
+        lline = lfun;
+c0100857:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c010085a:	89 45 cc             	mov    %eax,-0x34(%ebp)
+        rline = rfun;
+c010085d:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c0100860:	89 45 c8             	mov    %eax,-0x38(%ebp)
+c0100863:	eb 15                	jmp    c010087a <debuginfo_eip+0x25a>
+    } else {
+        // Couldn't find function stab!  Maybe we're in an assembly
+        // file.  Search the whole file for the line number.
+        info->eip_fn_addr = addr;
+c0100865:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0100868:	8b 55 08             	mov    0x8(%ebp),%edx
+c010086b:	89 50 10             	mov    %edx,0x10(%eax)
+        lline = lfile;
+c010086e:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0100871:	89 45 cc             	mov    %eax,-0x34(%ebp)
+        rline = rfile;
+c0100874:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c0100877:	89 45 c8             	mov    %eax,-0x38(%ebp)
+    }
+    info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
+c010087a:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010087d:	8b 40 08             	mov    0x8(%eax),%eax
+c0100880:	83 ec 08             	sub    $0x8,%esp
+c0100883:	6a 3a                	push   $0x3a
+c0100885:	50                   	push   %eax
+c0100886:	e8 41 a6 00 00       	call   c010aecc <strfind>
+c010088b:	83 c4 10             	add    $0x10,%esp
+c010088e:	89 c2                	mov    %eax,%edx
+c0100890:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0100893:	8b 40 08             	mov    0x8(%eax),%eax
+c0100896:	29 c2                	sub    %eax,%edx
+c0100898:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010089b:	89 50 0c             	mov    %edx,0xc(%eax)
+
+    // Search within [lline, rline] for the line number stab.
+    // If found, set info->eip_line to the right line number.
+    // If not found, return -1.
+    stab_binsearch(stabs, &lline, &rline, N_SLINE, addr);
+c010089e:	83 ec 0c             	sub    $0xc,%esp
+c01008a1:	ff 75 08             	pushl  0x8(%ebp)
+c01008a4:	6a 44                	push   $0x44
+c01008a6:	8d 45 c8             	lea    -0x38(%ebp),%eax
+c01008a9:	50                   	push   %eax
+c01008aa:	8d 45 cc             	lea    -0x34(%ebp),%eax
+c01008ad:	50                   	push   %eax
+c01008ae:	ff 75 f4             	pushl  -0xc(%ebp)
+c01008b1:	e8 13 fc ff ff       	call   c01004c9 <stab_binsearch>
+c01008b6:	83 c4 20             	add    $0x20,%esp
+    if (lline <= rline) {
+c01008b9:	8b 55 cc             	mov    -0x34(%ebp),%edx
+c01008bc:	8b 45 c8             	mov    -0x38(%ebp),%eax
+c01008bf:	39 c2                	cmp    %eax,%edx
+c01008c1:	7f 24                	jg     c01008e7 <debuginfo_eip+0x2c7>
+        info->eip_line = stabs[rline].n_desc;
+c01008c3:	8b 45 c8             	mov    -0x38(%ebp),%eax
+c01008c6:	89 c2                	mov    %eax,%edx
+c01008c8:	89 d0                	mov    %edx,%eax
+c01008ca:	01 c0                	add    %eax,%eax
+c01008cc:	01 d0                	add    %edx,%eax
+c01008ce:	c1 e0 02             	shl    $0x2,%eax
+c01008d1:	89 c2                	mov    %eax,%edx
+c01008d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01008d6:	01 d0                	add    %edx,%eax
+c01008d8:	0f b7 40 06          	movzwl 0x6(%eax),%eax
+c01008dc:	0f b7 d0             	movzwl %ax,%edx
+c01008df:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01008e2:	89 50 04             	mov    %edx,0x4(%eax)
+
+    // Search backwards from the line number for the relevant filename stab.
+    // We can't just use the "lfile" stab because inlined functions
+    // can interpolate code from a different file!
+    // Such included source files use the N_SOL stab type.
+    while (lline >= lfile
+c01008e5:	eb 13                	jmp    c01008fa <debuginfo_eip+0x2da>
+    // If not found, return -1.
+    stab_binsearch(stabs, &lline, &rline, N_SLINE, addr);
+    if (lline <= rline) {
+        info->eip_line = stabs[rline].n_desc;
+    } else {
+        return -1;
+c01008e7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+c01008ec:	e9 12 01 00 00       	jmp    c0100a03 <debuginfo_eip+0x3e3>
+    // can interpolate code from a different file!
+    // Such included source files use the N_SOL stab type.
+    while (lline >= lfile
+           && stabs[lline].n_type != N_SOL
+           && (stabs[lline].n_type != N_SO || !stabs[lline].n_value)) {
+        lline --;
+c01008f1:	8b 45 cc             	mov    -0x34(%ebp),%eax
+c01008f4:	83 e8 01             	sub    $0x1,%eax
+c01008f7:	89 45 cc             	mov    %eax,-0x34(%ebp)
+
+    // Search backwards from the line number for the relevant filename stab.
+    // We can't just use the "lfile" stab because inlined functions
+    // can interpolate code from a different file!
+    // Such included source files use the N_SOL stab type.
+    while (lline >= lfile
+c01008fa:	8b 55 cc             	mov    -0x34(%ebp),%edx
+c01008fd:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0100900:	39 c2                	cmp    %eax,%edx
+c0100902:	7c 56                	jl     c010095a <debuginfo_eip+0x33a>
+           && stabs[lline].n_type != N_SOL
+c0100904:	8b 45 cc             	mov    -0x34(%ebp),%eax
+c0100907:	89 c2                	mov    %eax,%edx
+c0100909:	89 d0                	mov    %edx,%eax
+c010090b:	01 c0                	add    %eax,%eax
+c010090d:	01 d0                	add    %edx,%eax
+c010090f:	c1 e0 02             	shl    $0x2,%eax
+c0100912:	89 c2                	mov    %eax,%edx
+c0100914:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100917:	01 d0                	add    %edx,%eax
+c0100919:	0f b6 40 04          	movzbl 0x4(%eax),%eax
+c010091d:	3c 84                	cmp    $0x84,%al
+c010091f:	74 39                	je     c010095a <debuginfo_eip+0x33a>
+           && (stabs[lline].n_type != N_SO || !stabs[lline].n_value)) {
+c0100921:	8b 45 cc             	mov    -0x34(%ebp),%eax
+c0100924:	89 c2                	mov    %eax,%edx
+c0100926:	89 d0                	mov    %edx,%eax
+c0100928:	01 c0                	add    %eax,%eax
+c010092a:	01 d0                	add    %edx,%eax
+c010092c:	c1 e0 02             	shl    $0x2,%eax
+c010092f:	89 c2                	mov    %eax,%edx
+c0100931:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100934:	01 d0                	add    %edx,%eax
+c0100936:	0f b6 40 04          	movzbl 0x4(%eax),%eax
+c010093a:	3c 64                	cmp    $0x64,%al
+c010093c:	75 b3                	jne    c01008f1 <debuginfo_eip+0x2d1>
+c010093e:	8b 45 cc             	mov    -0x34(%ebp),%eax
+c0100941:	89 c2                	mov    %eax,%edx
+c0100943:	89 d0                	mov    %edx,%eax
+c0100945:	01 c0                	add    %eax,%eax
+c0100947:	01 d0                	add    %edx,%eax
+c0100949:	c1 e0 02             	shl    $0x2,%eax
+c010094c:	89 c2                	mov    %eax,%edx
+c010094e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100951:	01 d0                	add    %edx,%eax
+c0100953:	8b 40 08             	mov    0x8(%eax),%eax
+c0100956:	85 c0                	test   %eax,%eax
+c0100958:	74 97                	je     c01008f1 <debuginfo_eip+0x2d1>
+        lline --;
+    }
+    if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr) {
+c010095a:	8b 55 cc             	mov    -0x34(%ebp),%edx
+c010095d:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0100960:	39 c2                	cmp    %eax,%edx
+c0100962:	7c 46                	jl     c01009aa <debuginfo_eip+0x38a>
+c0100964:	8b 45 cc             	mov    -0x34(%ebp),%eax
+c0100967:	89 c2                	mov    %eax,%edx
+c0100969:	89 d0                	mov    %edx,%eax
+c010096b:	01 c0                	add    %eax,%eax
+c010096d:	01 d0                	add    %edx,%eax
+c010096f:	c1 e0 02             	shl    $0x2,%eax
+c0100972:	89 c2                	mov    %eax,%edx
+c0100974:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100977:	01 d0                	add    %edx,%eax
+c0100979:	8b 00                	mov    (%eax),%eax
+c010097b:	8b 4d e8             	mov    -0x18(%ebp),%ecx
+c010097e:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c0100981:	29 d1                	sub    %edx,%ecx
+c0100983:	89 ca                	mov    %ecx,%edx
+c0100985:	39 d0                	cmp    %edx,%eax
+c0100987:	73 21                	jae    c01009aa <debuginfo_eip+0x38a>
+        info->eip_file = stabstr + stabs[lline].n_strx;
+c0100989:	8b 45 cc             	mov    -0x34(%ebp),%eax
+c010098c:	89 c2                	mov    %eax,%edx
+c010098e:	89 d0                	mov    %edx,%eax
+c0100990:	01 c0                	add    %eax,%eax
+c0100992:	01 d0                	add    %edx,%eax
+c0100994:	c1 e0 02             	shl    $0x2,%eax
+c0100997:	89 c2                	mov    %eax,%edx
+c0100999:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010099c:	01 d0                	add    %edx,%eax
+c010099e:	8b 10                	mov    (%eax),%edx
+c01009a0:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01009a3:	01 c2                	add    %eax,%edx
+c01009a5:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01009a8:	89 10                	mov    %edx,(%eax)
+    }
+
+    // Set eip_fn_narg to the number of arguments taken by the function,
+    // or 0 if there was no containing function.
+    if (lfun < rfun) {
+c01009aa:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c01009ad:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c01009b0:	39 c2                	cmp    %eax,%edx
+c01009b2:	7d 4a                	jge    c01009fe <debuginfo_eip+0x3de>
+        for (lline = lfun + 1;
+c01009b4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c01009b7:	83 c0 01             	add    $0x1,%eax
+c01009ba:	89 45 cc             	mov    %eax,-0x34(%ebp)
+c01009bd:	eb 18                	jmp    c01009d7 <debuginfo_eip+0x3b7>
+             lline < rfun && stabs[lline].n_type == N_PSYM;
+             lline ++) {
+            info->eip_fn_narg ++;
+c01009bf:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01009c2:	8b 40 14             	mov    0x14(%eax),%eax
+c01009c5:	8d 50 01             	lea    0x1(%eax),%edx
+c01009c8:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01009cb:	89 50 14             	mov    %edx,0x14(%eax)
+    // Set eip_fn_narg to the number of arguments taken by the function,
+    // or 0 if there was no containing function.
+    if (lfun < rfun) {
+        for (lline = lfun + 1;
+             lline < rfun && stabs[lline].n_type == N_PSYM;
+             lline ++) {
+c01009ce:	8b 45 cc             	mov    -0x34(%ebp),%eax
+c01009d1:	83 c0 01             	add    $0x1,%eax
+c01009d4:	89 45 cc             	mov    %eax,-0x34(%ebp)
+
+    // Set eip_fn_narg to the number of arguments taken by the function,
+    // or 0 if there was no containing function.
+    if (lfun < rfun) {
+        for (lline = lfun + 1;
+             lline < rfun && stabs[lline].n_type == N_PSYM;
+c01009d7:	8b 55 cc             	mov    -0x34(%ebp),%edx
+c01009da:	8b 45 d0             	mov    -0x30(%ebp),%eax
+    }
+
+    // Set eip_fn_narg to the number of arguments taken by the function,
+    // or 0 if there was no containing function.
+    if (lfun < rfun) {
+        for (lline = lfun + 1;
+c01009dd:	39 c2                	cmp    %eax,%edx
+c01009df:	7d 1d                	jge    c01009fe <debuginfo_eip+0x3de>
+             lline < rfun && stabs[lline].n_type == N_PSYM;
+c01009e1:	8b 45 cc             	mov    -0x34(%ebp),%eax
+c01009e4:	89 c2                	mov    %eax,%edx
+c01009e6:	89 d0                	mov    %edx,%eax
+c01009e8:	01 c0                	add    %eax,%eax
+c01009ea:	01 d0                	add    %edx,%eax
+c01009ec:	c1 e0 02             	shl    $0x2,%eax
+c01009ef:	89 c2                	mov    %eax,%edx
+c01009f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01009f4:	01 d0                	add    %edx,%eax
+c01009f6:	0f b6 40 04          	movzbl 0x4(%eax),%eax
+c01009fa:	3c a0                	cmp    $0xa0,%al
+c01009fc:	74 c1                	je     c01009bf <debuginfo_eip+0x39f>
+             lline ++) {
+            info->eip_fn_narg ++;
+        }
+    }
+    return 0;
+c01009fe:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c0100a03:	c9                   	leave  
+c0100a04:	c3                   	ret    
+
+c0100a05 <print_kerninfo>:
+ * print_kerninfo - print the information about kernel, including the location
+ * of kernel entry, the start addresses of data and text segements, the start
+ * address of free memory and how many memory that kernel has used.
+ * */
+void
+print_kerninfo(void) {
+c0100a05:	55                   	push   %ebp
+c0100a06:	89 e5                	mov    %esp,%ebp
+c0100a08:	83 ec 08             	sub    $0x8,%esp
+    extern char etext[], edata[], end[], kern_init[];
+    cprintf("Special kernel symbols:\n");
+c0100a0b:	83 ec 0c             	sub    $0xc,%esp
+c0100a0e:	68 02 ba 10 c0       	push   $0xc010ba02
+c0100a13:	e8 77 f8 ff ff       	call   c010028f <cprintf>
+c0100a18:	83 c4 10             	add    $0x10,%esp
+    cprintf("  entry  0x%08x (phys)\n", kern_init);
+c0100a1b:	83 ec 08             	sub    $0x8,%esp
+c0100a1e:	68 36 00 10 c0       	push   $0xc0100036
+c0100a23:	68 1b ba 10 c0       	push   $0xc010ba1b
+c0100a28:	e8 62 f8 ff ff       	call   c010028f <cprintf>
+c0100a2d:	83 c4 10             	add    $0x10,%esp
+    cprintf("  etext  0x%08x (phys)\n", etext);
+c0100a30:	83 ec 08             	sub    $0x8,%esp
+c0100a33:	68 ec b8 10 c0       	push   $0xc010b8ec
+c0100a38:	68 33 ba 10 c0       	push   $0xc010ba33
+c0100a3d:	e8 4d f8 ff ff       	call   c010028f <cprintf>
+c0100a42:	83 c4 10             	add    $0x10,%esp
+    cprintf("  edata  0x%08x (phys)\n", edata);
+c0100a45:	83 ec 08             	sub    $0x8,%esp
+c0100a48:	68 00 00 1b c0       	push   $0xc01b0000
+c0100a4d:	68 4b ba 10 c0       	push   $0xc010ba4b
+c0100a52:	e8 38 f8 ff ff       	call   c010028f <cprintf>
+c0100a57:	83 c4 10             	add    $0x10,%esp
+    cprintf("  end    0x%08x (phys)\n", end);
+c0100a5a:	83 ec 08             	sub    $0x8,%esp
+c0100a5d:	68 78 31 1b c0       	push   $0xc01b3178
+c0100a62:	68 63 ba 10 c0       	push   $0xc010ba63
+c0100a67:	e8 23 f8 ff ff       	call   c010028f <cprintf>
+c0100a6c:	83 c4 10             	add    $0x10,%esp
+    cprintf("Kernel executable memory footprint: %dKB\n", (end - kern_init + 1023)/1024);
+c0100a6f:	b8 78 31 1b c0       	mov    $0xc01b3178,%eax
+c0100a74:	05 ff 03 00 00       	add    $0x3ff,%eax
+c0100a79:	ba 36 00 10 c0       	mov    $0xc0100036,%edx
+c0100a7e:	29 d0                	sub    %edx,%eax
+c0100a80:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
+c0100a86:	85 c0                	test   %eax,%eax
+c0100a88:	0f 48 c2             	cmovs  %edx,%eax
+c0100a8b:	c1 f8 0a             	sar    $0xa,%eax
+c0100a8e:	83 ec 08             	sub    $0x8,%esp
+c0100a91:	50                   	push   %eax
+c0100a92:	68 7c ba 10 c0       	push   $0xc010ba7c
+c0100a97:	e8 f3 f7 ff ff       	call   c010028f <cprintf>
+c0100a9c:	83 c4 10             	add    $0x10,%esp
+}
+c0100a9f:	90                   	nop
+c0100aa0:	c9                   	leave  
+c0100aa1:	c3                   	ret    
+
+c0100aa2 <print_debuginfo>:
+/* *
+ * print_debuginfo - read and print the stat information for the address @eip,
+ * and info.eip_fn_addr should be the first address of the related function.
+ * */
+void
+print_debuginfo(uintptr_t eip) {
+c0100aa2:	55                   	push   %ebp
+c0100aa3:	89 e5                	mov    %esp,%ebp
+c0100aa5:	81 ec 28 01 00 00    	sub    $0x128,%esp
+    struct eipdebuginfo info;
+    if (debuginfo_eip(eip, &info) != 0) {
+c0100aab:	83 ec 08             	sub    $0x8,%esp
+c0100aae:	8d 45 dc             	lea    -0x24(%ebp),%eax
+c0100ab1:	50                   	push   %eax
+c0100ab2:	ff 75 08             	pushl  0x8(%ebp)
+c0100ab5:	e8 66 fb ff ff       	call   c0100620 <debuginfo_eip>
+c0100aba:	83 c4 10             	add    $0x10,%esp
+c0100abd:	85 c0                	test   %eax,%eax
+c0100abf:	74 15                	je     c0100ad6 <print_debuginfo+0x34>
+        cprintf("    <unknow>: -- 0x%08x --\n", eip);
+c0100ac1:	83 ec 08             	sub    $0x8,%esp
+c0100ac4:	ff 75 08             	pushl  0x8(%ebp)
+c0100ac7:	68 a6 ba 10 c0       	push   $0xc010baa6
+c0100acc:	e8 be f7 ff ff       	call   c010028f <cprintf>
+c0100ad1:	83 c4 10             	add    $0x10,%esp
+        }
+        fnname[j] = '\0';
+        cprintf("    %s:%d: %s+%d\n", info.eip_file, info.eip_line,
+                fnname, eip - info.eip_fn_addr);
+    }
+}
+c0100ad4:	eb 65                	jmp    c0100b3b <print_debuginfo+0x99>
+        cprintf("    <unknow>: -- 0x%08x --\n", eip);
+    }
+    else {
+        char fnname[256];
+        int j;
+        for (j = 0; j < info.eip_fn_namelen; j ++) {
+c0100ad6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c0100add:	eb 1c                	jmp    c0100afb <print_debuginfo+0x59>
+            fnname[j] = info.eip_fn_name[j];
+c0100adf:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c0100ae2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100ae5:	01 d0                	add    %edx,%eax
+c0100ae7:	0f b6 00             	movzbl (%eax),%eax
+c0100aea:	8d 8d dc fe ff ff    	lea    -0x124(%ebp),%ecx
+c0100af0:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0100af3:	01 ca                	add    %ecx,%edx
+c0100af5:	88 02                	mov    %al,(%edx)
+        cprintf("    <unknow>: -- 0x%08x --\n", eip);
+    }
+    else {
+        char fnname[256];
+        int j;
+        for (j = 0; j < info.eip_fn_namelen; j ++) {
+c0100af7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+c0100afb:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0100afe:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+c0100b01:	7f dc                	jg     c0100adf <print_debuginfo+0x3d>
+            fnname[j] = info.eip_fn_name[j];
+        }
+        fnname[j] = '\0';
+c0100b03:	8d 95 dc fe ff ff    	lea    -0x124(%ebp),%edx
+c0100b09:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100b0c:	01 d0                	add    %edx,%eax
+c0100b0e:	c6 00 00             	movb   $0x0,(%eax)
+        cprintf("    %s:%d: %s+%d\n", info.eip_file, info.eip_line,
+                fnname, eip - info.eip_fn_addr);
+c0100b11:	8b 45 ec             	mov    -0x14(%ebp),%eax
+        int j;
+        for (j = 0; j < info.eip_fn_namelen; j ++) {
+            fnname[j] = info.eip_fn_name[j];
+        }
+        fnname[j] = '\0';
+        cprintf("    %s:%d: %s+%d\n", info.eip_file, info.eip_line,
+c0100b14:	8b 55 08             	mov    0x8(%ebp),%edx
+c0100b17:	89 d1                	mov    %edx,%ecx
+c0100b19:	29 c1                	sub    %eax,%ecx
+c0100b1b:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c0100b1e:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0100b21:	83 ec 0c             	sub    $0xc,%esp
+c0100b24:	51                   	push   %ecx
+c0100b25:	8d 8d dc fe ff ff    	lea    -0x124(%ebp),%ecx
+c0100b2b:	51                   	push   %ecx
+c0100b2c:	52                   	push   %edx
+c0100b2d:	50                   	push   %eax
+c0100b2e:	68 c2 ba 10 c0       	push   $0xc010bac2
+c0100b33:	e8 57 f7 ff ff       	call   c010028f <cprintf>
+c0100b38:	83 c4 20             	add    $0x20,%esp
+                fnname, eip - info.eip_fn_addr);
+    }
+}
+c0100b3b:	90                   	nop
+c0100b3c:	c9                   	leave  
+c0100b3d:	c3                   	ret    
+
+c0100b3e <read_eip>:
+
+static __noinline uint32_t
+read_eip(void) {
+c0100b3e:	55                   	push   %ebp
+c0100b3f:	89 e5                	mov    %esp,%ebp
+c0100b41:	83 ec 10             	sub    $0x10,%esp
+    uint32_t eip;
+    asm volatile("movl 4(%%ebp), %0" : "=r" (eip));
+c0100b44:	8b 45 04             	mov    0x4(%ebp),%eax
+c0100b47:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    return eip;
+c0100b4a:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+c0100b4d:	c9                   	leave  
+c0100b4e:	c3                   	ret    
+
+c0100b4f <print_stackframe>:
+ *
+ * Note that, the length of ebp-chain is limited. In boot/bootasm.S, before jumping
+ * to the kernel entry, the value of ebp has been set to zero, that's the boundary.
+ * */
+void
+print_stackframe(void) {
+c0100b4f:	55                   	push   %ebp
+c0100b50:	89 e5                	mov    %esp,%ebp
+c0100b52:	83 ec 28             	sub    $0x28,%esp
+}
+
+static inline uint32_t
+read_ebp(void) {
+    uint32_t ebp;
+    asm volatile ("movl %%ebp, %0" : "=r" (ebp));
+c0100b55:	89 e8                	mov    %ebp,%eax
+c0100b57:	89 45 e0             	mov    %eax,-0x20(%ebp)
+    return ebp;
+c0100b5a:	8b 45 e0             	mov    -0x20(%ebp),%eax
+      *    (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.
+      *    (3.5) popup a calling stackframe
+      *           NOTICE: the calling funciton's return addr eip  = ss:[ebp+4]
+      *                   the calling funciton's ebp = ss:[ebp]
+      */
+    uint32_t my_ebp = read_ebp();
+c0100b5d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    uint32_t my_eip = read_eip();
+c0100b60:	e8 d9 ff ff ff       	call   c0100b3e <read_eip>
+c0100b65:	89 45 f0             	mov    %eax,-0x10(%ebp)
+
+    int i, j;
+    for (i = 0; my_ebp != 0 && i < STACKFRAME_DEPTH; i ++) {
+c0100b68:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+c0100b6f:	e9 8d 00 00 00       	jmp    c0100c01 <print_stackframe+0xb2>
+        cprintf("ebp:0x%08x eip:0x%08x args:", my_ebp, my_eip);
+c0100b74:	83 ec 04             	sub    $0x4,%esp
+c0100b77:	ff 75 f0             	pushl  -0x10(%ebp)
+c0100b7a:	ff 75 f4             	pushl  -0xc(%ebp)
+c0100b7d:	68 d4 ba 10 c0       	push   $0xc010bad4
+c0100b82:	e8 08 f7 ff ff       	call   c010028f <cprintf>
+c0100b87:	83 c4 10             	add    $0x10,%esp
+        uint32_t *args = (uint32_t *)my_ebp + 2;
+c0100b8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100b8d:	83 c0 08             	add    $0x8,%eax
+c0100b90:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+        for (j = 0; j < 4; j ++) {
+c0100b93:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+c0100b9a:	eb 26                	jmp    c0100bc2 <print_stackframe+0x73>
+            cprintf("0x%08x ", args[j]);
+c0100b9c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0100b9f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+c0100ba6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0100ba9:	01 d0                	add    %edx,%eax
+c0100bab:	8b 00                	mov    (%eax),%eax
+c0100bad:	83 ec 08             	sub    $0x8,%esp
+c0100bb0:	50                   	push   %eax
+c0100bb1:	68 f0 ba 10 c0       	push   $0xc010baf0
+c0100bb6:	e8 d4 f6 ff ff       	call   c010028f <cprintf>
+c0100bbb:	83 c4 10             	add    $0x10,%esp
+
+    int i, j;
+    for (i = 0; my_ebp != 0 && i < STACKFRAME_DEPTH; i ++) {
+        cprintf("ebp:0x%08x eip:0x%08x args:", my_ebp, my_eip);
+        uint32_t *args = (uint32_t *)my_ebp + 2;
+        for (j = 0; j < 4; j ++) {
+c0100bbe:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
+c0100bc2:	83 7d e8 03          	cmpl   $0x3,-0x18(%ebp)
+c0100bc6:	7e d4                	jle    c0100b9c <print_stackframe+0x4d>
+            cprintf("0x%08x ", args[j]);
+        }
+    cprintf("\n");
+c0100bc8:	83 ec 0c             	sub    $0xc,%esp
+c0100bcb:	68 f8 ba 10 c0       	push   $0xc010baf8
+c0100bd0:	e8 ba f6 ff ff       	call   c010028f <cprintf>
+c0100bd5:	83 c4 10             	add    $0x10,%esp
+    print_debuginfo(my_eip - 1);
+c0100bd8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0100bdb:	83 e8 01             	sub    $0x1,%eax
+c0100bde:	83 ec 0c             	sub    $0xc,%esp
+c0100be1:	50                   	push   %eax
+c0100be2:	e8 bb fe ff ff       	call   c0100aa2 <print_debuginfo>
+c0100be7:	83 c4 10             	add    $0x10,%esp
+    my_eip = ((uint32_t *)my_ebp)[1];
+c0100bea:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100bed:	83 c0 04             	add    $0x4,%eax
+c0100bf0:	8b 00                	mov    (%eax),%eax
+c0100bf2:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    my_ebp = ((uint32_t *)my_ebp)[0];
+c0100bf5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100bf8:	8b 00                	mov    (%eax),%eax
+c0100bfa:	89 45 f4             	mov    %eax,-0xc(%ebp)
+      */
+    uint32_t my_ebp = read_ebp();
+    uint32_t my_eip = read_eip();
+
+    int i, j;
+    for (i = 0; my_ebp != 0 && i < STACKFRAME_DEPTH; i ++) {
+c0100bfd:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
+c0100c01:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0100c05:	74 0a                	je     c0100c11 <print_stackframe+0xc2>
+c0100c07:	83 7d ec 13          	cmpl   $0x13,-0x14(%ebp)
+c0100c0b:	0f 8e 63 ff ff ff    	jle    c0100b74 <print_stackframe+0x25>
+    cprintf("\n");
+    print_debuginfo(my_eip - 1);
+    my_eip = ((uint32_t *)my_ebp)[1];
+    my_ebp = ((uint32_t *)my_ebp)[0];
+    }
+}
+c0100c11:	90                   	nop
+c0100c12:	c9                   	leave  
+c0100c13:	c3                   	ret    
+
+c0100c14 <parse>:
+#define MAXARGS         16
+#define WHITESPACE      " \t\n\r"
+
+/* parse - parse the command buffer into whitespace-separated arguments */
+static int
+parse(char *buf, char **argv) {
+c0100c14:	55                   	push   %ebp
+c0100c15:	89 e5                	mov    %esp,%ebp
+c0100c17:	83 ec 18             	sub    $0x18,%esp
+    int argc = 0;
+c0100c1a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    while (1) {
+        // find global whitespace
+        while (*buf != '\0' && strchr(WHITESPACE, *buf) != NULL) {
+c0100c21:	eb 0c                	jmp    c0100c2f <parse+0x1b>
+            *buf ++ = '\0';
+c0100c23:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100c26:	8d 50 01             	lea    0x1(%eax),%edx
+c0100c29:	89 55 08             	mov    %edx,0x8(%ebp)
+c0100c2c:	c6 00 00             	movb   $0x0,(%eax)
+static int
+parse(char *buf, char **argv) {
+    int argc = 0;
+    while (1) {
+        // find global whitespace
+        while (*buf != '\0' && strchr(WHITESPACE, *buf) != NULL) {
+c0100c2f:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100c32:	0f b6 00             	movzbl (%eax),%eax
+c0100c35:	84 c0                	test   %al,%al
+c0100c37:	74 1e                	je     c0100c57 <parse+0x43>
+c0100c39:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100c3c:	0f b6 00             	movzbl (%eax),%eax
+c0100c3f:	0f be c0             	movsbl %al,%eax
+c0100c42:	83 ec 08             	sub    $0x8,%esp
+c0100c45:	50                   	push   %eax
+c0100c46:	68 7c bb 10 c0       	push   $0xc010bb7c
+c0100c4b:	e8 49 a2 00 00       	call   c010ae99 <strchr>
+c0100c50:	83 c4 10             	add    $0x10,%esp
+c0100c53:	85 c0                	test   %eax,%eax
+c0100c55:	75 cc                	jne    c0100c23 <parse+0xf>
+            *buf ++ = '\0';
+        }
+        if (*buf == '\0') {
+c0100c57:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100c5a:	0f b6 00             	movzbl (%eax),%eax
+c0100c5d:	84 c0                	test   %al,%al
+c0100c5f:	74 69                	je     c0100cca <parse+0xb6>
+            break;
+        }
+
+        // save and scan past next arg
+        if (argc == MAXARGS - 1) {
+c0100c61:	83 7d f4 0f          	cmpl   $0xf,-0xc(%ebp)
+c0100c65:	75 12                	jne    c0100c79 <parse+0x65>
+            cprintf("Too many arguments (max %d).\n", MAXARGS);
+c0100c67:	83 ec 08             	sub    $0x8,%esp
+c0100c6a:	6a 10                	push   $0x10
+c0100c6c:	68 81 bb 10 c0       	push   $0xc010bb81
+c0100c71:	e8 19 f6 ff ff       	call   c010028f <cprintf>
+c0100c76:	83 c4 10             	add    $0x10,%esp
+        }
+        argv[argc ++] = buf;
+c0100c79:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100c7c:	8d 50 01             	lea    0x1(%eax),%edx
+c0100c7f:	89 55 f4             	mov    %edx,-0xc(%ebp)
+c0100c82:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+c0100c89:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0100c8c:	01 c2                	add    %eax,%edx
+c0100c8e:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100c91:	89 02                	mov    %eax,(%edx)
+        while (*buf != '\0' && strchr(WHITESPACE, *buf) == NULL) {
+c0100c93:	eb 04                	jmp    c0100c99 <parse+0x85>
+            buf ++;
+c0100c95:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+        // save and scan past next arg
+        if (argc == MAXARGS - 1) {
+            cprintf("Too many arguments (max %d).\n", MAXARGS);
+        }
+        argv[argc ++] = buf;
+        while (*buf != '\0' && strchr(WHITESPACE, *buf) == NULL) {
+c0100c99:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100c9c:	0f b6 00             	movzbl (%eax),%eax
+c0100c9f:	84 c0                	test   %al,%al
+c0100ca1:	0f 84 7a ff ff ff    	je     c0100c21 <parse+0xd>
+c0100ca7:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100caa:	0f b6 00             	movzbl (%eax),%eax
+c0100cad:	0f be c0             	movsbl %al,%eax
+c0100cb0:	83 ec 08             	sub    $0x8,%esp
+c0100cb3:	50                   	push   %eax
+c0100cb4:	68 7c bb 10 c0       	push   $0xc010bb7c
+c0100cb9:	e8 db a1 00 00       	call   c010ae99 <strchr>
+c0100cbe:	83 c4 10             	add    $0x10,%esp
+c0100cc1:	85 c0                	test   %eax,%eax
+c0100cc3:	74 d0                	je     c0100c95 <parse+0x81>
+            buf ++;
+        }
+    }
+c0100cc5:	e9 57 ff ff ff       	jmp    c0100c21 <parse+0xd>
+        // find global whitespace
+        while (*buf != '\0' && strchr(WHITESPACE, *buf) != NULL) {
+            *buf ++ = '\0';
+        }
+        if (*buf == '\0') {
+            break;
+c0100cca:	90                   	nop
+        argv[argc ++] = buf;
+        while (*buf != '\0' && strchr(WHITESPACE, *buf) == NULL) {
+            buf ++;
+        }
+    }
+    return argc;
+c0100ccb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+c0100cce:	c9                   	leave  
+c0100ccf:	c3                   	ret    
+
+c0100cd0 <runcmd>:
+/* *
+ * runcmd - parse the input string, split it into separated arguments
+ * and then lookup and invoke some related commands/
+ * */
+static int
+runcmd(char *buf, struct trapframe *tf) {
+c0100cd0:	55                   	push   %ebp
+c0100cd1:	89 e5                	mov    %esp,%ebp
+c0100cd3:	83 ec 58             	sub    $0x58,%esp
+    char *argv[MAXARGS];
+    int argc = parse(buf, argv);
+c0100cd6:	83 ec 08             	sub    $0x8,%esp
+c0100cd9:	8d 45 b0             	lea    -0x50(%ebp),%eax
+c0100cdc:	50                   	push   %eax
+c0100cdd:	ff 75 08             	pushl  0x8(%ebp)
+c0100ce0:	e8 2f ff ff ff       	call   c0100c14 <parse>
+c0100ce5:	83 c4 10             	add    $0x10,%esp
+c0100ce8:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if (argc == 0) {
+c0100ceb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c0100cef:	75 0a                	jne    c0100cfb <runcmd+0x2b>
+        return 0;
+c0100cf1:	b8 00 00 00 00       	mov    $0x0,%eax
+c0100cf6:	e9 83 00 00 00       	jmp    c0100d7e <runcmd+0xae>
+    }
+    int i;
+    for (i = 0; i < NCOMMANDS; i ++) {
+c0100cfb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c0100d02:	eb 59                	jmp    c0100d5d <runcmd+0x8d>
+        if (strcmp(commands[i].name, argv[0]) == 0) {
+c0100d04:	8b 4d b0             	mov    -0x50(%ebp),%ecx
+c0100d07:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0100d0a:	89 d0                	mov    %edx,%eax
+c0100d0c:	01 c0                	add    %eax,%eax
+c0100d0e:	01 d0                	add    %edx,%eax
+c0100d10:	c1 e0 02             	shl    $0x2,%eax
+c0100d13:	05 00 c0 12 c0       	add    $0xc012c000,%eax
+c0100d18:	8b 00                	mov    (%eax),%eax
+c0100d1a:	83 ec 08             	sub    $0x8,%esp
+c0100d1d:	51                   	push   %ecx
+c0100d1e:	50                   	push   %eax
+c0100d1f:	e8 d5 a0 00 00       	call   c010adf9 <strcmp>
+c0100d24:	83 c4 10             	add    $0x10,%esp
+c0100d27:	85 c0                	test   %eax,%eax
+c0100d29:	75 2e                	jne    c0100d59 <runcmd+0x89>
+            return commands[i].func(argc - 1, argv + 1, tf);
+c0100d2b:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0100d2e:	89 d0                	mov    %edx,%eax
+c0100d30:	01 c0                	add    %eax,%eax
+c0100d32:	01 d0                	add    %edx,%eax
+c0100d34:	c1 e0 02             	shl    $0x2,%eax
+c0100d37:	05 08 c0 12 c0       	add    $0xc012c008,%eax
+c0100d3c:	8b 10                	mov    (%eax),%edx
+c0100d3e:	8d 45 b0             	lea    -0x50(%ebp),%eax
+c0100d41:	83 c0 04             	add    $0x4,%eax
+c0100d44:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+c0100d47:	83 e9 01             	sub    $0x1,%ecx
+c0100d4a:	83 ec 04             	sub    $0x4,%esp
+c0100d4d:	ff 75 0c             	pushl  0xc(%ebp)
+c0100d50:	50                   	push   %eax
+c0100d51:	51                   	push   %ecx
+c0100d52:	ff d2                	call   *%edx
+c0100d54:	83 c4 10             	add    $0x10,%esp
+c0100d57:	eb 25                	jmp    c0100d7e <runcmd+0xae>
+    int argc = parse(buf, argv);
+    if (argc == 0) {
+        return 0;
+    }
+    int i;
+    for (i = 0; i < NCOMMANDS; i ++) {
+c0100d59:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+c0100d5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100d60:	83 f8 02             	cmp    $0x2,%eax
+c0100d63:	76 9f                	jbe    c0100d04 <runcmd+0x34>
+        if (strcmp(commands[i].name, argv[0]) == 0) {
+            return commands[i].func(argc - 1, argv + 1, tf);
+        }
+    }
+    cprintf("Unknown command '%s'\n", argv[0]);
+c0100d65:	8b 45 b0             	mov    -0x50(%ebp),%eax
+c0100d68:	83 ec 08             	sub    $0x8,%esp
+c0100d6b:	50                   	push   %eax
+c0100d6c:	68 9f bb 10 c0       	push   $0xc010bb9f
+c0100d71:	e8 19 f5 ff ff       	call   c010028f <cprintf>
+c0100d76:	83 c4 10             	add    $0x10,%esp
+    return 0;
+c0100d79:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c0100d7e:	c9                   	leave  
+c0100d7f:	c3                   	ret    
+
+c0100d80 <kmonitor>:
+
+/***** Implementations of basic kernel monitor commands *****/
+
+void
+kmonitor(struct trapframe *tf) {
+c0100d80:	55                   	push   %ebp
+c0100d81:	89 e5                	mov    %esp,%ebp
+c0100d83:	83 ec 18             	sub    $0x18,%esp
+    cprintf("Welcome to the kernel debug monitor!!\n");
+c0100d86:	83 ec 0c             	sub    $0xc,%esp
+c0100d89:	68 b8 bb 10 c0       	push   $0xc010bbb8
+c0100d8e:	e8 fc f4 ff ff       	call   c010028f <cprintf>
+c0100d93:	83 c4 10             	add    $0x10,%esp
+    cprintf("Type 'help' for a list of commands.\n");
+c0100d96:	83 ec 0c             	sub    $0xc,%esp
+c0100d99:	68 e0 bb 10 c0       	push   $0xc010bbe0
+c0100d9e:	e8 ec f4 ff ff       	call   c010028f <cprintf>
+c0100da3:	83 c4 10             	add    $0x10,%esp
+
+    if (tf != NULL) {
+c0100da6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c0100daa:	74 0e                	je     c0100dba <kmonitor+0x3a>
+        print_trapframe(tf);
+c0100dac:	83 ec 0c             	sub    $0xc,%esp
+c0100daf:	ff 75 08             	pushl  0x8(%ebp)
+c0100db2:	e8 ef 15 00 00       	call   c01023a6 <print_trapframe>
+c0100db7:	83 c4 10             	add    $0x10,%esp
+    }
+
+    char *buf;
+    while (1) {
+        if ((buf = readline("K> ")) != NULL) {
+c0100dba:	83 ec 0c             	sub    $0xc,%esp
+c0100dbd:	68 05 bc 10 c0       	push   $0xc010bc05
+c0100dc2:	e8 6c f5 ff ff       	call   c0100333 <readline>
+c0100dc7:	83 c4 10             	add    $0x10,%esp
+c0100dca:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0100dcd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0100dd1:	74 e7                	je     c0100dba <kmonitor+0x3a>
+            if (runcmd(buf, tf) < 0) {
+c0100dd3:	83 ec 08             	sub    $0x8,%esp
+c0100dd6:	ff 75 08             	pushl  0x8(%ebp)
+c0100dd9:	ff 75 f4             	pushl  -0xc(%ebp)
+c0100ddc:	e8 ef fe ff ff       	call   c0100cd0 <runcmd>
+c0100de1:	83 c4 10             	add    $0x10,%esp
+c0100de4:	85 c0                	test   %eax,%eax
+c0100de6:	78 02                	js     c0100dea <kmonitor+0x6a>
+                break;
+            }
+        }
+    }
+c0100de8:	eb d0                	jmp    c0100dba <kmonitor+0x3a>
+
+    char *buf;
+    while (1) {
+        if ((buf = readline("K> ")) != NULL) {
+            if (runcmd(buf, tf) < 0) {
+                break;
+c0100dea:	90                   	nop
+            }
+        }
+    }
+}
+c0100deb:	90                   	nop
+c0100dec:	c9                   	leave  
+c0100ded:	c3                   	ret    
+
+c0100dee <mon_help>:
+
+/* mon_help - print the information about mon_* functions */
+int
+mon_help(int argc, char **argv, struct trapframe *tf) {
+c0100dee:	55                   	push   %ebp
+c0100def:	89 e5                	mov    %esp,%ebp
+c0100df1:	83 ec 18             	sub    $0x18,%esp
+    int i;
+    for (i = 0; i < NCOMMANDS; i ++) {
+c0100df4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c0100dfb:	eb 3c                	jmp    c0100e39 <mon_help+0x4b>
+        cprintf("%s - %s\n", commands[i].name, commands[i].desc);
+c0100dfd:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0100e00:	89 d0                	mov    %edx,%eax
+c0100e02:	01 c0                	add    %eax,%eax
+c0100e04:	01 d0                	add    %edx,%eax
+c0100e06:	c1 e0 02             	shl    $0x2,%eax
+c0100e09:	05 04 c0 12 c0       	add    $0xc012c004,%eax
+c0100e0e:	8b 08                	mov    (%eax),%ecx
+c0100e10:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0100e13:	89 d0                	mov    %edx,%eax
+c0100e15:	01 c0                	add    %eax,%eax
+c0100e17:	01 d0                	add    %edx,%eax
+c0100e19:	c1 e0 02             	shl    $0x2,%eax
+c0100e1c:	05 00 c0 12 c0       	add    $0xc012c000,%eax
+c0100e21:	8b 00                	mov    (%eax),%eax
+c0100e23:	83 ec 04             	sub    $0x4,%esp
+c0100e26:	51                   	push   %ecx
+c0100e27:	50                   	push   %eax
+c0100e28:	68 09 bc 10 c0       	push   $0xc010bc09
+c0100e2d:	e8 5d f4 ff ff       	call   c010028f <cprintf>
+c0100e32:	83 c4 10             	add    $0x10,%esp
+
+/* mon_help - print the information about mon_* functions */
+int
+mon_help(int argc, char **argv, struct trapframe *tf) {
+    int i;
+    for (i = 0; i < NCOMMANDS; i ++) {
+c0100e35:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+c0100e39:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100e3c:	83 f8 02             	cmp    $0x2,%eax
+c0100e3f:	76 bc                	jbe    c0100dfd <mon_help+0xf>
+        cprintf("%s - %s\n", commands[i].name, commands[i].desc);
+    }
+    return 0;
+c0100e41:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c0100e46:	c9                   	leave  
+c0100e47:	c3                   	ret    
+
+c0100e48 <mon_kerninfo>:
+/* *
+ * mon_kerninfo - call print_kerninfo in kern/debug/kdebug.c to
+ * print the memory occupancy in kernel.
+ * */
+int
+mon_kerninfo(int argc, char **argv, struct trapframe *tf) {
+c0100e48:	55                   	push   %ebp
+c0100e49:	89 e5                	mov    %esp,%ebp
+c0100e4b:	83 ec 08             	sub    $0x8,%esp
+    print_kerninfo();
+c0100e4e:	e8 b2 fb ff ff       	call   c0100a05 <print_kerninfo>
+    return 0;
+c0100e53:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c0100e58:	c9                   	leave  
+c0100e59:	c3                   	ret    
+
+c0100e5a <mon_backtrace>:
+/* *
+ * mon_backtrace - call print_stackframe in kern/debug/kdebug.c to
+ * print a backtrace of the stack.
+ * */
+int
+mon_backtrace(int argc, char **argv, struct trapframe *tf) {
+c0100e5a:	55                   	push   %ebp
+c0100e5b:	89 e5                	mov    %esp,%ebp
+c0100e5d:	83 ec 08             	sub    $0x8,%esp
+    print_stackframe();
+c0100e60:	e8 ea fc ff ff       	call   c0100b4f <print_stackframe>
+    return 0;
+c0100e65:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c0100e6a:	c9                   	leave  
+c0100e6b:	c3                   	ret    
+
+c0100e6c <ide_wait_ready>:
+    unsigned int size;          // Size in Sectors
+    unsigned char model[41];    // Model in String
+} ide_devices[MAX_IDE];
+
+static int
+ide_wait_ready(unsigned short iobase, bool check_error) {
+c0100e6c:	55                   	push   %ebp
+c0100e6d:	89 e5                	mov    %esp,%ebp
+c0100e6f:	83 ec 14             	sub    $0x14,%esp
+c0100e72:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100e75:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
+    int r;
+    while ((r = inb(iobase + ISA_STATUS)) & IDE_BSY)
+c0100e79:	90                   	nop
+c0100e7a:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
+c0100e7e:	83 c0 07             	add    $0x7,%eax
+c0100e81:	0f b7 c0             	movzwl %ax,%eax
+c0100e84:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+c0100e88:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
+c0100e8c:	89 c2                	mov    %eax,%edx
+c0100e8e:	ec                   	in     (%dx),%al
+c0100e8f:	88 45 f9             	mov    %al,-0x7(%ebp)
+    return data;
+c0100e92:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
+c0100e96:	0f b6 c0             	movzbl %al,%eax
+c0100e99:	89 45 fc             	mov    %eax,-0x4(%ebp)
+c0100e9c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0100e9f:	25 80 00 00 00       	and    $0x80,%eax
+c0100ea4:	85 c0                	test   %eax,%eax
+c0100ea6:	75 d2                	jne    c0100e7a <ide_wait_ready+0xe>
+        /* nothing */;
+    if (check_error && (r & (IDE_DF | IDE_ERR)) != 0) {
+c0100ea8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+c0100eac:	74 11                	je     c0100ebf <ide_wait_ready+0x53>
+c0100eae:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0100eb1:	83 e0 21             	and    $0x21,%eax
+c0100eb4:	85 c0                	test   %eax,%eax
+c0100eb6:	74 07                	je     c0100ebf <ide_wait_ready+0x53>
+        return -1;
+c0100eb8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+c0100ebd:	eb 05                	jmp    c0100ec4 <ide_wait_ready+0x58>
+    }
+    return 0;
+c0100ebf:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c0100ec4:	c9                   	leave  
+c0100ec5:	c3                   	ret    
+
+c0100ec6 <ide_init>:
+
+void
+ide_init(void) {
+c0100ec6:	55                   	push   %ebp
+c0100ec7:	89 e5                	mov    %esp,%ebp
+c0100ec9:	57                   	push   %edi
+c0100eca:	53                   	push   %ebx
+c0100ecb:	81 ec 40 02 00 00    	sub    $0x240,%esp
+    static_assert((SECTSIZE % 4) == 0);
+    unsigned short ideno, iobase;
+    for (ideno = 0; ideno < MAX_IDE; ideno ++) {
+c0100ed1:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%ebp)
+c0100ed7:	e9 c1 02 00 00       	jmp    c010119d <ide_init+0x2d7>
+        /* assume that no device here */
+        ide_devices[ideno].valid = 0;
+c0100edc:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+c0100ee0:	c1 e0 03             	shl    $0x3,%eax
+c0100ee3:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+c0100eea:	29 c2                	sub    %eax,%edx
+c0100eec:	89 d0                	mov    %edx,%eax
+c0100eee:	05 40 04 1b c0       	add    $0xc01b0440,%eax
+c0100ef3:	c6 00 00             	movb   $0x0,(%eax)
+
+        iobase = IO_BASE(ideno);
+c0100ef6:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+c0100efa:	66 d1 e8             	shr    %ax
+c0100efd:	0f b7 c0             	movzwl %ax,%eax
+c0100f00:	0f b7 04 85 14 bc 10 	movzwl -0x3fef43ec(,%eax,4),%eax
+c0100f07:	c0 
+c0100f08:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
+
+        /* wait device ready */
+        ide_wait_ready(iobase, 0);
+c0100f0c:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
+c0100f10:	6a 00                	push   $0x0
+c0100f12:	50                   	push   %eax
+c0100f13:	e8 54 ff ff ff       	call   c0100e6c <ide_wait_ready>
+c0100f18:	83 c4 08             	add    $0x8,%esp
+
+        /* step1: select drive */
+        outb(iobase + ISA_SDH, 0xE0 | ((ideno & 1) << 4));
+c0100f1b:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+c0100f1f:	83 e0 01             	and    $0x1,%eax
+c0100f22:	c1 e0 04             	shl    $0x4,%eax
+c0100f25:	83 c8 e0             	or     $0xffffffe0,%eax
+c0100f28:	0f b6 c0             	movzbl %al,%eax
+c0100f2b:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+c0100f2f:	83 c2 06             	add    $0x6,%edx
+c0100f32:	0f b7 d2             	movzwl %dx,%edx
+c0100f35:	66 89 55 e2          	mov    %dx,-0x1e(%ebp)
+c0100f39:	88 45 c7             	mov    %al,-0x39(%ebp)
+        : "memory", "cc");
+}
+
+static inline void
+outb(uint16_t port, uint8_t data) {
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
+c0100f3c:	0f b6 45 c7          	movzbl -0x39(%ebp),%eax
+c0100f40:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
+c0100f44:	ee                   	out    %al,(%dx)
+        ide_wait_ready(iobase, 0);
+c0100f45:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
+c0100f49:	6a 00                	push   $0x0
+c0100f4b:	50                   	push   %eax
+c0100f4c:	e8 1b ff ff ff       	call   c0100e6c <ide_wait_ready>
+c0100f51:	83 c4 08             	add    $0x8,%esp
+
+        /* step2: send ATA identify command */
+        outb(iobase + ISA_COMMAND, IDE_CMD_IDENTIFY);
+c0100f54:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
+c0100f58:	83 c0 07             	add    $0x7,%eax
+c0100f5b:	0f b7 c0             	movzwl %ax,%eax
+c0100f5e:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
+c0100f62:	c6 45 c8 ec          	movb   $0xec,-0x38(%ebp)
+c0100f66:	0f b6 45 c8          	movzbl -0x38(%ebp),%eax
+c0100f6a:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
+c0100f6e:	ee                   	out    %al,(%dx)
+        ide_wait_ready(iobase, 0);
+c0100f6f:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
+c0100f73:	6a 00                	push   $0x0
+c0100f75:	50                   	push   %eax
+c0100f76:	e8 f1 fe ff ff       	call   c0100e6c <ide_wait_ready>
+c0100f7b:	83 c4 08             	add    $0x8,%esp
+
+        /* step3: polling */
+        if (inb(iobase + ISA_STATUS) == 0 || ide_wait_ready(iobase, 1) != 0) {
+c0100f7e:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
+c0100f82:	83 c0 07             	add    $0x7,%eax
+c0100f85:	0f b7 c0             	movzwl %ax,%eax
+c0100f88:	66 89 45 ca          	mov    %ax,-0x36(%ebp)
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+c0100f8c:	0f b7 45 ca          	movzwl -0x36(%ebp),%eax
+c0100f90:	89 c2                	mov    %eax,%edx
+c0100f92:	ec                   	in     (%dx),%al
+c0100f93:	88 45 c9             	mov    %al,-0x37(%ebp)
+    return data;
+c0100f96:	0f b6 45 c9          	movzbl -0x37(%ebp),%eax
+c0100f9a:	84 c0                	test   %al,%al
+c0100f9c:	0f 84 ef 01 00 00    	je     c0101191 <ide_init+0x2cb>
+c0100fa2:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
+c0100fa6:	6a 01                	push   $0x1
+c0100fa8:	50                   	push   %eax
+c0100fa9:	e8 be fe ff ff       	call   c0100e6c <ide_wait_ready>
+c0100fae:	83 c4 08             	add    $0x8,%esp
+c0100fb1:	85 c0                	test   %eax,%eax
+c0100fb3:	0f 85 d8 01 00 00    	jne    c0101191 <ide_init+0x2cb>
+            continue ;
+        }
+
+        /* device is ok */
+        ide_devices[ideno].valid = 1;
+c0100fb9:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+c0100fbd:	c1 e0 03             	shl    $0x3,%eax
+c0100fc0:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+c0100fc7:	29 c2                	sub    %eax,%edx
+c0100fc9:	89 d0                	mov    %edx,%eax
+c0100fcb:	05 40 04 1b c0       	add    $0xc01b0440,%eax
+c0100fd0:	c6 00 01             	movb   $0x1,(%eax)
+
+        /* read identification space of the device */
+        unsigned int buffer[128];
+        insl(iobase + ISA_DATA, buffer, sizeof(buffer) / sizeof(unsigned int));
+c0100fd3:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
+c0100fd7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c0100fda:	8d 85 bc fd ff ff    	lea    -0x244(%ebp),%eax
+c0100fe0:	89 45 c0             	mov    %eax,-0x40(%ebp)
+c0100fe3:	c7 45 bc 80 00 00 00 	movl   $0x80,-0x44(%ebp)
+}
+
+static inline void
+insl(uint32_t port, void *addr, int cnt) {
+    asm volatile (
+c0100fea:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c0100fed:	8b 4d c0             	mov    -0x40(%ebp),%ecx
+c0100ff0:	8b 45 bc             	mov    -0x44(%ebp),%eax
+c0100ff3:	89 cb                	mov    %ecx,%ebx
+c0100ff5:	89 df                	mov    %ebx,%edi
+c0100ff7:	89 c1                	mov    %eax,%ecx
+c0100ff9:	fc                   	cld    
+c0100ffa:	f2 6d                	repnz insl (%dx),%es:(%edi)
+c0100ffc:	89 c8                	mov    %ecx,%eax
+c0100ffe:	89 fb                	mov    %edi,%ebx
+c0101000:	89 5d c0             	mov    %ebx,-0x40(%ebp)
+c0101003:	89 45 bc             	mov    %eax,-0x44(%ebp)
+
+        unsigned char *ident = (unsigned char *)buffer;
+c0101006:	8d 85 bc fd ff ff    	lea    -0x244(%ebp),%eax
+c010100c:	89 45 dc             	mov    %eax,-0x24(%ebp)
+        unsigned int sectors;
+        unsigned int cmdsets = *(unsigned int *)(ident + IDE_IDENT_CMDSETS);
+c010100f:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0101012:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
+c0101018:	89 45 d8             	mov    %eax,-0x28(%ebp)
+        /* device use 48-bits or 28-bits addressing */
+        if (cmdsets & (1 << 26)) {
+c010101b:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c010101e:	25 00 00 00 04       	and    $0x4000000,%eax
+c0101023:	85 c0                	test   %eax,%eax
+c0101025:	74 0e                	je     c0101035 <ide_init+0x16f>
+            sectors = *(unsigned int *)(ident + IDE_IDENT_MAX_LBA_EXT);
+c0101027:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c010102a:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
+c0101030:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0101033:	eb 09                	jmp    c010103e <ide_init+0x178>
+        }
+        else {
+            sectors = *(unsigned int *)(ident + IDE_IDENT_MAX_LBA);
+c0101035:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0101038:	8b 40 78             	mov    0x78(%eax),%eax
+c010103b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+        }
+        ide_devices[ideno].sets = cmdsets;
+c010103e:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+c0101042:	c1 e0 03             	shl    $0x3,%eax
+c0101045:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+c010104c:	29 c2                	sub    %eax,%edx
+c010104e:	89 d0                	mov    %edx,%eax
+c0101050:	8d 90 44 04 1b c0    	lea    -0x3fe4fbbc(%eax),%edx
+c0101056:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c0101059:	89 02                	mov    %eax,(%edx)
+        ide_devices[ideno].size = sectors;
+c010105b:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+c010105f:	c1 e0 03             	shl    $0x3,%eax
+c0101062:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+c0101069:	29 c2                	sub    %eax,%edx
+c010106b:	89 d0                	mov    %edx,%eax
+c010106d:	8d 90 48 04 1b c0    	lea    -0x3fe4fbb8(%eax),%edx
+c0101073:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0101076:	89 02                	mov    %eax,(%edx)
+
+        /* check if supports LBA */
+        assert((*(unsigned short *)(ident + IDE_IDENT_CAPABILITIES) & 0x200) != 0);
+c0101078:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c010107b:	83 c0 62             	add    $0x62,%eax
+c010107e:	0f b7 00             	movzwl (%eax),%eax
+c0101081:	0f b7 c0             	movzwl %ax,%eax
+c0101084:	25 00 02 00 00       	and    $0x200,%eax
+c0101089:	85 c0                	test   %eax,%eax
+c010108b:	75 16                	jne    c01010a3 <ide_init+0x1dd>
+c010108d:	68 1c bc 10 c0       	push   $0xc010bc1c
+c0101092:	68 5f bc 10 c0       	push   $0xc010bc5f
+c0101097:	6a 7d                	push   $0x7d
+c0101099:	68 74 bc 10 c0       	push   $0xc010bc74
+c010109e:	e8 52 f3 ff ff       	call   c01003f5 <__panic>
+
+        unsigned char *model = ide_devices[ideno].model, *data = ident + IDE_IDENT_MODEL;
+c01010a3:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+c01010a7:	89 c2                	mov    %eax,%edx
+c01010a9:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
+c01010b0:	89 c2                	mov    %eax,%edx
+c01010b2:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
+c01010b9:	29 d0                	sub    %edx,%eax
+c01010bb:	05 40 04 1b c0       	add    $0xc01b0440,%eax
+c01010c0:	83 c0 0c             	add    $0xc,%eax
+c01010c3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+c01010c6:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c01010c9:	83 c0 36             	add    $0x36,%eax
+c01010cc:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        unsigned int i, length = 40;
+c01010cf:	c7 45 cc 28 00 00 00 	movl   $0x28,-0x34(%ebp)
+        for (i = 0; i < length; i += 2) {
+c01010d6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+c01010dd:	eb 34                	jmp    c0101113 <ide_init+0x24d>
+            model[i] = data[i + 1], model[i + 1] = data[i];
+c01010df:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c01010e2:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01010e5:	01 c2                	add    %eax,%edx
+c01010e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01010ea:	8d 48 01             	lea    0x1(%eax),%ecx
+c01010ed:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c01010f0:	01 c8                	add    %ecx,%eax
+c01010f2:	0f b6 00             	movzbl (%eax),%eax
+c01010f5:	88 02                	mov    %al,(%edx)
+c01010f7:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01010fa:	8d 50 01             	lea    0x1(%eax),%edx
+c01010fd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c0101100:	01 c2                	add    %eax,%edx
+c0101102:	8b 4d d0             	mov    -0x30(%ebp),%ecx
+c0101105:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0101108:	01 c8                	add    %ecx,%eax
+c010110a:	0f b6 00             	movzbl (%eax),%eax
+c010110d:	88 02                	mov    %al,(%edx)
+        /* check if supports LBA */
+        assert((*(unsigned short *)(ident + IDE_IDENT_CAPABILITIES) & 0x200) != 0);
+
+        unsigned char *model = ide_devices[ideno].model, *data = ident + IDE_IDENT_MODEL;
+        unsigned int i, length = 40;
+        for (i = 0; i < length; i += 2) {
+c010110f:	83 45 ec 02          	addl   $0x2,-0x14(%ebp)
+c0101113:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0101116:	3b 45 cc             	cmp    -0x34(%ebp),%eax
+c0101119:	72 c4                	jb     c01010df <ide_init+0x219>
+            model[i] = data[i + 1], model[i + 1] = data[i];
+        }
+        do {
+            model[i] = '\0';
+c010111b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c010111e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0101121:	01 d0                	add    %edx,%eax
+c0101123:	c6 00 00             	movb   $0x0,(%eax)
+        } while (i -- > 0 && model[i] == ' ');
+c0101126:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0101129:	8d 50 ff             	lea    -0x1(%eax),%edx
+c010112c:	89 55 ec             	mov    %edx,-0x14(%ebp)
+c010112f:	85 c0                	test   %eax,%eax
+c0101131:	74 0f                	je     c0101142 <ide_init+0x27c>
+c0101133:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c0101136:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0101139:	01 d0                	add    %edx,%eax
+c010113b:	0f b6 00             	movzbl (%eax),%eax
+c010113e:	3c 20                	cmp    $0x20,%al
+c0101140:	74 d9                	je     c010111b <ide_init+0x255>
+
+        cprintf("ide %d: %10u(sectors), '%s'.\n", ideno, ide_devices[ideno].size, ide_devices[ideno].model);
+c0101142:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+c0101146:	89 c2                	mov    %eax,%edx
+c0101148:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
+c010114f:	89 c2                	mov    %eax,%edx
+c0101151:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
+c0101158:	29 d0                	sub    %edx,%eax
+c010115a:	05 40 04 1b c0       	add    $0xc01b0440,%eax
+c010115f:	8d 48 0c             	lea    0xc(%eax),%ecx
+c0101162:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+c0101166:	c1 e0 03             	shl    $0x3,%eax
+c0101169:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+c0101170:	29 c2                	sub    %eax,%edx
+c0101172:	89 d0                	mov    %edx,%eax
+c0101174:	05 48 04 1b c0       	add    $0xc01b0448,%eax
+c0101179:	8b 10                	mov    (%eax),%edx
+c010117b:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+c010117f:	51                   	push   %ecx
+c0101180:	52                   	push   %edx
+c0101181:	50                   	push   %eax
+c0101182:	68 86 bc 10 c0       	push   $0xc010bc86
+c0101187:	e8 03 f1 ff ff       	call   c010028f <cprintf>
+c010118c:	83 c4 10             	add    $0x10,%esp
+c010118f:	eb 01                	jmp    c0101192 <ide_init+0x2cc>
+        outb(iobase + ISA_COMMAND, IDE_CMD_IDENTIFY);
+        ide_wait_ready(iobase, 0);
+
+        /* step3: polling */
+        if (inb(iobase + ISA_STATUS) == 0 || ide_wait_ready(iobase, 1) != 0) {
+            continue ;
+c0101191:	90                   	nop
+
+void
+ide_init(void) {
+    static_assert((SECTSIZE % 4) == 0);
+    unsigned short ideno, iobase;
+    for (ideno = 0; ideno < MAX_IDE; ideno ++) {
+c0101192:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+c0101196:	83 c0 01             	add    $0x1,%eax
+c0101199:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
+c010119d:	66 83 7d f6 03       	cmpw   $0x3,-0xa(%ebp)
+c01011a2:	0f 86 34 fd ff ff    	jbe    c0100edc <ide_init+0x16>
+
+        cprintf("ide %d: %10u(sectors), '%s'.\n", ideno, ide_devices[ideno].size, ide_devices[ideno].model);
+    }
+
+    // enable ide interrupt
+    pic_enable(IRQ_IDE1);
+c01011a8:	83 ec 0c             	sub    $0xc,%esp
+c01011ab:	6a 0e                	push   $0xe
+c01011ad:	e8 8a 0e 00 00       	call   c010203c <pic_enable>
+c01011b2:	83 c4 10             	add    $0x10,%esp
+    pic_enable(IRQ_IDE2);
+c01011b5:	83 ec 0c             	sub    $0xc,%esp
+c01011b8:	6a 0f                	push   $0xf
+c01011ba:	e8 7d 0e 00 00       	call   c010203c <pic_enable>
+c01011bf:	83 c4 10             	add    $0x10,%esp
+}
+c01011c2:	90                   	nop
+c01011c3:	8d 65 f8             	lea    -0x8(%ebp),%esp
+c01011c6:	5b                   	pop    %ebx
+c01011c7:	5f                   	pop    %edi
+c01011c8:	5d                   	pop    %ebp
+c01011c9:	c3                   	ret    
+
+c01011ca <ide_device_valid>:
+
+bool
+ide_device_valid(unsigned short ideno) {
+c01011ca:	55                   	push   %ebp
+c01011cb:	89 e5                	mov    %esp,%ebp
+c01011cd:	83 ec 04             	sub    $0x4,%esp
+c01011d0:	8b 45 08             	mov    0x8(%ebp),%eax
+c01011d3:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
+    return VALID_IDE(ideno);
+c01011d7:	66 83 7d fc 03       	cmpw   $0x3,-0x4(%ebp)
+c01011dc:	77 25                	ja     c0101203 <ide_device_valid+0x39>
+c01011de:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
+c01011e2:	c1 e0 03             	shl    $0x3,%eax
+c01011e5:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+c01011ec:	29 c2                	sub    %eax,%edx
+c01011ee:	89 d0                	mov    %edx,%eax
+c01011f0:	05 40 04 1b c0       	add    $0xc01b0440,%eax
+c01011f5:	0f b6 00             	movzbl (%eax),%eax
+c01011f8:	84 c0                	test   %al,%al
+c01011fa:	74 07                	je     c0101203 <ide_device_valid+0x39>
+c01011fc:	b8 01 00 00 00       	mov    $0x1,%eax
+c0101201:	eb 05                	jmp    c0101208 <ide_device_valid+0x3e>
+c0101203:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c0101208:	c9                   	leave  
+c0101209:	c3                   	ret    
+
+c010120a <ide_device_size>:
+
+size_t
+ide_device_size(unsigned short ideno) {
+c010120a:	55                   	push   %ebp
+c010120b:	89 e5                	mov    %esp,%ebp
+c010120d:	83 ec 04             	sub    $0x4,%esp
+c0101210:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101213:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
+    if (ide_device_valid(ideno)) {
+c0101217:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
+c010121b:	50                   	push   %eax
+c010121c:	e8 a9 ff ff ff       	call   c01011ca <ide_device_valid>
+c0101221:	83 c4 04             	add    $0x4,%esp
+c0101224:	85 c0                	test   %eax,%eax
+c0101226:	74 1b                	je     c0101243 <ide_device_size+0x39>
+        return ide_devices[ideno].size;
+c0101228:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
+c010122c:	c1 e0 03             	shl    $0x3,%eax
+c010122f:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+c0101236:	29 c2                	sub    %eax,%edx
+c0101238:	89 d0                	mov    %edx,%eax
+c010123a:	05 48 04 1b c0       	add    $0xc01b0448,%eax
+c010123f:	8b 00                	mov    (%eax),%eax
+c0101241:	eb 05                	jmp    c0101248 <ide_device_size+0x3e>
+    }
+    return 0;
+c0101243:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c0101248:	c9                   	leave  
+c0101249:	c3                   	ret    
+
+c010124a <ide_read_secs>:
+
+int
+ide_read_secs(unsigned short ideno, uint32_t secno, void *dst, size_t nsecs) {
+c010124a:	55                   	push   %ebp
+c010124b:	89 e5                	mov    %esp,%ebp
+c010124d:	57                   	push   %edi
+c010124e:	53                   	push   %ebx
+c010124f:	83 ec 40             	sub    $0x40,%esp
+c0101252:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101255:	66 89 45 c4          	mov    %ax,-0x3c(%ebp)
+    assert(nsecs <= MAX_NSECS && VALID_IDE(ideno));
+c0101259:	81 7d 14 80 00 00 00 	cmpl   $0x80,0x14(%ebp)
+c0101260:	77 25                	ja     c0101287 <ide_read_secs+0x3d>
+c0101262:	66 83 7d c4 03       	cmpw   $0x3,-0x3c(%ebp)
+c0101267:	77 1e                	ja     c0101287 <ide_read_secs+0x3d>
+c0101269:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
+c010126d:	c1 e0 03             	shl    $0x3,%eax
+c0101270:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+c0101277:	29 c2                	sub    %eax,%edx
+c0101279:	89 d0                	mov    %edx,%eax
+c010127b:	05 40 04 1b c0       	add    $0xc01b0440,%eax
+c0101280:	0f b6 00             	movzbl (%eax),%eax
+c0101283:	84 c0                	test   %al,%al
+c0101285:	75 19                	jne    c01012a0 <ide_read_secs+0x56>
+c0101287:	68 a4 bc 10 c0       	push   $0xc010bca4
+c010128c:	68 5f bc 10 c0       	push   $0xc010bc5f
+c0101291:	68 9f 00 00 00       	push   $0x9f
+c0101296:	68 74 bc 10 c0       	push   $0xc010bc74
+c010129b:	e8 55 f1 ff ff       	call   c01003f5 <__panic>
+    assert(secno < MAX_DISK_NSECS && secno + nsecs <= MAX_DISK_NSECS);
+c01012a0:	81 7d 0c ff ff ff 0f 	cmpl   $0xfffffff,0xc(%ebp)
+c01012a7:	77 0f                	ja     c01012b8 <ide_read_secs+0x6e>
+c01012a9:	8b 55 0c             	mov    0xc(%ebp),%edx
+c01012ac:	8b 45 14             	mov    0x14(%ebp),%eax
+c01012af:	01 d0                	add    %edx,%eax
+c01012b1:	3d 00 00 00 10       	cmp    $0x10000000,%eax
+c01012b6:	76 19                	jbe    c01012d1 <ide_read_secs+0x87>
+c01012b8:	68 cc bc 10 c0       	push   $0xc010bccc
+c01012bd:	68 5f bc 10 c0       	push   $0xc010bc5f
+c01012c2:	68 a0 00 00 00       	push   $0xa0
+c01012c7:	68 74 bc 10 c0       	push   $0xc010bc74
+c01012cc:	e8 24 f1 ff ff       	call   c01003f5 <__panic>
+    unsigned short iobase = IO_BASE(ideno), ioctrl = IO_CTRL(ideno);
+c01012d1:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
+c01012d5:	66 d1 e8             	shr    %ax
+c01012d8:	0f b7 c0             	movzwl %ax,%eax
+c01012db:	0f b7 04 85 14 bc 10 	movzwl -0x3fef43ec(,%eax,4),%eax
+c01012e2:	c0 
+c01012e3:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
+c01012e7:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
+c01012eb:	66 d1 e8             	shr    %ax
+c01012ee:	0f b7 c0             	movzwl %ax,%eax
+c01012f1:	0f b7 04 85 16 bc 10 	movzwl -0x3fef43ea(,%eax,4),%eax
+c01012f8:	c0 
+c01012f9:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
+
+    ide_wait_ready(iobase, 0);
+c01012fd:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
+c0101301:	83 ec 08             	sub    $0x8,%esp
+c0101304:	6a 00                	push   $0x0
+c0101306:	50                   	push   %eax
+c0101307:	e8 60 fb ff ff       	call   c0100e6c <ide_wait_ready>
+c010130c:	83 c4 10             	add    $0x10,%esp
+
+    // generate interrupt
+    outb(ioctrl + ISA_CTRL, 0);
+c010130f:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
+c0101313:	83 c0 02             	add    $0x2,%eax
+c0101316:	0f b7 c0             	movzwl %ax,%eax
+c0101319:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
+c010131d:	c6 45 d7 00          	movb   $0x0,-0x29(%ebp)
+        : "memory", "cc");
+}
+
+static inline void
+outb(uint16_t port, uint8_t data) {
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
+c0101321:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
+c0101325:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+c0101329:	ee                   	out    %al,(%dx)
+    outb(iobase + ISA_SECCNT, nsecs);
+c010132a:	8b 45 14             	mov    0x14(%ebp),%eax
+c010132d:	0f b6 c0             	movzbl %al,%eax
+c0101330:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+c0101334:	83 c2 02             	add    $0x2,%edx
+c0101337:	0f b7 d2             	movzwl %dx,%edx
+c010133a:	66 89 55 e8          	mov    %dx,-0x18(%ebp)
+c010133e:	88 45 d8             	mov    %al,-0x28(%ebp)
+c0101341:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
+c0101345:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
+c0101349:	ee                   	out    %al,(%dx)
+    outb(iobase + ISA_SECTOR, secno & 0xFF);
+c010134a:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010134d:	0f b6 c0             	movzbl %al,%eax
+c0101350:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+c0101354:	83 c2 03             	add    $0x3,%edx
+c0101357:	0f b7 d2             	movzwl %dx,%edx
+c010135a:	66 89 55 e6          	mov    %dx,-0x1a(%ebp)
+c010135e:	88 45 d9             	mov    %al,-0x27(%ebp)
+c0101361:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
+c0101365:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
+c0101369:	ee                   	out    %al,(%dx)
+    outb(iobase + ISA_CYL_LO, (secno >> 8) & 0xFF);
+c010136a:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010136d:	c1 e8 08             	shr    $0x8,%eax
+c0101370:	0f b6 c0             	movzbl %al,%eax
+c0101373:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+c0101377:	83 c2 04             	add    $0x4,%edx
+c010137a:	0f b7 d2             	movzwl %dx,%edx
+c010137d:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
+c0101381:	88 45 da             	mov    %al,-0x26(%ebp)
+c0101384:	0f b6 45 da          	movzbl -0x26(%ebp),%eax
+c0101388:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
+c010138c:	ee                   	out    %al,(%dx)
+    outb(iobase + ISA_CYL_HI, (secno >> 16) & 0xFF);
+c010138d:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0101390:	c1 e8 10             	shr    $0x10,%eax
+c0101393:	0f b6 c0             	movzbl %al,%eax
+c0101396:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+c010139a:	83 c2 05             	add    $0x5,%edx
+c010139d:	0f b7 d2             	movzwl %dx,%edx
+c01013a0:	66 89 55 e2          	mov    %dx,-0x1e(%ebp)
+c01013a4:	88 45 db             	mov    %al,-0x25(%ebp)
+c01013a7:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
+c01013ab:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
+c01013af:	ee                   	out    %al,(%dx)
+    outb(iobase + ISA_SDH, 0xE0 | ((ideno & 1) << 4) | ((secno >> 24) & 0xF));
+c01013b0:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
+c01013b4:	83 e0 01             	and    $0x1,%eax
+c01013b7:	c1 e0 04             	shl    $0x4,%eax
+c01013ba:	89 c2                	mov    %eax,%edx
+c01013bc:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01013bf:	c1 e8 18             	shr    $0x18,%eax
+c01013c2:	83 e0 0f             	and    $0xf,%eax
+c01013c5:	09 d0                	or     %edx,%eax
+c01013c7:	83 c8 e0             	or     $0xffffffe0,%eax
+c01013ca:	0f b6 c0             	movzbl %al,%eax
+c01013cd:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+c01013d1:	83 c2 06             	add    $0x6,%edx
+c01013d4:	0f b7 d2             	movzwl %dx,%edx
+c01013d7:	66 89 55 e0          	mov    %dx,-0x20(%ebp)
+c01013db:	88 45 dc             	mov    %al,-0x24(%ebp)
+c01013de:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
+c01013e2:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
+c01013e6:	ee                   	out    %al,(%dx)
+    outb(iobase + ISA_COMMAND, IDE_CMD_READ);
+c01013e7:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
+c01013eb:	83 c0 07             	add    $0x7,%eax
+c01013ee:	0f b7 c0             	movzwl %ax,%eax
+c01013f1:	66 89 45 de          	mov    %ax,-0x22(%ebp)
+c01013f5:	c6 45 dd 20          	movb   $0x20,-0x23(%ebp)
+c01013f9:	0f b6 45 dd          	movzbl -0x23(%ebp),%eax
+c01013fd:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
+c0101401:	ee                   	out    %al,(%dx)
+
+    int ret = 0;
+c0101402:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    for (; nsecs > 0; nsecs --, dst += SECTSIZE) {
+c0101409:	eb 56                	jmp    c0101461 <ide_read_secs+0x217>
+        if ((ret = ide_wait_ready(iobase, 1)) != 0) {
+c010140b:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
+c010140f:	83 ec 08             	sub    $0x8,%esp
+c0101412:	6a 01                	push   $0x1
+c0101414:	50                   	push   %eax
+c0101415:	e8 52 fa ff ff       	call   c0100e6c <ide_wait_ready>
+c010141a:	83 c4 10             	add    $0x10,%esp
+c010141d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0101420:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0101424:	75 43                	jne    c0101469 <ide_read_secs+0x21f>
+            goto out;
+        }
+        insl(iobase, dst, SECTSIZE / sizeof(uint32_t));
+c0101426:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
+c010142a:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c010142d:	8b 45 10             	mov    0x10(%ebp),%eax
+c0101430:	89 45 d0             	mov    %eax,-0x30(%ebp)
+c0101433:	c7 45 cc 80 00 00 00 	movl   $0x80,-0x34(%ebp)
+    return data;
+}
+
+static inline void
+insl(uint32_t port, void *addr, int cnt) {
+    asm volatile (
+c010143a:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c010143d:	8b 4d d0             	mov    -0x30(%ebp),%ecx
+c0101440:	8b 45 cc             	mov    -0x34(%ebp),%eax
+c0101443:	89 cb                	mov    %ecx,%ebx
+c0101445:	89 df                	mov    %ebx,%edi
+c0101447:	89 c1                	mov    %eax,%ecx
+c0101449:	fc                   	cld    
+c010144a:	f2 6d                	repnz insl (%dx),%es:(%edi)
+c010144c:	89 c8                	mov    %ecx,%eax
+c010144e:	89 fb                	mov    %edi,%ebx
+c0101450:	89 5d d0             	mov    %ebx,-0x30(%ebp)
+c0101453:	89 45 cc             	mov    %eax,-0x34(%ebp)
+    outb(iobase + ISA_CYL_HI, (secno >> 16) & 0xFF);
+    outb(iobase + ISA_SDH, 0xE0 | ((ideno & 1) << 4) | ((secno >> 24) & 0xF));
+    outb(iobase + ISA_COMMAND, IDE_CMD_READ);
+
+    int ret = 0;
+    for (; nsecs > 0; nsecs --, dst += SECTSIZE) {
+c0101456:	83 6d 14 01          	subl   $0x1,0x14(%ebp)
+c010145a:	81 45 10 00 02 00 00 	addl   $0x200,0x10(%ebp)
+c0101461:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+c0101465:	75 a4                	jne    c010140b <ide_read_secs+0x1c1>
+c0101467:	eb 01                	jmp    c010146a <ide_read_secs+0x220>
+        if ((ret = ide_wait_ready(iobase, 1)) != 0) {
+            goto out;
+c0101469:	90                   	nop
+        }
+        insl(iobase, dst, SECTSIZE / sizeof(uint32_t));
+    }
+
+out:
+    return ret;
+c010146a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+c010146d:	8d 65 f8             	lea    -0x8(%ebp),%esp
+c0101470:	5b                   	pop    %ebx
+c0101471:	5f                   	pop    %edi
+c0101472:	5d                   	pop    %ebp
+c0101473:	c3                   	ret    
+
+c0101474 <ide_write_secs>:
+
+int
+ide_write_secs(unsigned short ideno, uint32_t secno, const void *src, size_t nsecs) {
+c0101474:	55                   	push   %ebp
+c0101475:	89 e5                	mov    %esp,%ebp
+c0101477:	56                   	push   %esi
+c0101478:	53                   	push   %ebx
+c0101479:	83 ec 40             	sub    $0x40,%esp
+c010147c:	8b 45 08             	mov    0x8(%ebp),%eax
+c010147f:	66 89 45 c4          	mov    %ax,-0x3c(%ebp)
+    assert(nsecs <= MAX_NSECS && VALID_IDE(ideno));
+c0101483:	81 7d 14 80 00 00 00 	cmpl   $0x80,0x14(%ebp)
+c010148a:	77 25                	ja     c01014b1 <ide_write_secs+0x3d>
+c010148c:	66 83 7d c4 03       	cmpw   $0x3,-0x3c(%ebp)
+c0101491:	77 1e                	ja     c01014b1 <ide_write_secs+0x3d>
+c0101493:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
+c0101497:	c1 e0 03             	shl    $0x3,%eax
+c010149a:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+c01014a1:	29 c2                	sub    %eax,%edx
+c01014a3:	89 d0                	mov    %edx,%eax
+c01014a5:	05 40 04 1b c0       	add    $0xc01b0440,%eax
+c01014aa:	0f b6 00             	movzbl (%eax),%eax
+c01014ad:	84 c0                	test   %al,%al
+c01014af:	75 19                	jne    c01014ca <ide_write_secs+0x56>
+c01014b1:	68 a4 bc 10 c0       	push   $0xc010bca4
+c01014b6:	68 5f bc 10 c0       	push   $0xc010bc5f
+c01014bb:	68 bc 00 00 00       	push   $0xbc
+c01014c0:	68 74 bc 10 c0       	push   $0xc010bc74
+c01014c5:	e8 2b ef ff ff       	call   c01003f5 <__panic>
+    assert(secno < MAX_DISK_NSECS && secno + nsecs <= MAX_DISK_NSECS);
+c01014ca:	81 7d 0c ff ff ff 0f 	cmpl   $0xfffffff,0xc(%ebp)
+c01014d1:	77 0f                	ja     c01014e2 <ide_write_secs+0x6e>
+c01014d3:	8b 55 0c             	mov    0xc(%ebp),%edx
+c01014d6:	8b 45 14             	mov    0x14(%ebp),%eax
+c01014d9:	01 d0                	add    %edx,%eax
+c01014db:	3d 00 00 00 10       	cmp    $0x10000000,%eax
+c01014e0:	76 19                	jbe    c01014fb <ide_write_secs+0x87>
+c01014e2:	68 cc bc 10 c0       	push   $0xc010bccc
+c01014e7:	68 5f bc 10 c0       	push   $0xc010bc5f
+c01014ec:	68 bd 00 00 00       	push   $0xbd
+c01014f1:	68 74 bc 10 c0       	push   $0xc010bc74
+c01014f6:	e8 fa ee ff ff       	call   c01003f5 <__panic>
+    unsigned short iobase = IO_BASE(ideno), ioctrl = IO_CTRL(ideno);
+c01014fb:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
+c01014ff:	66 d1 e8             	shr    %ax
+c0101502:	0f b7 c0             	movzwl %ax,%eax
+c0101505:	0f b7 04 85 14 bc 10 	movzwl -0x3fef43ec(,%eax,4),%eax
+c010150c:	c0 
+c010150d:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
+c0101511:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
+c0101515:	66 d1 e8             	shr    %ax
+c0101518:	0f b7 c0             	movzwl %ax,%eax
+c010151b:	0f b7 04 85 16 bc 10 	movzwl -0x3fef43ea(,%eax,4),%eax
+c0101522:	c0 
+c0101523:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
+
+    ide_wait_ready(iobase, 0);
+c0101527:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
+c010152b:	83 ec 08             	sub    $0x8,%esp
+c010152e:	6a 00                	push   $0x0
+c0101530:	50                   	push   %eax
+c0101531:	e8 36 f9 ff ff       	call   c0100e6c <ide_wait_ready>
+c0101536:	83 c4 10             	add    $0x10,%esp
+
+    // generate interrupt
+    outb(ioctrl + ISA_CTRL, 0);
+c0101539:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
+c010153d:	83 c0 02             	add    $0x2,%eax
+c0101540:	0f b7 c0             	movzwl %ax,%eax
+c0101543:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
+c0101547:	c6 45 d7 00          	movb   $0x0,-0x29(%ebp)
+        : "memory", "cc");
+}
+
+static inline void
+outb(uint16_t port, uint8_t data) {
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
+c010154b:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
+c010154f:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+c0101553:	ee                   	out    %al,(%dx)
+    outb(iobase + ISA_SECCNT, nsecs);
+c0101554:	8b 45 14             	mov    0x14(%ebp),%eax
+c0101557:	0f b6 c0             	movzbl %al,%eax
+c010155a:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+c010155e:	83 c2 02             	add    $0x2,%edx
+c0101561:	0f b7 d2             	movzwl %dx,%edx
+c0101564:	66 89 55 e8          	mov    %dx,-0x18(%ebp)
+c0101568:	88 45 d8             	mov    %al,-0x28(%ebp)
+c010156b:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
+c010156f:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
+c0101573:	ee                   	out    %al,(%dx)
+    outb(iobase + ISA_SECTOR, secno & 0xFF);
+c0101574:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0101577:	0f b6 c0             	movzbl %al,%eax
+c010157a:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+c010157e:	83 c2 03             	add    $0x3,%edx
+c0101581:	0f b7 d2             	movzwl %dx,%edx
+c0101584:	66 89 55 e6          	mov    %dx,-0x1a(%ebp)
+c0101588:	88 45 d9             	mov    %al,-0x27(%ebp)
+c010158b:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
+c010158f:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
+c0101593:	ee                   	out    %al,(%dx)
+    outb(iobase + ISA_CYL_LO, (secno >> 8) & 0xFF);
+c0101594:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0101597:	c1 e8 08             	shr    $0x8,%eax
+c010159a:	0f b6 c0             	movzbl %al,%eax
+c010159d:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+c01015a1:	83 c2 04             	add    $0x4,%edx
+c01015a4:	0f b7 d2             	movzwl %dx,%edx
+c01015a7:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
+c01015ab:	88 45 da             	mov    %al,-0x26(%ebp)
+c01015ae:	0f b6 45 da          	movzbl -0x26(%ebp),%eax
+c01015b2:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
+c01015b6:	ee                   	out    %al,(%dx)
+    outb(iobase + ISA_CYL_HI, (secno >> 16) & 0xFF);
+c01015b7:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01015ba:	c1 e8 10             	shr    $0x10,%eax
+c01015bd:	0f b6 c0             	movzbl %al,%eax
+c01015c0:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+c01015c4:	83 c2 05             	add    $0x5,%edx
+c01015c7:	0f b7 d2             	movzwl %dx,%edx
+c01015ca:	66 89 55 e2          	mov    %dx,-0x1e(%ebp)
+c01015ce:	88 45 db             	mov    %al,-0x25(%ebp)
+c01015d1:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
+c01015d5:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
+c01015d9:	ee                   	out    %al,(%dx)
+    outb(iobase + ISA_SDH, 0xE0 | ((ideno & 1) << 4) | ((secno >> 24) & 0xF));
+c01015da:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
+c01015de:	83 e0 01             	and    $0x1,%eax
+c01015e1:	c1 e0 04             	shl    $0x4,%eax
+c01015e4:	89 c2                	mov    %eax,%edx
+c01015e6:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01015e9:	c1 e8 18             	shr    $0x18,%eax
+c01015ec:	83 e0 0f             	and    $0xf,%eax
+c01015ef:	09 d0                	or     %edx,%eax
+c01015f1:	83 c8 e0             	or     $0xffffffe0,%eax
+c01015f4:	0f b6 c0             	movzbl %al,%eax
+c01015f7:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+c01015fb:	83 c2 06             	add    $0x6,%edx
+c01015fe:	0f b7 d2             	movzwl %dx,%edx
+c0101601:	66 89 55 e0          	mov    %dx,-0x20(%ebp)
+c0101605:	88 45 dc             	mov    %al,-0x24(%ebp)
+c0101608:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
+c010160c:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
+c0101610:	ee                   	out    %al,(%dx)
+    outb(iobase + ISA_COMMAND, IDE_CMD_WRITE);
+c0101611:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
+c0101615:	83 c0 07             	add    $0x7,%eax
+c0101618:	0f b7 c0             	movzwl %ax,%eax
+c010161b:	66 89 45 de          	mov    %ax,-0x22(%ebp)
+c010161f:	c6 45 dd 30          	movb   $0x30,-0x23(%ebp)
+c0101623:	0f b6 45 dd          	movzbl -0x23(%ebp),%eax
+c0101627:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
+c010162b:	ee                   	out    %al,(%dx)
+
+    int ret = 0;
+c010162c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    for (; nsecs > 0; nsecs --, src += SECTSIZE) {
+c0101633:	eb 56                	jmp    c010168b <ide_write_secs+0x217>
+        if ((ret = ide_wait_ready(iobase, 1)) != 0) {
+c0101635:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
+c0101639:	83 ec 08             	sub    $0x8,%esp
+c010163c:	6a 01                	push   $0x1
+c010163e:	50                   	push   %eax
+c010163f:	e8 28 f8 ff ff       	call   c0100e6c <ide_wait_ready>
+c0101644:	83 c4 10             	add    $0x10,%esp
+c0101647:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c010164a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c010164e:	75 43                	jne    c0101693 <ide_write_secs+0x21f>
+            goto out;
+        }
+        outsl(iobase, src, SECTSIZE / sizeof(uint32_t));
+c0101650:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
+c0101654:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0101657:	8b 45 10             	mov    0x10(%ebp),%eax
+c010165a:	89 45 d0             	mov    %eax,-0x30(%ebp)
+c010165d:	c7 45 cc 80 00 00 00 	movl   $0x80,-0x34(%ebp)
+    asm volatile ("outw %0, %1" :: "a" (data), "d" (port) : "memory");
+}
+
+static inline void
+outsl(uint32_t port, const void *addr, int cnt) {
+    asm volatile (
+c0101664:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c0101667:	8b 4d d0             	mov    -0x30(%ebp),%ecx
+c010166a:	8b 45 cc             	mov    -0x34(%ebp),%eax
+c010166d:	89 cb                	mov    %ecx,%ebx
+c010166f:	89 de                	mov    %ebx,%esi
+c0101671:	89 c1                	mov    %eax,%ecx
+c0101673:	fc                   	cld    
+c0101674:	f2 6f                	repnz outsl %ds:(%esi),(%dx)
+c0101676:	89 c8                	mov    %ecx,%eax
+c0101678:	89 f3                	mov    %esi,%ebx
+c010167a:	89 5d d0             	mov    %ebx,-0x30(%ebp)
+c010167d:	89 45 cc             	mov    %eax,-0x34(%ebp)
+    outb(iobase + ISA_CYL_HI, (secno >> 16) & 0xFF);
+    outb(iobase + ISA_SDH, 0xE0 | ((ideno & 1) << 4) | ((secno >> 24) & 0xF));
+    outb(iobase + ISA_COMMAND, IDE_CMD_WRITE);
+
+    int ret = 0;
+    for (; nsecs > 0; nsecs --, src += SECTSIZE) {
+c0101680:	83 6d 14 01          	subl   $0x1,0x14(%ebp)
+c0101684:	81 45 10 00 02 00 00 	addl   $0x200,0x10(%ebp)
+c010168b:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+c010168f:	75 a4                	jne    c0101635 <ide_write_secs+0x1c1>
+c0101691:	eb 01                	jmp    c0101694 <ide_write_secs+0x220>
+        if ((ret = ide_wait_ready(iobase, 1)) != 0) {
+            goto out;
+c0101693:	90                   	nop
+        }
+        outsl(iobase, src, SECTSIZE / sizeof(uint32_t));
+    }
+
+out:
+    return ret;
+c0101694:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+c0101697:	8d 65 f8             	lea    -0x8(%ebp),%esp
+c010169a:	5b                   	pop    %ebx
+c010169b:	5e                   	pop    %esi
+c010169c:	5d                   	pop    %ebp
+c010169d:	c3                   	ret    
+
+c010169e <clock_init>:
+/* *
+ * clock_init - initialize 8253 clock to interrupt 100 times per second,
+ * and then enable IRQ_TIMER.
+ * */
+void
+clock_init(void) {
+c010169e:	55                   	push   %ebp
+c010169f:	89 e5                	mov    %esp,%ebp
+c01016a1:	83 ec 18             	sub    $0x18,%esp
+c01016a4:	66 c7 45 f6 43 00    	movw   $0x43,-0xa(%ebp)
+c01016aa:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
+        : "memory", "cc");
+}
+
+static inline void
+outb(uint16_t port, uint8_t data) {
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
+c01016ae:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+c01016b2:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
+c01016b6:	ee                   	out    %al,(%dx)
+c01016b7:	66 c7 45 f4 40 00    	movw   $0x40,-0xc(%ebp)
+c01016bd:	c6 45 f0 9c          	movb   $0x9c,-0x10(%ebp)
+c01016c1:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
+c01016c5:	0f b7 55 f4          	movzwl -0xc(%ebp),%edx
+c01016c9:	ee                   	out    %al,(%dx)
+c01016ca:	66 c7 45 f2 40 00    	movw   $0x40,-0xe(%ebp)
+c01016d0:	c6 45 f1 2e          	movb   $0x2e,-0xf(%ebp)
+c01016d4:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
+c01016d8:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+c01016dc:	ee                   	out    %al,(%dx)
+    outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
+    outb(IO_TIMER1, TIMER_DIV(100) % 256);
+    outb(IO_TIMER1, TIMER_DIV(100) / 256);
+
+    // initialize time counter 'ticks' to zero
+    ticks = 0;
+c01016dd:	c7 05 78 30 1b c0 00 	movl   $0x0,0xc01b3078
+c01016e4:	00 00 00 
+
+    cprintf("++ setup timer interrupts\n");
+c01016e7:	83 ec 0c             	sub    $0xc,%esp
+c01016ea:	68 06 bd 10 c0       	push   $0xc010bd06
+c01016ef:	e8 9b eb ff ff       	call   c010028f <cprintf>
+c01016f4:	83 c4 10             	add    $0x10,%esp
+    pic_enable(IRQ_TIMER);
+c01016f7:	83 ec 0c             	sub    $0xc,%esp
+c01016fa:	6a 00                	push   $0x0
+c01016fc:	e8 3b 09 00 00       	call   c010203c <pic_enable>
+c0101701:	83 c4 10             	add    $0x10,%esp
+}
+c0101704:	90                   	nop
+c0101705:	c9                   	leave  
+c0101706:	c3                   	ret    
+
+c0101707 <__intr_save>:
+#include <assert.h>
+#include <atomic.h>
+#include <sched.h>
+
+static inline bool
+__intr_save(void) {
+c0101707:	55                   	push   %ebp
+c0101708:	89 e5                	mov    %esp,%ebp
+c010170a:	83 ec 18             	sub    $0x18,%esp
+}
+
+static inline uint32_t
+read_eflags(void) {
+    uint32_t eflags;
+    asm volatile ("pushfl; popl %0" : "=r" (eflags));
+c010170d:	9c                   	pushf  
+c010170e:	58                   	pop    %eax
+c010170f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    return eflags;
+c0101712:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    if (read_eflags() & FL_IF) {
+c0101715:	25 00 02 00 00       	and    $0x200,%eax
+c010171a:	85 c0                	test   %eax,%eax
+c010171c:	74 0c                	je     c010172a <__intr_save+0x23>
+        intr_disable();
+c010171e:	e8 8a 0a 00 00       	call   c01021ad <intr_disable>
+        return 1;
+c0101723:	b8 01 00 00 00       	mov    $0x1,%eax
+c0101728:	eb 05                	jmp    c010172f <__intr_save+0x28>
+    }
+    return 0;
+c010172a:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c010172f:	c9                   	leave  
+c0101730:	c3                   	ret    
+
+c0101731 <__intr_restore>:
+
+static inline void
+__intr_restore(bool flag) {
+c0101731:	55                   	push   %ebp
+c0101732:	89 e5                	mov    %esp,%ebp
+c0101734:	83 ec 08             	sub    $0x8,%esp
+    if (flag) {
+c0101737:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c010173b:	74 05                	je     c0101742 <__intr_restore+0x11>
+        intr_enable();
+c010173d:	e8 64 0a 00 00       	call   c01021a6 <intr_enable>
+    }
+}
+c0101742:	90                   	nop
+c0101743:	c9                   	leave  
+c0101744:	c3                   	ret    
+
+c0101745 <delay>:
+#include <memlayout.h>
+#include <sync.h>
+
+/* stupid I/O delay routine necessitated by historical PC design flaws */
+static void
+delay(void) {
+c0101745:	55                   	push   %ebp
+c0101746:	89 e5                	mov    %esp,%ebp
+c0101748:	83 ec 10             	sub    $0x10,%esp
+c010174b:	66 c7 45 fe 84 00    	movw   $0x84,-0x2(%ebp)
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+c0101751:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
+c0101755:	89 c2                	mov    %eax,%edx
+c0101757:	ec                   	in     (%dx),%al
+c0101758:	88 45 f4             	mov    %al,-0xc(%ebp)
+c010175b:	66 c7 45 fc 84 00    	movw   $0x84,-0x4(%ebp)
+c0101761:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
+c0101765:	89 c2                	mov    %eax,%edx
+c0101767:	ec                   	in     (%dx),%al
+c0101768:	88 45 f5             	mov    %al,-0xb(%ebp)
+c010176b:	66 c7 45 fa 84 00    	movw   $0x84,-0x6(%ebp)
+c0101771:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
+c0101775:	89 c2                	mov    %eax,%edx
+c0101777:	ec                   	in     (%dx),%al
+c0101778:	88 45 f6             	mov    %al,-0xa(%ebp)
+c010177b:	66 c7 45 f8 84 00    	movw   $0x84,-0x8(%ebp)
+c0101781:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
+c0101785:	89 c2                	mov    %eax,%edx
+c0101787:	ec                   	in     (%dx),%al
+c0101788:	88 45 f7             	mov    %al,-0x9(%ebp)
+    inb(0x84);
+    inb(0x84);
+    inb(0x84);
+    inb(0x84);
+}
+c010178b:	90                   	nop
+c010178c:	c9                   	leave  
+c010178d:	c3                   	ret    
+
+c010178e <cga_init>:
+static uint16_t addr_6845;
+
+/* TEXT-mode CGA/VGA display output */
+
+static void
+cga_init(void) {
+c010178e:	55                   	push   %ebp
+c010178f:	89 e5                	mov    %esp,%ebp
+c0101791:	83 ec 20             	sub    $0x20,%esp
+    volatile uint16_t *cp = (uint16_t *)(CGA_BUF + KERNBASE);
+c0101794:	c7 45 fc 00 80 0b c0 	movl   $0xc00b8000,-0x4(%ebp)
+    uint16_t was = *cp;
+c010179b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c010179e:	0f b7 00             	movzwl (%eax),%eax
+c01017a1:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
+    *cp = (uint16_t) 0xA55A;
+c01017a5:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c01017a8:	66 c7 00 5a a5       	movw   $0xa55a,(%eax)
+    if (*cp != 0xA55A) {
+c01017ad:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c01017b0:	0f b7 00             	movzwl (%eax),%eax
+c01017b3:	66 3d 5a a5          	cmp    $0xa55a,%ax
+c01017b7:	74 12                	je     c01017cb <cga_init+0x3d>
+        cp = (uint16_t*)(MONO_BUF + KERNBASE);
+c01017b9:	c7 45 fc 00 00 0b c0 	movl   $0xc00b0000,-0x4(%ebp)
+        addr_6845 = MONO_BASE;
+c01017c0:	66 c7 05 26 05 1b c0 	movw   $0x3b4,0xc01b0526
+c01017c7:	b4 03 
+c01017c9:	eb 13                	jmp    c01017de <cga_init+0x50>
+    } else {
+        *cp = was;
+c01017cb:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c01017ce:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
+c01017d2:	66 89 10             	mov    %dx,(%eax)
+        addr_6845 = CGA_BASE;
+c01017d5:	66 c7 05 26 05 1b c0 	movw   $0x3d4,0xc01b0526
+c01017dc:	d4 03 
+    }
+
+    // Extract cursor location
+    uint32_t pos;
+    outb(addr_6845, 14);
+c01017de:	0f b7 05 26 05 1b c0 	movzwl 0xc01b0526,%eax
+c01017e5:	0f b7 c0             	movzwl %ax,%eax
+c01017e8:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
+c01017ec:	c6 45 ea 0e          	movb   $0xe,-0x16(%ebp)
+        : "memory", "cc");
+}
+
+static inline void
+outb(uint16_t port, uint8_t data) {
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
+c01017f0:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
+c01017f4:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
+c01017f8:	ee                   	out    %al,(%dx)
+    pos = inb(addr_6845 + 1) << 8;
+c01017f9:	0f b7 05 26 05 1b c0 	movzwl 0xc01b0526,%eax
+c0101800:	83 c0 01             	add    $0x1,%eax
+c0101803:	0f b7 c0             	movzwl %ax,%eax
+c0101806:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+c010180a:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
+c010180e:	89 c2                	mov    %eax,%edx
+c0101810:	ec                   	in     (%dx),%al
+c0101811:	88 45 eb             	mov    %al,-0x15(%ebp)
+    return data;
+c0101814:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
+c0101818:	0f b6 c0             	movzbl %al,%eax
+c010181b:	c1 e0 08             	shl    $0x8,%eax
+c010181e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    outb(addr_6845, 15);
+c0101821:	0f b7 05 26 05 1b c0 	movzwl 0xc01b0526,%eax
+c0101828:	0f b7 c0             	movzwl %ax,%eax
+c010182b:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
+c010182f:	c6 45 ec 0f          	movb   $0xf,-0x14(%ebp)
+        : "memory", "cc");
+}
+
+static inline void
+outb(uint16_t port, uint8_t data) {
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
+c0101833:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
+c0101837:	0f b7 55 f0          	movzwl -0x10(%ebp),%edx
+c010183b:	ee                   	out    %al,(%dx)
+    pos |= inb(addr_6845 + 1);
+c010183c:	0f b7 05 26 05 1b c0 	movzwl 0xc01b0526,%eax
+c0101843:	83 c0 01             	add    $0x1,%eax
+c0101846:	0f b7 c0             	movzwl %ax,%eax
+c0101849:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+c010184d:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
+c0101851:	89 c2                	mov    %eax,%edx
+c0101853:	ec                   	in     (%dx),%al
+c0101854:	88 45 ed             	mov    %al,-0x13(%ebp)
+    return data;
+c0101857:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
+c010185b:	0f b6 c0             	movzbl %al,%eax
+c010185e:	09 45 f4             	or     %eax,-0xc(%ebp)
+
+    crt_buf = (uint16_t*) cp;
+c0101861:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0101864:	a3 20 05 1b c0       	mov    %eax,0xc01b0520
+    crt_pos = pos;
+c0101869:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010186c:	66 a3 24 05 1b c0    	mov    %ax,0xc01b0524
+}
+c0101872:	90                   	nop
+c0101873:	c9                   	leave  
+c0101874:	c3                   	ret    
+
+c0101875 <serial_init>:
+
+static bool serial_exists = 0;
+
+static void
+serial_init(void) {
+c0101875:	55                   	push   %ebp
+c0101876:	89 e5                	mov    %esp,%ebp
+c0101878:	83 ec 28             	sub    $0x28,%esp
+c010187b:	66 c7 45 f6 fa 03    	movw   $0x3fa,-0xa(%ebp)
+c0101881:	c6 45 da 00          	movb   $0x0,-0x26(%ebp)
+        : "memory", "cc");
+}
+
+static inline void
+outb(uint16_t port, uint8_t data) {
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
+c0101885:	0f b6 45 da          	movzbl -0x26(%ebp),%eax
+c0101889:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
+c010188d:	ee                   	out    %al,(%dx)
+c010188e:	66 c7 45 f4 fb 03    	movw   $0x3fb,-0xc(%ebp)
+c0101894:	c6 45 db 80          	movb   $0x80,-0x25(%ebp)
+c0101898:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
+c010189c:	0f b7 55 f4          	movzwl -0xc(%ebp),%edx
+c01018a0:	ee                   	out    %al,(%dx)
+c01018a1:	66 c7 45 f2 f8 03    	movw   $0x3f8,-0xe(%ebp)
+c01018a7:	c6 45 dc 0c          	movb   $0xc,-0x24(%ebp)
+c01018ab:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
+c01018af:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+c01018b3:	ee                   	out    %al,(%dx)
+c01018b4:	66 c7 45 f0 f9 03    	movw   $0x3f9,-0x10(%ebp)
+c01018ba:	c6 45 dd 00          	movb   $0x0,-0x23(%ebp)
+c01018be:	0f b6 45 dd          	movzbl -0x23(%ebp),%eax
+c01018c2:	0f b7 55 f0          	movzwl -0x10(%ebp),%edx
+c01018c6:	ee                   	out    %al,(%dx)
+c01018c7:	66 c7 45 ee fb 03    	movw   $0x3fb,-0x12(%ebp)
+c01018cd:	c6 45 de 03          	movb   $0x3,-0x22(%ebp)
+c01018d1:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
+c01018d5:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
+c01018d9:	ee                   	out    %al,(%dx)
+c01018da:	66 c7 45 ec fc 03    	movw   $0x3fc,-0x14(%ebp)
+c01018e0:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
+c01018e4:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
+c01018e8:	0f b7 55 ec          	movzwl -0x14(%ebp),%edx
+c01018ec:	ee                   	out    %al,(%dx)
+c01018ed:	66 c7 45 ea f9 03    	movw   $0x3f9,-0x16(%ebp)
+c01018f3:	c6 45 e0 01          	movb   $0x1,-0x20(%ebp)
+c01018f7:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
+c01018fb:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+c01018ff:	ee                   	out    %al,(%dx)
+c0101900:	66 c7 45 e8 fd 03    	movw   $0x3fd,-0x18(%ebp)
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+c0101906:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
+c010190a:	89 c2                	mov    %eax,%edx
+c010190c:	ec                   	in     (%dx),%al
+c010190d:	88 45 e1             	mov    %al,-0x1f(%ebp)
+    return data;
+c0101910:	0f b6 45 e1          	movzbl -0x1f(%ebp),%eax
+    // Enable rcv interrupts
+    outb(COM1 + COM_IER, COM_IER_RDI);
+
+    // Clear any preexisting overrun indications and interrupts
+    // Serial port doesn't exist if COM_LSR returns 0xFF
+    serial_exists = (inb(COM1 + COM_LSR) != 0xFF);
+c0101914:	3c ff                	cmp    $0xff,%al
+c0101916:	0f 95 c0             	setne  %al
+c0101919:	0f b6 c0             	movzbl %al,%eax
+c010191c:	a3 28 05 1b c0       	mov    %eax,0xc01b0528
+c0101921:	66 c7 45 e6 fa 03    	movw   $0x3fa,-0x1a(%ebp)
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+c0101927:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
+c010192b:	89 c2                	mov    %eax,%edx
+c010192d:	ec                   	in     (%dx),%al
+c010192e:	88 45 e2             	mov    %al,-0x1e(%ebp)
+c0101931:	66 c7 45 e4 f8 03    	movw   $0x3f8,-0x1c(%ebp)
+c0101937:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
+c010193b:	89 c2                	mov    %eax,%edx
+c010193d:	ec                   	in     (%dx),%al
+c010193e:	88 45 e3             	mov    %al,-0x1d(%ebp)
+    (void) inb(COM1+COM_IIR);
+    (void) inb(COM1+COM_RX);
+
+    if (serial_exists) {
+c0101941:	a1 28 05 1b c0       	mov    0xc01b0528,%eax
+c0101946:	85 c0                	test   %eax,%eax
+c0101948:	74 0d                	je     c0101957 <serial_init+0xe2>
+        pic_enable(IRQ_COM1);
+c010194a:	83 ec 0c             	sub    $0xc,%esp
+c010194d:	6a 04                	push   $0x4
+c010194f:	e8 e8 06 00 00       	call   c010203c <pic_enable>
+c0101954:	83 c4 10             	add    $0x10,%esp
+    }
+}
+c0101957:	90                   	nop
+c0101958:	c9                   	leave  
+c0101959:	c3                   	ret    
+
+c010195a <lpt_putc_sub>:
+
+static void
+lpt_putc_sub(int c) {
+c010195a:	55                   	push   %ebp
+c010195b:	89 e5                	mov    %esp,%ebp
+c010195d:	83 ec 10             	sub    $0x10,%esp
+    int i;
+    for (i = 0; !(inb(LPTPORT + 1) & 0x80) && i < 12800; i ++) {
+c0101960:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+c0101967:	eb 09                	jmp    c0101972 <lpt_putc_sub+0x18>
+        delay();
+c0101969:	e8 d7 fd ff ff       	call   c0101745 <delay>
+}
+
+static void
+lpt_putc_sub(int c) {
+    int i;
+    for (i = 0; !(inb(LPTPORT + 1) & 0x80) && i < 12800; i ++) {
+c010196e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+c0101972:	66 c7 45 f4 79 03    	movw   $0x379,-0xc(%ebp)
+c0101978:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
+c010197c:	89 c2                	mov    %eax,%edx
+c010197e:	ec                   	in     (%dx),%al
+c010197f:	88 45 f3             	mov    %al,-0xd(%ebp)
+    return data;
+c0101982:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+c0101986:	84 c0                	test   %al,%al
+c0101988:	78 09                	js     c0101993 <lpt_putc_sub+0x39>
+c010198a:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%ebp)
+c0101991:	7e d6                	jle    c0101969 <lpt_putc_sub+0xf>
+        delay();
+    }
+    outb(LPTPORT + 0, c);
+c0101993:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101996:	0f b6 c0             	movzbl %al,%eax
+c0101999:	66 c7 45 f8 78 03    	movw   $0x378,-0x8(%ebp)
+c010199f:	88 45 f0             	mov    %al,-0x10(%ebp)
+        : "memory", "cc");
+}
+
+static inline void
+outb(uint16_t port, uint8_t data) {
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
+c01019a2:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
+c01019a6:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
+c01019aa:	ee                   	out    %al,(%dx)
+c01019ab:	66 c7 45 f6 7a 03    	movw   $0x37a,-0xa(%ebp)
+c01019b1:	c6 45 f1 0d          	movb   $0xd,-0xf(%ebp)
+c01019b5:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
+c01019b9:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
+c01019bd:	ee                   	out    %al,(%dx)
+c01019be:	66 c7 45 fa 7a 03    	movw   $0x37a,-0x6(%ebp)
+c01019c4:	c6 45 f2 08          	movb   $0x8,-0xe(%ebp)
+c01019c8:	0f b6 45 f2          	movzbl -0xe(%ebp),%eax
+c01019cc:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
+c01019d0:	ee                   	out    %al,(%dx)
+    outb(LPTPORT + 2, 0x08 | 0x04 | 0x01);
+    outb(LPTPORT + 2, 0x08);
+}
+c01019d1:	90                   	nop
+c01019d2:	c9                   	leave  
+c01019d3:	c3                   	ret    
+
+c01019d4 <lpt_putc>:
+
+/* lpt_putc - copy console output to parallel port */
+static void
+lpt_putc(int c) {
+c01019d4:	55                   	push   %ebp
+c01019d5:	89 e5                	mov    %esp,%ebp
+    if (c != '\b') {
+c01019d7:	83 7d 08 08          	cmpl   $0x8,0x8(%ebp)
+c01019db:	74 0d                	je     c01019ea <lpt_putc+0x16>
+        lpt_putc_sub(c);
+c01019dd:	ff 75 08             	pushl  0x8(%ebp)
+c01019e0:	e8 75 ff ff ff       	call   c010195a <lpt_putc_sub>
+c01019e5:	83 c4 04             	add    $0x4,%esp
+    else {
+        lpt_putc_sub('\b');
+        lpt_putc_sub(' ');
+        lpt_putc_sub('\b');
+    }
+}
+c01019e8:	eb 1e                	jmp    c0101a08 <lpt_putc+0x34>
+lpt_putc(int c) {
+    if (c != '\b') {
+        lpt_putc_sub(c);
+    }
+    else {
+        lpt_putc_sub('\b');
+c01019ea:	6a 08                	push   $0x8
+c01019ec:	e8 69 ff ff ff       	call   c010195a <lpt_putc_sub>
+c01019f1:	83 c4 04             	add    $0x4,%esp
+        lpt_putc_sub(' ');
+c01019f4:	6a 20                	push   $0x20
+c01019f6:	e8 5f ff ff ff       	call   c010195a <lpt_putc_sub>
+c01019fb:	83 c4 04             	add    $0x4,%esp
+        lpt_putc_sub('\b');
+c01019fe:	6a 08                	push   $0x8
+c0101a00:	e8 55 ff ff ff       	call   c010195a <lpt_putc_sub>
+c0101a05:	83 c4 04             	add    $0x4,%esp
+    }
+}
+c0101a08:	90                   	nop
+c0101a09:	c9                   	leave  
+c0101a0a:	c3                   	ret    
+
+c0101a0b <cga_putc>:
+
+/* cga_putc - print character to console */
+static void
+cga_putc(int c) {
+c0101a0b:	55                   	push   %ebp
+c0101a0c:	89 e5                	mov    %esp,%ebp
+c0101a0e:	53                   	push   %ebx
+c0101a0f:	83 ec 14             	sub    $0x14,%esp
+    // set black on white
+    if (!(c & ~0xFF)) {
+c0101a12:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101a15:	b0 00                	mov    $0x0,%al
+c0101a17:	85 c0                	test   %eax,%eax
+c0101a19:	75 07                	jne    c0101a22 <cga_putc+0x17>
+        c |= 0x0700;
+c0101a1b:	81 4d 08 00 07 00 00 	orl    $0x700,0x8(%ebp)
+    }
+
+    switch (c & 0xff) {
+c0101a22:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101a25:	0f b6 c0             	movzbl %al,%eax
+c0101a28:	83 f8 0a             	cmp    $0xa,%eax
+c0101a2b:	74 4e                	je     c0101a7b <cga_putc+0x70>
+c0101a2d:	83 f8 0d             	cmp    $0xd,%eax
+c0101a30:	74 59                	je     c0101a8b <cga_putc+0x80>
+c0101a32:	83 f8 08             	cmp    $0x8,%eax
+c0101a35:	0f 85 8a 00 00 00    	jne    c0101ac5 <cga_putc+0xba>
+    case '\b':
+        if (crt_pos > 0) {
+c0101a3b:	0f b7 05 24 05 1b c0 	movzwl 0xc01b0524,%eax
+c0101a42:	66 85 c0             	test   %ax,%ax
+c0101a45:	0f 84 a0 00 00 00    	je     c0101aeb <cga_putc+0xe0>
+            crt_pos --;
+c0101a4b:	0f b7 05 24 05 1b c0 	movzwl 0xc01b0524,%eax
+c0101a52:	83 e8 01             	sub    $0x1,%eax
+c0101a55:	66 a3 24 05 1b c0    	mov    %ax,0xc01b0524
+            crt_buf[crt_pos] = (c & ~0xff) | ' ';
+c0101a5b:	a1 20 05 1b c0       	mov    0xc01b0520,%eax
+c0101a60:	0f b7 15 24 05 1b c0 	movzwl 0xc01b0524,%edx
+c0101a67:	0f b7 d2             	movzwl %dx,%edx
+c0101a6a:	01 d2                	add    %edx,%edx
+c0101a6c:	01 d0                	add    %edx,%eax
+c0101a6e:	8b 55 08             	mov    0x8(%ebp),%edx
+c0101a71:	b2 00                	mov    $0x0,%dl
+c0101a73:	83 ca 20             	or     $0x20,%edx
+c0101a76:	66 89 10             	mov    %dx,(%eax)
+        }
+        break;
+c0101a79:	eb 70                	jmp    c0101aeb <cga_putc+0xe0>
+    case '\n':
+        crt_pos += CRT_COLS;
+c0101a7b:	0f b7 05 24 05 1b c0 	movzwl 0xc01b0524,%eax
+c0101a82:	83 c0 50             	add    $0x50,%eax
+c0101a85:	66 a3 24 05 1b c0    	mov    %ax,0xc01b0524
+    case '\r':
+        crt_pos -= (crt_pos % CRT_COLS);
+c0101a8b:	0f b7 1d 24 05 1b c0 	movzwl 0xc01b0524,%ebx
+c0101a92:	0f b7 0d 24 05 1b c0 	movzwl 0xc01b0524,%ecx
+c0101a99:	0f b7 c1             	movzwl %cx,%eax
+c0101a9c:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
+c0101aa2:	c1 e8 10             	shr    $0x10,%eax
+c0101aa5:	89 c2                	mov    %eax,%edx
+c0101aa7:	66 c1 ea 06          	shr    $0x6,%dx
+c0101aab:	89 d0                	mov    %edx,%eax
+c0101aad:	c1 e0 02             	shl    $0x2,%eax
+c0101ab0:	01 d0                	add    %edx,%eax
+c0101ab2:	c1 e0 04             	shl    $0x4,%eax
+c0101ab5:	29 c1                	sub    %eax,%ecx
+c0101ab7:	89 ca                	mov    %ecx,%edx
+c0101ab9:	89 d8                	mov    %ebx,%eax
+c0101abb:	29 d0                	sub    %edx,%eax
+c0101abd:	66 a3 24 05 1b c0    	mov    %ax,0xc01b0524
+        break;
+c0101ac3:	eb 27                	jmp    c0101aec <cga_putc+0xe1>
+    default:
+        crt_buf[crt_pos ++] = c;     // write the character
+c0101ac5:	8b 0d 20 05 1b c0    	mov    0xc01b0520,%ecx
+c0101acb:	0f b7 05 24 05 1b c0 	movzwl 0xc01b0524,%eax
+c0101ad2:	8d 50 01             	lea    0x1(%eax),%edx
+c0101ad5:	66 89 15 24 05 1b c0 	mov    %dx,0xc01b0524
+c0101adc:	0f b7 c0             	movzwl %ax,%eax
+c0101adf:	01 c0                	add    %eax,%eax
+c0101ae1:	01 c8                	add    %ecx,%eax
+c0101ae3:	8b 55 08             	mov    0x8(%ebp),%edx
+c0101ae6:	66 89 10             	mov    %dx,(%eax)
+        break;
+c0101ae9:	eb 01                	jmp    c0101aec <cga_putc+0xe1>
+    case '\b':
+        if (crt_pos > 0) {
+            crt_pos --;
+            crt_buf[crt_pos] = (c & ~0xff) | ' ';
+        }
+        break;
+c0101aeb:	90                   	nop
+        crt_buf[crt_pos ++] = c;     // write the character
+        break;
+    }
+
+    // What is the purpose of this?
+    if (crt_pos >= CRT_SIZE) {
+c0101aec:	0f b7 05 24 05 1b c0 	movzwl 0xc01b0524,%eax
+c0101af3:	66 3d cf 07          	cmp    $0x7cf,%ax
+c0101af7:	76 59                	jbe    c0101b52 <cga_putc+0x147>
+        int i;
+        memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
+c0101af9:	a1 20 05 1b c0       	mov    0xc01b0520,%eax
+c0101afe:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
+c0101b04:	a1 20 05 1b c0       	mov    0xc01b0520,%eax
+c0101b09:	83 ec 04             	sub    $0x4,%esp
+c0101b0c:	68 00 0f 00 00       	push   $0xf00
+c0101b11:	52                   	push   %edx
+c0101b12:	50                   	push   %eax
+c0101b13:	e8 80 95 00 00       	call   c010b098 <memmove>
+c0101b18:	83 c4 10             	add    $0x10,%esp
+        for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i ++) {
+c0101b1b:	c7 45 f4 80 07 00 00 	movl   $0x780,-0xc(%ebp)
+c0101b22:	eb 15                	jmp    c0101b39 <cga_putc+0x12e>
+            crt_buf[i] = 0x0700 | ' ';
+c0101b24:	a1 20 05 1b c0       	mov    0xc01b0520,%eax
+c0101b29:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0101b2c:	01 d2                	add    %edx,%edx
+c0101b2e:	01 d0                	add    %edx,%eax
+c0101b30:	66 c7 00 20 07       	movw   $0x720,(%eax)
+
+    // What is the purpose of this?
+    if (crt_pos >= CRT_SIZE) {
+        int i;
+        memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
+        for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i ++) {
+c0101b35:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+c0101b39:	81 7d f4 cf 07 00 00 	cmpl   $0x7cf,-0xc(%ebp)
+c0101b40:	7e e2                	jle    c0101b24 <cga_putc+0x119>
+            crt_buf[i] = 0x0700 | ' ';
+        }
+        crt_pos -= CRT_COLS;
+c0101b42:	0f b7 05 24 05 1b c0 	movzwl 0xc01b0524,%eax
+c0101b49:	83 e8 50             	sub    $0x50,%eax
+c0101b4c:	66 a3 24 05 1b c0    	mov    %ax,0xc01b0524
+    }
+
+    // move that little blinky thing
+    outb(addr_6845, 14);
+c0101b52:	0f b7 05 26 05 1b c0 	movzwl 0xc01b0526,%eax
+c0101b59:	0f b7 c0             	movzwl %ax,%eax
+c0101b5c:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
+c0101b60:	c6 45 e8 0e          	movb   $0xe,-0x18(%ebp)
+c0101b64:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
+c0101b68:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+c0101b6c:	ee                   	out    %al,(%dx)
+    outb(addr_6845 + 1, crt_pos >> 8);
+c0101b6d:	0f b7 05 24 05 1b c0 	movzwl 0xc01b0524,%eax
+c0101b74:	66 c1 e8 08          	shr    $0x8,%ax
+c0101b78:	0f b6 c0             	movzbl %al,%eax
+c0101b7b:	0f b7 15 26 05 1b c0 	movzwl 0xc01b0526,%edx
+c0101b82:	83 c2 01             	add    $0x1,%edx
+c0101b85:	0f b7 d2             	movzwl %dx,%edx
+c0101b88:	66 89 55 f0          	mov    %dx,-0x10(%ebp)
+c0101b8c:	88 45 e9             	mov    %al,-0x17(%ebp)
+c0101b8f:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
+c0101b93:	0f b7 55 f0          	movzwl -0x10(%ebp),%edx
+c0101b97:	ee                   	out    %al,(%dx)
+    outb(addr_6845, 15);
+c0101b98:	0f b7 05 26 05 1b c0 	movzwl 0xc01b0526,%eax
+c0101b9f:	0f b7 c0             	movzwl %ax,%eax
+c0101ba2:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
+c0101ba6:	c6 45 ea 0f          	movb   $0xf,-0x16(%ebp)
+c0101baa:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
+c0101bae:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
+c0101bb2:	ee                   	out    %al,(%dx)
+    outb(addr_6845 + 1, crt_pos);
+c0101bb3:	0f b7 05 24 05 1b c0 	movzwl 0xc01b0524,%eax
+c0101bba:	0f b6 c0             	movzbl %al,%eax
+c0101bbd:	0f b7 15 26 05 1b c0 	movzwl 0xc01b0526,%edx
+c0101bc4:	83 c2 01             	add    $0x1,%edx
+c0101bc7:	0f b7 d2             	movzwl %dx,%edx
+c0101bca:	66 89 55 ec          	mov    %dx,-0x14(%ebp)
+c0101bce:	88 45 eb             	mov    %al,-0x15(%ebp)
+c0101bd1:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
+c0101bd5:	0f b7 55 ec          	movzwl -0x14(%ebp),%edx
+c0101bd9:	ee                   	out    %al,(%dx)
+}
+c0101bda:	90                   	nop
+c0101bdb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+c0101bde:	c9                   	leave  
+c0101bdf:	c3                   	ret    
+
+c0101be0 <serial_putc_sub>:
+
+static void
+serial_putc_sub(int c) {
+c0101be0:	55                   	push   %ebp
+c0101be1:	89 e5                	mov    %esp,%ebp
+c0101be3:	83 ec 10             	sub    $0x10,%esp
+    int i;
+    for (i = 0; !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800; i ++) {
+c0101be6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+c0101bed:	eb 09                	jmp    c0101bf8 <serial_putc_sub+0x18>
+        delay();
+c0101bef:	e8 51 fb ff ff       	call   c0101745 <delay>
+}
+
+static void
+serial_putc_sub(int c) {
+    int i;
+    for (i = 0; !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800; i ++) {
+c0101bf4:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+c0101bf8:	66 c7 45 f8 fd 03    	movw   $0x3fd,-0x8(%ebp)
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+c0101bfe:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
+c0101c02:	89 c2                	mov    %eax,%edx
+c0101c04:	ec                   	in     (%dx),%al
+c0101c05:	88 45 f7             	mov    %al,-0x9(%ebp)
+    return data;
+c0101c08:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
+c0101c0c:	0f b6 c0             	movzbl %al,%eax
+c0101c0f:	83 e0 20             	and    $0x20,%eax
+c0101c12:	85 c0                	test   %eax,%eax
+c0101c14:	75 09                	jne    c0101c1f <serial_putc_sub+0x3f>
+c0101c16:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%ebp)
+c0101c1d:	7e d0                	jle    c0101bef <serial_putc_sub+0xf>
+        delay();
+    }
+    outb(COM1 + COM_TX, c);
+c0101c1f:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101c22:	0f b6 c0             	movzbl %al,%eax
+c0101c25:	66 c7 45 fa f8 03    	movw   $0x3f8,-0x6(%ebp)
+c0101c2b:	88 45 f6             	mov    %al,-0xa(%ebp)
+        : "memory", "cc");
+}
+
+static inline void
+outb(uint16_t port, uint8_t data) {
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
+c0101c2e:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
+c0101c32:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
+c0101c36:	ee                   	out    %al,(%dx)
+}
+c0101c37:	90                   	nop
+c0101c38:	c9                   	leave  
+c0101c39:	c3                   	ret    
+
+c0101c3a <serial_putc>:
+
+/* serial_putc - print character to serial port */
+static void
+serial_putc(int c) {
+c0101c3a:	55                   	push   %ebp
+c0101c3b:	89 e5                	mov    %esp,%ebp
+    if (c != '\b') {
+c0101c3d:	83 7d 08 08          	cmpl   $0x8,0x8(%ebp)
+c0101c41:	74 0d                	je     c0101c50 <serial_putc+0x16>
+        serial_putc_sub(c);
+c0101c43:	ff 75 08             	pushl  0x8(%ebp)
+c0101c46:	e8 95 ff ff ff       	call   c0101be0 <serial_putc_sub>
+c0101c4b:	83 c4 04             	add    $0x4,%esp
+    else {
+        serial_putc_sub('\b');
+        serial_putc_sub(' ');
+        serial_putc_sub('\b');
+    }
+}
+c0101c4e:	eb 1e                	jmp    c0101c6e <serial_putc+0x34>
+serial_putc(int c) {
+    if (c != '\b') {
+        serial_putc_sub(c);
+    }
+    else {
+        serial_putc_sub('\b');
+c0101c50:	6a 08                	push   $0x8
+c0101c52:	e8 89 ff ff ff       	call   c0101be0 <serial_putc_sub>
+c0101c57:	83 c4 04             	add    $0x4,%esp
+        serial_putc_sub(' ');
+c0101c5a:	6a 20                	push   $0x20
+c0101c5c:	e8 7f ff ff ff       	call   c0101be0 <serial_putc_sub>
+c0101c61:	83 c4 04             	add    $0x4,%esp
+        serial_putc_sub('\b');
+c0101c64:	6a 08                	push   $0x8
+c0101c66:	e8 75 ff ff ff       	call   c0101be0 <serial_putc_sub>
+c0101c6b:	83 c4 04             	add    $0x4,%esp
+    }
+}
+c0101c6e:	90                   	nop
+c0101c6f:	c9                   	leave  
+c0101c70:	c3                   	ret    
+
+c0101c71 <cons_intr>:
+/* *
+ * cons_intr - called by device interrupt routines to feed input
+ * characters into the circular console input buffer.
+ * */
+static void
+cons_intr(int (*proc)(void)) {
+c0101c71:	55                   	push   %ebp
+c0101c72:	89 e5                	mov    %esp,%ebp
+c0101c74:	83 ec 18             	sub    $0x18,%esp
+    int c;
+    while ((c = (*proc)()) != -1) {
+c0101c77:	eb 33                	jmp    c0101cac <cons_intr+0x3b>
+        if (c != 0) {
+c0101c79:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0101c7d:	74 2d                	je     c0101cac <cons_intr+0x3b>
+            cons.buf[cons.wpos ++] = c;
+c0101c7f:	a1 44 07 1b c0       	mov    0xc01b0744,%eax
+c0101c84:	8d 50 01             	lea    0x1(%eax),%edx
+c0101c87:	89 15 44 07 1b c0    	mov    %edx,0xc01b0744
+c0101c8d:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0101c90:	88 90 40 05 1b c0    	mov    %dl,-0x3fe4fac0(%eax)
+            if (cons.wpos == CONSBUFSIZE) {
+c0101c96:	a1 44 07 1b c0       	mov    0xc01b0744,%eax
+c0101c9b:	3d 00 02 00 00       	cmp    $0x200,%eax
+c0101ca0:	75 0a                	jne    c0101cac <cons_intr+0x3b>
+                cons.wpos = 0;
+c0101ca2:	c7 05 44 07 1b c0 00 	movl   $0x0,0xc01b0744
+c0101ca9:	00 00 00 
+ * characters into the circular console input buffer.
+ * */
+static void
+cons_intr(int (*proc)(void)) {
+    int c;
+    while ((c = (*proc)()) != -1) {
+c0101cac:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101caf:	ff d0                	call   *%eax
+c0101cb1:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0101cb4:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+c0101cb8:	75 bf                	jne    c0101c79 <cons_intr+0x8>
+            if (cons.wpos == CONSBUFSIZE) {
+                cons.wpos = 0;
+            }
+        }
+    }
+}
+c0101cba:	90                   	nop
+c0101cbb:	c9                   	leave  
+c0101cbc:	c3                   	ret    
+
+c0101cbd <serial_proc_data>:
+
+/* serial_proc_data - get data from serial port */
+static int
+serial_proc_data(void) {
+c0101cbd:	55                   	push   %ebp
+c0101cbe:	89 e5                	mov    %esp,%ebp
+c0101cc0:	83 ec 10             	sub    $0x10,%esp
+c0101cc3:	66 c7 45 f8 fd 03    	movw   $0x3fd,-0x8(%ebp)
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+c0101cc9:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
+c0101ccd:	89 c2                	mov    %eax,%edx
+c0101ccf:	ec                   	in     (%dx),%al
+c0101cd0:	88 45 f7             	mov    %al,-0x9(%ebp)
+    return data;
+c0101cd3:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
+    if (!(inb(COM1 + COM_LSR) & COM_LSR_DATA)) {
+c0101cd7:	0f b6 c0             	movzbl %al,%eax
+c0101cda:	83 e0 01             	and    $0x1,%eax
+c0101cdd:	85 c0                	test   %eax,%eax
+c0101cdf:	75 07                	jne    c0101ce8 <serial_proc_data+0x2b>
+        return -1;
+c0101ce1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+c0101ce6:	eb 2a                	jmp    c0101d12 <serial_proc_data+0x55>
+c0101ce8:	66 c7 45 fa f8 03    	movw   $0x3f8,-0x6(%ebp)
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+c0101cee:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
+c0101cf2:	89 c2                	mov    %eax,%edx
+c0101cf4:	ec                   	in     (%dx),%al
+c0101cf5:	88 45 f6             	mov    %al,-0xa(%ebp)
+    return data;
+c0101cf8:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
+    }
+    int c = inb(COM1 + COM_RX);
+c0101cfc:	0f b6 c0             	movzbl %al,%eax
+c0101cff:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    if (c == 127) {
+c0101d02:	83 7d fc 7f          	cmpl   $0x7f,-0x4(%ebp)
+c0101d06:	75 07                	jne    c0101d0f <serial_proc_data+0x52>
+        c = '\b';
+c0101d08:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%ebp)
+    }
+    return c;
+c0101d0f:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+c0101d12:	c9                   	leave  
+c0101d13:	c3                   	ret    
+
+c0101d14 <serial_intr>:
+
+/* serial_intr - try to feed input characters from serial port */
+void
+serial_intr(void) {
+c0101d14:	55                   	push   %ebp
+c0101d15:	89 e5                	mov    %esp,%ebp
+c0101d17:	83 ec 08             	sub    $0x8,%esp
+    if (serial_exists) {
+c0101d1a:	a1 28 05 1b c0       	mov    0xc01b0528,%eax
+c0101d1f:	85 c0                	test   %eax,%eax
+c0101d21:	74 10                	je     c0101d33 <serial_intr+0x1f>
+        cons_intr(serial_proc_data);
+c0101d23:	83 ec 0c             	sub    $0xc,%esp
+c0101d26:	68 bd 1c 10 c0       	push   $0xc0101cbd
+c0101d2b:	e8 41 ff ff ff       	call   c0101c71 <cons_intr>
+c0101d30:	83 c4 10             	add    $0x10,%esp
+    }
+}
+c0101d33:	90                   	nop
+c0101d34:	c9                   	leave  
+c0101d35:	c3                   	ret    
+
+c0101d36 <kbd_proc_data>:
+ *
+ * The kbd_proc_data() function gets data from the keyboard.
+ * If we finish a character, return it, else 0. And return -1 if no data.
+ * */
+static int
+kbd_proc_data(void) {
+c0101d36:	55                   	push   %ebp
+c0101d37:	89 e5                	mov    %esp,%ebp
+c0101d39:	83 ec 18             	sub    $0x18,%esp
+c0101d3c:	66 c7 45 ec 64 00    	movw   $0x64,-0x14(%ebp)
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+c0101d42:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
+c0101d46:	89 c2                	mov    %eax,%edx
+c0101d48:	ec                   	in     (%dx),%al
+c0101d49:	88 45 eb             	mov    %al,-0x15(%ebp)
+    return data;
+c0101d4c:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
+    int c;
+    uint8_t data;
+    static uint32_t shift;
+
+    if ((inb(KBSTATP) & KBS_DIB) == 0) {
+c0101d50:	0f b6 c0             	movzbl %al,%eax
+c0101d53:	83 e0 01             	and    $0x1,%eax
+c0101d56:	85 c0                	test   %eax,%eax
+c0101d58:	75 0a                	jne    c0101d64 <kbd_proc_data+0x2e>
+        return -1;
+c0101d5a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+c0101d5f:	e9 5d 01 00 00       	jmp    c0101ec1 <kbd_proc_data+0x18b>
+c0101d64:	66 c7 45 f0 60 00    	movw   $0x60,-0x10(%ebp)
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+c0101d6a:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
+c0101d6e:	89 c2                	mov    %eax,%edx
+c0101d70:	ec                   	in     (%dx),%al
+c0101d71:	88 45 ea             	mov    %al,-0x16(%ebp)
+    return data;
+c0101d74:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
+    }
+
+    data = inb(KBDATAP);
+c0101d78:	88 45 f3             	mov    %al,-0xd(%ebp)
+
+    if (data == 0xE0) {
+c0101d7b:	80 7d f3 e0          	cmpb   $0xe0,-0xd(%ebp)
+c0101d7f:	75 17                	jne    c0101d98 <kbd_proc_data+0x62>
+        // E0 escape character
+        shift |= E0ESC;
+c0101d81:	a1 48 07 1b c0       	mov    0xc01b0748,%eax
+c0101d86:	83 c8 40             	or     $0x40,%eax
+c0101d89:	a3 48 07 1b c0       	mov    %eax,0xc01b0748
+        return 0;
+c0101d8e:	b8 00 00 00 00       	mov    $0x0,%eax
+c0101d93:	e9 29 01 00 00       	jmp    c0101ec1 <kbd_proc_data+0x18b>
+    } else if (data & 0x80) {
+c0101d98:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+c0101d9c:	84 c0                	test   %al,%al
+c0101d9e:	79 47                	jns    c0101de7 <kbd_proc_data+0xb1>
+        // Key released
+        data = (shift & E0ESC ? data : data & 0x7F);
+c0101da0:	a1 48 07 1b c0       	mov    0xc01b0748,%eax
+c0101da5:	83 e0 40             	and    $0x40,%eax
+c0101da8:	85 c0                	test   %eax,%eax
+c0101daa:	75 09                	jne    c0101db5 <kbd_proc_data+0x7f>
+c0101dac:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+c0101db0:	83 e0 7f             	and    $0x7f,%eax
+c0101db3:	eb 04                	jmp    c0101db9 <kbd_proc_data+0x83>
+c0101db5:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+c0101db9:	88 45 f3             	mov    %al,-0xd(%ebp)
+        shift &= ~(shiftcode[data] | E0ESC);
+c0101dbc:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+c0101dc0:	0f b6 80 40 c0 12 c0 	movzbl -0x3fed3fc0(%eax),%eax
+c0101dc7:	83 c8 40             	or     $0x40,%eax
+c0101dca:	0f b6 c0             	movzbl %al,%eax
+c0101dcd:	f7 d0                	not    %eax
+c0101dcf:	89 c2                	mov    %eax,%edx
+c0101dd1:	a1 48 07 1b c0       	mov    0xc01b0748,%eax
+c0101dd6:	21 d0                	and    %edx,%eax
+c0101dd8:	a3 48 07 1b c0       	mov    %eax,0xc01b0748
+        return 0;
+c0101ddd:	b8 00 00 00 00       	mov    $0x0,%eax
+c0101de2:	e9 da 00 00 00       	jmp    c0101ec1 <kbd_proc_data+0x18b>
+    } else if (shift & E0ESC) {
+c0101de7:	a1 48 07 1b c0       	mov    0xc01b0748,%eax
+c0101dec:	83 e0 40             	and    $0x40,%eax
+c0101def:	85 c0                	test   %eax,%eax
+c0101df1:	74 11                	je     c0101e04 <kbd_proc_data+0xce>
+        // Last character was an E0 escape; or with 0x80
+        data |= 0x80;
+c0101df3:	80 4d f3 80          	orb    $0x80,-0xd(%ebp)
+        shift &= ~E0ESC;
+c0101df7:	a1 48 07 1b c0       	mov    0xc01b0748,%eax
+c0101dfc:	83 e0 bf             	and    $0xffffffbf,%eax
+c0101dff:	a3 48 07 1b c0       	mov    %eax,0xc01b0748
+    }
+
+    shift |= shiftcode[data];
+c0101e04:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+c0101e08:	0f b6 80 40 c0 12 c0 	movzbl -0x3fed3fc0(%eax),%eax
+c0101e0f:	0f b6 d0             	movzbl %al,%edx
+c0101e12:	a1 48 07 1b c0       	mov    0xc01b0748,%eax
+c0101e17:	09 d0                	or     %edx,%eax
+c0101e19:	a3 48 07 1b c0       	mov    %eax,0xc01b0748
+    shift ^= togglecode[data];
+c0101e1e:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+c0101e22:	0f b6 80 40 c1 12 c0 	movzbl -0x3fed3ec0(%eax),%eax
+c0101e29:	0f b6 d0             	movzbl %al,%edx
+c0101e2c:	a1 48 07 1b c0       	mov    0xc01b0748,%eax
+c0101e31:	31 d0                	xor    %edx,%eax
+c0101e33:	a3 48 07 1b c0       	mov    %eax,0xc01b0748
+
+    c = charcode[shift & (CTL | SHIFT)][data];
+c0101e38:	a1 48 07 1b c0       	mov    0xc01b0748,%eax
+c0101e3d:	83 e0 03             	and    $0x3,%eax
+c0101e40:	8b 14 85 40 c5 12 c0 	mov    -0x3fed3ac0(,%eax,4),%edx
+c0101e47:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+c0101e4b:	01 d0                	add    %edx,%eax
+c0101e4d:	0f b6 00             	movzbl (%eax),%eax
+c0101e50:	0f b6 c0             	movzbl %al,%eax
+c0101e53:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if (shift & CAPSLOCK) {
+c0101e56:	a1 48 07 1b c0       	mov    0xc01b0748,%eax
+c0101e5b:	83 e0 08             	and    $0x8,%eax
+c0101e5e:	85 c0                	test   %eax,%eax
+c0101e60:	74 22                	je     c0101e84 <kbd_proc_data+0x14e>
+        if ('a' <= c && c <= 'z')
+c0101e62:	83 7d f4 60          	cmpl   $0x60,-0xc(%ebp)
+c0101e66:	7e 0c                	jle    c0101e74 <kbd_proc_data+0x13e>
+c0101e68:	83 7d f4 7a          	cmpl   $0x7a,-0xc(%ebp)
+c0101e6c:	7f 06                	jg     c0101e74 <kbd_proc_data+0x13e>
+            c += 'A' - 'a';
+c0101e6e:	83 6d f4 20          	subl   $0x20,-0xc(%ebp)
+c0101e72:	eb 10                	jmp    c0101e84 <kbd_proc_data+0x14e>
+        else if ('A' <= c && c <= 'Z')
+c0101e74:	83 7d f4 40          	cmpl   $0x40,-0xc(%ebp)
+c0101e78:	7e 0a                	jle    c0101e84 <kbd_proc_data+0x14e>
+c0101e7a:	83 7d f4 5a          	cmpl   $0x5a,-0xc(%ebp)
+c0101e7e:	7f 04                	jg     c0101e84 <kbd_proc_data+0x14e>
+            c += 'a' - 'A';
+c0101e80:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
+    }
+
+    // Process special keys
+    // Ctrl-Alt-Del: reboot
+    if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
+c0101e84:	a1 48 07 1b c0       	mov    0xc01b0748,%eax
+c0101e89:	f7 d0                	not    %eax
+c0101e8b:	83 e0 06             	and    $0x6,%eax
+c0101e8e:	85 c0                	test   %eax,%eax
+c0101e90:	75 2c                	jne    c0101ebe <kbd_proc_data+0x188>
+c0101e92:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
+c0101e99:	75 23                	jne    c0101ebe <kbd_proc_data+0x188>
+        cprintf("Rebooting!\n");
+c0101e9b:	83 ec 0c             	sub    $0xc,%esp
+c0101e9e:	68 21 bd 10 c0       	push   $0xc010bd21
+c0101ea3:	e8 e7 e3 ff ff       	call   c010028f <cprintf>
+c0101ea8:	83 c4 10             	add    $0x10,%esp
+c0101eab:	66 c7 45 ee 92 00    	movw   $0x92,-0x12(%ebp)
+c0101eb1:	c6 45 e9 03          	movb   $0x3,-0x17(%ebp)
+        : "memory", "cc");
+}
+
+static inline void
+outb(uint16_t port, uint8_t data) {
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
+c0101eb5:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
+c0101eb9:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
+c0101ebd:	ee                   	out    %al,(%dx)
+        outb(0x92, 0x3); // courtesy of Chris Frost
+    }
+    return c;
+c0101ebe:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+c0101ec1:	c9                   	leave  
+c0101ec2:	c3                   	ret    
+
+c0101ec3 <kbd_intr>:
+
+/* kbd_intr - try to feed input characters from keyboard */
+static void
+kbd_intr(void) {
+c0101ec3:	55                   	push   %ebp
+c0101ec4:	89 e5                	mov    %esp,%ebp
+c0101ec6:	83 ec 08             	sub    $0x8,%esp
+    cons_intr(kbd_proc_data);
+c0101ec9:	83 ec 0c             	sub    $0xc,%esp
+c0101ecc:	68 36 1d 10 c0       	push   $0xc0101d36
+c0101ed1:	e8 9b fd ff ff       	call   c0101c71 <cons_intr>
+c0101ed6:	83 c4 10             	add    $0x10,%esp
+}
+c0101ed9:	90                   	nop
+c0101eda:	c9                   	leave  
+c0101edb:	c3                   	ret    
+
+c0101edc <kbd_init>:
+
+static void
+kbd_init(void) {
+c0101edc:	55                   	push   %ebp
+c0101edd:	89 e5                	mov    %esp,%ebp
+c0101edf:	83 ec 08             	sub    $0x8,%esp
+    // drain the kbd buffer
+    kbd_intr();
+c0101ee2:	e8 dc ff ff ff       	call   c0101ec3 <kbd_intr>
+    pic_enable(IRQ_KBD);
+c0101ee7:	83 ec 0c             	sub    $0xc,%esp
+c0101eea:	6a 01                	push   $0x1
+c0101eec:	e8 4b 01 00 00       	call   c010203c <pic_enable>
+c0101ef1:	83 c4 10             	add    $0x10,%esp
+}
+c0101ef4:	90                   	nop
+c0101ef5:	c9                   	leave  
+c0101ef6:	c3                   	ret    
+
+c0101ef7 <cons_init>:
+
+/* cons_init - initializes the console devices */
+void
+cons_init(void) {
+c0101ef7:	55                   	push   %ebp
+c0101ef8:	89 e5                	mov    %esp,%ebp
+c0101efa:	83 ec 08             	sub    $0x8,%esp
+    cga_init();
+c0101efd:	e8 8c f8 ff ff       	call   c010178e <cga_init>
+    serial_init();
+c0101f02:	e8 6e f9 ff ff       	call   c0101875 <serial_init>
+    kbd_init();
+c0101f07:	e8 d0 ff ff ff       	call   c0101edc <kbd_init>
+    if (!serial_exists) {
+c0101f0c:	a1 28 05 1b c0       	mov    0xc01b0528,%eax
+c0101f11:	85 c0                	test   %eax,%eax
+c0101f13:	75 10                	jne    c0101f25 <cons_init+0x2e>
+        cprintf("serial port does not exist!!\n");
+c0101f15:	83 ec 0c             	sub    $0xc,%esp
+c0101f18:	68 2d bd 10 c0       	push   $0xc010bd2d
+c0101f1d:	e8 6d e3 ff ff       	call   c010028f <cprintf>
+c0101f22:	83 c4 10             	add    $0x10,%esp
+    }
+}
+c0101f25:	90                   	nop
+c0101f26:	c9                   	leave  
+c0101f27:	c3                   	ret    
+
+c0101f28 <cons_putc>:
+
+/* cons_putc - print a single character @c to console devices */
+void
+cons_putc(int c) {
+c0101f28:	55                   	push   %ebp
+c0101f29:	89 e5                	mov    %esp,%ebp
+c0101f2b:	83 ec 18             	sub    $0x18,%esp
+    bool intr_flag;
+    local_intr_save(intr_flag);
+c0101f2e:	e8 d4 f7 ff ff       	call   c0101707 <__intr_save>
+c0101f33:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    {
+        lpt_putc(c);
+c0101f36:	83 ec 0c             	sub    $0xc,%esp
+c0101f39:	ff 75 08             	pushl  0x8(%ebp)
+c0101f3c:	e8 93 fa ff ff       	call   c01019d4 <lpt_putc>
+c0101f41:	83 c4 10             	add    $0x10,%esp
+        cga_putc(c);
+c0101f44:	83 ec 0c             	sub    $0xc,%esp
+c0101f47:	ff 75 08             	pushl  0x8(%ebp)
+c0101f4a:	e8 bc fa ff ff       	call   c0101a0b <cga_putc>
+c0101f4f:	83 c4 10             	add    $0x10,%esp
+        serial_putc(c);
+c0101f52:	83 ec 0c             	sub    $0xc,%esp
+c0101f55:	ff 75 08             	pushl  0x8(%ebp)
+c0101f58:	e8 dd fc ff ff       	call   c0101c3a <serial_putc>
+c0101f5d:	83 c4 10             	add    $0x10,%esp
+    }
+    local_intr_restore(intr_flag);
+c0101f60:	83 ec 0c             	sub    $0xc,%esp
+c0101f63:	ff 75 f4             	pushl  -0xc(%ebp)
+c0101f66:	e8 c6 f7 ff ff       	call   c0101731 <__intr_restore>
+c0101f6b:	83 c4 10             	add    $0x10,%esp
+}
+c0101f6e:	90                   	nop
+c0101f6f:	c9                   	leave  
+c0101f70:	c3                   	ret    
+
+c0101f71 <cons_getc>:
+/* *
+ * cons_getc - return the next input character from console,
+ * or 0 if none waiting.
+ * */
+int
+cons_getc(void) {
+c0101f71:	55                   	push   %ebp
+c0101f72:	89 e5                	mov    %esp,%ebp
+c0101f74:	83 ec 18             	sub    $0x18,%esp
+    int c = 0;
+c0101f77:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    bool intr_flag;
+    local_intr_save(intr_flag);
+c0101f7e:	e8 84 f7 ff ff       	call   c0101707 <__intr_save>
+c0101f83:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    {
+        // poll for any pending input characters,
+        // so that this function works even when interrupts are disabled
+        // (e.g., when called from the kernel monitor).
+        serial_intr();
+c0101f86:	e8 89 fd ff ff       	call   c0101d14 <serial_intr>
+        kbd_intr();
+c0101f8b:	e8 33 ff ff ff       	call   c0101ec3 <kbd_intr>
+
+        // grab the next character from the input buffer.
+        if (cons.rpos != cons.wpos) {
+c0101f90:	8b 15 40 07 1b c0    	mov    0xc01b0740,%edx
+c0101f96:	a1 44 07 1b c0       	mov    0xc01b0744,%eax
+c0101f9b:	39 c2                	cmp    %eax,%edx
+c0101f9d:	74 31                	je     c0101fd0 <cons_getc+0x5f>
+            c = cons.buf[cons.rpos ++];
+c0101f9f:	a1 40 07 1b c0       	mov    0xc01b0740,%eax
+c0101fa4:	8d 50 01             	lea    0x1(%eax),%edx
+c0101fa7:	89 15 40 07 1b c0    	mov    %edx,0xc01b0740
+c0101fad:	0f b6 80 40 05 1b c0 	movzbl -0x3fe4fac0(%eax),%eax
+c0101fb4:	0f b6 c0             	movzbl %al,%eax
+c0101fb7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+            if (cons.rpos == CONSBUFSIZE) {
+c0101fba:	a1 40 07 1b c0       	mov    0xc01b0740,%eax
+c0101fbf:	3d 00 02 00 00       	cmp    $0x200,%eax
+c0101fc4:	75 0a                	jne    c0101fd0 <cons_getc+0x5f>
+                cons.rpos = 0;
+c0101fc6:	c7 05 40 07 1b c0 00 	movl   $0x0,0xc01b0740
+c0101fcd:	00 00 00 
+            }
+        }
+    }
+    local_intr_restore(intr_flag);
+c0101fd0:	83 ec 0c             	sub    $0xc,%esp
+c0101fd3:	ff 75 f0             	pushl  -0x10(%ebp)
+c0101fd6:	e8 56 f7 ff ff       	call   c0101731 <__intr_restore>
+c0101fdb:	83 c4 10             	add    $0x10,%esp
+    return c;
+c0101fde:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+c0101fe1:	c9                   	leave  
+c0101fe2:	c3                   	ret    
+
+c0101fe3 <pic_setmask>:
+// Initial IRQ mask has interrupt 2 enabled (for slave 8259A).
+static uint16_t irq_mask = 0xFFFF & ~(1 << IRQ_SLAVE);
+static bool did_init = 0;
+
+static void
+pic_setmask(uint16_t mask) {
+c0101fe3:	55                   	push   %ebp
+c0101fe4:	89 e5                	mov    %esp,%ebp
+c0101fe6:	83 ec 14             	sub    $0x14,%esp
+c0101fe9:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101fec:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
+    irq_mask = mask;
+c0101ff0:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
+c0101ff4:	66 a3 50 c5 12 c0    	mov    %ax,0xc012c550
+    if (did_init) {
+c0101ffa:	a1 4c 07 1b c0       	mov    0xc01b074c,%eax
+c0101fff:	85 c0                	test   %eax,%eax
+c0102001:	74 36                	je     c0102039 <pic_setmask+0x56>
+        outb(IO_PIC1 + 1, mask);
+c0102003:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
+c0102007:	0f b6 c0             	movzbl %al,%eax
+c010200a:	66 c7 45 fe 21 00    	movw   $0x21,-0x2(%ebp)
+c0102010:	88 45 fa             	mov    %al,-0x6(%ebp)
+c0102013:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
+c0102017:	0f b7 55 fe          	movzwl -0x2(%ebp),%edx
+c010201b:	ee                   	out    %al,(%dx)
+        outb(IO_PIC2 + 1, mask >> 8);
+c010201c:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
+c0102020:	66 c1 e8 08          	shr    $0x8,%ax
+c0102024:	0f b6 c0             	movzbl %al,%eax
+c0102027:	66 c7 45 fc a1 00    	movw   $0xa1,-0x4(%ebp)
+c010202d:	88 45 fb             	mov    %al,-0x5(%ebp)
+c0102030:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
+c0102034:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
+c0102038:	ee                   	out    %al,(%dx)
+    }
+}
+c0102039:	90                   	nop
+c010203a:	c9                   	leave  
+c010203b:	c3                   	ret    
+
+c010203c <pic_enable>:
+
+void
+pic_enable(unsigned int irq) {
+c010203c:	55                   	push   %ebp
+c010203d:	89 e5                	mov    %esp,%ebp
+    pic_setmask(irq_mask & ~(1 << irq));
+c010203f:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102042:	ba 01 00 00 00       	mov    $0x1,%edx
+c0102047:	89 c1                	mov    %eax,%ecx
+c0102049:	d3 e2                	shl    %cl,%edx
+c010204b:	89 d0                	mov    %edx,%eax
+c010204d:	f7 d0                	not    %eax
+c010204f:	89 c2                	mov    %eax,%edx
+c0102051:	0f b7 05 50 c5 12 c0 	movzwl 0xc012c550,%eax
+c0102058:	21 d0                	and    %edx,%eax
+c010205a:	0f b7 c0             	movzwl %ax,%eax
+c010205d:	50                   	push   %eax
+c010205e:	e8 80 ff ff ff       	call   c0101fe3 <pic_setmask>
+c0102063:	83 c4 04             	add    $0x4,%esp
+}
+c0102066:	90                   	nop
+c0102067:	c9                   	leave  
+c0102068:	c3                   	ret    
+
+c0102069 <pic_init>:
+
+/* pic_init - initialize the 8259A interrupt controllers */
+void
+pic_init(void) {
+c0102069:	55                   	push   %ebp
+c010206a:	89 e5                	mov    %esp,%ebp
+c010206c:	83 ec 30             	sub    $0x30,%esp
+    did_init = 1;
+c010206f:	c7 05 4c 07 1b c0 01 	movl   $0x1,0xc01b074c
+c0102076:	00 00 00 
+c0102079:	66 c7 45 fe 21 00    	movw   $0x21,-0x2(%ebp)
+c010207f:	c6 45 d6 ff          	movb   $0xff,-0x2a(%ebp)
+c0102083:	0f b6 45 d6          	movzbl -0x2a(%ebp),%eax
+c0102087:	0f b7 55 fe          	movzwl -0x2(%ebp),%edx
+c010208b:	ee                   	out    %al,(%dx)
+c010208c:	66 c7 45 fc a1 00    	movw   $0xa1,-0x4(%ebp)
+c0102092:	c6 45 d7 ff          	movb   $0xff,-0x29(%ebp)
+c0102096:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
+c010209a:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
+c010209e:	ee                   	out    %al,(%dx)
+c010209f:	66 c7 45 fa 20 00    	movw   $0x20,-0x6(%ebp)
+c01020a5:	c6 45 d8 11          	movb   $0x11,-0x28(%ebp)
+c01020a9:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
+c01020ad:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
+c01020b1:	ee                   	out    %al,(%dx)
+c01020b2:	66 c7 45 f8 21 00    	movw   $0x21,-0x8(%ebp)
+c01020b8:	c6 45 d9 20          	movb   $0x20,-0x27(%ebp)
+c01020bc:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
+c01020c0:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
+c01020c4:	ee                   	out    %al,(%dx)
+c01020c5:	66 c7 45 f6 21 00    	movw   $0x21,-0xa(%ebp)
+c01020cb:	c6 45 da 04          	movb   $0x4,-0x26(%ebp)
+c01020cf:	0f b6 45 da          	movzbl -0x26(%ebp),%eax
+c01020d3:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
+c01020d7:	ee                   	out    %al,(%dx)
+c01020d8:	66 c7 45 f4 21 00    	movw   $0x21,-0xc(%ebp)
+c01020de:	c6 45 db 03          	movb   $0x3,-0x25(%ebp)
+c01020e2:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
+c01020e6:	0f b7 55 f4          	movzwl -0xc(%ebp),%edx
+c01020ea:	ee                   	out    %al,(%dx)
+c01020eb:	66 c7 45 f2 a0 00    	movw   $0xa0,-0xe(%ebp)
+c01020f1:	c6 45 dc 11          	movb   $0x11,-0x24(%ebp)
+c01020f5:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
+c01020f9:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+c01020fd:	ee                   	out    %al,(%dx)
+c01020fe:	66 c7 45 f0 a1 00    	movw   $0xa1,-0x10(%ebp)
+c0102104:	c6 45 dd 28          	movb   $0x28,-0x23(%ebp)
+c0102108:	0f b6 45 dd          	movzbl -0x23(%ebp),%eax
+c010210c:	0f b7 55 f0          	movzwl -0x10(%ebp),%edx
+c0102110:	ee                   	out    %al,(%dx)
+c0102111:	66 c7 45 ee a1 00    	movw   $0xa1,-0x12(%ebp)
+c0102117:	c6 45 de 02          	movb   $0x2,-0x22(%ebp)
+c010211b:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
+c010211f:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
+c0102123:	ee                   	out    %al,(%dx)
+c0102124:	66 c7 45 ec a1 00    	movw   $0xa1,-0x14(%ebp)
+c010212a:	c6 45 df 03          	movb   $0x3,-0x21(%ebp)
+c010212e:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
+c0102132:	0f b7 55 ec          	movzwl -0x14(%ebp),%edx
+c0102136:	ee                   	out    %al,(%dx)
+c0102137:	66 c7 45 ea 20 00    	movw   $0x20,-0x16(%ebp)
+c010213d:	c6 45 e0 68          	movb   $0x68,-0x20(%ebp)
+c0102141:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
+c0102145:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+c0102149:	ee                   	out    %al,(%dx)
+c010214a:	66 c7 45 e8 20 00    	movw   $0x20,-0x18(%ebp)
+c0102150:	c6 45 e1 0a          	movb   $0xa,-0x1f(%ebp)
+c0102154:	0f b6 45 e1          	movzbl -0x1f(%ebp),%eax
+c0102158:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
+c010215c:	ee                   	out    %al,(%dx)
+c010215d:	66 c7 45 e6 a0 00    	movw   $0xa0,-0x1a(%ebp)
+c0102163:	c6 45 e2 68          	movb   $0x68,-0x1e(%ebp)
+c0102167:	0f b6 45 e2          	movzbl -0x1e(%ebp),%eax
+c010216b:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
+c010216f:	ee                   	out    %al,(%dx)
+c0102170:	66 c7 45 e4 a0 00    	movw   $0xa0,-0x1c(%ebp)
+c0102176:	c6 45 e3 0a          	movb   $0xa,-0x1d(%ebp)
+c010217a:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
+c010217e:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
+c0102182:	ee                   	out    %al,(%dx)
+    outb(IO_PIC1, 0x0a);    // read IRR by default
+
+    outb(IO_PIC2, 0x68);    // OCW3
+    outb(IO_PIC2, 0x0a);    // OCW3
+
+    if (irq_mask != 0xFFFF) {
+c0102183:	0f b7 05 50 c5 12 c0 	movzwl 0xc012c550,%eax
+c010218a:	66 83 f8 ff          	cmp    $0xffff,%ax
+c010218e:	74 13                	je     c01021a3 <pic_init+0x13a>
+        pic_setmask(irq_mask);
+c0102190:	0f b7 05 50 c5 12 c0 	movzwl 0xc012c550,%eax
+c0102197:	0f b7 c0             	movzwl %ax,%eax
+c010219a:	50                   	push   %eax
+c010219b:	e8 43 fe ff ff       	call   c0101fe3 <pic_setmask>
+c01021a0:	83 c4 04             	add    $0x4,%esp
+    }
+}
+c01021a3:	90                   	nop
+c01021a4:	c9                   	leave  
+c01021a5:	c3                   	ret    
+
+c01021a6 <intr_enable>:
+#include <x86.h>
+#include <intr.h>
+
+/* intr_enable - enable irq interrupt */
+void
+intr_enable(void) {
+c01021a6:	55                   	push   %ebp
+c01021a7:	89 e5                	mov    %esp,%ebp
+    asm volatile ("lidt (%0)" :: "r" (pd) : "memory");
+}
+
+static inline void
+sti(void) {
+    asm volatile ("sti");
+c01021a9:	fb                   	sti    
+    sti();
+}
+c01021aa:	90                   	nop
+c01021ab:	5d                   	pop    %ebp
+c01021ac:	c3                   	ret    
+
+c01021ad <intr_disable>:
+
+/* intr_disable - disable irq interrupt */
+void
+intr_disable(void) {
+c01021ad:	55                   	push   %ebp
+c01021ae:	89 e5                	mov    %esp,%ebp
+}
+
+static inline void
+cli(void) {
+    asm volatile ("cli" ::: "memory");
+c01021b0:	fa                   	cli    
+    cli();
+}
+c01021b1:	90                   	nop
+c01021b2:	5d                   	pop    %ebp
+c01021b3:	c3                   	ret    
+
+c01021b4 <print_ticks>:
+#include <sync.h>
+#include <proc.h>
+
+#define TICK_NUM 100
+
+static void print_ticks() {
+c01021b4:	55                   	push   %ebp
+c01021b5:	89 e5                	mov    %esp,%ebp
+c01021b7:	83 ec 08             	sub    $0x8,%esp
+    cprintf("%d ticks\n",TICK_NUM);
+c01021ba:	83 ec 08             	sub    $0x8,%esp
+c01021bd:	6a 64                	push   $0x64
+c01021bf:	68 60 bd 10 c0       	push   $0xc010bd60
+c01021c4:	e8 c6 e0 ff ff       	call   c010028f <cprintf>
+c01021c9:	83 c4 10             	add    $0x10,%esp
+#ifdef DEBUG_GRADE
+    cprintf("End of Test.\n");
+c01021cc:	83 ec 0c             	sub    $0xc,%esp
+c01021cf:	68 6a bd 10 c0       	push   $0xc010bd6a
+c01021d4:	e8 b6 e0 ff ff       	call   c010028f <cprintf>
+c01021d9:	83 c4 10             	add    $0x10,%esp
+    panic("EOT: kernel seems ok.");
+c01021dc:	83 ec 04             	sub    $0x4,%esp
+c01021df:	68 78 bd 10 c0       	push   $0xc010bd78
+c01021e4:	6a 1a                	push   $0x1a
+c01021e6:	68 8e bd 10 c0       	push   $0xc010bd8e
+c01021eb:	e8 05 e2 ff ff       	call   c01003f5 <__panic>
+
+c01021f0 <idt_init>:
+    sizeof(idt) - 1, (uintptr_t)idt
+};
+
+/* idt_init - initialize IDT to each of the entry points in kern/trap/vectors.S */
+void
+idt_init(void) {
+c01021f0:	55                   	push   %ebp
+c01021f1:	89 e5                	mov    %esp,%ebp
+c01021f3:	83 ec 10             	sub    $0x10,%esp
+      *     Notice: the argument of lidt is idt_pd. try to find it!
+      */
+    extern uintptr_t __vectors[];
+    int i;
+//    for(i=0;i<256;i++)
+        for(i=0;i< sizeof(idt) / sizeof(struct gatedesc); i++){
+c01021f6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+c01021fd:	e9 c3 00 00 00       	jmp    c01022c5 <idt_init+0xd5>
+            SETGATE(idt[i],0,GD_KTEXT,__vectors[i],DPL_KERNEL);
+c0102202:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0102205:	8b 04 85 e0 c5 12 c0 	mov    -0x3fed3a20(,%eax,4),%eax
+c010220c:	89 c2                	mov    %eax,%edx
+c010220e:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0102211:	66 89 14 c5 60 07 1b 	mov    %dx,-0x3fe4f8a0(,%eax,8)
+c0102218:	c0 
+c0102219:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c010221c:	66 c7 04 c5 62 07 1b 	movw   $0x8,-0x3fe4f89e(,%eax,8)
+c0102223:	c0 08 00 
+c0102226:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0102229:	0f b6 14 c5 64 07 1b 	movzbl -0x3fe4f89c(,%eax,8),%edx
+c0102230:	c0 
+c0102231:	83 e2 e0             	and    $0xffffffe0,%edx
+c0102234:	88 14 c5 64 07 1b c0 	mov    %dl,-0x3fe4f89c(,%eax,8)
+c010223b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c010223e:	0f b6 14 c5 64 07 1b 	movzbl -0x3fe4f89c(,%eax,8),%edx
+c0102245:	c0 
+c0102246:	83 e2 1f             	and    $0x1f,%edx
+c0102249:	88 14 c5 64 07 1b c0 	mov    %dl,-0x3fe4f89c(,%eax,8)
+c0102250:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0102253:	0f b6 14 c5 65 07 1b 	movzbl -0x3fe4f89b(,%eax,8),%edx
+c010225a:	c0 
+c010225b:	83 e2 f0             	and    $0xfffffff0,%edx
+c010225e:	83 ca 0e             	or     $0xe,%edx
+c0102261:	88 14 c5 65 07 1b c0 	mov    %dl,-0x3fe4f89b(,%eax,8)
+c0102268:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c010226b:	0f b6 14 c5 65 07 1b 	movzbl -0x3fe4f89b(,%eax,8),%edx
+c0102272:	c0 
+c0102273:	83 e2 ef             	and    $0xffffffef,%edx
+c0102276:	88 14 c5 65 07 1b c0 	mov    %dl,-0x3fe4f89b(,%eax,8)
+c010227d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0102280:	0f b6 14 c5 65 07 1b 	movzbl -0x3fe4f89b(,%eax,8),%edx
+c0102287:	c0 
+c0102288:	83 e2 9f             	and    $0xffffff9f,%edx
+c010228b:	88 14 c5 65 07 1b c0 	mov    %dl,-0x3fe4f89b(,%eax,8)
+c0102292:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0102295:	0f b6 14 c5 65 07 1b 	movzbl -0x3fe4f89b(,%eax,8),%edx
+c010229c:	c0 
+c010229d:	83 ca 80             	or     $0xffffff80,%edx
+c01022a0:	88 14 c5 65 07 1b c0 	mov    %dl,-0x3fe4f89b(,%eax,8)
+c01022a7:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c01022aa:	8b 04 85 e0 c5 12 c0 	mov    -0x3fed3a20(,%eax,4),%eax
+c01022b1:	c1 e8 10             	shr    $0x10,%eax
+c01022b4:	89 c2                	mov    %eax,%edx
+c01022b6:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c01022b9:	66 89 14 c5 66 07 1b 	mov    %dx,-0x3fe4f89a(,%eax,8)
+c01022c0:	c0 
+      *     Notice: the argument of lidt is idt_pd. try to find it!
+      */
+    extern uintptr_t __vectors[];
+    int i;
+//    for(i=0;i<256;i++)
+        for(i=0;i< sizeof(idt) / sizeof(struct gatedesc); i++){
+c01022c1:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+c01022c5:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c01022c8:	3d ff 00 00 00       	cmp    $0xff,%eax
+c01022cd:	0f 86 2f ff ff ff    	jbe    c0102202 <idt_init+0x12>
+            SETGATE(idt[i],0,GD_KTEXT,__vectors[i],DPL_KERNEL);
+    }
+//  SETGATE(idt[T_SWITCH_TOK], 0, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER);
+    SETGATE(idt[T_SYSCALL], 1, GD_KTEXT, __vectors[T_SYSCALL], DPL_USER);
+c01022d3:	a1 e0 c7 12 c0       	mov    0xc012c7e0,%eax
+c01022d8:	66 a3 60 0b 1b c0    	mov    %ax,0xc01b0b60
+c01022de:	66 c7 05 62 0b 1b c0 	movw   $0x8,0xc01b0b62
+c01022e5:	08 00 
+c01022e7:	0f b6 05 64 0b 1b c0 	movzbl 0xc01b0b64,%eax
+c01022ee:	83 e0 e0             	and    $0xffffffe0,%eax
+c01022f1:	a2 64 0b 1b c0       	mov    %al,0xc01b0b64
+c01022f6:	0f b6 05 64 0b 1b c0 	movzbl 0xc01b0b64,%eax
+c01022fd:	83 e0 1f             	and    $0x1f,%eax
+c0102300:	a2 64 0b 1b c0       	mov    %al,0xc01b0b64
+c0102305:	0f b6 05 65 0b 1b c0 	movzbl 0xc01b0b65,%eax
+c010230c:	83 c8 0f             	or     $0xf,%eax
+c010230f:	a2 65 0b 1b c0       	mov    %al,0xc01b0b65
+c0102314:	0f b6 05 65 0b 1b c0 	movzbl 0xc01b0b65,%eax
+c010231b:	83 e0 ef             	and    $0xffffffef,%eax
+c010231e:	a2 65 0b 1b c0       	mov    %al,0xc01b0b65
+c0102323:	0f b6 05 65 0b 1b c0 	movzbl 0xc01b0b65,%eax
+c010232a:	83 c8 60             	or     $0x60,%eax
+c010232d:	a2 65 0b 1b c0       	mov    %al,0xc01b0b65
+c0102332:	0f b6 05 65 0b 1b c0 	movzbl 0xc01b0b65,%eax
+c0102339:	83 c8 80             	or     $0xffffff80,%eax
+c010233c:	a2 65 0b 1b c0       	mov    %al,0xc01b0b65
+c0102341:	a1 e0 c7 12 c0       	mov    0xc012c7e0,%eax
+c0102346:	c1 e8 10             	shr    $0x10,%eax
+c0102349:	66 a3 66 0b 1b c0    	mov    %ax,0xc01b0b66
+c010234f:	c7 45 f8 60 c5 12 c0 	movl   $0xc012c560,-0x8(%ebp)
+    }
+}
+
+static inline void
+lidt(struct pseudodesc *pd) {
+    asm volatile ("lidt (%0)" :: "r" (pd) : "memory");
+c0102356:	8b 45 f8             	mov    -0x8(%ebp),%eax
+c0102359:	0f 01 18             	lidtl  (%eax)
+    lidt(&idt_pd);   
+     /* LAB5 YOUR CODE */ 
+     //you should update your lab1 code (just add ONE or TWO lines of code), let user app to use syscall to get the service of ucore
+     //so you should setup the syscall interrupt gate in here
+}
+c010235c:	90                   	nop
+c010235d:	c9                   	leave  
+c010235e:	c3                   	ret    
+
+c010235f <trapname>:
+
+static const char *
+trapname(int trapno) {
+c010235f:	55                   	push   %ebp
+c0102360:	89 e5                	mov    %esp,%ebp
+        "Alignment Check",
+        "Machine-Check",
+        "SIMD Floating-Point Exception"
+    };
+
+    if (trapno < sizeof(excnames)/sizeof(const char * const)) {
+c0102362:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102365:	83 f8 13             	cmp    $0x13,%eax
+c0102368:	77 0c                	ja     c0102376 <trapname+0x17>
+        return excnames[trapno];
+c010236a:	8b 45 08             	mov    0x8(%ebp),%eax
+c010236d:	8b 04 85 20 c2 10 c0 	mov    -0x3fef3de0(,%eax,4),%eax
+c0102374:	eb 18                	jmp    c010238e <trapname+0x2f>
+    }
+    if (trapno >= IRQ_OFFSET && trapno < IRQ_OFFSET + 16) {
+c0102376:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
+c010237a:	7e 0d                	jle    c0102389 <trapname+0x2a>
+c010237c:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
+c0102380:	7f 07                	jg     c0102389 <trapname+0x2a>
+        return "Hardware Interrupt";
+c0102382:	b8 9f bd 10 c0       	mov    $0xc010bd9f,%eax
+c0102387:	eb 05                	jmp    c010238e <trapname+0x2f>
+    }
+    return "(unknown trap)";
+c0102389:	b8 b2 bd 10 c0       	mov    $0xc010bdb2,%eax
+}
+c010238e:	5d                   	pop    %ebp
+c010238f:	c3                   	ret    
+
+c0102390 <trap_in_kernel>:
+
+/* trap_in_kernel - test if trap happened in kernel */
+bool
+trap_in_kernel(struct trapframe *tf) {
+c0102390:	55                   	push   %ebp
+c0102391:	89 e5                	mov    %esp,%ebp
+    return (tf->tf_cs == (uint16_t)KERNEL_CS);
+c0102393:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102396:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
+c010239a:	66 83 f8 08          	cmp    $0x8,%ax
+c010239e:	0f 94 c0             	sete   %al
+c01023a1:	0f b6 c0             	movzbl %al,%eax
+}
+c01023a4:	5d                   	pop    %ebp
+c01023a5:	c3                   	ret    
+
+c01023a6 <print_trapframe>:
+    "TF", "IF", "DF", "OF", NULL, NULL, "NT", NULL,
+    "RF", "VM", "AC", "VIF", "VIP", "ID", NULL, NULL,
+};
+
+void
+print_trapframe(struct trapframe *tf) {
+c01023a6:	55                   	push   %ebp
+c01023a7:	89 e5                	mov    %esp,%ebp
+c01023a9:	83 ec 18             	sub    $0x18,%esp
+    cprintf("trapframe at %p\n", tf);
+c01023ac:	83 ec 08             	sub    $0x8,%esp
+c01023af:	ff 75 08             	pushl  0x8(%ebp)
+c01023b2:	68 f3 bd 10 c0       	push   $0xc010bdf3
+c01023b7:	e8 d3 de ff ff       	call   c010028f <cprintf>
+c01023bc:	83 c4 10             	add    $0x10,%esp
+    print_regs(&tf->tf_regs);
+c01023bf:	8b 45 08             	mov    0x8(%ebp),%eax
+c01023c2:	83 ec 0c             	sub    $0xc,%esp
+c01023c5:	50                   	push   %eax
+c01023c6:	e8 b8 01 00 00       	call   c0102583 <print_regs>
+c01023cb:	83 c4 10             	add    $0x10,%esp
+    cprintf("  ds   0x----%04x\n", tf->tf_ds);
+c01023ce:	8b 45 08             	mov    0x8(%ebp),%eax
+c01023d1:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
+c01023d5:	0f b7 c0             	movzwl %ax,%eax
+c01023d8:	83 ec 08             	sub    $0x8,%esp
+c01023db:	50                   	push   %eax
+c01023dc:	68 04 be 10 c0       	push   $0xc010be04
+c01023e1:	e8 a9 de ff ff       	call   c010028f <cprintf>
+c01023e6:	83 c4 10             	add    $0x10,%esp
+    cprintf("  es   0x----%04x\n", tf->tf_es);
+c01023e9:	8b 45 08             	mov    0x8(%ebp),%eax
+c01023ec:	0f b7 40 28          	movzwl 0x28(%eax),%eax
+c01023f0:	0f b7 c0             	movzwl %ax,%eax
+c01023f3:	83 ec 08             	sub    $0x8,%esp
+c01023f6:	50                   	push   %eax
+c01023f7:	68 17 be 10 c0       	push   $0xc010be17
+c01023fc:	e8 8e de ff ff       	call   c010028f <cprintf>
+c0102401:	83 c4 10             	add    $0x10,%esp
+    cprintf("  fs   0x----%04x\n", tf->tf_fs);
+c0102404:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102407:	0f b7 40 24          	movzwl 0x24(%eax),%eax
+c010240b:	0f b7 c0             	movzwl %ax,%eax
+c010240e:	83 ec 08             	sub    $0x8,%esp
+c0102411:	50                   	push   %eax
+c0102412:	68 2a be 10 c0       	push   $0xc010be2a
+c0102417:	e8 73 de ff ff       	call   c010028f <cprintf>
+c010241c:	83 c4 10             	add    $0x10,%esp
+    cprintf("  gs   0x----%04x\n", tf->tf_gs);
+c010241f:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102422:	0f b7 40 20          	movzwl 0x20(%eax),%eax
+c0102426:	0f b7 c0             	movzwl %ax,%eax
+c0102429:	83 ec 08             	sub    $0x8,%esp
+c010242c:	50                   	push   %eax
+c010242d:	68 3d be 10 c0       	push   $0xc010be3d
+c0102432:	e8 58 de ff ff       	call   c010028f <cprintf>
+c0102437:	83 c4 10             	add    $0x10,%esp
+    cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
+c010243a:	8b 45 08             	mov    0x8(%ebp),%eax
+c010243d:	8b 40 30             	mov    0x30(%eax),%eax
+c0102440:	83 ec 0c             	sub    $0xc,%esp
+c0102443:	50                   	push   %eax
+c0102444:	e8 16 ff ff ff       	call   c010235f <trapname>
+c0102449:	83 c4 10             	add    $0x10,%esp
+c010244c:	89 c2                	mov    %eax,%edx
+c010244e:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102451:	8b 40 30             	mov    0x30(%eax),%eax
+c0102454:	83 ec 04             	sub    $0x4,%esp
+c0102457:	52                   	push   %edx
+c0102458:	50                   	push   %eax
+c0102459:	68 50 be 10 c0       	push   $0xc010be50
+c010245e:	e8 2c de ff ff       	call   c010028f <cprintf>
+c0102463:	83 c4 10             	add    $0x10,%esp
+    cprintf("  err  0x%08x\n", tf->tf_err);
+c0102466:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102469:	8b 40 34             	mov    0x34(%eax),%eax
+c010246c:	83 ec 08             	sub    $0x8,%esp
+c010246f:	50                   	push   %eax
+c0102470:	68 62 be 10 c0       	push   $0xc010be62
+c0102475:	e8 15 de ff ff       	call   c010028f <cprintf>
+c010247a:	83 c4 10             	add    $0x10,%esp
+    cprintf("  eip  0x%08x\n", tf->tf_eip);
+c010247d:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102480:	8b 40 38             	mov    0x38(%eax),%eax
+c0102483:	83 ec 08             	sub    $0x8,%esp
+c0102486:	50                   	push   %eax
+c0102487:	68 71 be 10 c0       	push   $0xc010be71
+c010248c:	e8 fe dd ff ff       	call   c010028f <cprintf>
+c0102491:	83 c4 10             	add    $0x10,%esp
+    cprintf("  cs   0x----%04x\n", tf->tf_cs);
+c0102494:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102497:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
+c010249b:	0f b7 c0             	movzwl %ax,%eax
+c010249e:	83 ec 08             	sub    $0x8,%esp
+c01024a1:	50                   	push   %eax
+c01024a2:	68 80 be 10 c0       	push   $0xc010be80
+c01024a7:	e8 e3 dd ff ff       	call   c010028f <cprintf>
+c01024ac:	83 c4 10             	add    $0x10,%esp
+    cprintf("  flag 0x%08x ", tf->tf_eflags);
+c01024af:	8b 45 08             	mov    0x8(%ebp),%eax
+c01024b2:	8b 40 40             	mov    0x40(%eax),%eax
+c01024b5:	83 ec 08             	sub    $0x8,%esp
+c01024b8:	50                   	push   %eax
+c01024b9:	68 93 be 10 c0       	push   $0xc010be93
+c01024be:	e8 cc dd ff ff       	call   c010028f <cprintf>
+c01024c3:	83 c4 10             	add    $0x10,%esp
+
+    int i, j;
+    for (i = 0, j = 1; i < sizeof(IA32flags) / sizeof(IA32flags[0]); i ++, j <<= 1) {
+c01024c6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c01024cd:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+c01024d4:	eb 3f                	jmp    c0102515 <print_trapframe+0x16f>
+        if ((tf->tf_eflags & j) && IA32flags[i] != NULL) {
+c01024d6:	8b 45 08             	mov    0x8(%ebp),%eax
+c01024d9:	8b 50 40             	mov    0x40(%eax),%edx
+c01024dc:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01024df:	21 d0                	and    %edx,%eax
+c01024e1:	85 c0                	test   %eax,%eax
+c01024e3:	74 29                	je     c010250e <print_trapframe+0x168>
+c01024e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01024e8:	8b 04 85 80 c5 12 c0 	mov    -0x3fed3a80(,%eax,4),%eax
+c01024ef:	85 c0                	test   %eax,%eax
+c01024f1:	74 1b                	je     c010250e <print_trapframe+0x168>
+            cprintf("%s,", IA32flags[i]);
+c01024f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01024f6:	8b 04 85 80 c5 12 c0 	mov    -0x3fed3a80(,%eax,4),%eax
+c01024fd:	83 ec 08             	sub    $0x8,%esp
+c0102500:	50                   	push   %eax
+c0102501:	68 a2 be 10 c0       	push   $0xc010bea2
+c0102506:	e8 84 dd ff ff       	call   c010028f <cprintf>
+c010250b:	83 c4 10             	add    $0x10,%esp
+    cprintf("  eip  0x%08x\n", tf->tf_eip);
+    cprintf("  cs   0x----%04x\n", tf->tf_cs);
+    cprintf("  flag 0x%08x ", tf->tf_eflags);
+
+    int i, j;
+    for (i = 0, j = 1; i < sizeof(IA32flags) / sizeof(IA32flags[0]); i ++, j <<= 1) {
+c010250e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+c0102512:	d1 65 f0             	shll   -0x10(%ebp)
+c0102515:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0102518:	83 f8 17             	cmp    $0x17,%eax
+c010251b:	76 b9                	jbe    c01024d6 <print_trapframe+0x130>
+        if ((tf->tf_eflags & j) && IA32flags[i] != NULL) {
+            cprintf("%s,", IA32flags[i]);
+        }
+    }
+    cprintf("IOPL=%d\n", (tf->tf_eflags & FL_IOPL_MASK) >> 12);
+c010251d:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102520:	8b 40 40             	mov    0x40(%eax),%eax
+c0102523:	25 00 30 00 00       	and    $0x3000,%eax
+c0102528:	c1 e8 0c             	shr    $0xc,%eax
+c010252b:	83 ec 08             	sub    $0x8,%esp
+c010252e:	50                   	push   %eax
+c010252f:	68 a6 be 10 c0       	push   $0xc010bea6
+c0102534:	e8 56 dd ff ff       	call   c010028f <cprintf>
+c0102539:	83 c4 10             	add    $0x10,%esp
+
+    if (!trap_in_kernel(tf)) {
+c010253c:	83 ec 0c             	sub    $0xc,%esp
+c010253f:	ff 75 08             	pushl  0x8(%ebp)
+c0102542:	e8 49 fe ff ff       	call   c0102390 <trap_in_kernel>
+c0102547:	83 c4 10             	add    $0x10,%esp
+c010254a:	85 c0                	test   %eax,%eax
+c010254c:	75 32                	jne    c0102580 <print_trapframe+0x1da>
+        cprintf("  esp  0x%08x\n", tf->tf_esp);
+c010254e:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102551:	8b 40 44             	mov    0x44(%eax),%eax
+c0102554:	83 ec 08             	sub    $0x8,%esp
+c0102557:	50                   	push   %eax
+c0102558:	68 af be 10 c0       	push   $0xc010beaf
+c010255d:	e8 2d dd ff ff       	call   c010028f <cprintf>
+c0102562:	83 c4 10             	add    $0x10,%esp
+        cprintf("  ss   0x----%04x\n", tf->tf_ss);
+c0102565:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102568:	0f b7 40 48          	movzwl 0x48(%eax),%eax
+c010256c:	0f b7 c0             	movzwl %ax,%eax
+c010256f:	83 ec 08             	sub    $0x8,%esp
+c0102572:	50                   	push   %eax
+c0102573:	68 be be 10 c0       	push   $0xc010bebe
+c0102578:	e8 12 dd ff ff       	call   c010028f <cprintf>
+c010257d:	83 c4 10             	add    $0x10,%esp
+    }
+}
+c0102580:	90                   	nop
+c0102581:	c9                   	leave  
+c0102582:	c3                   	ret    
+
+c0102583 <print_regs>:
+
+void
+print_regs(struct pushregs *regs) {
+c0102583:	55                   	push   %ebp
+c0102584:	89 e5                	mov    %esp,%ebp
+c0102586:	83 ec 08             	sub    $0x8,%esp
+    cprintf("  edi  0x%08x\n", regs->reg_edi);
+c0102589:	8b 45 08             	mov    0x8(%ebp),%eax
+c010258c:	8b 00                	mov    (%eax),%eax
+c010258e:	83 ec 08             	sub    $0x8,%esp
+c0102591:	50                   	push   %eax
+c0102592:	68 d1 be 10 c0       	push   $0xc010bed1
+c0102597:	e8 f3 dc ff ff       	call   c010028f <cprintf>
+c010259c:	83 c4 10             	add    $0x10,%esp
+    cprintf("  esi  0x%08x\n", regs->reg_esi);
+c010259f:	8b 45 08             	mov    0x8(%ebp),%eax
+c01025a2:	8b 40 04             	mov    0x4(%eax),%eax
+c01025a5:	83 ec 08             	sub    $0x8,%esp
+c01025a8:	50                   	push   %eax
+c01025a9:	68 e0 be 10 c0       	push   $0xc010bee0
+c01025ae:	e8 dc dc ff ff       	call   c010028f <cprintf>
+c01025b3:	83 c4 10             	add    $0x10,%esp
+    cprintf("  ebp  0x%08x\n", regs->reg_ebp);
+c01025b6:	8b 45 08             	mov    0x8(%ebp),%eax
+c01025b9:	8b 40 08             	mov    0x8(%eax),%eax
+c01025bc:	83 ec 08             	sub    $0x8,%esp
+c01025bf:	50                   	push   %eax
+c01025c0:	68 ef be 10 c0       	push   $0xc010beef
+c01025c5:	e8 c5 dc ff ff       	call   c010028f <cprintf>
+c01025ca:	83 c4 10             	add    $0x10,%esp
+    cprintf("  oesp 0x%08x\n", regs->reg_oesp);
+c01025cd:	8b 45 08             	mov    0x8(%ebp),%eax
+c01025d0:	8b 40 0c             	mov    0xc(%eax),%eax
+c01025d3:	83 ec 08             	sub    $0x8,%esp
+c01025d6:	50                   	push   %eax
+c01025d7:	68 fe be 10 c0       	push   $0xc010befe
+c01025dc:	e8 ae dc ff ff       	call   c010028f <cprintf>
+c01025e1:	83 c4 10             	add    $0x10,%esp
+    cprintf("  ebx  0x%08x\n", regs->reg_ebx);
+c01025e4:	8b 45 08             	mov    0x8(%ebp),%eax
+c01025e7:	8b 40 10             	mov    0x10(%eax),%eax
+c01025ea:	83 ec 08             	sub    $0x8,%esp
+c01025ed:	50                   	push   %eax
+c01025ee:	68 0d bf 10 c0       	push   $0xc010bf0d
+c01025f3:	e8 97 dc ff ff       	call   c010028f <cprintf>
+c01025f8:	83 c4 10             	add    $0x10,%esp
+    cprintf("  edx  0x%08x\n", regs->reg_edx);
+c01025fb:	8b 45 08             	mov    0x8(%ebp),%eax
+c01025fe:	8b 40 14             	mov    0x14(%eax),%eax
+c0102601:	83 ec 08             	sub    $0x8,%esp
+c0102604:	50                   	push   %eax
+c0102605:	68 1c bf 10 c0       	push   $0xc010bf1c
+c010260a:	e8 80 dc ff ff       	call   c010028f <cprintf>
+c010260f:	83 c4 10             	add    $0x10,%esp
+    cprintf("  ecx  0x%08x\n", regs->reg_ecx);
+c0102612:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102615:	8b 40 18             	mov    0x18(%eax),%eax
+c0102618:	83 ec 08             	sub    $0x8,%esp
+c010261b:	50                   	push   %eax
+c010261c:	68 2b bf 10 c0       	push   $0xc010bf2b
+c0102621:	e8 69 dc ff ff       	call   c010028f <cprintf>
+c0102626:	83 c4 10             	add    $0x10,%esp
+    cprintf("  eax  0x%08x\n", regs->reg_eax);
+c0102629:	8b 45 08             	mov    0x8(%ebp),%eax
+c010262c:	8b 40 1c             	mov    0x1c(%eax),%eax
+c010262f:	83 ec 08             	sub    $0x8,%esp
+c0102632:	50                   	push   %eax
+c0102633:	68 3a bf 10 c0       	push   $0xc010bf3a
+c0102638:	e8 52 dc ff ff       	call   c010028f <cprintf>
+c010263d:	83 c4 10             	add    $0x10,%esp
+}
+c0102640:	90                   	nop
+c0102641:	c9                   	leave  
+c0102642:	c3                   	ret    
+
+c0102643 <print_pgfault>:
+
+static inline void
+print_pgfault(struct trapframe *tf) {
+c0102643:	55                   	push   %ebp
+c0102644:	89 e5                	mov    %esp,%ebp
+c0102646:	53                   	push   %ebx
+c0102647:	83 ec 14             	sub    $0x14,%esp
+     * bit 2 == 0 means kernel, 1 means user
+     * */
+    cprintf("page fault at 0x%08x: %c/%c [%s].\n", rcr2(),
+            (tf->tf_err & 4) ? 'U' : 'K',
+            (tf->tf_err & 2) ? 'W' : 'R',
+            (tf->tf_err & 1) ? "protection fault" : "no page found");
+c010264a:	8b 45 08             	mov    0x8(%ebp),%eax
+c010264d:	8b 40 34             	mov    0x34(%eax),%eax
+c0102650:	83 e0 01             	and    $0x1,%eax
+    /* error_code:
+     * bit 0 == 0 means no page found, 1 means protection fault
+     * bit 1 == 0 means read, 1 means write
+     * bit 2 == 0 means kernel, 1 means user
+     * */
+    cprintf("page fault at 0x%08x: %c/%c [%s].\n", rcr2(),
+c0102653:	85 c0                	test   %eax,%eax
+c0102655:	74 07                	je     c010265e <print_pgfault+0x1b>
+c0102657:	bb 49 bf 10 c0       	mov    $0xc010bf49,%ebx
+c010265c:	eb 05                	jmp    c0102663 <print_pgfault+0x20>
+c010265e:	bb 5a bf 10 c0       	mov    $0xc010bf5a,%ebx
+            (tf->tf_err & 4) ? 'U' : 'K',
+            (tf->tf_err & 2) ? 'W' : 'R',
+c0102663:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102666:	8b 40 34             	mov    0x34(%eax),%eax
+c0102669:	83 e0 02             	and    $0x2,%eax
+    /* error_code:
+     * bit 0 == 0 means no page found, 1 means protection fault
+     * bit 1 == 0 means read, 1 means write
+     * bit 2 == 0 means kernel, 1 means user
+     * */
+    cprintf("page fault at 0x%08x: %c/%c [%s].\n", rcr2(),
+c010266c:	85 c0                	test   %eax,%eax
+c010266e:	74 07                	je     c0102677 <print_pgfault+0x34>
+c0102670:	b9 57 00 00 00       	mov    $0x57,%ecx
+c0102675:	eb 05                	jmp    c010267c <print_pgfault+0x39>
+c0102677:	b9 52 00 00 00       	mov    $0x52,%ecx
+            (tf->tf_err & 4) ? 'U' : 'K',
+c010267c:	8b 45 08             	mov    0x8(%ebp),%eax
+c010267f:	8b 40 34             	mov    0x34(%eax),%eax
+c0102682:	83 e0 04             	and    $0x4,%eax
+    /* error_code:
+     * bit 0 == 0 means no page found, 1 means protection fault
+     * bit 1 == 0 means read, 1 means write
+     * bit 2 == 0 means kernel, 1 means user
+     * */
+    cprintf("page fault at 0x%08x: %c/%c [%s].\n", rcr2(),
+c0102685:	85 c0                	test   %eax,%eax
+c0102687:	74 07                	je     c0102690 <print_pgfault+0x4d>
+c0102689:	ba 55 00 00 00       	mov    $0x55,%edx
+c010268e:	eb 05                	jmp    c0102695 <print_pgfault+0x52>
+c0102690:	ba 4b 00 00 00       	mov    $0x4b,%edx
+}
+
+static inline uintptr_t
+rcr2(void) {
+    uintptr_t cr2;
+    asm volatile ("mov %%cr2, %0" : "=r" (cr2) :: "memory");
+c0102695:	0f 20 d0             	mov    %cr2,%eax
+c0102698:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    return cr2;
+c010269b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010269e:	83 ec 0c             	sub    $0xc,%esp
+c01026a1:	53                   	push   %ebx
+c01026a2:	51                   	push   %ecx
+c01026a3:	52                   	push   %edx
+c01026a4:	50                   	push   %eax
+c01026a5:	68 68 bf 10 c0       	push   $0xc010bf68
+c01026aa:	e8 e0 db ff ff       	call   c010028f <cprintf>
+c01026af:	83 c4 20             	add    $0x20,%esp
+            (tf->tf_err & 4) ? 'U' : 'K',
+            (tf->tf_err & 2) ? 'W' : 'R',
+            (tf->tf_err & 1) ? "protection fault" : "no page found");
+}
+c01026b2:	90                   	nop
+c01026b3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+c01026b6:	c9                   	leave  
+c01026b7:	c3                   	ret    
+
+c01026b8 <pgfault_handler>:
+
+static int
+pgfault_handler(struct trapframe *tf) {
+c01026b8:	55                   	push   %ebp
+c01026b9:	89 e5                	mov    %esp,%ebp
+c01026bb:	83 ec 18             	sub    $0x18,%esp
+    extern struct mm_struct *check_mm_struct;
+    if(check_mm_struct !=NULL) { //used for test check_swap
+c01026be:	a1 90 30 1b c0       	mov    0xc01b3090,%eax
+c01026c3:	85 c0                	test   %eax,%eax
+c01026c5:	74 0e                	je     c01026d5 <pgfault_handler+0x1d>
+            print_pgfault(tf);
+c01026c7:	83 ec 0c             	sub    $0xc,%esp
+c01026ca:	ff 75 08             	pushl  0x8(%ebp)
+c01026cd:	e8 71 ff ff ff       	call   c0102643 <print_pgfault>
+c01026d2:	83 c4 10             	add    $0x10,%esp
+        }
+    struct mm_struct *mm;
+    if (check_mm_struct != NULL) {
+c01026d5:	a1 90 30 1b c0       	mov    0xc01b3090,%eax
+c01026da:	85 c0                	test   %eax,%eax
+c01026dc:	74 32                	je     c0102710 <pgfault_handler+0x58>
+        assert(current == idleproc);
+c01026de:	8b 15 28 10 1b c0    	mov    0xc01b1028,%edx
+c01026e4:	a1 20 10 1b c0       	mov    0xc01b1020,%eax
+c01026e9:	39 c2                	cmp    %eax,%edx
+c01026eb:	74 19                	je     c0102706 <pgfault_handler+0x4e>
+c01026ed:	68 8b bf 10 c0       	push   $0xc010bf8b
+c01026f2:	68 9f bf 10 c0       	push   $0xc010bf9f
+c01026f7:	68 b2 00 00 00       	push   $0xb2
+c01026fc:	68 8e bd 10 c0       	push   $0xc010bd8e
+c0102701:	e8 ef dc ff ff       	call   c01003f5 <__panic>
+        mm = check_mm_struct;
+c0102706:	a1 90 30 1b c0       	mov    0xc01b3090,%eax
+c010270b:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c010270e:	eb 47                	jmp    c0102757 <pgfault_handler+0x9f>
+    }
+    else {
+        if (current == NULL) {
+c0102710:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c0102715:	85 c0                	test   %eax,%eax
+c0102717:	75 33                	jne    c010274c <pgfault_handler+0x94>
+            print_trapframe(tf);
+c0102719:	83 ec 0c             	sub    $0xc,%esp
+c010271c:	ff 75 08             	pushl  0x8(%ebp)
+c010271f:	e8 82 fc ff ff       	call   c01023a6 <print_trapframe>
+c0102724:	83 c4 10             	add    $0x10,%esp
+            print_pgfault(tf);
+c0102727:	83 ec 0c             	sub    $0xc,%esp
+c010272a:	ff 75 08             	pushl  0x8(%ebp)
+c010272d:	e8 11 ff ff ff       	call   c0102643 <print_pgfault>
+c0102732:	83 c4 10             	add    $0x10,%esp
+            panic("unhandled page fault.\n");
+c0102735:	83 ec 04             	sub    $0x4,%esp
+c0102738:	68 b4 bf 10 c0       	push   $0xc010bfb4
+c010273d:	68 b9 00 00 00       	push   $0xb9
+c0102742:	68 8e bd 10 c0       	push   $0xc010bd8e
+c0102747:	e8 a9 dc ff ff       	call   c01003f5 <__panic>
+        }
+        mm = current->mm;
+c010274c:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c0102751:	8b 40 18             	mov    0x18(%eax),%eax
+c0102754:	89 45 f4             	mov    %eax,-0xc(%ebp)
+}
+
+static inline uintptr_t
+rcr2(void) {
+    uintptr_t cr2;
+    asm volatile ("mov %%cr2, %0" : "=r" (cr2) :: "memory");
+c0102757:	0f 20 d0             	mov    %cr2,%eax
+c010275a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    return cr2;
+c010275d:	8b 55 f0             	mov    -0x10(%ebp),%edx
+    }
+    return do_pgfault(mm, tf->tf_err, rcr2());
+c0102760:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102763:	8b 40 34             	mov    0x34(%eax),%eax
+c0102766:	83 ec 04             	sub    $0x4,%esp
+c0102769:	52                   	push   %edx
+c010276a:	50                   	push   %eax
+c010276b:	ff 75 f4             	pushl  -0xc(%ebp)
+c010276e:	e8 2d 3b 00 00       	call   c01062a0 <do_pgfault>
+c0102773:	83 c4 10             	add    $0x10,%esp
+}
+c0102776:	c9                   	leave  
+c0102777:	c3                   	ret    
+
+c0102778 <trap_dispatch>:
+
+static volatile int in_swap_tick_event = 0;
+extern struct mm_struct *check_mm_struct;
+
+static void
+trap_dispatch(struct trapframe *tf) {
+c0102778:	55                   	push   %ebp
+c0102779:	89 e5                	mov    %esp,%ebp
+c010277b:	83 ec 18             	sub    $0x18,%esp
+    char c;
+
+    int ret=0;
+c010277e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+
+    switch (tf->tf_trapno) {
+c0102785:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102788:	8b 40 30             	mov    0x30(%eax),%eax
+c010278b:	83 f8 2f             	cmp    $0x2f,%eax
+c010278e:	77 38                	ja     c01027c8 <trap_dispatch+0x50>
+c0102790:	83 f8 2e             	cmp    $0x2e,%eax
+c0102793:	0f 83 e6 01 00 00    	jae    c010297f <trap_dispatch+0x207>
+c0102799:	83 f8 20             	cmp    $0x20,%eax
+c010279c:	0f 84 eb 00 00 00    	je     c010288d <trap_dispatch+0x115>
+c01027a2:	83 f8 20             	cmp    $0x20,%eax
+c01027a5:	77 0a                	ja     c01027b1 <trap_dispatch+0x39>
+c01027a7:	83 f8 0e             	cmp    $0xe,%eax
+c01027aa:	74 3e                	je     c01027ea <trap_dispatch+0x72>
+c01027ac:	e9 83 01 00 00       	jmp    c0102934 <trap_dispatch+0x1bc>
+c01027b1:	83 f8 21             	cmp    $0x21,%eax
+c01027b4:	0f 84 3f 01 00 00    	je     c01028f9 <trap_dispatch+0x181>
+c01027ba:	83 f8 24             	cmp    $0x24,%eax
+c01027bd:	0f 84 0f 01 00 00    	je     c01028d2 <trap_dispatch+0x15a>
+c01027c3:	e9 6c 01 00 00       	jmp    c0102934 <trap_dispatch+0x1bc>
+c01027c8:	83 f8 78             	cmp    $0x78,%eax
+c01027cb:	0f 82 63 01 00 00    	jb     c0102934 <trap_dispatch+0x1bc>
+c01027d1:	83 f8 79             	cmp    $0x79,%eax
+c01027d4:	0f 86 43 01 00 00    	jbe    c010291d <trap_dispatch+0x1a5>
+c01027da:	3d 80 00 00 00       	cmp    $0x80,%eax
+c01027df:	0f 84 9e 00 00 00    	je     c0102883 <trap_dispatch+0x10b>
+c01027e5:	e9 4a 01 00 00       	jmp    c0102934 <trap_dispatch+0x1bc>
+    case T_PGFLT:  //page fault
+        if ((ret = pgfault_handler(tf)) != 0) {
+c01027ea:	83 ec 0c             	sub    $0xc,%esp
+c01027ed:	ff 75 08             	pushl  0x8(%ebp)
+c01027f0:	e8 c3 fe ff ff       	call   c01026b8 <pgfault_handler>
+c01027f5:	83 c4 10             	add    $0x10,%esp
+c01027f8:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c01027fb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c01027ff:	0f 84 7d 01 00 00    	je     c0102982 <trap_dispatch+0x20a>
+            print_trapframe(tf);
+c0102805:	83 ec 0c             	sub    $0xc,%esp
+c0102808:	ff 75 08             	pushl  0x8(%ebp)
+c010280b:	e8 96 fb ff ff       	call   c01023a6 <print_trapframe>
+c0102810:	83 c4 10             	add    $0x10,%esp
+            if (current == NULL) {
+c0102813:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c0102818:	85 c0                	test   %eax,%eax
+c010281a:	75 17                	jne    c0102833 <trap_dispatch+0xbb>
+                panic("handle pgfault failed. ret=%d\n", ret);
+c010281c:	ff 75 f4             	pushl  -0xc(%ebp)
+c010281f:	68 cc bf 10 c0       	push   $0xc010bfcc
+c0102824:	68 ce 00 00 00       	push   $0xce
+c0102829:	68 8e bd 10 c0       	push   $0xc010bd8e
+c010282e:	e8 c2 db ff ff       	call   c01003f5 <__panic>
+            }
+            else {
+                if (trap_in_kernel(tf)) {
+c0102833:	83 ec 0c             	sub    $0xc,%esp
+c0102836:	ff 75 08             	pushl  0x8(%ebp)
+c0102839:	e8 52 fb ff ff       	call   c0102390 <trap_in_kernel>
+c010283e:	83 c4 10             	add    $0x10,%esp
+c0102841:	85 c0                	test   %eax,%eax
+c0102843:	74 17                	je     c010285c <trap_dispatch+0xe4>
+                    panic("handle pgfault failed in kernel mode. ret=%d\n", ret);
+c0102845:	ff 75 f4             	pushl  -0xc(%ebp)
+c0102848:	68 ec bf 10 c0       	push   $0xc010bfec
+c010284d:	68 d2 00 00 00       	push   $0xd2
+c0102852:	68 8e bd 10 c0       	push   $0xc010bd8e
+c0102857:	e8 99 db ff ff       	call   c01003f5 <__panic>
+                }
+                cprintf("killed by kernel.\n");
+c010285c:	83 ec 0c             	sub    $0xc,%esp
+c010285f:	68 1a c0 10 c0       	push   $0xc010c01a
+c0102864:	e8 26 da ff ff       	call   c010028f <cprintf>
+c0102869:	83 c4 10             	add    $0x10,%esp
+                panic("handle user mode pgfault failed. ret=%d\n", ret); 
+c010286c:	ff 75 f4             	pushl  -0xc(%ebp)
+c010286f:	68 30 c0 10 c0       	push   $0xc010c030
+c0102874:	68 d5 00 00 00       	push   $0xd5
+c0102879:	68 8e bd 10 c0       	push   $0xc010bd8e
+c010287e:	e8 72 db ff ff       	call   c01003f5 <__panic>
+                do_exit(-E_KILLED);
+            }
+        }
+        break;
+    case T_SYSCALL:
+        syscall();
+c0102883:	e8 e2 83 00 00       	call   c010ac6a <syscall>
+        break;
+c0102888:	e9 f6 00 00 00       	jmp    c0102983 <trap_dispatch+0x20b>
+        /* handle the timer interrupt */
+        /* (1) After a timer interrupt, you should record this event using a global variable (increase it), such as ticks in kern/driver/clock.c
+         * (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks().
+         * (3) Too Simple? Yes, I think so!
+         */
+           assert(current != NULL);
+c010288d:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c0102892:	85 c0                	test   %eax,%eax
+c0102894:	75 19                	jne    c01028af <trap_dispatch+0x137>
+c0102896:	68 59 c0 10 c0       	push   $0xc010c059
+c010289b:	68 9f bf 10 c0       	push   $0xc010bf9f
+c01028a0:	68 e8 00 00 00       	push   $0xe8
+c01028a5:	68 8e bd 10 c0       	push   $0xc010bd8e
+c01028aa:	e8 46 db ff ff       	call   c01003f5 <__panic>
+           ticks++;
+c01028af:	a1 78 30 1b c0       	mov    0xc01b3078,%eax
+c01028b4:	83 c0 01             	add    $0x1,%eax
+c01028b7:	a3 78 30 1b c0       	mov    %eax,0xc01b3078
+           sched_class_proc_tick(current);
+c01028bc:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c01028c1:	83 ec 0c             	sub    $0xc,%esp
+c01028c4:	50                   	push   %eax
+c01028c5:	e8 39 7b 00 00       	call   c010a403 <sched_class_proc_tick>
+c01028ca:	83 c4 10             	add    $0x10,%esp
+        /* LAB6 YOUR CODE */
+        /* you should upate you lab5 code
+         * IMPORTANT FUNCTIONS:
+	     * sched_class_proc_tick
+         */
+        break;
+c01028cd:	e9 b1 00 00 00       	jmp    c0102983 <trap_dispatch+0x20b>
+    case IRQ_OFFSET + IRQ_COM1:
+        c = cons_getc();
+c01028d2:	e8 9a f6 ff ff       	call   c0101f71 <cons_getc>
+c01028d7:	88 45 f3             	mov    %al,-0xd(%ebp)
+        cprintf("serial [%03d] %c\n", c, c);
+c01028da:	0f be 55 f3          	movsbl -0xd(%ebp),%edx
+c01028de:	0f be 45 f3          	movsbl -0xd(%ebp),%eax
+c01028e2:	83 ec 04             	sub    $0x4,%esp
+c01028e5:	52                   	push   %edx
+c01028e6:	50                   	push   %eax
+c01028e7:	68 69 c0 10 c0       	push   $0xc010c069
+c01028ec:	e8 9e d9 ff ff       	call   c010028f <cprintf>
+c01028f1:	83 c4 10             	add    $0x10,%esp
+        break;
+c01028f4:	e9 8a 00 00 00       	jmp    c0102983 <trap_dispatch+0x20b>
+    case IRQ_OFFSET + IRQ_KBD:
+        c = cons_getc();
+c01028f9:	e8 73 f6 ff ff       	call   c0101f71 <cons_getc>
+c01028fe:	88 45 f3             	mov    %al,-0xd(%ebp)
+        cprintf("kbd [%03d] %c\n", c, c);
+c0102901:	0f be 55 f3          	movsbl -0xd(%ebp),%edx
+c0102905:	0f be 45 f3          	movsbl -0xd(%ebp),%eax
+c0102909:	83 ec 04             	sub    $0x4,%esp
+c010290c:	52                   	push   %edx
+c010290d:	50                   	push   %eax
+c010290e:	68 7b c0 10 c0       	push   $0xc010c07b
+c0102913:	e8 77 d9 ff ff       	call   c010028f <cprintf>
+c0102918:	83 c4 10             	add    $0x10,%esp
+        break;
+c010291b:	eb 66                	jmp    c0102983 <trap_dispatch+0x20b>
+    //LAB1 CHALLENGE 1 : YOUR CODE you should modify below codes.
+    case T_SWITCH_TOU:
+    case T_SWITCH_TOK:
+        panic("T_SWITCH_** ??\n");
+c010291d:	83 ec 04             	sub    $0x4,%esp
+c0102920:	68 8a c0 10 c0       	push   $0xc010c08a
+c0102925:	68 06 01 00 00       	push   $0x106
+c010292a:	68 8e bd 10 c0       	push   $0xc010bd8e
+c010292f:	e8 c1 da ff ff       	call   c01003f5 <__panic>
+    case IRQ_OFFSET + IRQ_IDE1:
+    case IRQ_OFFSET + IRQ_IDE2:
+        /* do nothing */
+        break;
+    default:
+        print_trapframe(tf);
+c0102934:	83 ec 0c             	sub    $0xc,%esp
+c0102937:	ff 75 08             	pushl  0x8(%ebp)
+c010293a:	e8 67 fa ff ff       	call   c01023a6 <print_trapframe>
+c010293f:	83 c4 10             	add    $0x10,%esp
+        if (current != NULL) {
+c0102942:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c0102947:	85 c0                	test   %eax,%eax
+c0102949:	74 1d                	je     c0102968 <trap_dispatch+0x1f0>
+            cprintf("unhandled trap.\n");
+c010294b:	83 ec 0c             	sub    $0xc,%esp
+c010294e:	68 9a c0 10 c0       	push   $0xc010c09a
+c0102953:	e8 37 d9 ff ff       	call   c010028f <cprintf>
+c0102958:	83 c4 10             	add    $0x10,%esp
+            do_exit(-E_KILLED);
+c010295b:	83 ec 0c             	sub    $0xc,%esp
+c010295e:	6a f7                	push   $0xfffffff7
+c0102960:	e8 5a 6b 00 00       	call   c01094bf <do_exit>
+c0102965:	83 c4 10             	add    $0x10,%esp
+        }
+        // in kernel, it must be a mistake
+        panic("unexpected trap in kernel.\n");
+c0102968:	83 ec 04             	sub    $0x4,%esp
+c010296b:	68 ab c0 10 c0       	push   $0xc010c0ab
+c0102970:	68 13 01 00 00       	push   $0x113
+c0102975:	68 8e bd 10 c0       	push   $0xc010bd8e
+c010297a:	e8 76 da ff ff       	call   c01003f5 <__panic>
+        panic("T_SWITCH_** ??\n");
+        break;
+    case IRQ_OFFSET + IRQ_IDE1:
+    case IRQ_OFFSET + IRQ_IDE2:
+        /* do nothing */
+        break;
+c010297f:	90                   	nop
+c0102980:	eb 01                	jmp    c0102983 <trap_dispatch+0x20b>
+                cprintf("killed by kernel.\n");
+                panic("handle user mode pgfault failed. ret=%d\n", ret); 
+                do_exit(-E_KILLED);
+            }
+        }
+        break;
+c0102982:	90                   	nop
+        }
+        // in kernel, it must be a mistake
+        panic("unexpected trap in kernel.\n");
+
+    }
+}
+c0102983:	90                   	nop
+c0102984:	c9                   	leave  
+c0102985:	c3                   	ret    
+
+c0102986 <trap>:
+ * trap - handles or dispatches an exception/interrupt. if and when trap() returns,
+ * the code in kern/trap/trapentry.S restores the old CPU state saved in the
+ * trapframe and then uses the iret instruction to return from the exception.
+ * */
+void
+trap(struct trapframe *tf) {
+c0102986:	55                   	push   %ebp
+c0102987:	89 e5                	mov    %esp,%ebp
+c0102989:	83 ec 18             	sub    $0x18,%esp
+    // dispatch based on what type of trap occurred
+    // used for previous projects
+    if (current == NULL) {
+c010298c:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c0102991:	85 c0                	test   %eax,%eax
+c0102993:	75 10                	jne    c01029a5 <trap+0x1f>
+        trap_dispatch(tf);
+c0102995:	83 ec 0c             	sub    $0xc,%esp
+c0102998:	ff 75 08             	pushl  0x8(%ebp)
+c010299b:	e8 d8 fd ff ff       	call   c0102778 <trap_dispatch>
+c01029a0:	83 c4 10             	add    $0x10,%esp
+            if (current->need_resched) {
+                schedule();
+            }
+        }
+    }
+}
+c01029a3:	eb 73                	jmp    c0102a18 <trap+0x92>
+    if (current == NULL) {
+        trap_dispatch(tf);
+    }
+    else {
+        // keep a trapframe chain in stack
+        struct trapframe *otf = current->tf;
+c01029a5:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c01029aa:	8b 40 3c             	mov    0x3c(%eax),%eax
+c01029ad:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        current->tf = tf;
+c01029b0:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c01029b5:	8b 55 08             	mov    0x8(%ebp),%edx
+c01029b8:	89 50 3c             	mov    %edx,0x3c(%eax)
+    
+        bool in_kernel = trap_in_kernel(tf);
+c01029bb:	83 ec 0c             	sub    $0xc,%esp
+c01029be:	ff 75 08             	pushl  0x8(%ebp)
+c01029c1:	e8 ca f9 ff ff       	call   c0102390 <trap_in_kernel>
+c01029c6:	83 c4 10             	add    $0x10,%esp
+c01029c9:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    
+        trap_dispatch(tf);
+c01029cc:	83 ec 0c             	sub    $0xc,%esp
+c01029cf:	ff 75 08             	pushl  0x8(%ebp)
+c01029d2:	e8 a1 fd ff ff       	call   c0102778 <trap_dispatch>
+c01029d7:	83 c4 10             	add    $0x10,%esp
+    
+        current->tf = otf;
+c01029da:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c01029df:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c01029e2:	89 50 3c             	mov    %edx,0x3c(%eax)
+        if (!in_kernel) {
+c01029e5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c01029e9:	75 2d                	jne    c0102a18 <trap+0x92>
+            if (current->flags & PF_EXITING) {
+c01029eb:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c01029f0:	8b 40 44             	mov    0x44(%eax),%eax
+c01029f3:	83 e0 01             	and    $0x1,%eax
+c01029f6:	85 c0                	test   %eax,%eax
+c01029f8:	74 0d                	je     c0102a07 <trap+0x81>
+                do_exit(-E_KILLED);
+c01029fa:	83 ec 0c             	sub    $0xc,%esp
+c01029fd:	6a f7                	push   $0xfffffff7
+c01029ff:	e8 bb 6a 00 00       	call   c01094bf <do_exit>
+c0102a04:	83 c4 10             	add    $0x10,%esp
+            }
+            if (current->need_resched) {
+c0102a07:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c0102a0c:	8b 40 10             	mov    0x10(%eax),%eax
+c0102a0f:	85 c0                	test   %eax,%eax
+c0102a11:	74 05                	je     c0102a18 <trap+0x92>
+                schedule();
+c0102a13:	e8 24 7b 00 00       	call   c010a53c <schedule>
+            }
+        }
+    }
+}
+c0102a18:	90                   	nop
+c0102a19:	c9                   	leave  
+c0102a1a:	c3                   	ret    
+
+c0102a1b <vector0>:
+# handler
+.text
+.globl __alltraps
+.globl vector0
+vector0:
+  pushl $0
+c0102a1b:	6a 00                	push   $0x0
+  pushl $0
+c0102a1d:	6a 00                	push   $0x0
+  jmp __alltraps
+c0102a1f:	e9 69 0a 00 00       	jmp    c010348d <__alltraps>
+
+c0102a24 <vector1>:
+.globl vector1
+vector1:
+  pushl $0
+c0102a24:	6a 00                	push   $0x0
+  pushl $1
+c0102a26:	6a 01                	push   $0x1
+  jmp __alltraps
+c0102a28:	e9 60 0a 00 00       	jmp    c010348d <__alltraps>
+
+c0102a2d <vector2>:
+.globl vector2
+vector2:
+  pushl $0
+c0102a2d:	6a 00                	push   $0x0
+  pushl $2
+c0102a2f:	6a 02                	push   $0x2
+  jmp __alltraps
+c0102a31:	e9 57 0a 00 00       	jmp    c010348d <__alltraps>
+
+c0102a36 <vector3>:
+.globl vector3
+vector3:
+  pushl $0
+c0102a36:	6a 00                	push   $0x0
+  pushl $3
+c0102a38:	6a 03                	push   $0x3
+  jmp __alltraps
+c0102a3a:	e9 4e 0a 00 00       	jmp    c010348d <__alltraps>
+
+c0102a3f <vector4>:
+.globl vector4
+vector4:
+  pushl $0
+c0102a3f:	6a 00                	push   $0x0
+  pushl $4
+c0102a41:	6a 04                	push   $0x4
+  jmp __alltraps
+c0102a43:	e9 45 0a 00 00       	jmp    c010348d <__alltraps>
+
+c0102a48 <vector5>:
+.globl vector5
+vector5:
+  pushl $0
+c0102a48:	6a 00                	push   $0x0
+  pushl $5
+c0102a4a:	6a 05                	push   $0x5
+  jmp __alltraps
+c0102a4c:	e9 3c 0a 00 00       	jmp    c010348d <__alltraps>
+
+c0102a51 <vector6>:
+.globl vector6
+vector6:
+  pushl $0
+c0102a51:	6a 00                	push   $0x0
+  pushl $6
+c0102a53:	6a 06                	push   $0x6
+  jmp __alltraps
+c0102a55:	e9 33 0a 00 00       	jmp    c010348d <__alltraps>
+
+c0102a5a <vector7>:
+.globl vector7
+vector7:
+  pushl $0
+c0102a5a:	6a 00                	push   $0x0
+  pushl $7
+c0102a5c:	6a 07                	push   $0x7
+  jmp __alltraps
+c0102a5e:	e9 2a 0a 00 00       	jmp    c010348d <__alltraps>
+
+c0102a63 <vector8>:
+.globl vector8
+vector8:
+  pushl $8
+c0102a63:	6a 08                	push   $0x8
+  jmp __alltraps
+c0102a65:	e9 23 0a 00 00       	jmp    c010348d <__alltraps>
+
+c0102a6a <vector9>:
+.globl vector9
+vector9:
+  pushl $0
+c0102a6a:	6a 00                	push   $0x0
+  pushl $9
+c0102a6c:	6a 09                	push   $0x9
+  jmp __alltraps
+c0102a6e:	e9 1a 0a 00 00       	jmp    c010348d <__alltraps>
+
+c0102a73 <vector10>:
+.globl vector10
+vector10:
+  pushl $10
+c0102a73:	6a 0a                	push   $0xa
+  jmp __alltraps
+c0102a75:	e9 13 0a 00 00       	jmp    c010348d <__alltraps>
+
+c0102a7a <vector11>:
+.globl vector11
+vector11:
+  pushl $11
+c0102a7a:	6a 0b                	push   $0xb
+  jmp __alltraps
+c0102a7c:	e9 0c 0a 00 00       	jmp    c010348d <__alltraps>
+
+c0102a81 <vector12>:
+.globl vector12
+vector12:
+  pushl $12
+c0102a81:	6a 0c                	push   $0xc
+  jmp __alltraps
+c0102a83:	e9 05 0a 00 00       	jmp    c010348d <__alltraps>
+
+c0102a88 <vector13>:
+.globl vector13
+vector13:
+  pushl $13
+c0102a88:	6a 0d                	push   $0xd
+  jmp __alltraps
+c0102a8a:	e9 fe 09 00 00       	jmp    c010348d <__alltraps>
+
+c0102a8f <vector14>:
+.globl vector14
+vector14:
+  pushl $14
+c0102a8f:	6a 0e                	push   $0xe
+  jmp __alltraps
+c0102a91:	e9 f7 09 00 00       	jmp    c010348d <__alltraps>
+
+c0102a96 <vector15>:
+.globl vector15
+vector15:
+  pushl $0
+c0102a96:	6a 00                	push   $0x0
+  pushl $15
+c0102a98:	6a 0f                	push   $0xf
+  jmp __alltraps
+c0102a9a:	e9 ee 09 00 00       	jmp    c010348d <__alltraps>
+
+c0102a9f <vector16>:
+.globl vector16
+vector16:
+  pushl $0
+c0102a9f:	6a 00                	push   $0x0
+  pushl $16
+c0102aa1:	6a 10                	push   $0x10
+  jmp __alltraps
+c0102aa3:	e9 e5 09 00 00       	jmp    c010348d <__alltraps>
+
+c0102aa8 <vector17>:
+.globl vector17
+vector17:
+  pushl $17
+c0102aa8:	6a 11                	push   $0x11
+  jmp __alltraps
+c0102aaa:	e9 de 09 00 00       	jmp    c010348d <__alltraps>
+
+c0102aaf <vector18>:
+.globl vector18
+vector18:
+  pushl $0
+c0102aaf:	6a 00                	push   $0x0
+  pushl $18
+c0102ab1:	6a 12                	push   $0x12
+  jmp __alltraps
+c0102ab3:	e9 d5 09 00 00       	jmp    c010348d <__alltraps>
+
+c0102ab8 <vector19>:
+.globl vector19
+vector19:
+  pushl $0
+c0102ab8:	6a 00                	push   $0x0
+  pushl $19
+c0102aba:	6a 13                	push   $0x13
+  jmp __alltraps
+c0102abc:	e9 cc 09 00 00       	jmp    c010348d <__alltraps>
+
+c0102ac1 <vector20>:
+.globl vector20
+vector20:
+  pushl $0
+c0102ac1:	6a 00                	push   $0x0
+  pushl $20
+c0102ac3:	6a 14                	push   $0x14
+  jmp __alltraps
+c0102ac5:	e9 c3 09 00 00       	jmp    c010348d <__alltraps>
+
+c0102aca <vector21>:
+.globl vector21
+vector21:
+  pushl $0
+c0102aca:	6a 00                	push   $0x0
+  pushl $21
+c0102acc:	6a 15                	push   $0x15
+  jmp __alltraps
+c0102ace:	e9 ba 09 00 00       	jmp    c010348d <__alltraps>
+
+c0102ad3 <vector22>:
+.globl vector22
+vector22:
+  pushl $0
+c0102ad3:	6a 00                	push   $0x0
+  pushl $22
+c0102ad5:	6a 16                	push   $0x16
+  jmp __alltraps
+c0102ad7:	e9 b1 09 00 00       	jmp    c010348d <__alltraps>
+
+c0102adc <vector23>:
+.globl vector23
+vector23:
+  pushl $0
+c0102adc:	6a 00                	push   $0x0
+  pushl $23
+c0102ade:	6a 17                	push   $0x17
+  jmp __alltraps
+c0102ae0:	e9 a8 09 00 00       	jmp    c010348d <__alltraps>
+
+c0102ae5 <vector24>:
+.globl vector24
+vector24:
+  pushl $0
+c0102ae5:	6a 00                	push   $0x0
+  pushl $24
+c0102ae7:	6a 18                	push   $0x18
+  jmp __alltraps
+c0102ae9:	e9 9f 09 00 00       	jmp    c010348d <__alltraps>
+
+c0102aee <vector25>:
+.globl vector25
+vector25:
+  pushl $0
+c0102aee:	6a 00                	push   $0x0
+  pushl $25
+c0102af0:	6a 19                	push   $0x19
+  jmp __alltraps
+c0102af2:	e9 96 09 00 00       	jmp    c010348d <__alltraps>
+
+c0102af7 <vector26>:
+.globl vector26
+vector26:
+  pushl $0
+c0102af7:	6a 00                	push   $0x0
+  pushl $26
+c0102af9:	6a 1a                	push   $0x1a
+  jmp __alltraps
+c0102afb:	e9 8d 09 00 00       	jmp    c010348d <__alltraps>
+
+c0102b00 <vector27>:
+.globl vector27
+vector27:
+  pushl $0
+c0102b00:	6a 00                	push   $0x0
+  pushl $27
+c0102b02:	6a 1b                	push   $0x1b
+  jmp __alltraps
+c0102b04:	e9 84 09 00 00       	jmp    c010348d <__alltraps>
+
+c0102b09 <vector28>:
+.globl vector28
+vector28:
+  pushl $0
+c0102b09:	6a 00                	push   $0x0
+  pushl $28
+c0102b0b:	6a 1c                	push   $0x1c
+  jmp __alltraps
+c0102b0d:	e9 7b 09 00 00       	jmp    c010348d <__alltraps>
+
+c0102b12 <vector29>:
+.globl vector29
+vector29:
+  pushl $0
+c0102b12:	6a 00                	push   $0x0
+  pushl $29
+c0102b14:	6a 1d                	push   $0x1d
+  jmp __alltraps
+c0102b16:	e9 72 09 00 00       	jmp    c010348d <__alltraps>
+
+c0102b1b <vector30>:
+.globl vector30
+vector30:
+  pushl $0
+c0102b1b:	6a 00                	push   $0x0
+  pushl $30
+c0102b1d:	6a 1e                	push   $0x1e
+  jmp __alltraps
+c0102b1f:	e9 69 09 00 00       	jmp    c010348d <__alltraps>
+
+c0102b24 <vector31>:
+.globl vector31
+vector31:
+  pushl $0
+c0102b24:	6a 00                	push   $0x0
+  pushl $31
+c0102b26:	6a 1f                	push   $0x1f
+  jmp __alltraps
+c0102b28:	e9 60 09 00 00       	jmp    c010348d <__alltraps>
+
+c0102b2d <vector32>:
+.globl vector32
+vector32:
+  pushl $0
+c0102b2d:	6a 00                	push   $0x0
+  pushl $32
+c0102b2f:	6a 20                	push   $0x20
+  jmp __alltraps
+c0102b31:	e9 57 09 00 00       	jmp    c010348d <__alltraps>
+
+c0102b36 <vector33>:
+.globl vector33
+vector33:
+  pushl $0
+c0102b36:	6a 00                	push   $0x0
+  pushl $33
+c0102b38:	6a 21                	push   $0x21
+  jmp __alltraps
+c0102b3a:	e9 4e 09 00 00       	jmp    c010348d <__alltraps>
+
+c0102b3f <vector34>:
+.globl vector34
+vector34:
+  pushl $0
+c0102b3f:	6a 00                	push   $0x0
+  pushl $34
+c0102b41:	6a 22                	push   $0x22
+  jmp __alltraps
+c0102b43:	e9 45 09 00 00       	jmp    c010348d <__alltraps>
+
+c0102b48 <vector35>:
+.globl vector35
+vector35:
+  pushl $0
+c0102b48:	6a 00                	push   $0x0
+  pushl $35
+c0102b4a:	6a 23                	push   $0x23
+  jmp __alltraps
+c0102b4c:	e9 3c 09 00 00       	jmp    c010348d <__alltraps>
+
+c0102b51 <vector36>:
+.globl vector36
+vector36:
+  pushl $0
+c0102b51:	6a 00                	push   $0x0
+  pushl $36
+c0102b53:	6a 24                	push   $0x24
+  jmp __alltraps
+c0102b55:	e9 33 09 00 00       	jmp    c010348d <__alltraps>
+
+c0102b5a <vector37>:
+.globl vector37
+vector37:
+  pushl $0
+c0102b5a:	6a 00                	push   $0x0
+  pushl $37
+c0102b5c:	6a 25                	push   $0x25
+  jmp __alltraps
+c0102b5e:	e9 2a 09 00 00       	jmp    c010348d <__alltraps>
+
+c0102b63 <vector38>:
+.globl vector38
+vector38:
+  pushl $0
+c0102b63:	6a 00                	push   $0x0
+  pushl $38
+c0102b65:	6a 26                	push   $0x26
+  jmp __alltraps
+c0102b67:	e9 21 09 00 00       	jmp    c010348d <__alltraps>
+
+c0102b6c <vector39>:
+.globl vector39
+vector39:
+  pushl $0
+c0102b6c:	6a 00                	push   $0x0
+  pushl $39
+c0102b6e:	6a 27                	push   $0x27
+  jmp __alltraps
+c0102b70:	e9 18 09 00 00       	jmp    c010348d <__alltraps>
+
+c0102b75 <vector40>:
+.globl vector40
+vector40:
+  pushl $0
+c0102b75:	6a 00                	push   $0x0
+  pushl $40
+c0102b77:	6a 28                	push   $0x28
+  jmp __alltraps
+c0102b79:	e9 0f 09 00 00       	jmp    c010348d <__alltraps>
+
+c0102b7e <vector41>:
+.globl vector41
+vector41:
+  pushl $0
+c0102b7e:	6a 00                	push   $0x0
+  pushl $41
+c0102b80:	6a 29                	push   $0x29
+  jmp __alltraps
+c0102b82:	e9 06 09 00 00       	jmp    c010348d <__alltraps>
+
+c0102b87 <vector42>:
+.globl vector42
+vector42:
+  pushl $0
+c0102b87:	6a 00                	push   $0x0
+  pushl $42
+c0102b89:	6a 2a                	push   $0x2a
+  jmp __alltraps
+c0102b8b:	e9 fd 08 00 00       	jmp    c010348d <__alltraps>
+
+c0102b90 <vector43>:
+.globl vector43
+vector43:
+  pushl $0
+c0102b90:	6a 00                	push   $0x0
+  pushl $43
+c0102b92:	6a 2b                	push   $0x2b
+  jmp __alltraps
+c0102b94:	e9 f4 08 00 00       	jmp    c010348d <__alltraps>
+
+c0102b99 <vector44>:
+.globl vector44
+vector44:
+  pushl $0
+c0102b99:	6a 00                	push   $0x0
+  pushl $44
+c0102b9b:	6a 2c                	push   $0x2c
+  jmp __alltraps
+c0102b9d:	e9 eb 08 00 00       	jmp    c010348d <__alltraps>
+
+c0102ba2 <vector45>:
+.globl vector45
+vector45:
+  pushl $0
+c0102ba2:	6a 00                	push   $0x0
+  pushl $45
+c0102ba4:	6a 2d                	push   $0x2d
+  jmp __alltraps
+c0102ba6:	e9 e2 08 00 00       	jmp    c010348d <__alltraps>
+
+c0102bab <vector46>:
+.globl vector46
+vector46:
+  pushl $0
+c0102bab:	6a 00                	push   $0x0
+  pushl $46
+c0102bad:	6a 2e                	push   $0x2e
+  jmp __alltraps
+c0102baf:	e9 d9 08 00 00       	jmp    c010348d <__alltraps>
+
+c0102bb4 <vector47>:
+.globl vector47
+vector47:
+  pushl $0
+c0102bb4:	6a 00                	push   $0x0
+  pushl $47
+c0102bb6:	6a 2f                	push   $0x2f
+  jmp __alltraps
+c0102bb8:	e9 d0 08 00 00       	jmp    c010348d <__alltraps>
+
+c0102bbd <vector48>:
+.globl vector48
+vector48:
+  pushl $0
+c0102bbd:	6a 00                	push   $0x0
+  pushl $48
+c0102bbf:	6a 30                	push   $0x30
+  jmp __alltraps
+c0102bc1:	e9 c7 08 00 00       	jmp    c010348d <__alltraps>
+
+c0102bc6 <vector49>:
+.globl vector49
+vector49:
+  pushl $0
+c0102bc6:	6a 00                	push   $0x0
+  pushl $49
+c0102bc8:	6a 31                	push   $0x31
+  jmp __alltraps
+c0102bca:	e9 be 08 00 00       	jmp    c010348d <__alltraps>
+
+c0102bcf <vector50>:
+.globl vector50
+vector50:
+  pushl $0
+c0102bcf:	6a 00                	push   $0x0
+  pushl $50
+c0102bd1:	6a 32                	push   $0x32
+  jmp __alltraps
+c0102bd3:	e9 b5 08 00 00       	jmp    c010348d <__alltraps>
+
+c0102bd8 <vector51>:
+.globl vector51
+vector51:
+  pushl $0
+c0102bd8:	6a 00                	push   $0x0
+  pushl $51
+c0102bda:	6a 33                	push   $0x33
+  jmp __alltraps
+c0102bdc:	e9 ac 08 00 00       	jmp    c010348d <__alltraps>
+
+c0102be1 <vector52>:
+.globl vector52
+vector52:
+  pushl $0
+c0102be1:	6a 00                	push   $0x0
+  pushl $52
+c0102be3:	6a 34                	push   $0x34
+  jmp __alltraps
+c0102be5:	e9 a3 08 00 00       	jmp    c010348d <__alltraps>
+
+c0102bea <vector53>:
+.globl vector53
+vector53:
+  pushl $0
+c0102bea:	6a 00                	push   $0x0
+  pushl $53
+c0102bec:	6a 35                	push   $0x35
+  jmp __alltraps
+c0102bee:	e9 9a 08 00 00       	jmp    c010348d <__alltraps>
+
+c0102bf3 <vector54>:
+.globl vector54
+vector54:
+  pushl $0
+c0102bf3:	6a 00                	push   $0x0
+  pushl $54
+c0102bf5:	6a 36                	push   $0x36
+  jmp __alltraps
+c0102bf7:	e9 91 08 00 00       	jmp    c010348d <__alltraps>
+
+c0102bfc <vector55>:
+.globl vector55
+vector55:
+  pushl $0
+c0102bfc:	6a 00                	push   $0x0
+  pushl $55
+c0102bfe:	6a 37                	push   $0x37
+  jmp __alltraps
+c0102c00:	e9 88 08 00 00       	jmp    c010348d <__alltraps>
+
+c0102c05 <vector56>:
+.globl vector56
+vector56:
+  pushl $0
+c0102c05:	6a 00                	push   $0x0
+  pushl $56
+c0102c07:	6a 38                	push   $0x38
+  jmp __alltraps
+c0102c09:	e9 7f 08 00 00       	jmp    c010348d <__alltraps>
+
+c0102c0e <vector57>:
+.globl vector57
+vector57:
+  pushl $0
+c0102c0e:	6a 00                	push   $0x0
+  pushl $57
+c0102c10:	6a 39                	push   $0x39
+  jmp __alltraps
+c0102c12:	e9 76 08 00 00       	jmp    c010348d <__alltraps>
+
+c0102c17 <vector58>:
+.globl vector58
+vector58:
+  pushl $0
+c0102c17:	6a 00                	push   $0x0
+  pushl $58
+c0102c19:	6a 3a                	push   $0x3a
+  jmp __alltraps
+c0102c1b:	e9 6d 08 00 00       	jmp    c010348d <__alltraps>
+
+c0102c20 <vector59>:
+.globl vector59
+vector59:
+  pushl $0
+c0102c20:	6a 00                	push   $0x0
+  pushl $59
+c0102c22:	6a 3b                	push   $0x3b
+  jmp __alltraps
+c0102c24:	e9 64 08 00 00       	jmp    c010348d <__alltraps>
+
+c0102c29 <vector60>:
+.globl vector60
+vector60:
+  pushl $0
+c0102c29:	6a 00                	push   $0x0
+  pushl $60
+c0102c2b:	6a 3c                	push   $0x3c
+  jmp __alltraps
+c0102c2d:	e9 5b 08 00 00       	jmp    c010348d <__alltraps>
+
+c0102c32 <vector61>:
+.globl vector61
+vector61:
+  pushl $0
+c0102c32:	6a 00                	push   $0x0
+  pushl $61
+c0102c34:	6a 3d                	push   $0x3d
+  jmp __alltraps
+c0102c36:	e9 52 08 00 00       	jmp    c010348d <__alltraps>
+
+c0102c3b <vector62>:
+.globl vector62
+vector62:
+  pushl $0
+c0102c3b:	6a 00                	push   $0x0
+  pushl $62
+c0102c3d:	6a 3e                	push   $0x3e
+  jmp __alltraps
+c0102c3f:	e9 49 08 00 00       	jmp    c010348d <__alltraps>
+
+c0102c44 <vector63>:
+.globl vector63
+vector63:
+  pushl $0
+c0102c44:	6a 00                	push   $0x0
+  pushl $63
+c0102c46:	6a 3f                	push   $0x3f
+  jmp __alltraps
+c0102c48:	e9 40 08 00 00       	jmp    c010348d <__alltraps>
+
+c0102c4d <vector64>:
+.globl vector64
+vector64:
+  pushl $0
+c0102c4d:	6a 00                	push   $0x0
+  pushl $64
+c0102c4f:	6a 40                	push   $0x40
+  jmp __alltraps
+c0102c51:	e9 37 08 00 00       	jmp    c010348d <__alltraps>
+
+c0102c56 <vector65>:
+.globl vector65
+vector65:
+  pushl $0
+c0102c56:	6a 00                	push   $0x0
+  pushl $65
+c0102c58:	6a 41                	push   $0x41
+  jmp __alltraps
+c0102c5a:	e9 2e 08 00 00       	jmp    c010348d <__alltraps>
+
+c0102c5f <vector66>:
+.globl vector66
+vector66:
+  pushl $0
+c0102c5f:	6a 00                	push   $0x0
+  pushl $66
+c0102c61:	6a 42                	push   $0x42
+  jmp __alltraps
+c0102c63:	e9 25 08 00 00       	jmp    c010348d <__alltraps>
+
+c0102c68 <vector67>:
+.globl vector67
+vector67:
+  pushl $0
+c0102c68:	6a 00                	push   $0x0
+  pushl $67
+c0102c6a:	6a 43                	push   $0x43
+  jmp __alltraps
+c0102c6c:	e9 1c 08 00 00       	jmp    c010348d <__alltraps>
+
+c0102c71 <vector68>:
+.globl vector68
+vector68:
+  pushl $0
+c0102c71:	6a 00                	push   $0x0
+  pushl $68
+c0102c73:	6a 44                	push   $0x44
+  jmp __alltraps
+c0102c75:	e9 13 08 00 00       	jmp    c010348d <__alltraps>
+
+c0102c7a <vector69>:
+.globl vector69
+vector69:
+  pushl $0
+c0102c7a:	6a 00                	push   $0x0
+  pushl $69
+c0102c7c:	6a 45                	push   $0x45
+  jmp __alltraps
+c0102c7e:	e9 0a 08 00 00       	jmp    c010348d <__alltraps>
+
+c0102c83 <vector70>:
+.globl vector70
+vector70:
+  pushl $0
+c0102c83:	6a 00                	push   $0x0
+  pushl $70
+c0102c85:	6a 46                	push   $0x46
+  jmp __alltraps
+c0102c87:	e9 01 08 00 00       	jmp    c010348d <__alltraps>
+
+c0102c8c <vector71>:
+.globl vector71
+vector71:
+  pushl $0
+c0102c8c:	6a 00                	push   $0x0
+  pushl $71
+c0102c8e:	6a 47                	push   $0x47
+  jmp __alltraps
+c0102c90:	e9 f8 07 00 00       	jmp    c010348d <__alltraps>
+
+c0102c95 <vector72>:
+.globl vector72
+vector72:
+  pushl $0
+c0102c95:	6a 00                	push   $0x0
+  pushl $72
+c0102c97:	6a 48                	push   $0x48
+  jmp __alltraps
+c0102c99:	e9 ef 07 00 00       	jmp    c010348d <__alltraps>
+
+c0102c9e <vector73>:
+.globl vector73
+vector73:
+  pushl $0
+c0102c9e:	6a 00                	push   $0x0
+  pushl $73
+c0102ca0:	6a 49                	push   $0x49
+  jmp __alltraps
+c0102ca2:	e9 e6 07 00 00       	jmp    c010348d <__alltraps>
+
+c0102ca7 <vector74>:
+.globl vector74
+vector74:
+  pushl $0
+c0102ca7:	6a 00                	push   $0x0
+  pushl $74
+c0102ca9:	6a 4a                	push   $0x4a
+  jmp __alltraps
+c0102cab:	e9 dd 07 00 00       	jmp    c010348d <__alltraps>
+
+c0102cb0 <vector75>:
+.globl vector75
+vector75:
+  pushl $0
+c0102cb0:	6a 00                	push   $0x0
+  pushl $75
+c0102cb2:	6a 4b                	push   $0x4b
+  jmp __alltraps
+c0102cb4:	e9 d4 07 00 00       	jmp    c010348d <__alltraps>
+
+c0102cb9 <vector76>:
+.globl vector76
+vector76:
+  pushl $0
+c0102cb9:	6a 00                	push   $0x0
+  pushl $76
+c0102cbb:	6a 4c                	push   $0x4c
+  jmp __alltraps
+c0102cbd:	e9 cb 07 00 00       	jmp    c010348d <__alltraps>
+
+c0102cc2 <vector77>:
+.globl vector77
+vector77:
+  pushl $0
+c0102cc2:	6a 00                	push   $0x0
+  pushl $77
+c0102cc4:	6a 4d                	push   $0x4d
+  jmp __alltraps
+c0102cc6:	e9 c2 07 00 00       	jmp    c010348d <__alltraps>
+
+c0102ccb <vector78>:
+.globl vector78
+vector78:
+  pushl $0
+c0102ccb:	6a 00                	push   $0x0
+  pushl $78
+c0102ccd:	6a 4e                	push   $0x4e
+  jmp __alltraps
+c0102ccf:	e9 b9 07 00 00       	jmp    c010348d <__alltraps>
+
+c0102cd4 <vector79>:
+.globl vector79
+vector79:
+  pushl $0
+c0102cd4:	6a 00                	push   $0x0
+  pushl $79
+c0102cd6:	6a 4f                	push   $0x4f
+  jmp __alltraps
+c0102cd8:	e9 b0 07 00 00       	jmp    c010348d <__alltraps>
+
+c0102cdd <vector80>:
+.globl vector80
+vector80:
+  pushl $0
+c0102cdd:	6a 00                	push   $0x0
+  pushl $80
+c0102cdf:	6a 50                	push   $0x50
+  jmp __alltraps
+c0102ce1:	e9 a7 07 00 00       	jmp    c010348d <__alltraps>
+
+c0102ce6 <vector81>:
+.globl vector81
+vector81:
+  pushl $0
+c0102ce6:	6a 00                	push   $0x0
+  pushl $81
+c0102ce8:	6a 51                	push   $0x51
+  jmp __alltraps
+c0102cea:	e9 9e 07 00 00       	jmp    c010348d <__alltraps>
+
+c0102cef <vector82>:
+.globl vector82
+vector82:
+  pushl $0
+c0102cef:	6a 00                	push   $0x0
+  pushl $82
+c0102cf1:	6a 52                	push   $0x52
+  jmp __alltraps
+c0102cf3:	e9 95 07 00 00       	jmp    c010348d <__alltraps>
+
+c0102cf8 <vector83>:
+.globl vector83
+vector83:
+  pushl $0
+c0102cf8:	6a 00                	push   $0x0
+  pushl $83
+c0102cfa:	6a 53                	push   $0x53
+  jmp __alltraps
+c0102cfc:	e9 8c 07 00 00       	jmp    c010348d <__alltraps>
+
+c0102d01 <vector84>:
+.globl vector84
+vector84:
+  pushl $0
+c0102d01:	6a 00                	push   $0x0
+  pushl $84
+c0102d03:	6a 54                	push   $0x54
+  jmp __alltraps
+c0102d05:	e9 83 07 00 00       	jmp    c010348d <__alltraps>
+
+c0102d0a <vector85>:
+.globl vector85
+vector85:
+  pushl $0
+c0102d0a:	6a 00                	push   $0x0
+  pushl $85
+c0102d0c:	6a 55                	push   $0x55
+  jmp __alltraps
+c0102d0e:	e9 7a 07 00 00       	jmp    c010348d <__alltraps>
+
+c0102d13 <vector86>:
+.globl vector86
+vector86:
+  pushl $0
+c0102d13:	6a 00                	push   $0x0
+  pushl $86
+c0102d15:	6a 56                	push   $0x56
+  jmp __alltraps
+c0102d17:	e9 71 07 00 00       	jmp    c010348d <__alltraps>
+
+c0102d1c <vector87>:
+.globl vector87
+vector87:
+  pushl $0
+c0102d1c:	6a 00                	push   $0x0
+  pushl $87
+c0102d1e:	6a 57                	push   $0x57
+  jmp __alltraps
+c0102d20:	e9 68 07 00 00       	jmp    c010348d <__alltraps>
+
+c0102d25 <vector88>:
+.globl vector88
+vector88:
+  pushl $0
+c0102d25:	6a 00                	push   $0x0
+  pushl $88
+c0102d27:	6a 58                	push   $0x58
+  jmp __alltraps
+c0102d29:	e9 5f 07 00 00       	jmp    c010348d <__alltraps>
+
+c0102d2e <vector89>:
+.globl vector89
+vector89:
+  pushl $0
+c0102d2e:	6a 00                	push   $0x0
+  pushl $89
+c0102d30:	6a 59                	push   $0x59
+  jmp __alltraps
+c0102d32:	e9 56 07 00 00       	jmp    c010348d <__alltraps>
+
+c0102d37 <vector90>:
+.globl vector90
+vector90:
+  pushl $0
+c0102d37:	6a 00                	push   $0x0
+  pushl $90
+c0102d39:	6a 5a                	push   $0x5a
+  jmp __alltraps
+c0102d3b:	e9 4d 07 00 00       	jmp    c010348d <__alltraps>
+
+c0102d40 <vector91>:
+.globl vector91
+vector91:
+  pushl $0
+c0102d40:	6a 00                	push   $0x0
+  pushl $91
+c0102d42:	6a 5b                	push   $0x5b
+  jmp __alltraps
+c0102d44:	e9 44 07 00 00       	jmp    c010348d <__alltraps>
+
+c0102d49 <vector92>:
+.globl vector92
+vector92:
+  pushl $0
+c0102d49:	6a 00                	push   $0x0
+  pushl $92
+c0102d4b:	6a 5c                	push   $0x5c
+  jmp __alltraps
+c0102d4d:	e9 3b 07 00 00       	jmp    c010348d <__alltraps>
+
+c0102d52 <vector93>:
+.globl vector93
+vector93:
+  pushl $0
+c0102d52:	6a 00                	push   $0x0
+  pushl $93
+c0102d54:	6a 5d                	push   $0x5d
+  jmp __alltraps
+c0102d56:	e9 32 07 00 00       	jmp    c010348d <__alltraps>
+
+c0102d5b <vector94>:
+.globl vector94
+vector94:
+  pushl $0
+c0102d5b:	6a 00                	push   $0x0
+  pushl $94
+c0102d5d:	6a 5e                	push   $0x5e
+  jmp __alltraps
+c0102d5f:	e9 29 07 00 00       	jmp    c010348d <__alltraps>
+
+c0102d64 <vector95>:
+.globl vector95
+vector95:
+  pushl $0
+c0102d64:	6a 00                	push   $0x0
+  pushl $95
+c0102d66:	6a 5f                	push   $0x5f
+  jmp __alltraps
+c0102d68:	e9 20 07 00 00       	jmp    c010348d <__alltraps>
+
+c0102d6d <vector96>:
+.globl vector96
+vector96:
+  pushl $0
+c0102d6d:	6a 00                	push   $0x0
+  pushl $96
+c0102d6f:	6a 60                	push   $0x60
+  jmp __alltraps
+c0102d71:	e9 17 07 00 00       	jmp    c010348d <__alltraps>
+
+c0102d76 <vector97>:
+.globl vector97
+vector97:
+  pushl $0
+c0102d76:	6a 00                	push   $0x0
+  pushl $97
+c0102d78:	6a 61                	push   $0x61
+  jmp __alltraps
+c0102d7a:	e9 0e 07 00 00       	jmp    c010348d <__alltraps>
+
+c0102d7f <vector98>:
+.globl vector98
+vector98:
+  pushl $0
+c0102d7f:	6a 00                	push   $0x0
+  pushl $98
+c0102d81:	6a 62                	push   $0x62
+  jmp __alltraps
+c0102d83:	e9 05 07 00 00       	jmp    c010348d <__alltraps>
+
+c0102d88 <vector99>:
+.globl vector99
+vector99:
+  pushl $0
+c0102d88:	6a 00                	push   $0x0
+  pushl $99
+c0102d8a:	6a 63                	push   $0x63
+  jmp __alltraps
+c0102d8c:	e9 fc 06 00 00       	jmp    c010348d <__alltraps>
+
+c0102d91 <vector100>:
+.globl vector100
+vector100:
+  pushl $0
+c0102d91:	6a 00                	push   $0x0
+  pushl $100
+c0102d93:	6a 64                	push   $0x64
+  jmp __alltraps
+c0102d95:	e9 f3 06 00 00       	jmp    c010348d <__alltraps>
+
+c0102d9a <vector101>:
+.globl vector101
+vector101:
+  pushl $0
+c0102d9a:	6a 00                	push   $0x0
+  pushl $101
+c0102d9c:	6a 65                	push   $0x65
+  jmp __alltraps
+c0102d9e:	e9 ea 06 00 00       	jmp    c010348d <__alltraps>
+
+c0102da3 <vector102>:
+.globl vector102
+vector102:
+  pushl $0
+c0102da3:	6a 00                	push   $0x0
+  pushl $102
+c0102da5:	6a 66                	push   $0x66
+  jmp __alltraps
+c0102da7:	e9 e1 06 00 00       	jmp    c010348d <__alltraps>
+
+c0102dac <vector103>:
+.globl vector103
+vector103:
+  pushl $0
+c0102dac:	6a 00                	push   $0x0
+  pushl $103
+c0102dae:	6a 67                	push   $0x67
+  jmp __alltraps
+c0102db0:	e9 d8 06 00 00       	jmp    c010348d <__alltraps>
+
+c0102db5 <vector104>:
+.globl vector104
+vector104:
+  pushl $0
+c0102db5:	6a 00                	push   $0x0
+  pushl $104
+c0102db7:	6a 68                	push   $0x68
+  jmp __alltraps
+c0102db9:	e9 cf 06 00 00       	jmp    c010348d <__alltraps>
+
+c0102dbe <vector105>:
+.globl vector105
+vector105:
+  pushl $0
+c0102dbe:	6a 00                	push   $0x0
+  pushl $105
+c0102dc0:	6a 69                	push   $0x69
+  jmp __alltraps
+c0102dc2:	e9 c6 06 00 00       	jmp    c010348d <__alltraps>
+
+c0102dc7 <vector106>:
+.globl vector106
+vector106:
+  pushl $0
+c0102dc7:	6a 00                	push   $0x0
+  pushl $106
+c0102dc9:	6a 6a                	push   $0x6a
+  jmp __alltraps
+c0102dcb:	e9 bd 06 00 00       	jmp    c010348d <__alltraps>
+
+c0102dd0 <vector107>:
+.globl vector107
+vector107:
+  pushl $0
+c0102dd0:	6a 00                	push   $0x0
+  pushl $107
+c0102dd2:	6a 6b                	push   $0x6b
+  jmp __alltraps
+c0102dd4:	e9 b4 06 00 00       	jmp    c010348d <__alltraps>
+
+c0102dd9 <vector108>:
+.globl vector108
+vector108:
+  pushl $0
+c0102dd9:	6a 00                	push   $0x0
+  pushl $108
+c0102ddb:	6a 6c                	push   $0x6c
+  jmp __alltraps
+c0102ddd:	e9 ab 06 00 00       	jmp    c010348d <__alltraps>
+
+c0102de2 <vector109>:
+.globl vector109
+vector109:
+  pushl $0
+c0102de2:	6a 00                	push   $0x0
+  pushl $109
+c0102de4:	6a 6d                	push   $0x6d
+  jmp __alltraps
+c0102de6:	e9 a2 06 00 00       	jmp    c010348d <__alltraps>
+
+c0102deb <vector110>:
+.globl vector110
+vector110:
+  pushl $0
+c0102deb:	6a 00                	push   $0x0
+  pushl $110
+c0102ded:	6a 6e                	push   $0x6e
+  jmp __alltraps
+c0102def:	e9 99 06 00 00       	jmp    c010348d <__alltraps>
+
+c0102df4 <vector111>:
+.globl vector111
+vector111:
+  pushl $0
+c0102df4:	6a 00                	push   $0x0
+  pushl $111
+c0102df6:	6a 6f                	push   $0x6f
+  jmp __alltraps
+c0102df8:	e9 90 06 00 00       	jmp    c010348d <__alltraps>
+
+c0102dfd <vector112>:
+.globl vector112
+vector112:
+  pushl $0
+c0102dfd:	6a 00                	push   $0x0
+  pushl $112
+c0102dff:	6a 70                	push   $0x70
+  jmp __alltraps
+c0102e01:	e9 87 06 00 00       	jmp    c010348d <__alltraps>
+
+c0102e06 <vector113>:
+.globl vector113
+vector113:
+  pushl $0
+c0102e06:	6a 00                	push   $0x0
+  pushl $113
+c0102e08:	6a 71                	push   $0x71
+  jmp __alltraps
+c0102e0a:	e9 7e 06 00 00       	jmp    c010348d <__alltraps>
+
+c0102e0f <vector114>:
+.globl vector114
+vector114:
+  pushl $0
+c0102e0f:	6a 00                	push   $0x0
+  pushl $114
+c0102e11:	6a 72                	push   $0x72
+  jmp __alltraps
+c0102e13:	e9 75 06 00 00       	jmp    c010348d <__alltraps>
+
+c0102e18 <vector115>:
+.globl vector115
+vector115:
+  pushl $0
+c0102e18:	6a 00                	push   $0x0
+  pushl $115
+c0102e1a:	6a 73                	push   $0x73
+  jmp __alltraps
+c0102e1c:	e9 6c 06 00 00       	jmp    c010348d <__alltraps>
+
+c0102e21 <vector116>:
+.globl vector116
+vector116:
+  pushl $0
+c0102e21:	6a 00                	push   $0x0
+  pushl $116
+c0102e23:	6a 74                	push   $0x74
+  jmp __alltraps
+c0102e25:	e9 63 06 00 00       	jmp    c010348d <__alltraps>
+
+c0102e2a <vector117>:
+.globl vector117
+vector117:
+  pushl $0
+c0102e2a:	6a 00                	push   $0x0
+  pushl $117
+c0102e2c:	6a 75                	push   $0x75
+  jmp __alltraps
+c0102e2e:	e9 5a 06 00 00       	jmp    c010348d <__alltraps>
+
+c0102e33 <vector118>:
+.globl vector118
+vector118:
+  pushl $0
+c0102e33:	6a 00                	push   $0x0
+  pushl $118
+c0102e35:	6a 76                	push   $0x76
+  jmp __alltraps
+c0102e37:	e9 51 06 00 00       	jmp    c010348d <__alltraps>
+
+c0102e3c <vector119>:
+.globl vector119
+vector119:
+  pushl $0
+c0102e3c:	6a 00                	push   $0x0
+  pushl $119
+c0102e3e:	6a 77                	push   $0x77
+  jmp __alltraps
+c0102e40:	e9 48 06 00 00       	jmp    c010348d <__alltraps>
+
+c0102e45 <vector120>:
+.globl vector120
+vector120:
+  pushl $0
+c0102e45:	6a 00                	push   $0x0
+  pushl $120
+c0102e47:	6a 78                	push   $0x78
+  jmp __alltraps
+c0102e49:	e9 3f 06 00 00       	jmp    c010348d <__alltraps>
+
+c0102e4e <vector121>:
+.globl vector121
+vector121:
+  pushl $0
+c0102e4e:	6a 00                	push   $0x0
+  pushl $121
+c0102e50:	6a 79                	push   $0x79
+  jmp __alltraps
+c0102e52:	e9 36 06 00 00       	jmp    c010348d <__alltraps>
+
+c0102e57 <vector122>:
+.globl vector122
+vector122:
+  pushl $0
+c0102e57:	6a 00                	push   $0x0
+  pushl $122
+c0102e59:	6a 7a                	push   $0x7a
+  jmp __alltraps
+c0102e5b:	e9 2d 06 00 00       	jmp    c010348d <__alltraps>
+
+c0102e60 <vector123>:
+.globl vector123
+vector123:
+  pushl $0
+c0102e60:	6a 00                	push   $0x0
+  pushl $123
+c0102e62:	6a 7b                	push   $0x7b
+  jmp __alltraps
+c0102e64:	e9 24 06 00 00       	jmp    c010348d <__alltraps>
+
+c0102e69 <vector124>:
+.globl vector124
+vector124:
+  pushl $0
+c0102e69:	6a 00                	push   $0x0
+  pushl $124
+c0102e6b:	6a 7c                	push   $0x7c
+  jmp __alltraps
+c0102e6d:	e9 1b 06 00 00       	jmp    c010348d <__alltraps>
+
+c0102e72 <vector125>:
+.globl vector125
+vector125:
+  pushl $0
+c0102e72:	6a 00                	push   $0x0
+  pushl $125
+c0102e74:	6a 7d                	push   $0x7d
+  jmp __alltraps
+c0102e76:	e9 12 06 00 00       	jmp    c010348d <__alltraps>
+
+c0102e7b <vector126>:
+.globl vector126
+vector126:
+  pushl $0
+c0102e7b:	6a 00                	push   $0x0
+  pushl $126
+c0102e7d:	6a 7e                	push   $0x7e
+  jmp __alltraps
+c0102e7f:	e9 09 06 00 00       	jmp    c010348d <__alltraps>
+
+c0102e84 <vector127>:
+.globl vector127
+vector127:
+  pushl $0
+c0102e84:	6a 00                	push   $0x0
+  pushl $127
+c0102e86:	6a 7f                	push   $0x7f
+  jmp __alltraps
+c0102e88:	e9 00 06 00 00       	jmp    c010348d <__alltraps>
+
+c0102e8d <vector128>:
+.globl vector128
+vector128:
+  pushl $0
+c0102e8d:	6a 00                	push   $0x0
+  pushl $128
+c0102e8f:	68 80 00 00 00       	push   $0x80
+  jmp __alltraps
+c0102e94:	e9 f4 05 00 00       	jmp    c010348d <__alltraps>
+
+c0102e99 <vector129>:
+.globl vector129
+vector129:
+  pushl $0
+c0102e99:	6a 00                	push   $0x0
+  pushl $129
+c0102e9b:	68 81 00 00 00       	push   $0x81
+  jmp __alltraps
+c0102ea0:	e9 e8 05 00 00       	jmp    c010348d <__alltraps>
+
+c0102ea5 <vector130>:
+.globl vector130
+vector130:
+  pushl $0
+c0102ea5:	6a 00                	push   $0x0
+  pushl $130
+c0102ea7:	68 82 00 00 00       	push   $0x82
+  jmp __alltraps
+c0102eac:	e9 dc 05 00 00       	jmp    c010348d <__alltraps>
+
+c0102eb1 <vector131>:
+.globl vector131
+vector131:
+  pushl $0
+c0102eb1:	6a 00                	push   $0x0
+  pushl $131
+c0102eb3:	68 83 00 00 00       	push   $0x83
+  jmp __alltraps
+c0102eb8:	e9 d0 05 00 00       	jmp    c010348d <__alltraps>
+
+c0102ebd <vector132>:
+.globl vector132
+vector132:
+  pushl $0
+c0102ebd:	6a 00                	push   $0x0
+  pushl $132
+c0102ebf:	68 84 00 00 00       	push   $0x84
+  jmp __alltraps
+c0102ec4:	e9 c4 05 00 00       	jmp    c010348d <__alltraps>
+
+c0102ec9 <vector133>:
+.globl vector133
+vector133:
+  pushl $0
+c0102ec9:	6a 00                	push   $0x0
+  pushl $133
+c0102ecb:	68 85 00 00 00       	push   $0x85
+  jmp __alltraps
+c0102ed0:	e9 b8 05 00 00       	jmp    c010348d <__alltraps>
+
+c0102ed5 <vector134>:
+.globl vector134
+vector134:
+  pushl $0
+c0102ed5:	6a 00                	push   $0x0
+  pushl $134
+c0102ed7:	68 86 00 00 00       	push   $0x86
+  jmp __alltraps
+c0102edc:	e9 ac 05 00 00       	jmp    c010348d <__alltraps>
+
+c0102ee1 <vector135>:
+.globl vector135
+vector135:
+  pushl $0
+c0102ee1:	6a 00                	push   $0x0
+  pushl $135
+c0102ee3:	68 87 00 00 00       	push   $0x87
+  jmp __alltraps
+c0102ee8:	e9 a0 05 00 00       	jmp    c010348d <__alltraps>
+
+c0102eed <vector136>:
+.globl vector136
+vector136:
+  pushl $0
+c0102eed:	6a 00                	push   $0x0
+  pushl $136
+c0102eef:	68 88 00 00 00       	push   $0x88
+  jmp __alltraps
+c0102ef4:	e9 94 05 00 00       	jmp    c010348d <__alltraps>
+
+c0102ef9 <vector137>:
+.globl vector137
+vector137:
+  pushl $0
+c0102ef9:	6a 00                	push   $0x0
+  pushl $137
+c0102efb:	68 89 00 00 00       	push   $0x89
+  jmp __alltraps
+c0102f00:	e9 88 05 00 00       	jmp    c010348d <__alltraps>
+
+c0102f05 <vector138>:
+.globl vector138
+vector138:
+  pushl $0
+c0102f05:	6a 00                	push   $0x0
+  pushl $138
+c0102f07:	68 8a 00 00 00       	push   $0x8a
+  jmp __alltraps
+c0102f0c:	e9 7c 05 00 00       	jmp    c010348d <__alltraps>
+
+c0102f11 <vector139>:
+.globl vector139
+vector139:
+  pushl $0
+c0102f11:	6a 00                	push   $0x0
+  pushl $139
+c0102f13:	68 8b 00 00 00       	push   $0x8b
+  jmp __alltraps
+c0102f18:	e9 70 05 00 00       	jmp    c010348d <__alltraps>
+
+c0102f1d <vector140>:
+.globl vector140
+vector140:
+  pushl $0
+c0102f1d:	6a 00                	push   $0x0
+  pushl $140
+c0102f1f:	68 8c 00 00 00       	push   $0x8c
+  jmp __alltraps
+c0102f24:	e9 64 05 00 00       	jmp    c010348d <__alltraps>
+
+c0102f29 <vector141>:
+.globl vector141
+vector141:
+  pushl $0
+c0102f29:	6a 00                	push   $0x0
+  pushl $141
+c0102f2b:	68 8d 00 00 00       	push   $0x8d
+  jmp __alltraps
+c0102f30:	e9 58 05 00 00       	jmp    c010348d <__alltraps>
+
+c0102f35 <vector142>:
+.globl vector142
+vector142:
+  pushl $0
+c0102f35:	6a 00                	push   $0x0
+  pushl $142
+c0102f37:	68 8e 00 00 00       	push   $0x8e
+  jmp __alltraps
+c0102f3c:	e9 4c 05 00 00       	jmp    c010348d <__alltraps>
+
+c0102f41 <vector143>:
+.globl vector143
+vector143:
+  pushl $0
+c0102f41:	6a 00                	push   $0x0
+  pushl $143
+c0102f43:	68 8f 00 00 00       	push   $0x8f
+  jmp __alltraps
+c0102f48:	e9 40 05 00 00       	jmp    c010348d <__alltraps>
+
+c0102f4d <vector144>:
+.globl vector144
+vector144:
+  pushl $0
+c0102f4d:	6a 00                	push   $0x0
+  pushl $144
+c0102f4f:	68 90 00 00 00       	push   $0x90
+  jmp __alltraps
+c0102f54:	e9 34 05 00 00       	jmp    c010348d <__alltraps>
+
+c0102f59 <vector145>:
+.globl vector145
+vector145:
+  pushl $0
+c0102f59:	6a 00                	push   $0x0
+  pushl $145
+c0102f5b:	68 91 00 00 00       	push   $0x91
+  jmp __alltraps
+c0102f60:	e9 28 05 00 00       	jmp    c010348d <__alltraps>
+
+c0102f65 <vector146>:
+.globl vector146
+vector146:
+  pushl $0
+c0102f65:	6a 00                	push   $0x0
+  pushl $146
+c0102f67:	68 92 00 00 00       	push   $0x92
+  jmp __alltraps
+c0102f6c:	e9 1c 05 00 00       	jmp    c010348d <__alltraps>
+
+c0102f71 <vector147>:
+.globl vector147
+vector147:
+  pushl $0
+c0102f71:	6a 00                	push   $0x0
+  pushl $147
+c0102f73:	68 93 00 00 00       	push   $0x93
+  jmp __alltraps
+c0102f78:	e9 10 05 00 00       	jmp    c010348d <__alltraps>
+
+c0102f7d <vector148>:
+.globl vector148
+vector148:
+  pushl $0
+c0102f7d:	6a 00                	push   $0x0
+  pushl $148
+c0102f7f:	68 94 00 00 00       	push   $0x94
+  jmp __alltraps
+c0102f84:	e9 04 05 00 00       	jmp    c010348d <__alltraps>
+
+c0102f89 <vector149>:
+.globl vector149
+vector149:
+  pushl $0
+c0102f89:	6a 00                	push   $0x0
+  pushl $149
+c0102f8b:	68 95 00 00 00       	push   $0x95
+  jmp __alltraps
+c0102f90:	e9 f8 04 00 00       	jmp    c010348d <__alltraps>
+
+c0102f95 <vector150>:
+.globl vector150
+vector150:
+  pushl $0
+c0102f95:	6a 00                	push   $0x0
+  pushl $150
+c0102f97:	68 96 00 00 00       	push   $0x96
+  jmp __alltraps
+c0102f9c:	e9 ec 04 00 00       	jmp    c010348d <__alltraps>
+
+c0102fa1 <vector151>:
+.globl vector151
+vector151:
+  pushl $0
+c0102fa1:	6a 00                	push   $0x0
+  pushl $151
+c0102fa3:	68 97 00 00 00       	push   $0x97
+  jmp __alltraps
+c0102fa8:	e9 e0 04 00 00       	jmp    c010348d <__alltraps>
+
+c0102fad <vector152>:
+.globl vector152
+vector152:
+  pushl $0
+c0102fad:	6a 00                	push   $0x0
+  pushl $152
+c0102faf:	68 98 00 00 00       	push   $0x98
+  jmp __alltraps
+c0102fb4:	e9 d4 04 00 00       	jmp    c010348d <__alltraps>
+
+c0102fb9 <vector153>:
+.globl vector153
+vector153:
+  pushl $0
+c0102fb9:	6a 00                	push   $0x0
+  pushl $153
+c0102fbb:	68 99 00 00 00       	push   $0x99
+  jmp __alltraps
+c0102fc0:	e9 c8 04 00 00       	jmp    c010348d <__alltraps>
+
+c0102fc5 <vector154>:
+.globl vector154
+vector154:
+  pushl $0
+c0102fc5:	6a 00                	push   $0x0
+  pushl $154
+c0102fc7:	68 9a 00 00 00       	push   $0x9a
+  jmp __alltraps
+c0102fcc:	e9 bc 04 00 00       	jmp    c010348d <__alltraps>
+
+c0102fd1 <vector155>:
+.globl vector155
+vector155:
+  pushl $0
+c0102fd1:	6a 00                	push   $0x0
+  pushl $155
+c0102fd3:	68 9b 00 00 00       	push   $0x9b
+  jmp __alltraps
+c0102fd8:	e9 b0 04 00 00       	jmp    c010348d <__alltraps>
+
+c0102fdd <vector156>:
+.globl vector156
+vector156:
+  pushl $0
+c0102fdd:	6a 00                	push   $0x0
+  pushl $156
+c0102fdf:	68 9c 00 00 00       	push   $0x9c
+  jmp __alltraps
+c0102fe4:	e9 a4 04 00 00       	jmp    c010348d <__alltraps>
+
+c0102fe9 <vector157>:
+.globl vector157
+vector157:
+  pushl $0
+c0102fe9:	6a 00                	push   $0x0
+  pushl $157
+c0102feb:	68 9d 00 00 00       	push   $0x9d
+  jmp __alltraps
+c0102ff0:	e9 98 04 00 00       	jmp    c010348d <__alltraps>
+
+c0102ff5 <vector158>:
+.globl vector158
+vector158:
+  pushl $0
+c0102ff5:	6a 00                	push   $0x0
+  pushl $158
+c0102ff7:	68 9e 00 00 00       	push   $0x9e
+  jmp __alltraps
+c0102ffc:	e9 8c 04 00 00       	jmp    c010348d <__alltraps>
+
+c0103001 <vector159>:
+.globl vector159
+vector159:
+  pushl $0
+c0103001:	6a 00                	push   $0x0
+  pushl $159
+c0103003:	68 9f 00 00 00       	push   $0x9f
+  jmp __alltraps
+c0103008:	e9 80 04 00 00       	jmp    c010348d <__alltraps>
+
+c010300d <vector160>:
+.globl vector160
+vector160:
+  pushl $0
+c010300d:	6a 00                	push   $0x0
+  pushl $160
+c010300f:	68 a0 00 00 00       	push   $0xa0
+  jmp __alltraps
+c0103014:	e9 74 04 00 00       	jmp    c010348d <__alltraps>
+
+c0103019 <vector161>:
+.globl vector161
+vector161:
+  pushl $0
+c0103019:	6a 00                	push   $0x0
+  pushl $161
+c010301b:	68 a1 00 00 00       	push   $0xa1
+  jmp __alltraps
+c0103020:	e9 68 04 00 00       	jmp    c010348d <__alltraps>
+
+c0103025 <vector162>:
+.globl vector162
+vector162:
+  pushl $0
+c0103025:	6a 00                	push   $0x0
+  pushl $162
+c0103027:	68 a2 00 00 00       	push   $0xa2
+  jmp __alltraps
+c010302c:	e9 5c 04 00 00       	jmp    c010348d <__alltraps>
+
+c0103031 <vector163>:
+.globl vector163
+vector163:
+  pushl $0
+c0103031:	6a 00                	push   $0x0
+  pushl $163
+c0103033:	68 a3 00 00 00       	push   $0xa3
+  jmp __alltraps
+c0103038:	e9 50 04 00 00       	jmp    c010348d <__alltraps>
+
+c010303d <vector164>:
+.globl vector164
+vector164:
+  pushl $0
+c010303d:	6a 00                	push   $0x0
+  pushl $164
+c010303f:	68 a4 00 00 00       	push   $0xa4
+  jmp __alltraps
+c0103044:	e9 44 04 00 00       	jmp    c010348d <__alltraps>
+
+c0103049 <vector165>:
+.globl vector165
+vector165:
+  pushl $0
+c0103049:	6a 00                	push   $0x0
+  pushl $165
+c010304b:	68 a5 00 00 00       	push   $0xa5
+  jmp __alltraps
+c0103050:	e9 38 04 00 00       	jmp    c010348d <__alltraps>
+
+c0103055 <vector166>:
+.globl vector166
+vector166:
+  pushl $0
+c0103055:	6a 00                	push   $0x0
+  pushl $166
+c0103057:	68 a6 00 00 00       	push   $0xa6
+  jmp __alltraps
+c010305c:	e9 2c 04 00 00       	jmp    c010348d <__alltraps>
+
+c0103061 <vector167>:
+.globl vector167
+vector167:
+  pushl $0
+c0103061:	6a 00                	push   $0x0
+  pushl $167
+c0103063:	68 a7 00 00 00       	push   $0xa7
+  jmp __alltraps
+c0103068:	e9 20 04 00 00       	jmp    c010348d <__alltraps>
+
+c010306d <vector168>:
+.globl vector168
+vector168:
+  pushl $0
+c010306d:	6a 00                	push   $0x0
+  pushl $168
+c010306f:	68 a8 00 00 00       	push   $0xa8
+  jmp __alltraps
+c0103074:	e9 14 04 00 00       	jmp    c010348d <__alltraps>
+
+c0103079 <vector169>:
+.globl vector169
+vector169:
+  pushl $0
+c0103079:	6a 00                	push   $0x0
+  pushl $169
+c010307b:	68 a9 00 00 00       	push   $0xa9
+  jmp __alltraps
+c0103080:	e9 08 04 00 00       	jmp    c010348d <__alltraps>
+
+c0103085 <vector170>:
+.globl vector170
+vector170:
+  pushl $0
+c0103085:	6a 00                	push   $0x0
+  pushl $170
+c0103087:	68 aa 00 00 00       	push   $0xaa
+  jmp __alltraps
+c010308c:	e9 fc 03 00 00       	jmp    c010348d <__alltraps>
+
+c0103091 <vector171>:
+.globl vector171
+vector171:
+  pushl $0
+c0103091:	6a 00                	push   $0x0
+  pushl $171
+c0103093:	68 ab 00 00 00       	push   $0xab
+  jmp __alltraps
+c0103098:	e9 f0 03 00 00       	jmp    c010348d <__alltraps>
+
+c010309d <vector172>:
+.globl vector172
+vector172:
+  pushl $0
+c010309d:	6a 00                	push   $0x0
+  pushl $172
+c010309f:	68 ac 00 00 00       	push   $0xac
+  jmp __alltraps
+c01030a4:	e9 e4 03 00 00       	jmp    c010348d <__alltraps>
+
+c01030a9 <vector173>:
+.globl vector173
+vector173:
+  pushl $0
+c01030a9:	6a 00                	push   $0x0
+  pushl $173
+c01030ab:	68 ad 00 00 00       	push   $0xad
+  jmp __alltraps
+c01030b0:	e9 d8 03 00 00       	jmp    c010348d <__alltraps>
+
+c01030b5 <vector174>:
+.globl vector174
+vector174:
+  pushl $0
+c01030b5:	6a 00                	push   $0x0
+  pushl $174
+c01030b7:	68 ae 00 00 00       	push   $0xae
+  jmp __alltraps
+c01030bc:	e9 cc 03 00 00       	jmp    c010348d <__alltraps>
+
+c01030c1 <vector175>:
+.globl vector175
+vector175:
+  pushl $0
+c01030c1:	6a 00                	push   $0x0
+  pushl $175
+c01030c3:	68 af 00 00 00       	push   $0xaf
+  jmp __alltraps
+c01030c8:	e9 c0 03 00 00       	jmp    c010348d <__alltraps>
+
+c01030cd <vector176>:
+.globl vector176
+vector176:
+  pushl $0
+c01030cd:	6a 00                	push   $0x0
+  pushl $176
+c01030cf:	68 b0 00 00 00       	push   $0xb0
+  jmp __alltraps
+c01030d4:	e9 b4 03 00 00       	jmp    c010348d <__alltraps>
+
+c01030d9 <vector177>:
+.globl vector177
+vector177:
+  pushl $0
+c01030d9:	6a 00                	push   $0x0
+  pushl $177
+c01030db:	68 b1 00 00 00       	push   $0xb1
+  jmp __alltraps
+c01030e0:	e9 a8 03 00 00       	jmp    c010348d <__alltraps>
+
+c01030e5 <vector178>:
+.globl vector178
+vector178:
+  pushl $0
+c01030e5:	6a 00                	push   $0x0
+  pushl $178
+c01030e7:	68 b2 00 00 00       	push   $0xb2
+  jmp __alltraps
+c01030ec:	e9 9c 03 00 00       	jmp    c010348d <__alltraps>
+
+c01030f1 <vector179>:
+.globl vector179
+vector179:
+  pushl $0
+c01030f1:	6a 00                	push   $0x0
+  pushl $179
+c01030f3:	68 b3 00 00 00       	push   $0xb3
+  jmp __alltraps
+c01030f8:	e9 90 03 00 00       	jmp    c010348d <__alltraps>
+
+c01030fd <vector180>:
+.globl vector180
+vector180:
+  pushl $0
+c01030fd:	6a 00                	push   $0x0
+  pushl $180
+c01030ff:	68 b4 00 00 00       	push   $0xb4
+  jmp __alltraps
+c0103104:	e9 84 03 00 00       	jmp    c010348d <__alltraps>
+
+c0103109 <vector181>:
+.globl vector181
+vector181:
+  pushl $0
+c0103109:	6a 00                	push   $0x0
+  pushl $181
+c010310b:	68 b5 00 00 00       	push   $0xb5
+  jmp __alltraps
+c0103110:	e9 78 03 00 00       	jmp    c010348d <__alltraps>
+
+c0103115 <vector182>:
+.globl vector182
+vector182:
+  pushl $0
+c0103115:	6a 00                	push   $0x0
+  pushl $182
+c0103117:	68 b6 00 00 00       	push   $0xb6
+  jmp __alltraps
+c010311c:	e9 6c 03 00 00       	jmp    c010348d <__alltraps>
+
+c0103121 <vector183>:
+.globl vector183
+vector183:
+  pushl $0
+c0103121:	6a 00                	push   $0x0
+  pushl $183
+c0103123:	68 b7 00 00 00       	push   $0xb7
+  jmp __alltraps
+c0103128:	e9 60 03 00 00       	jmp    c010348d <__alltraps>
+
+c010312d <vector184>:
+.globl vector184
+vector184:
+  pushl $0
+c010312d:	6a 00                	push   $0x0
+  pushl $184
+c010312f:	68 b8 00 00 00       	push   $0xb8
+  jmp __alltraps
+c0103134:	e9 54 03 00 00       	jmp    c010348d <__alltraps>
+
+c0103139 <vector185>:
+.globl vector185
+vector185:
+  pushl $0
+c0103139:	6a 00                	push   $0x0
+  pushl $185
+c010313b:	68 b9 00 00 00       	push   $0xb9
+  jmp __alltraps
+c0103140:	e9 48 03 00 00       	jmp    c010348d <__alltraps>
+
+c0103145 <vector186>:
+.globl vector186
+vector186:
+  pushl $0
+c0103145:	6a 00                	push   $0x0
+  pushl $186
+c0103147:	68 ba 00 00 00       	push   $0xba
+  jmp __alltraps
+c010314c:	e9 3c 03 00 00       	jmp    c010348d <__alltraps>
+
+c0103151 <vector187>:
+.globl vector187
+vector187:
+  pushl $0
+c0103151:	6a 00                	push   $0x0
+  pushl $187
+c0103153:	68 bb 00 00 00       	push   $0xbb
+  jmp __alltraps
+c0103158:	e9 30 03 00 00       	jmp    c010348d <__alltraps>
+
+c010315d <vector188>:
+.globl vector188
+vector188:
+  pushl $0
+c010315d:	6a 00                	push   $0x0
+  pushl $188
+c010315f:	68 bc 00 00 00       	push   $0xbc
+  jmp __alltraps
+c0103164:	e9 24 03 00 00       	jmp    c010348d <__alltraps>
+
+c0103169 <vector189>:
+.globl vector189
+vector189:
+  pushl $0
+c0103169:	6a 00                	push   $0x0
+  pushl $189
+c010316b:	68 bd 00 00 00       	push   $0xbd
+  jmp __alltraps
+c0103170:	e9 18 03 00 00       	jmp    c010348d <__alltraps>
+
+c0103175 <vector190>:
+.globl vector190
+vector190:
+  pushl $0
+c0103175:	6a 00                	push   $0x0
+  pushl $190
+c0103177:	68 be 00 00 00       	push   $0xbe
+  jmp __alltraps
+c010317c:	e9 0c 03 00 00       	jmp    c010348d <__alltraps>
+
+c0103181 <vector191>:
+.globl vector191
+vector191:
+  pushl $0
+c0103181:	6a 00                	push   $0x0
+  pushl $191
+c0103183:	68 bf 00 00 00       	push   $0xbf
+  jmp __alltraps
+c0103188:	e9 00 03 00 00       	jmp    c010348d <__alltraps>
+
+c010318d <vector192>:
+.globl vector192
+vector192:
+  pushl $0
+c010318d:	6a 00                	push   $0x0
+  pushl $192
+c010318f:	68 c0 00 00 00       	push   $0xc0
+  jmp __alltraps
+c0103194:	e9 f4 02 00 00       	jmp    c010348d <__alltraps>
+
+c0103199 <vector193>:
+.globl vector193
+vector193:
+  pushl $0
+c0103199:	6a 00                	push   $0x0
+  pushl $193
+c010319b:	68 c1 00 00 00       	push   $0xc1
+  jmp __alltraps
+c01031a0:	e9 e8 02 00 00       	jmp    c010348d <__alltraps>
+
+c01031a5 <vector194>:
+.globl vector194
+vector194:
+  pushl $0
+c01031a5:	6a 00                	push   $0x0
+  pushl $194
+c01031a7:	68 c2 00 00 00       	push   $0xc2
+  jmp __alltraps
+c01031ac:	e9 dc 02 00 00       	jmp    c010348d <__alltraps>
+
+c01031b1 <vector195>:
+.globl vector195
+vector195:
+  pushl $0
+c01031b1:	6a 00                	push   $0x0
+  pushl $195
+c01031b3:	68 c3 00 00 00       	push   $0xc3
+  jmp __alltraps
+c01031b8:	e9 d0 02 00 00       	jmp    c010348d <__alltraps>
+
+c01031bd <vector196>:
+.globl vector196
+vector196:
+  pushl $0
+c01031bd:	6a 00                	push   $0x0
+  pushl $196
+c01031bf:	68 c4 00 00 00       	push   $0xc4
+  jmp __alltraps
+c01031c4:	e9 c4 02 00 00       	jmp    c010348d <__alltraps>
+
+c01031c9 <vector197>:
+.globl vector197
+vector197:
+  pushl $0
+c01031c9:	6a 00                	push   $0x0
+  pushl $197
+c01031cb:	68 c5 00 00 00       	push   $0xc5
+  jmp __alltraps
+c01031d0:	e9 b8 02 00 00       	jmp    c010348d <__alltraps>
+
+c01031d5 <vector198>:
+.globl vector198
+vector198:
+  pushl $0
+c01031d5:	6a 00                	push   $0x0
+  pushl $198
+c01031d7:	68 c6 00 00 00       	push   $0xc6
+  jmp __alltraps
+c01031dc:	e9 ac 02 00 00       	jmp    c010348d <__alltraps>
+
+c01031e1 <vector199>:
+.globl vector199
+vector199:
+  pushl $0
+c01031e1:	6a 00                	push   $0x0
+  pushl $199
+c01031e3:	68 c7 00 00 00       	push   $0xc7
+  jmp __alltraps
+c01031e8:	e9 a0 02 00 00       	jmp    c010348d <__alltraps>
+
+c01031ed <vector200>:
+.globl vector200
+vector200:
+  pushl $0
+c01031ed:	6a 00                	push   $0x0
+  pushl $200
+c01031ef:	68 c8 00 00 00       	push   $0xc8
+  jmp __alltraps
+c01031f4:	e9 94 02 00 00       	jmp    c010348d <__alltraps>
+
+c01031f9 <vector201>:
+.globl vector201
+vector201:
+  pushl $0
+c01031f9:	6a 00                	push   $0x0
+  pushl $201
+c01031fb:	68 c9 00 00 00       	push   $0xc9
+  jmp __alltraps
+c0103200:	e9 88 02 00 00       	jmp    c010348d <__alltraps>
+
+c0103205 <vector202>:
+.globl vector202
+vector202:
+  pushl $0
+c0103205:	6a 00                	push   $0x0
+  pushl $202
+c0103207:	68 ca 00 00 00       	push   $0xca
+  jmp __alltraps
+c010320c:	e9 7c 02 00 00       	jmp    c010348d <__alltraps>
+
+c0103211 <vector203>:
+.globl vector203
+vector203:
+  pushl $0
+c0103211:	6a 00                	push   $0x0
+  pushl $203
+c0103213:	68 cb 00 00 00       	push   $0xcb
+  jmp __alltraps
+c0103218:	e9 70 02 00 00       	jmp    c010348d <__alltraps>
+
+c010321d <vector204>:
+.globl vector204
+vector204:
+  pushl $0
+c010321d:	6a 00                	push   $0x0
+  pushl $204
+c010321f:	68 cc 00 00 00       	push   $0xcc
+  jmp __alltraps
+c0103224:	e9 64 02 00 00       	jmp    c010348d <__alltraps>
+
+c0103229 <vector205>:
+.globl vector205
+vector205:
+  pushl $0
+c0103229:	6a 00                	push   $0x0
+  pushl $205
+c010322b:	68 cd 00 00 00       	push   $0xcd
+  jmp __alltraps
+c0103230:	e9 58 02 00 00       	jmp    c010348d <__alltraps>
+
+c0103235 <vector206>:
+.globl vector206
+vector206:
+  pushl $0
+c0103235:	6a 00                	push   $0x0
+  pushl $206
+c0103237:	68 ce 00 00 00       	push   $0xce
+  jmp __alltraps
+c010323c:	e9 4c 02 00 00       	jmp    c010348d <__alltraps>
+
+c0103241 <vector207>:
+.globl vector207
+vector207:
+  pushl $0
+c0103241:	6a 00                	push   $0x0
+  pushl $207
+c0103243:	68 cf 00 00 00       	push   $0xcf
+  jmp __alltraps
+c0103248:	e9 40 02 00 00       	jmp    c010348d <__alltraps>
+
+c010324d <vector208>:
+.globl vector208
+vector208:
+  pushl $0
+c010324d:	6a 00                	push   $0x0
+  pushl $208
+c010324f:	68 d0 00 00 00       	push   $0xd0
+  jmp __alltraps
+c0103254:	e9 34 02 00 00       	jmp    c010348d <__alltraps>
+
+c0103259 <vector209>:
+.globl vector209
+vector209:
+  pushl $0
+c0103259:	6a 00                	push   $0x0
+  pushl $209
+c010325b:	68 d1 00 00 00       	push   $0xd1
+  jmp __alltraps
+c0103260:	e9 28 02 00 00       	jmp    c010348d <__alltraps>
+
+c0103265 <vector210>:
+.globl vector210
+vector210:
+  pushl $0
+c0103265:	6a 00                	push   $0x0
+  pushl $210
+c0103267:	68 d2 00 00 00       	push   $0xd2
+  jmp __alltraps
+c010326c:	e9 1c 02 00 00       	jmp    c010348d <__alltraps>
+
+c0103271 <vector211>:
+.globl vector211
+vector211:
+  pushl $0
+c0103271:	6a 00                	push   $0x0
+  pushl $211
+c0103273:	68 d3 00 00 00       	push   $0xd3
+  jmp __alltraps
+c0103278:	e9 10 02 00 00       	jmp    c010348d <__alltraps>
+
+c010327d <vector212>:
+.globl vector212
+vector212:
+  pushl $0
+c010327d:	6a 00                	push   $0x0
+  pushl $212
+c010327f:	68 d4 00 00 00       	push   $0xd4
+  jmp __alltraps
+c0103284:	e9 04 02 00 00       	jmp    c010348d <__alltraps>
+
+c0103289 <vector213>:
+.globl vector213
+vector213:
+  pushl $0
+c0103289:	6a 00                	push   $0x0
+  pushl $213
+c010328b:	68 d5 00 00 00       	push   $0xd5
+  jmp __alltraps
+c0103290:	e9 f8 01 00 00       	jmp    c010348d <__alltraps>
+
+c0103295 <vector214>:
+.globl vector214
+vector214:
+  pushl $0
+c0103295:	6a 00                	push   $0x0
+  pushl $214
+c0103297:	68 d6 00 00 00       	push   $0xd6
+  jmp __alltraps
+c010329c:	e9 ec 01 00 00       	jmp    c010348d <__alltraps>
+
+c01032a1 <vector215>:
+.globl vector215
+vector215:
+  pushl $0
+c01032a1:	6a 00                	push   $0x0
+  pushl $215
+c01032a3:	68 d7 00 00 00       	push   $0xd7
+  jmp __alltraps
+c01032a8:	e9 e0 01 00 00       	jmp    c010348d <__alltraps>
+
+c01032ad <vector216>:
+.globl vector216
+vector216:
+  pushl $0
+c01032ad:	6a 00                	push   $0x0
+  pushl $216
+c01032af:	68 d8 00 00 00       	push   $0xd8
+  jmp __alltraps
+c01032b4:	e9 d4 01 00 00       	jmp    c010348d <__alltraps>
+
+c01032b9 <vector217>:
+.globl vector217
+vector217:
+  pushl $0
+c01032b9:	6a 00                	push   $0x0
+  pushl $217
+c01032bb:	68 d9 00 00 00       	push   $0xd9
+  jmp __alltraps
+c01032c0:	e9 c8 01 00 00       	jmp    c010348d <__alltraps>
+
+c01032c5 <vector218>:
+.globl vector218
+vector218:
+  pushl $0
+c01032c5:	6a 00                	push   $0x0
+  pushl $218
+c01032c7:	68 da 00 00 00       	push   $0xda
+  jmp __alltraps
+c01032cc:	e9 bc 01 00 00       	jmp    c010348d <__alltraps>
+
+c01032d1 <vector219>:
+.globl vector219
+vector219:
+  pushl $0
+c01032d1:	6a 00                	push   $0x0
+  pushl $219
+c01032d3:	68 db 00 00 00       	push   $0xdb
+  jmp __alltraps
+c01032d8:	e9 b0 01 00 00       	jmp    c010348d <__alltraps>
+
+c01032dd <vector220>:
+.globl vector220
+vector220:
+  pushl $0
+c01032dd:	6a 00                	push   $0x0
+  pushl $220
+c01032df:	68 dc 00 00 00       	push   $0xdc
+  jmp __alltraps
+c01032e4:	e9 a4 01 00 00       	jmp    c010348d <__alltraps>
+
+c01032e9 <vector221>:
+.globl vector221
+vector221:
+  pushl $0
+c01032e9:	6a 00                	push   $0x0
+  pushl $221
+c01032eb:	68 dd 00 00 00       	push   $0xdd
+  jmp __alltraps
+c01032f0:	e9 98 01 00 00       	jmp    c010348d <__alltraps>
+
+c01032f5 <vector222>:
+.globl vector222
+vector222:
+  pushl $0
+c01032f5:	6a 00                	push   $0x0
+  pushl $222
+c01032f7:	68 de 00 00 00       	push   $0xde
+  jmp __alltraps
+c01032fc:	e9 8c 01 00 00       	jmp    c010348d <__alltraps>
+
+c0103301 <vector223>:
+.globl vector223
+vector223:
+  pushl $0
+c0103301:	6a 00                	push   $0x0
+  pushl $223
+c0103303:	68 df 00 00 00       	push   $0xdf
+  jmp __alltraps
+c0103308:	e9 80 01 00 00       	jmp    c010348d <__alltraps>
+
+c010330d <vector224>:
+.globl vector224
+vector224:
+  pushl $0
+c010330d:	6a 00                	push   $0x0
+  pushl $224
+c010330f:	68 e0 00 00 00       	push   $0xe0
+  jmp __alltraps
+c0103314:	e9 74 01 00 00       	jmp    c010348d <__alltraps>
+
+c0103319 <vector225>:
+.globl vector225
+vector225:
+  pushl $0
+c0103319:	6a 00                	push   $0x0
+  pushl $225
+c010331b:	68 e1 00 00 00       	push   $0xe1
+  jmp __alltraps
+c0103320:	e9 68 01 00 00       	jmp    c010348d <__alltraps>
+
+c0103325 <vector226>:
+.globl vector226
+vector226:
+  pushl $0
+c0103325:	6a 00                	push   $0x0
+  pushl $226
+c0103327:	68 e2 00 00 00       	push   $0xe2
+  jmp __alltraps
+c010332c:	e9 5c 01 00 00       	jmp    c010348d <__alltraps>
+
+c0103331 <vector227>:
+.globl vector227
+vector227:
+  pushl $0
+c0103331:	6a 00                	push   $0x0
+  pushl $227
+c0103333:	68 e3 00 00 00       	push   $0xe3
+  jmp __alltraps
+c0103338:	e9 50 01 00 00       	jmp    c010348d <__alltraps>
+
+c010333d <vector228>:
+.globl vector228
+vector228:
+  pushl $0
+c010333d:	6a 00                	push   $0x0
+  pushl $228
+c010333f:	68 e4 00 00 00       	push   $0xe4
+  jmp __alltraps
+c0103344:	e9 44 01 00 00       	jmp    c010348d <__alltraps>
+
+c0103349 <vector229>:
+.globl vector229
+vector229:
+  pushl $0
+c0103349:	6a 00                	push   $0x0
+  pushl $229
+c010334b:	68 e5 00 00 00       	push   $0xe5
+  jmp __alltraps
+c0103350:	e9 38 01 00 00       	jmp    c010348d <__alltraps>
+
+c0103355 <vector230>:
+.globl vector230
+vector230:
+  pushl $0
+c0103355:	6a 00                	push   $0x0
+  pushl $230
+c0103357:	68 e6 00 00 00       	push   $0xe6
+  jmp __alltraps
+c010335c:	e9 2c 01 00 00       	jmp    c010348d <__alltraps>
+
+c0103361 <vector231>:
+.globl vector231
+vector231:
+  pushl $0
+c0103361:	6a 00                	push   $0x0
+  pushl $231
+c0103363:	68 e7 00 00 00       	push   $0xe7
+  jmp __alltraps
+c0103368:	e9 20 01 00 00       	jmp    c010348d <__alltraps>
+
+c010336d <vector232>:
+.globl vector232
+vector232:
+  pushl $0
+c010336d:	6a 00                	push   $0x0
+  pushl $232
+c010336f:	68 e8 00 00 00       	push   $0xe8
+  jmp __alltraps
+c0103374:	e9 14 01 00 00       	jmp    c010348d <__alltraps>
+
+c0103379 <vector233>:
+.globl vector233
+vector233:
+  pushl $0
+c0103379:	6a 00                	push   $0x0
+  pushl $233
+c010337b:	68 e9 00 00 00       	push   $0xe9
+  jmp __alltraps
+c0103380:	e9 08 01 00 00       	jmp    c010348d <__alltraps>
+
+c0103385 <vector234>:
+.globl vector234
+vector234:
+  pushl $0
+c0103385:	6a 00                	push   $0x0
+  pushl $234
+c0103387:	68 ea 00 00 00       	push   $0xea
+  jmp __alltraps
+c010338c:	e9 fc 00 00 00       	jmp    c010348d <__alltraps>
+
+c0103391 <vector235>:
+.globl vector235
+vector235:
+  pushl $0
+c0103391:	6a 00                	push   $0x0
+  pushl $235
+c0103393:	68 eb 00 00 00       	push   $0xeb
+  jmp __alltraps
+c0103398:	e9 f0 00 00 00       	jmp    c010348d <__alltraps>
+
+c010339d <vector236>:
+.globl vector236
+vector236:
+  pushl $0
+c010339d:	6a 00                	push   $0x0
+  pushl $236
+c010339f:	68 ec 00 00 00       	push   $0xec
+  jmp __alltraps
+c01033a4:	e9 e4 00 00 00       	jmp    c010348d <__alltraps>
+
+c01033a9 <vector237>:
+.globl vector237
+vector237:
+  pushl $0
+c01033a9:	6a 00                	push   $0x0
+  pushl $237
+c01033ab:	68 ed 00 00 00       	push   $0xed
+  jmp __alltraps
+c01033b0:	e9 d8 00 00 00       	jmp    c010348d <__alltraps>
+
+c01033b5 <vector238>:
+.globl vector238
+vector238:
+  pushl $0
+c01033b5:	6a 00                	push   $0x0
+  pushl $238
+c01033b7:	68 ee 00 00 00       	push   $0xee
+  jmp __alltraps
+c01033bc:	e9 cc 00 00 00       	jmp    c010348d <__alltraps>
+
+c01033c1 <vector239>:
+.globl vector239
+vector239:
+  pushl $0
+c01033c1:	6a 00                	push   $0x0
+  pushl $239
+c01033c3:	68 ef 00 00 00       	push   $0xef
+  jmp __alltraps
+c01033c8:	e9 c0 00 00 00       	jmp    c010348d <__alltraps>
+
+c01033cd <vector240>:
+.globl vector240
+vector240:
+  pushl $0
+c01033cd:	6a 00                	push   $0x0
+  pushl $240
+c01033cf:	68 f0 00 00 00       	push   $0xf0
+  jmp __alltraps
+c01033d4:	e9 b4 00 00 00       	jmp    c010348d <__alltraps>
+
+c01033d9 <vector241>:
+.globl vector241
+vector241:
+  pushl $0
+c01033d9:	6a 00                	push   $0x0
+  pushl $241
+c01033db:	68 f1 00 00 00       	push   $0xf1
+  jmp __alltraps
+c01033e0:	e9 a8 00 00 00       	jmp    c010348d <__alltraps>
+
+c01033e5 <vector242>:
+.globl vector242
+vector242:
+  pushl $0
+c01033e5:	6a 00                	push   $0x0
+  pushl $242
+c01033e7:	68 f2 00 00 00       	push   $0xf2
+  jmp __alltraps
+c01033ec:	e9 9c 00 00 00       	jmp    c010348d <__alltraps>
+
+c01033f1 <vector243>:
+.globl vector243
+vector243:
+  pushl $0
+c01033f1:	6a 00                	push   $0x0
+  pushl $243
+c01033f3:	68 f3 00 00 00       	push   $0xf3
+  jmp __alltraps
+c01033f8:	e9 90 00 00 00       	jmp    c010348d <__alltraps>
+
+c01033fd <vector244>:
+.globl vector244
+vector244:
+  pushl $0
+c01033fd:	6a 00                	push   $0x0
+  pushl $244
+c01033ff:	68 f4 00 00 00       	push   $0xf4
+  jmp __alltraps
+c0103404:	e9 84 00 00 00       	jmp    c010348d <__alltraps>
+
+c0103409 <vector245>:
+.globl vector245
+vector245:
+  pushl $0
+c0103409:	6a 00                	push   $0x0
+  pushl $245
+c010340b:	68 f5 00 00 00       	push   $0xf5
+  jmp __alltraps
+c0103410:	e9 78 00 00 00       	jmp    c010348d <__alltraps>
+
+c0103415 <vector246>:
+.globl vector246
+vector246:
+  pushl $0
+c0103415:	6a 00                	push   $0x0
+  pushl $246
+c0103417:	68 f6 00 00 00       	push   $0xf6
+  jmp __alltraps
+c010341c:	e9 6c 00 00 00       	jmp    c010348d <__alltraps>
+
+c0103421 <vector247>:
+.globl vector247
+vector247:
+  pushl $0
+c0103421:	6a 00                	push   $0x0
+  pushl $247
+c0103423:	68 f7 00 00 00       	push   $0xf7
+  jmp __alltraps
+c0103428:	e9 60 00 00 00       	jmp    c010348d <__alltraps>
+
+c010342d <vector248>:
+.globl vector248
+vector248:
+  pushl $0
+c010342d:	6a 00                	push   $0x0
+  pushl $248
+c010342f:	68 f8 00 00 00       	push   $0xf8
+  jmp __alltraps
+c0103434:	e9 54 00 00 00       	jmp    c010348d <__alltraps>
+
+c0103439 <vector249>:
+.globl vector249
+vector249:
+  pushl $0
+c0103439:	6a 00                	push   $0x0
+  pushl $249
+c010343b:	68 f9 00 00 00       	push   $0xf9
+  jmp __alltraps
+c0103440:	e9 48 00 00 00       	jmp    c010348d <__alltraps>
+
+c0103445 <vector250>:
+.globl vector250
+vector250:
+  pushl $0
+c0103445:	6a 00                	push   $0x0
+  pushl $250
+c0103447:	68 fa 00 00 00       	push   $0xfa
+  jmp __alltraps
+c010344c:	e9 3c 00 00 00       	jmp    c010348d <__alltraps>
+
+c0103451 <vector251>:
+.globl vector251
+vector251:
+  pushl $0
+c0103451:	6a 00                	push   $0x0
+  pushl $251
+c0103453:	68 fb 00 00 00       	push   $0xfb
+  jmp __alltraps
+c0103458:	e9 30 00 00 00       	jmp    c010348d <__alltraps>
+
+c010345d <vector252>:
+.globl vector252
+vector252:
+  pushl $0
+c010345d:	6a 00                	push   $0x0
+  pushl $252
+c010345f:	68 fc 00 00 00       	push   $0xfc
+  jmp __alltraps
+c0103464:	e9 24 00 00 00       	jmp    c010348d <__alltraps>
+
+c0103469 <vector253>:
+.globl vector253
+vector253:
+  pushl $0
+c0103469:	6a 00                	push   $0x0
+  pushl $253
+c010346b:	68 fd 00 00 00       	push   $0xfd
+  jmp __alltraps
+c0103470:	e9 18 00 00 00       	jmp    c010348d <__alltraps>
+
+c0103475 <vector254>:
+.globl vector254
+vector254:
+  pushl $0
+c0103475:	6a 00                	push   $0x0
+  pushl $254
+c0103477:	68 fe 00 00 00       	push   $0xfe
+  jmp __alltraps
+c010347c:	e9 0c 00 00 00       	jmp    c010348d <__alltraps>
+
+c0103481 <vector255>:
+.globl vector255
+vector255:
+  pushl $0
+c0103481:	6a 00                	push   $0x0
+  pushl $255
+c0103483:	68 ff 00 00 00       	push   $0xff
+  jmp __alltraps
+c0103488:	e9 00 00 00 00       	jmp    c010348d <__alltraps>
+
+c010348d <__alltraps>:
+.text
+.globl __alltraps
+__alltraps:
+    # push registers to build a trap frame
+    # therefore make the stack look like a struct trapframe
+    pushl %ds
+c010348d:	1e                   	push   %ds
+    pushl %es
+c010348e:	06                   	push   %es
+    pushl %fs
+c010348f:	0f a0                	push   %fs
+    pushl %gs
+c0103491:	0f a8                	push   %gs
+    pushal
+c0103493:	60                   	pusha  
+
+    # load GD_KDATA into %ds and %es to set up data segments for kernel
+    movl $GD_KDATA, %eax
+c0103494:	b8 10 00 00 00       	mov    $0x10,%eax
+    movw %ax, %ds
+c0103499:	8e d8                	mov    %eax,%ds
+    movw %ax, %es
+c010349b:	8e c0                	mov    %eax,%es
+
+    # push %esp to pass a pointer to the trapframe as an argument to trap()
+    pushl %esp
+c010349d:	54                   	push   %esp
+
+    # call trap(tf), where tf=%esp
+    call trap
+c010349e:	e8 e3 f4 ff ff       	call   c0102986 <trap>
+
+    # pop the pushed stack pointer
+    popl %esp
+c01034a3:	5c                   	pop    %esp
+
+c01034a4 <__trapret>:
+
+    # return falls through to trapret...
+.globl __trapret
+__trapret:
+    # restore registers from stack
+    popal
+c01034a4:	61                   	popa   
+
+    # restore %ds, %es, %fs and %gs
+    popl %gs
+c01034a5:	0f a9                	pop    %gs
+    popl %fs
+c01034a7:	0f a1                	pop    %fs
+    popl %es
+c01034a9:	07                   	pop    %es
+    popl %ds
+c01034aa:	1f                   	pop    %ds
+
+    # get rid of the trap number and error code
+    addl $0x8, %esp
+c01034ab:	83 c4 08             	add    $0x8,%esp
+    iret
+c01034ae:	cf                   	iret   
+
+c01034af <forkrets>:
+
+.globl forkrets
+forkrets:
+    # set stack to this new process's trapframe
+    movl 4(%esp), %esp
+c01034af:	8b 64 24 04          	mov    0x4(%esp),%esp
+    jmp __trapret
+c01034b3:	eb ef                	jmp    c01034a4 <__trapret>
+
+c01034b5 <page2ppn>:
+
+extern struct Page *pages;
+extern size_t npage;
+
+static inline ppn_t
+page2ppn(struct Page *page) {
+c01034b5:	55                   	push   %ebp
+c01034b6:	89 e5                	mov    %esp,%ebp
+    return page - pages;
+c01034b8:	8b 45 08             	mov    0x8(%ebp),%eax
+c01034bb:	8b 15 84 30 1b c0    	mov    0xc01b3084,%edx
+c01034c1:	29 d0                	sub    %edx,%eax
+c01034c3:	c1 f8 05             	sar    $0x5,%eax
+}
+c01034c6:	5d                   	pop    %ebp
+c01034c7:	c3                   	ret    
+
+c01034c8 <page2pa>:
+
+static inline uintptr_t
+page2pa(struct Page *page) {
+c01034c8:	55                   	push   %ebp
+c01034c9:	89 e5                	mov    %esp,%ebp
+    return page2ppn(page) << PGSHIFT;
+c01034cb:	ff 75 08             	pushl  0x8(%ebp)
+c01034ce:	e8 e2 ff ff ff       	call   c01034b5 <page2ppn>
+c01034d3:	83 c4 04             	add    $0x4,%esp
+c01034d6:	c1 e0 0c             	shl    $0xc,%eax
+}
+c01034d9:	c9                   	leave  
+c01034da:	c3                   	ret    
+
+c01034db <pa2page>:
+
+static inline struct Page *
+pa2page(uintptr_t pa) {
+c01034db:	55                   	push   %ebp
+c01034dc:	89 e5                	mov    %esp,%ebp
+c01034de:	83 ec 08             	sub    $0x8,%esp
+    if (PPN(pa) >= npage) {
+c01034e1:	8b 45 08             	mov    0x8(%ebp),%eax
+c01034e4:	c1 e8 0c             	shr    $0xc,%eax
+c01034e7:	89 c2                	mov    %eax,%edx
+c01034e9:	a1 80 0f 1b c0       	mov    0xc01b0f80,%eax
+c01034ee:	39 c2                	cmp    %eax,%edx
+c01034f0:	72 14                	jb     c0103506 <pa2page+0x2b>
+        panic("pa2page called with invalid pa");
+c01034f2:	83 ec 04             	sub    $0x4,%esp
+c01034f5:	68 70 c2 10 c0       	push   $0xc010c270
+c01034fa:	6a 5e                	push   $0x5e
+c01034fc:	68 8f c2 10 c0       	push   $0xc010c28f
+c0103501:	e8 ef ce ff ff       	call   c01003f5 <__panic>
+    }
+    return &pages[PPN(pa)];
+c0103506:	a1 84 30 1b c0       	mov    0xc01b3084,%eax
+c010350b:	8b 55 08             	mov    0x8(%ebp),%edx
+c010350e:	c1 ea 0c             	shr    $0xc,%edx
+c0103511:	c1 e2 05             	shl    $0x5,%edx
+c0103514:	01 d0                	add    %edx,%eax
+}
+c0103516:	c9                   	leave  
+c0103517:	c3                   	ret    
+
+c0103518 <page2kva>:
+
+static inline void *
+page2kva(struct Page *page) {
+c0103518:	55                   	push   %ebp
+c0103519:	89 e5                	mov    %esp,%ebp
+c010351b:	83 ec 18             	sub    $0x18,%esp
+    return KADDR(page2pa(page));
+c010351e:	ff 75 08             	pushl  0x8(%ebp)
+c0103521:	e8 a2 ff ff ff       	call   c01034c8 <page2pa>
+c0103526:	83 c4 04             	add    $0x4,%esp
+c0103529:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c010352c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010352f:	c1 e8 0c             	shr    $0xc,%eax
+c0103532:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0103535:	a1 80 0f 1b c0       	mov    0xc01b0f80,%eax
+c010353a:	39 45 f0             	cmp    %eax,-0x10(%ebp)
+c010353d:	72 14                	jb     c0103553 <page2kva+0x3b>
+c010353f:	ff 75 f4             	pushl  -0xc(%ebp)
+c0103542:	68 a0 c2 10 c0       	push   $0xc010c2a0
+c0103547:	6a 65                	push   $0x65
+c0103549:	68 8f c2 10 c0       	push   $0xc010c28f
+c010354e:	e8 a2 ce ff ff       	call   c01003f5 <__panic>
+c0103553:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0103556:	2d 00 00 00 40       	sub    $0x40000000,%eax
+}
+c010355b:	c9                   	leave  
+c010355c:	c3                   	ret    
+
+c010355d <pte2page>:
+kva2page(void *kva) {
+    return pa2page(PADDR(kva));
+}
+
+static inline struct Page *
+pte2page(pte_t pte) {
+c010355d:	55                   	push   %ebp
+c010355e:	89 e5                	mov    %esp,%ebp
+c0103560:	83 ec 08             	sub    $0x8,%esp
+    if (!(pte & PTE_P)) {
+c0103563:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103566:	83 e0 01             	and    $0x1,%eax
+c0103569:	85 c0                	test   %eax,%eax
+c010356b:	75 14                	jne    c0103581 <pte2page+0x24>
+        panic("pte2page called with invalid pte");
+c010356d:	83 ec 04             	sub    $0x4,%esp
+c0103570:	68 c4 c2 10 c0       	push   $0xc010c2c4
+c0103575:	6a 70                	push   $0x70
+c0103577:	68 8f c2 10 c0       	push   $0xc010c28f
+c010357c:	e8 74 ce ff ff       	call   c01003f5 <__panic>
+    }
+    return pa2page(PTE_ADDR(pte));
+c0103581:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103584:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+c0103589:	83 ec 0c             	sub    $0xc,%esp
+c010358c:	50                   	push   %eax
+c010358d:	e8 49 ff ff ff       	call   c01034db <pa2page>
+c0103592:	83 c4 10             	add    $0x10,%esp
+}
+c0103595:	c9                   	leave  
+c0103596:	c3                   	ret    
+
+c0103597 <pde2page>:
+
+static inline struct Page *
+pde2page(pde_t pde) {
+c0103597:	55                   	push   %ebp
+c0103598:	89 e5                	mov    %esp,%ebp
+c010359a:	83 ec 08             	sub    $0x8,%esp
+    return pa2page(PDE_ADDR(pde));
+c010359d:	8b 45 08             	mov    0x8(%ebp),%eax
+c01035a0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+c01035a5:	83 ec 0c             	sub    $0xc,%esp
+c01035a8:	50                   	push   %eax
+c01035a9:	e8 2d ff ff ff       	call   c01034db <pa2page>
+c01035ae:	83 c4 10             	add    $0x10,%esp
+}
+c01035b1:	c9                   	leave  
+c01035b2:	c3                   	ret    
+
+c01035b3 <page_ref>:
+
+static inline int
+page_ref(struct Page *page) {
+c01035b3:	55                   	push   %ebp
+c01035b4:	89 e5                	mov    %esp,%ebp
+    return page->ref;
+c01035b6:	8b 45 08             	mov    0x8(%ebp),%eax
+c01035b9:	8b 00                	mov    (%eax),%eax
+}
+c01035bb:	5d                   	pop    %ebp
+c01035bc:	c3                   	ret    
+
+c01035bd <set_page_ref>:
+
+static inline void
+set_page_ref(struct Page *page, int val) {
+c01035bd:	55                   	push   %ebp
+c01035be:	89 e5                	mov    %esp,%ebp
+    page->ref = val;
+c01035c0:	8b 45 08             	mov    0x8(%ebp),%eax
+c01035c3:	8b 55 0c             	mov    0xc(%ebp),%edx
+c01035c6:	89 10                	mov    %edx,(%eax)
+}
+c01035c8:	90                   	nop
+c01035c9:	5d                   	pop    %ebp
+c01035ca:	c3                   	ret    
+
+c01035cb <page_ref_inc>:
+
+static inline int
+page_ref_inc(struct Page *page) {
+c01035cb:	55                   	push   %ebp
+c01035cc:	89 e5                	mov    %esp,%ebp
+    page->ref += 1;
+c01035ce:	8b 45 08             	mov    0x8(%ebp),%eax
+c01035d1:	8b 00                	mov    (%eax),%eax
+c01035d3:	8d 50 01             	lea    0x1(%eax),%edx
+c01035d6:	8b 45 08             	mov    0x8(%ebp),%eax
+c01035d9:	89 10                	mov    %edx,(%eax)
+    return page->ref;
+c01035db:	8b 45 08             	mov    0x8(%ebp),%eax
+c01035de:	8b 00                	mov    (%eax),%eax
+}
+c01035e0:	5d                   	pop    %ebp
+c01035e1:	c3                   	ret    
+
+c01035e2 <page_ref_dec>:
+
+static inline int
+page_ref_dec(struct Page *page) {
+c01035e2:	55                   	push   %ebp
+c01035e3:	89 e5                	mov    %esp,%ebp
+    page->ref -= 1;
+c01035e5:	8b 45 08             	mov    0x8(%ebp),%eax
+c01035e8:	8b 00                	mov    (%eax),%eax
+c01035ea:	8d 50 ff             	lea    -0x1(%eax),%edx
+c01035ed:	8b 45 08             	mov    0x8(%ebp),%eax
+c01035f0:	89 10                	mov    %edx,(%eax)
+    return page->ref;
+c01035f2:	8b 45 08             	mov    0x8(%ebp),%eax
+c01035f5:	8b 00                	mov    (%eax),%eax
+}
+c01035f7:	5d                   	pop    %ebp
+c01035f8:	c3                   	ret    
+
+c01035f9 <__intr_save>:
+#include <assert.h>
+#include <atomic.h>
+#include <sched.h>
+
+static inline bool
+__intr_save(void) {
+c01035f9:	55                   	push   %ebp
+c01035fa:	89 e5                	mov    %esp,%ebp
+c01035fc:	83 ec 18             	sub    $0x18,%esp
+}
+
+static inline uint32_t
+read_eflags(void) {
+    uint32_t eflags;
+    asm volatile ("pushfl; popl %0" : "=r" (eflags));
+c01035ff:	9c                   	pushf  
+c0103600:	58                   	pop    %eax
+c0103601:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    return eflags;
+c0103604:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    if (read_eflags() & FL_IF) {
+c0103607:	25 00 02 00 00       	and    $0x200,%eax
+c010360c:	85 c0                	test   %eax,%eax
+c010360e:	74 0c                	je     c010361c <__intr_save+0x23>
+        intr_disable();
+c0103610:	e8 98 eb ff ff       	call   c01021ad <intr_disable>
+        return 1;
+c0103615:	b8 01 00 00 00       	mov    $0x1,%eax
+c010361a:	eb 05                	jmp    c0103621 <__intr_save+0x28>
+    }
+    return 0;
+c010361c:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c0103621:	c9                   	leave  
+c0103622:	c3                   	ret    
+
+c0103623 <__intr_restore>:
+
+static inline void
+__intr_restore(bool flag) {
+c0103623:	55                   	push   %ebp
+c0103624:	89 e5                	mov    %esp,%ebp
+c0103626:	83 ec 08             	sub    $0x8,%esp
+    if (flag) {
+c0103629:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c010362d:	74 05                	je     c0103634 <__intr_restore+0x11>
+        intr_enable();
+c010362f:	e8 72 eb ff ff       	call   c01021a6 <intr_enable>
+    }
+}
+c0103634:	90                   	nop
+c0103635:	c9                   	leave  
+c0103636:	c3                   	ret    
+
+c0103637 <lgdt>:
+/* *
+ * lgdt - load the global descriptor table register and reset the
+ * data/code segement registers for kernel.
+ * */
+static inline void
+lgdt(struct pseudodesc *pd) {
+c0103637:	55                   	push   %ebp
+c0103638:	89 e5                	mov    %esp,%ebp
+    asm volatile ("lgdt (%0)" :: "r" (pd));
+c010363a:	8b 45 08             	mov    0x8(%ebp),%eax
+c010363d:	0f 01 10             	lgdtl  (%eax)
+    asm volatile ("movw %%ax, %%gs" :: "a" (USER_DS));
+c0103640:	b8 23 00 00 00       	mov    $0x23,%eax
+c0103645:	8e e8                	mov    %eax,%gs
+    asm volatile ("movw %%ax, %%fs" :: "a" (USER_DS));
+c0103647:	b8 23 00 00 00       	mov    $0x23,%eax
+c010364c:	8e e0                	mov    %eax,%fs
+    asm volatile ("movw %%ax, %%es" :: "a" (KERNEL_DS));
+c010364e:	b8 10 00 00 00       	mov    $0x10,%eax
+c0103653:	8e c0                	mov    %eax,%es
+    asm volatile ("movw %%ax, %%ds" :: "a" (KERNEL_DS));
+c0103655:	b8 10 00 00 00       	mov    $0x10,%eax
+c010365a:	8e d8                	mov    %eax,%ds
+    asm volatile ("movw %%ax, %%ss" :: "a" (KERNEL_DS));
+c010365c:	b8 10 00 00 00       	mov    $0x10,%eax
+c0103661:	8e d0                	mov    %eax,%ss
+    // reload cs
+    asm volatile ("ljmp %0, $1f\n 1:\n" :: "i" (KERNEL_CS));
+c0103663:	ea 6a 36 10 c0 08 00 	ljmp   $0x8,$0xc010366a
+}
+c010366a:	90                   	nop
+c010366b:	5d                   	pop    %ebp
+c010366c:	c3                   	ret    
+
+c010366d <load_esp0>:
+ * load_esp0 - change the ESP0 in default task state segment,
+ * so that we can use different kernel stack when we trap frame
+ * user to kernel.
+ * */
+void
+load_esp0(uintptr_t esp0) {
+c010366d:	55                   	push   %ebp
+c010366e:	89 e5                	mov    %esp,%ebp
+    ts.ts_esp0 = esp0;
+c0103670:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103673:	a3 a4 0f 1b c0       	mov    %eax,0xc01b0fa4
+}
+c0103678:	90                   	nop
+c0103679:	5d                   	pop    %ebp
+c010367a:	c3                   	ret    
+
+c010367b <gdt_init>:
+
+/* gdt_init - initialize the default GDT and TSS */
+static void
+gdt_init(void) {
+c010367b:	55                   	push   %ebp
+c010367c:	89 e5                	mov    %esp,%ebp
+c010367e:	83 ec 10             	sub    $0x10,%esp
+    // set boot kernel stack and default SS0
+    load_esp0((uintptr_t)bootstacktop);
+c0103681:	b8 00 c0 12 c0       	mov    $0xc012c000,%eax
+c0103686:	50                   	push   %eax
+c0103687:	e8 e1 ff ff ff       	call   c010366d <load_esp0>
+c010368c:	83 c4 04             	add    $0x4,%esp
+    ts.ts_ss0 = KERNEL_DS;
+c010368f:	66 c7 05 a8 0f 1b c0 	movw   $0x10,0xc01b0fa8
+c0103696:	10 00 
+
+    // initialize the TSS filed of the gdt
+    gdt[SEG_TSS] = SEGTSS(STS_T32A, (uintptr_t)&ts, sizeof(ts), DPL_KERNEL);
+c0103698:	66 c7 05 28 ca 12 c0 	movw   $0x68,0xc012ca28
+c010369f:	68 00 
+c01036a1:	b8 a0 0f 1b c0       	mov    $0xc01b0fa0,%eax
+c01036a6:	66 a3 2a ca 12 c0    	mov    %ax,0xc012ca2a
+c01036ac:	b8 a0 0f 1b c0       	mov    $0xc01b0fa0,%eax
+c01036b1:	c1 e8 10             	shr    $0x10,%eax
+c01036b4:	a2 2c ca 12 c0       	mov    %al,0xc012ca2c
+c01036b9:	0f b6 05 2d ca 12 c0 	movzbl 0xc012ca2d,%eax
+c01036c0:	83 e0 f0             	and    $0xfffffff0,%eax
+c01036c3:	83 c8 09             	or     $0x9,%eax
+c01036c6:	a2 2d ca 12 c0       	mov    %al,0xc012ca2d
+c01036cb:	0f b6 05 2d ca 12 c0 	movzbl 0xc012ca2d,%eax
+c01036d2:	83 e0 ef             	and    $0xffffffef,%eax
+c01036d5:	a2 2d ca 12 c0       	mov    %al,0xc012ca2d
+c01036da:	0f b6 05 2d ca 12 c0 	movzbl 0xc012ca2d,%eax
+c01036e1:	83 e0 9f             	and    $0xffffff9f,%eax
+c01036e4:	a2 2d ca 12 c0       	mov    %al,0xc012ca2d
+c01036e9:	0f b6 05 2d ca 12 c0 	movzbl 0xc012ca2d,%eax
+c01036f0:	83 c8 80             	or     $0xffffff80,%eax
+c01036f3:	a2 2d ca 12 c0       	mov    %al,0xc012ca2d
+c01036f8:	0f b6 05 2e ca 12 c0 	movzbl 0xc012ca2e,%eax
+c01036ff:	83 e0 f0             	and    $0xfffffff0,%eax
+c0103702:	a2 2e ca 12 c0       	mov    %al,0xc012ca2e
+c0103707:	0f b6 05 2e ca 12 c0 	movzbl 0xc012ca2e,%eax
+c010370e:	83 e0 ef             	and    $0xffffffef,%eax
+c0103711:	a2 2e ca 12 c0       	mov    %al,0xc012ca2e
+c0103716:	0f b6 05 2e ca 12 c0 	movzbl 0xc012ca2e,%eax
+c010371d:	83 e0 df             	and    $0xffffffdf,%eax
+c0103720:	a2 2e ca 12 c0       	mov    %al,0xc012ca2e
+c0103725:	0f b6 05 2e ca 12 c0 	movzbl 0xc012ca2e,%eax
+c010372c:	83 c8 40             	or     $0x40,%eax
+c010372f:	a2 2e ca 12 c0       	mov    %al,0xc012ca2e
+c0103734:	0f b6 05 2e ca 12 c0 	movzbl 0xc012ca2e,%eax
+c010373b:	83 e0 7f             	and    $0x7f,%eax
+c010373e:	a2 2e ca 12 c0       	mov    %al,0xc012ca2e
+c0103743:	b8 a0 0f 1b c0       	mov    $0xc01b0fa0,%eax
+c0103748:	c1 e8 18             	shr    $0x18,%eax
+c010374b:	a2 2f ca 12 c0       	mov    %al,0xc012ca2f
+
+    // reload all segment registers
+    lgdt(&gdt_pd);
+c0103750:	68 30 ca 12 c0       	push   $0xc012ca30
+c0103755:	e8 dd fe ff ff       	call   c0103637 <lgdt>
+c010375a:	83 c4 04             	add    $0x4,%esp
+c010375d:	66 c7 45 fe 28 00    	movw   $0x28,-0x2(%ebp)
+    asm volatile ("cli" ::: "memory");
+}
+
+static inline void
+ltr(uint16_t sel) {
+    asm volatile ("ltr %0" :: "r" (sel) : "memory");
+c0103763:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
+c0103767:	0f 00 d8             	ltr    %ax
+
+    // load the TSS
+    ltr(GD_TSS);
+}
+c010376a:	90                   	nop
+c010376b:	c9                   	leave  
+c010376c:	c3                   	ret    
+
+c010376d <init_pmm_manager>:
+
+//init_pmm_manager - initialize a pmm_manager instance
+static void
+init_pmm_manager(void) {
+c010376d:	55                   	push   %ebp
+c010376e:	89 e5                	mov    %esp,%ebp
+c0103770:	83 ec 08             	sub    $0x8,%esp
+    pmm_manager = &default_pmm_manager;
+c0103773:	c7 05 7c 30 1b c0 60 	movl   $0xc010d860,0xc01b307c
+c010377a:	d8 10 c0 
+    cprintf("memory management: %s\n", pmm_manager->name);
+c010377d:	a1 7c 30 1b c0       	mov    0xc01b307c,%eax
+c0103782:	8b 00                	mov    (%eax),%eax
+c0103784:	83 ec 08             	sub    $0x8,%esp
+c0103787:	50                   	push   %eax
+c0103788:	68 f0 c2 10 c0       	push   $0xc010c2f0
+c010378d:	e8 fd ca ff ff       	call   c010028f <cprintf>
+c0103792:	83 c4 10             	add    $0x10,%esp
+    pmm_manager->init();
+c0103795:	a1 7c 30 1b c0       	mov    0xc01b307c,%eax
+c010379a:	8b 40 04             	mov    0x4(%eax),%eax
+c010379d:	ff d0                	call   *%eax
+}
+c010379f:	90                   	nop
+c01037a0:	c9                   	leave  
+c01037a1:	c3                   	ret    
+
+c01037a2 <init_memmap>:
+
+//init_memmap - call pmm->init_memmap to build Page struct for free memory  
+static void
+init_memmap(struct Page *base, size_t n) {
+c01037a2:	55                   	push   %ebp
+c01037a3:	89 e5                	mov    %esp,%ebp
+c01037a5:	83 ec 08             	sub    $0x8,%esp
+    pmm_manager->init_memmap(base, n);
+c01037a8:	a1 7c 30 1b c0       	mov    0xc01b307c,%eax
+c01037ad:	8b 40 08             	mov    0x8(%eax),%eax
+c01037b0:	83 ec 08             	sub    $0x8,%esp
+c01037b3:	ff 75 0c             	pushl  0xc(%ebp)
+c01037b6:	ff 75 08             	pushl  0x8(%ebp)
+c01037b9:	ff d0                	call   *%eax
+c01037bb:	83 c4 10             	add    $0x10,%esp
+}
+c01037be:	90                   	nop
+c01037bf:	c9                   	leave  
+c01037c0:	c3                   	ret    
+
+c01037c1 <alloc_pages>:
+
+//alloc_pages - call pmm->alloc_pages to allocate a continuous n*PAGESIZE memory 
+struct Page *
+alloc_pages(size_t n) {
+c01037c1:	55                   	push   %ebp
+c01037c2:	89 e5                	mov    %esp,%ebp
+c01037c4:	83 ec 18             	sub    $0x18,%esp
+    struct Page *page=NULL;
+c01037c7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    bool intr_flag;
+    
+    while (1)
+    {
+         local_intr_save(intr_flag);
+c01037ce:	e8 26 fe ff ff       	call   c01035f9 <__intr_save>
+c01037d3:	89 45 f0             	mov    %eax,-0x10(%ebp)
+         {
+              page = pmm_manager->alloc_pages(n);
+c01037d6:	a1 7c 30 1b c0       	mov    0xc01b307c,%eax
+c01037db:	8b 40 0c             	mov    0xc(%eax),%eax
+c01037de:	83 ec 0c             	sub    $0xc,%esp
+c01037e1:	ff 75 08             	pushl  0x8(%ebp)
+c01037e4:	ff d0                	call   *%eax
+c01037e6:	83 c4 10             	add    $0x10,%esp
+c01037e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
+         }
+         local_intr_restore(intr_flag);
+c01037ec:	83 ec 0c             	sub    $0xc,%esp
+c01037ef:	ff 75 f0             	pushl  -0x10(%ebp)
+c01037f2:	e8 2c fe ff ff       	call   c0103623 <__intr_restore>
+c01037f7:	83 c4 10             	add    $0x10,%esp
+
+         if (page != NULL || n > 1 || swap_init_ok == 0) break;
+c01037fa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c01037fe:	75 28                	jne    c0103828 <alloc_pages+0x67>
+c0103800:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
+c0103804:	77 22                	ja     c0103828 <alloc_pages+0x67>
+c0103806:	a1 14 10 1b c0       	mov    0xc01b1014,%eax
+c010380b:	85 c0                	test   %eax,%eax
+c010380d:	74 19                	je     c0103828 <alloc_pages+0x67>
+         
+         extern struct mm_struct *check_mm_struct;
+         //cprintf("page %x, call swap_out in alloc_pages %d\n",page, n);
+         swap_out(check_mm_struct, n, 0);
+c010380f:	8b 55 08             	mov    0x8(%ebp),%edx
+c0103812:	a1 90 30 1b c0       	mov    0xc01b3090,%eax
+c0103817:	83 ec 04             	sub    $0x4,%esp
+c010381a:	6a 00                	push   $0x0
+c010381c:	52                   	push   %edx
+c010381d:	50                   	push   %eax
+c010381e:	e8 7f 36 00 00       	call   c0106ea2 <swap_out>
+c0103823:	83 c4 10             	add    $0x10,%esp
+    }
+c0103826:	eb a6                	jmp    c01037ce <alloc_pages+0xd>
+    //cprintf("n %d,get page %x, No %d in alloc_pages\n",n,page,(page-pages));
+    return page;
+c0103828:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+c010382b:	c9                   	leave  
+c010382c:	c3                   	ret    
+
+c010382d <free_pages>:
+
+//free_pages - call pmm->free_pages to free a continuous n*PAGESIZE memory 
+void
+free_pages(struct Page *base, size_t n) {
+c010382d:	55                   	push   %ebp
+c010382e:	89 e5                	mov    %esp,%ebp
+c0103830:	83 ec 18             	sub    $0x18,%esp
+    bool intr_flag;
+    local_intr_save(intr_flag);
+c0103833:	e8 c1 fd ff ff       	call   c01035f9 <__intr_save>
+c0103838:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    {
+        pmm_manager->free_pages(base, n);
+c010383b:	a1 7c 30 1b c0       	mov    0xc01b307c,%eax
+c0103840:	8b 40 10             	mov    0x10(%eax),%eax
+c0103843:	83 ec 08             	sub    $0x8,%esp
+c0103846:	ff 75 0c             	pushl  0xc(%ebp)
+c0103849:	ff 75 08             	pushl  0x8(%ebp)
+c010384c:	ff d0                	call   *%eax
+c010384e:	83 c4 10             	add    $0x10,%esp
+    }
+    local_intr_restore(intr_flag);
+c0103851:	83 ec 0c             	sub    $0xc,%esp
+c0103854:	ff 75 f4             	pushl  -0xc(%ebp)
+c0103857:	e8 c7 fd ff ff       	call   c0103623 <__intr_restore>
+c010385c:	83 c4 10             	add    $0x10,%esp
+}
+c010385f:	90                   	nop
+c0103860:	c9                   	leave  
+c0103861:	c3                   	ret    
+
+c0103862 <nr_free_pages>:
+
+//nr_free_pages - call pmm->nr_free_pages to get the size (nr*PAGESIZE) 
+//of current free memory
+size_t
+nr_free_pages(void) {
+c0103862:	55                   	push   %ebp
+c0103863:	89 e5                	mov    %esp,%ebp
+c0103865:	83 ec 18             	sub    $0x18,%esp
+    size_t ret;
+    bool intr_flag;
+    local_intr_save(intr_flag);
+c0103868:	e8 8c fd ff ff       	call   c01035f9 <__intr_save>
+c010386d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    {
+        ret = pmm_manager->nr_free_pages();
+c0103870:	a1 7c 30 1b c0       	mov    0xc01b307c,%eax
+c0103875:	8b 40 14             	mov    0x14(%eax),%eax
+c0103878:	ff d0                	call   *%eax
+c010387a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    }
+    local_intr_restore(intr_flag);
+c010387d:	83 ec 0c             	sub    $0xc,%esp
+c0103880:	ff 75 f4             	pushl  -0xc(%ebp)
+c0103883:	e8 9b fd ff ff       	call   c0103623 <__intr_restore>
+c0103888:	83 c4 10             	add    $0x10,%esp
+    return ret;
+c010388b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+c010388e:	c9                   	leave  
+c010388f:	c3                   	ret    
+
+c0103890 <page_init>:
+
+/* pmm_init - initialize the physical memory management */
+static void
+page_init(void) {
+c0103890:	55                   	push   %ebp
+c0103891:	89 e5                	mov    %esp,%ebp
+c0103893:	57                   	push   %edi
+c0103894:	56                   	push   %esi
+c0103895:	53                   	push   %ebx
+c0103896:	83 ec 7c             	sub    $0x7c,%esp
+    struct e820map *memmap = (struct e820map *)(0x8000 + KERNBASE);
+c0103899:	c7 45 c4 00 80 00 c0 	movl   $0xc0008000,-0x3c(%ebp)
+    uint64_t maxpa = 0;
+c01038a0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
+c01038a7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+
+    cprintf("e820map:\n");
+c01038ae:	83 ec 0c             	sub    $0xc,%esp
+c01038b1:	68 07 c3 10 c0       	push   $0xc010c307
+c01038b6:	e8 d4 c9 ff ff       	call   c010028f <cprintf>
+c01038bb:	83 c4 10             	add    $0x10,%esp
+    int i;
+    for (i = 0; i < memmap->nr_map; i ++) {
+c01038be:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+c01038c5:	e9 fc 00 00 00       	jmp    c01039c6 <page_init+0x136>
+        uint64_t begin = memmap->map[i].addr, end = begin + memmap->map[i].size;
+c01038ca:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
+c01038cd:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c01038d0:	89 d0                	mov    %edx,%eax
+c01038d2:	c1 e0 02             	shl    $0x2,%eax
+c01038d5:	01 d0                	add    %edx,%eax
+c01038d7:	c1 e0 02             	shl    $0x2,%eax
+c01038da:	01 c8                	add    %ecx,%eax
+c01038dc:	8b 50 08             	mov    0x8(%eax),%edx
+c01038df:	8b 40 04             	mov    0x4(%eax),%eax
+c01038e2:	89 45 b8             	mov    %eax,-0x48(%ebp)
+c01038e5:	89 55 bc             	mov    %edx,-0x44(%ebp)
+c01038e8:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
+c01038eb:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c01038ee:	89 d0                	mov    %edx,%eax
+c01038f0:	c1 e0 02             	shl    $0x2,%eax
+c01038f3:	01 d0                	add    %edx,%eax
+c01038f5:	c1 e0 02             	shl    $0x2,%eax
+c01038f8:	01 c8                	add    %ecx,%eax
+c01038fa:	8b 48 0c             	mov    0xc(%eax),%ecx
+c01038fd:	8b 58 10             	mov    0x10(%eax),%ebx
+c0103900:	8b 45 b8             	mov    -0x48(%ebp),%eax
+c0103903:	8b 55 bc             	mov    -0x44(%ebp),%edx
+c0103906:	01 c8                	add    %ecx,%eax
+c0103908:	11 da                	adc    %ebx,%edx
+c010390a:	89 45 b0             	mov    %eax,-0x50(%ebp)
+c010390d:	89 55 b4             	mov    %edx,-0x4c(%ebp)
+        cprintf("  memory: %08llx, [%08llx, %08llx], type = %d.\n",
+c0103910:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
+c0103913:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c0103916:	89 d0                	mov    %edx,%eax
+c0103918:	c1 e0 02             	shl    $0x2,%eax
+c010391b:	01 d0                	add    %edx,%eax
+c010391d:	c1 e0 02             	shl    $0x2,%eax
+c0103920:	01 c8                	add    %ecx,%eax
+c0103922:	83 c0 14             	add    $0x14,%eax
+c0103925:	8b 00                	mov    (%eax),%eax
+c0103927:	89 45 84             	mov    %eax,-0x7c(%ebp)
+c010392a:	8b 45 b0             	mov    -0x50(%ebp),%eax
+c010392d:	8b 55 b4             	mov    -0x4c(%ebp),%edx
+c0103930:	83 c0 ff             	add    $0xffffffff,%eax
+c0103933:	83 d2 ff             	adc    $0xffffffff,%edx
+c0103936:	89 c1                	mov    %eax,%ecx
+c0103938:	89 d3                	mov    %edx,%ebx
+c010393a:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+c010393d:	89 55 80             	mov    %edx,-0x80(%ebp)
+c0103940:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c0103943:	89 d0                	mov    %edx,%eax
+c0103945:	c1 e0 02             	shl    $0x2,%eax
+c0103948:	01 d0                	add    %edx,%eax
+c010394a:	c1 e0 02             	shl    $0x2,%eax
+c010394d:	03 45 80             	add    -0x80(%ebp),%eax
+c0103950:	8b 50 10             	mov    0x10(%eax),%edx
+c0103953:	8b 40 0c             	mov    0xc(%eax),%eax
+c0103956:	ff 75 84             	pushl  -0x7c(%ebp)
+c0103959:	53                   	push   %ebx
+c010395a:	51                   	push   %ecx
+c010395b:	ff 75 bc             	pushl  -0x44(%ebp)
+c010395e:	ff 75 b8             	pushl  -0x48(%ebp)
+c0103961:	52                   	push   %edx
+c0103962:	50                   	push   %eax
+c0103963:	68 14 c3 10 c0       	push   $0xc010c314
+c0103968:	e8 22 c9 ff ff       	call   c010028f <cprintf>
+c010396d:	83 c4 20             	add    $0x20,%esp
+                memmap->map[i].size, begin, end - 1, memmap->map[i].type);
+        if (memmap->map[i].type == E820_ARM) {
+c0103970:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
+c0103973:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c0103976:	89 d0                	mov    %edx,%eax
+c0103978:	c1 e0 02             	shl    $0x2,%eax
+c010397b:	01 d0                	add    %edx,%eax
+c010397d:	c1 e0 02             	shl    $0x2,%eax
+c0103980:	01 c8                	add    %ecx,%eax
+c0103982:	83 c0 14             	add    $0x14,%eax
+c0103985:	8b 00                	mov    (%eax),%eax
+c0103987:	83 f8 01             	cmp    $0x1,%eax
+c010398a:	75 36                	jne    c01039c2 <page_init+0x132>
+            if (maxpa < end && begin < KMEMSIZE) {
+c010398c:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c010398f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c0103992:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
+c0103995:	77 2b                	ja     c01039c2 <page_init+0x132>
+c0103997:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
+c010399a:	72 05                	jb     c01039a1 <page_init+0x111>
+c010399c:	3b 45 b0             	cmp    -0x50(%ebp),%eax
+c010399f:	73 21                	jae    c01039c2 <page_init+0x132>
+c01039a1:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
+c01039a5:	77 1b                	ja     c01039c2 <page_init+0x132>
+c01039a7:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
+c01039ab:	72 09                	jb     c01039b6 <page_init+0x126>
+c01039ad:	81 7d b8 ff ff ff 37 	cmpl   $0x37ffffff,-0x48(%ebp)
+c01039b4:	77 0c                	ja     c01039c2 <page_init+0x132>
+                maxpa = end;
+c01039b6:	8b 45 b0             	mov    -0x50(%ebp),%eax
+c01039b9:	8b 55 b4             	mov    -0x4c(%ebp),%edx
+c01039bc:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c01039bf:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+    struct e820map *memmap = (struct e820map *)(0x8000 + KERNBASE);
+    uint64_t maxpa = 0;
+
+    cprintf("e820map:\n");
+    int i;
+    for (i = 0; i < memmap->nr_map; i ++) {
+c01039c2:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
+c01039c6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+c01039c9:	8b 00                	mov    (%eax),%eax
+c01039cb:	3b 45 dc             	cmp    -0x24(%ebp),%eax
+c01039ce:	0f 8f f6 fe ff ff    	jg     c01038ca <page_init+0x3a>
+            if (maxpa < end && begin < KMEMSIZE) {
+                maxpa = end;
+            }
+        }
+    }
+    if (maxpa > KMEMSIZE) {
+c01039d4:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+c01039d8:	72 1d                	jb     c01039f7 <page_init+0x167>
+c01039da:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+c01039de:	77 09                	ja     c01039e9 <page_init+0x159>
+c01039e0:	81 7d e0 00 00 00 38 	cmpl   $0x38000000,-0x20(%ebp)
+c01039e7:	76 0e                	jbe    c01039f7 <page_init+0x167>
+        maxpa = KMEMSIZE;
+c01039e9:	c7 45 e0 00 00 00 38 	movl   $0x38000000,-0x20(%ebp)
+c01039f0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+    }
+
+    extern char end[];
+
+    npage = maxpa / PGSIZE;
+c01039f7:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c01039fa:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c01039fd:	0f ac d0 0c          	shrd   $0xc,%edx,%eax
+c0103a01:	c1 ea 0c             	shr    $0xc,%edx
+c0103a04:	a3 80 0f 1b c0       	mov    %eax,0xc01b0f80
+    pages = (struct Page *)ROUNDUP((void *)end, PGSIZE);
+c0103a09:	c7 45 ac 00 10 00 00 	movl   $0x1000,-0x54(%ebp)
+c0103a10:	b8 78 31 1b c0       	mov    $0xc01b3178,%eax
+c0103a15:	8d 50 ff             	lea    -0x1(%eax),%edx
+c0103a18:	8b 45 ac             	mov    -0x54(%ebp),%eax
+c0103a1b:	01 d0                	add    %edx,%eax
+c0103a1d:	89 45 a8             	mov    %eax,-0x58(%ebp)
+c0103a20:	8b 45 a8             	mov    -0x58(%ebp),%eax
+c0103a23:	ba 00 00 00 00       	mov    $0x0,%edx
+c0103a28:	f7 75 ac             	divl   -0x54(%ebp)
+c0103a2b:	8b 45 a8             	mov    -0x58(%ebp),%eax
+c0103a2e:	29 d0                	sub    %edx,%eax
+c0103a30:	a3 84 30 1b c0       	mov    %eax,0xc01b3084
+
+    for (i = 0; i < npage; i ++) {
+c0103a35:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+c0103a3c:	eb 27                	jmp    c0103a65 <page_init+0x1d5>
+        SetPageReserved(pages + i);
+c0103a3e:	a1 84 30 1b c0       	mov    0xc01b3084,%eax
+c0103a43:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c0103a46:	c1 e2 05             	shl    $0x5,%edx
+c0103a49:	01 d0                	add    %edx,%eax
+c0103a4b:	83 c0 04             	add    $0x4,%eax
+c0103a4e:	c7 45 90 00 00 00 00 	movl   $0x0,-0x70(%ebp)
+c0103a55:	89 45 8c             	mov    %eax,-0x74(%ebp)
+ * Note that @nr may be almost arbitrarily large; this function is not
+ * restricted to acting on a single-word quantity.
+ * */
+static inline void
+set_bit(int nr, volatile void *addr) {
+    asm volatile ("btsl %1, %0" :"=m" (*(volatile long *)addr) : "Ir" (nr));
+c0103a58:	8b 45 8c             	mov    -0x74(%ebp),%eax
+c0103a5b:	8b 55 90             	mov    -0x70(%ebp),%edx
+c0103a5e:	0f ab 10             	bts    %edx,(%eax)
+    extern char end[];
+
+    npage = maxpa / PGSIZE;
+    pages = (struct Page *)ROUNDUP((void *)end, PGSIZE);
+
+    for (i = 0; i < npage; i ++) {
+c0103a61:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
+c0103a65:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c0103a68:	a1 80 0f 1b c0       	mov    0xc01b0f80,%eax
+c0103a6d:	39 c2                	cmp    %eax,%edx
+c0103a6f:	72 cd                	jb     c0103a3e <page_init+0x1ae>
+        SetPageReserved(pages + i);
+    }
+
+    uintptr_t freemem = PADDR((uintptr_t)pages + sizeof(struct Page) * npage);
+c0103a71:	a1 80 0f 1b c0       	mov    0xc01b0f80,%eax
+c0103a76:	c1 e0 05             	shl    $0x5,%eax
+c0103a79:	89 c2                	mov    %eax,%edx
+c0103a7b:	a1 84 30 1b c0       	mov    0xc01b3084,%eax
+c0103a80:	01 d0                	add    %edx,%eax
+c0103a82:	89 45 a4             	mov    %eax,-0x5c(%ebp)
+c0103a85:	81 7d a4 ff ff ff bf 	cmpl   $0xbfffffff,-0x5c(%ebp)
+c0103a8c:	77 17                	ja     c0103aa5 <page_init+0x215>
+c0103a8e:	ff 75 a4             	pushl  -0x5c(%ebp)
+c0103a91:	68 44 c3 10 c0       	push   $0xc010c344
+c0103a96:	68 ea 00 00 00       	push   $0xea
+c0103a9b:	68 68 c3 10 c0       	push   $0xc010c368
+c0103aa0:	e8 50 c9 ff ff       	call   c01003f5 <__panic>
+c0103aa5:	8b 45 a4             	mov    -0x5c(%ebp),%eax
+c0103aa8:	05 00 00 00 40       	add    $0x40000000,%eax
+c0103aad:	89 45 a0             	mov    %eax,-0x60(%ebp)
+
+    for (i = 0; i < memmap->nr_map; i ++) {
+c0103ab0:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+c0103ab7:	e9 69 01 00 00       	jmp    c0103c25 <page_init+0x395>
+        uint64_t begin = memmap->map[i].addr, end = begin + memmap->map[i].size;
+c0103abc:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
+c0103abf:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c0103ac2:	89 d0                	mov    %edx,%eax
+c0103ac4:	c1 e0 02             	shl    $0x2,%eax
+c0103ac7:	01 d0                	add    %edx,%eax
+c0103ac9:	c1 e0 02             	shl    $0x2,%eax
+c0103acc:	01 c8                	add    %ecx,%eax
+c0103ace:	8b 50 08             	mov    0x8(%eax),%edx
+c0103ad1:	8b 40 04             	mov    0x4(%eax),%eax
+c0103ad4:	89 45 d0             	mov    %eax,-0x30(%ebp)
+c0103ad7:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+c0103ada:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
+c0103add:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c0103ae0:	89 d0                	mov    %edx,%eax
+c0103ae2:	c1 e0 02             	shl    $0x2,%eax
+c0103ae5:	01 d0                	add    %edx,%eax
+c0103ae7:	c1 e0 02             	shl    $0x2,%eax
+c0103aea:	01 c8                	add    %ecx,%eax
+c0103aec:	8b 48 0c             	mov    0xc(%eax),%ecx
+c0103aef:	8b 58 10             	mov    0x10(%eax),%ebx
+c0103af2:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c0103af5:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c0103af8:	01 c8                	add    %ecx,%eax
+c0103afa:	11 da                	adc    %ebx,%edx
+c0103afc:	89 45 c8             	mov    %eax,-0x38(%ebp)
+c0103aff:	89 55 cc             	mov    %edx,-0x34(%ebp)
+        if (memmap->map[i].type == E820_ARM) {
+c0103b02:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
+c0103b05:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c0103b08:	89 d0                	mov    %edx,%eax
+c0103b0a:	c1 e0 02             	shl    $0x2,%eax
+c0103b0d:	01 d0                	add    %edx,%eax
+c0103b0f:	c1 e0 02             	shl    $0x2,%eax
+c0103b12:	01 c8                	add    %ecx,%eax
+c0103b14:	83 c0 14             	add    $0x14,%eax
+c0103b17:	8b 00                	mov    (%eax),%eax
+c0103b19:	83 f8 01             	cmp    $0x1,%eax
+c0103b1c:	0f 85 ff 00 00 00    	jne    c0103c21 <page_init+0x391>
+            if (begin < freemem) {
+c0103b22:	8b 45 a0             	mov    -0x60(%ebp),%eax
+c0103b25:	ba 00 00 00 00       	mov    $0x0,%edx
+c0103b2a:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+c0103b2d:	72 17                	jb     c0103b46 <page_init+0x2b6>
+c0103b2f:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+c0103b32:	77 05                	ja     c0103b39 <page_init+0x2a9>
+c0103b34:	3b 45 d0             	cmp    -0x30(%ebp),%eax
+c0103b37:	76 0d                	jbe    c0103b46 <page_init+0x2b6>
+                begin = freemem;
+c0103b39:	8b 45 a0             	mov    -0x60(%ebp),%eax
+c0103b3c:	89 45 d0             	mov    %eax,-0x30(%ebp)
+c0103b3f:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
+            }
+            if (end > KMEMSIZE) {
+c0103b46:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
+c0103b4a:	72 1d                	jb     c0103b69 <page_init+0x2d9>
+c0103b4c:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
+c0103b50:	77 09                	ja     c0103b5b <page_init+0x2cb>
+c0103b52:	81 7d c8 00 00 00 38 	cmpl   $0x38000000,-0x38(%ebp)
+c0103b59:	76 0e                	jbe    c0103b69 <page_init+0x2d9>
+                end = KMEMSIZE;
+c0103b5b:	c7 45 c8 00 00 00 38 	movl   $0x38000000,-0x38(%ebp)
+c0103b62:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
+            }
+            if (begin < end) {
+c0103b69:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c0103b6c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c0103b6f:	3b 55 cc             	cmp    -0x34(%ebp),%edx
+c0103b72:	0f 87 a9 00 00 00    	ja     c0103c21 <page_init+0x391>
+c0103b78:	3b 55 cc             	cmp    -0x34(%ebp),%edx
+c0103b7b:	72 09                	jb     c0103b86 <page_init+0x2f6>
+c0103b7d:	3b 45 c8             	cmp    -0x38(%ebp),%eax
+c0103b80:	0f 83 9b 00 00 00    	jae    c0103c21 <page_init+0x391>
+                begin = ROUNDUP(begin, PGSIZE);
+c0103b86:	c7 45 9c 00 10 00 00 	movl   $0x1000,-0x64(%ebp)
+c0103b8d:	8b 55 d0             	mov    -0x30(%ebp),%edx
+c0103b90:	8b 45 9c             	mov    -0x64(%ebp),%eax
+c0103b93:	01 d0                	add    %edx,%eax
+c0103b95:	83 e8 01             	sub    $0x1,%eax
+c0103b98:	89 45 98             	mov    %eax,-0x68(%ebp)
+c0103b9b:	8b 45 98             	mov    -0x68(%ebp),%eax
+c0103b9e:	ba 00 00 00 00       	mov    $0x0,%edx
+c0103ba3:	f7 75 9c             	divl   -0x64(%ebp)
+c0103ba6:	8b 45 98             	mov    -0x68(%ebp),%eax
+c0103ba9:	29 d0                	sub    %edx,%eax
+c0103bab:	ba 00 00 00 00       	mov    $0x0,%edx
+c0103bb0:	89 45 d0             	mov    %eax,-0x30(%ebp)
+c0103bb3:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+                end = ROUNDDOWN(end, PGSIZE);
+c0103bb6:	8b 45 c8             	mov    -0x38(%ebp),%eax
+c0103bb9:	89 45 94             	mov    %eax,-0x6c(%ebp)
+c0103bbc:	8b 45 94             	mov    -0x6c(%ebp),%eax
+c0103bbf:	ba 00 00 00 00       	mov    $0x0,%edx
+c0103bc4:	89 c3                	mov    %eax,%ebx
+c0103bc6:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
+c0103bcc:	89 de                	mov    %ebx,%esi
+c0103bce:	89 d0                	mov    %edx,%eax
+c0103bd0:	83 e0 00             	and    $0x0,%eax
+c0103bd3:	89 c7                	mov    %eax,%edi
+c0103bd5:	89 75 c8             	mov    %esi,-0x38(%ebp)
+c0103bd8:	89 7d cc             	mov    %edi,-0x34(%ebp)
+                if (begin < end) {
+c0103bdb:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c0103bde:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c0103be1:	3b 55 cc             	cmp    -0x34(%ebp),%edx
+c0103be4:	77 3b                	ja     c0103c21 <page_init+0x391>
+c0103be6:	3b 55 cc             	cmp    -0x34(%ebp),%edx
+c0103be9:	72 05                	jb     c0103bf0 <page_init+0x360>
+c0103beb:	3b 45 c8             	cmp    -0x38(%ebp),%eax
+c0103bee:	73 31                	jae    c0103c21 <page_init+0x391>
+                    init_memmap(pa2page(begin), (end - begin) / PGSIZE);
+c0103bf0:	8b 45 c8             	mov    -0x38(%ebp),%eax
+c0103bf3:	8b 55 cc             	mov    -0x34(%ebp),%edx
+c0103bf6:	2b 45 d0             	sub    -0x30(%ebp),%eax
+c0103bf9:	1b 55 d4             	sbb    -0x2c(%ebp),%edx
+c0103bfc:	0f ac d0 0c          	shrd   $0xc,%edx,%eax
+c0103c00:	c1 ea 0c             	shr    $0xc,%edx
+c0103c03:	89 c3                	mov    %eax,%ebx
+c0103c05:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c0103c08:	83 ec 0c             	sub    $0xc,%esp
+c0103c0b:	50                   	push   %eax
+c0103c0c:	e8 ca f8 ff ff       	call   c01034db <pa2page>
+c0103c11:	83 c4 10             	add    $0x10,%esp
+c0103c14:	83 ec 08             	sub    $0x8,%esp
+c0103c17:	53                   	push   %ebx
+c0103c18:	50                   	push   %eax
+c0103c19:	e8 84 fb ff ff       	call   c01037a2 <init_memmap>
+c0103c1e:	83 c4 10             	add    $0x10,%esp
+        SetPageReserved(pages + i);
+    }
+
+    uintptr_t freemem = PADDR((uintptr_t)pages + sizeof(struct Page) * npage);
+
+    for (i = 0; i < memmap->nr_map; i ++) {
+c0103c21:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
+c0103c25:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+c0103c28:	8b 00                	mov    (%eax),%eax
+c0103c2a:	3b 45 dc             	cmp    -0x24(%ebp),%eax
+c0103c2d:	0f 8f 89 fe ff ff    	jg     c0103abc <page_init+0x22c>
+                    init_memmap(pa2page(begin), (end - begin) / PGSIZE);
+                }
+            }
+        }
+    }
+}
+c0103c33:	90                   	nop
+c0103c34:	8d 65 f4             	lea    -0xc(%ebp),%esp
+c0103c37:	5b                   	pop    %ebx
+c0103c38:	5e                   	pop    %esi
+c0103c39:	5f                   	pop    %edi
+c0103c3a:	5d                   	pop    %ebp
+c0103c3b:	c3                   	ret    
+
+c0103c3c <boot_map_segment>:
+//  la:   linear address of this memory need to map (after x86 segment map)
+//  size: memory size
+//  pa:   physical address of this memory
+//  perm: permission of this memory  
+static void
+boot_map_segment(pde_t *pgdir, uintptr_t la, size_t size, uintptr_t pa, uint32_t perm) {
+c0103c3c:	55                   	push   %ebp
+c0103c3d:	89 e5                	mov    %esp,%ebp
+c0103c3f:	83 ec 28             	sub    $0x28,%esp
+    assert(PGOFF(la) == PGOFF(pa));
+c0103c42:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0103c45:	33 45 14             	xor    0x14(%ebp),%eax
+c0103c48:	25 ff 0f 00 00       	and    $0xfff,%eax
+c0103c4d:	85 c0                	test   %eax,%eax
+c0103c4f:	74 19                	je     c0103c6a <boot_map_segment+0x2e>
+c0103c51:	68 76 c3 10 c0       	push   $0xc010c376
+c0103c56:	68 8d c3 10 c0       	push   $0xc010c38d
+c0103c5b:	68 08 01 00 00       	push   $0x108
+c0103c60:	68 68 c3 10 c0       	push   $0xc010c368
+c0103c65:	e8 8b c7 ff ff       	call   c01003f5 <__panic>
+    size_t n = ROUNDUP(size + PGOFF(la), PGSIZE) / PGSIZE;
+c0103c6a:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
+c0103c71:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0103c74:	25 ff 0f 00 00       	and    $0xfff,%eax
+c0103c79:	89 c2                	mov    %eax,%edx
+c0103c7b:	8b 45 10             	mov    0x10(%ebp),%eax
+c0103c7e:	01 c2                	add    %eax,%edx
+c0103c80:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0103c83:	01 d0                	add    %edx,%eax
+c0103c85:	83 e8 01             	sub    $0x1,%eax
+c0103c88:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0103c8b:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0103c8e:	ba 00 00 00 00       	mov    $0x0,%edx
+c0103c93:	f7 75 f0             	divl   -0x10(%ebp)
+c0103c96:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0103c99:	29 d0                	sub    %edx,%eax
+c0103c9b:	c1 e8 0c             	shr    $0xc,%eax
+c0103c9e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    la = ROUNDDOWN(la, PGSIZE);
+c0103ca1:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0103ca4:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c0103ca7:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0103caa:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+c0103caf:	89 45 0c             	mov    %eax,0xc(%ebp)
+    pa = ROUNDDOWN(pa, PGSIZE);
+c0103cb2:	8b 45 14             	mov    0x14(%ebp),%eax
+c0103cb5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c0103cb8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0103cbb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+c0103cc0:	89 45 14             	mov    %eax,0x14(%ebp)
+    for (; n > 0; n --, la += PGSIZE, pa += PGSIZE) {
+c0103cc3:	eb 57                	jmp    c0103d1c <boot_map_segment+0xe0>
+        pte_t *ptep = get_pte(pgdir, la, 1);
+c0103cc5:	83 ec 04             	sub    $0x4,%esp
+c0103cc8:	6a 01                	push   $0x1
+c0103cca:	ff 75 0c             	pushl  0xc(%ebp)
+c0103ccd:	ff 75 08             	pushl  0x8(%ebp)
+c0103cd0:	e8 58 01 00 00       	call   c0103e2d <get_pte>
+c0103cd5:	83 c4 10             	add    $0x10,%esp
+c0103cd8:	89 45 e0             	mov    %eax,-0x20(%ebp)
+        assert(ptep != NULL);
+c0103cdb:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+c0103cdf:	75 19                	jne    c0103cfa <boot_map_segment+0xbe>
+c0103ce1:	68 a2 c3 10 c0       	push   $0xc010c3a2
+c0103ce6:	68 8d c3 10 c0       	push   $0xc010c38d
+c0103ceb:	68 0e 01 00 00       	push   $0x10e
+c0103cf0:	68 68 c3 10 c0       	push   $0xc010c368
+c0103cf5:	e8 fb c6 ff ff       	call   c01003f5 <__panic>
+        *ptep = pa | PTE_P | perm;
+c0103cfa:	8b 45 14             	mov    0x14(%ebp),%eax
+c0103cfd:	0b 45 18             	or     0x18(%ebp),%eax
+c0103d00:	83 c8 01             	or     $0x1,%eax
+c0103d03:	89 c2                	mov    %eax,%edx
+c0103d05:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0103d08:	89 10                	mov    %edx,(%eax)
+boot_map_segment(pde_t *pgdir, uintptr_t la, size_t size, uintptr_t pa, uint32_t perm) {
+    assert(PGOFF(la) == PGOFF(pa));
+    size_t n = ROUNDUP(size + PGOFF(la), PGSIZE) / PGSIZE;
+    la = ROUNDDOWN(la, PGSIZE);
+    pa = ROUNDDOWN(pa, PGSIZE);
+    for (; n > 0; n --, la += PGSIZE, pa += PGSIZE) {
+c0103d0a:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+c0103d0e:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
+c0103d15:	81 45 14 00 10 00 00 	addl   $0x1000,0x14(%ebp)
+c0103d1c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0103d20:	75 a3                	jne    c0103cc5 <boot_map_segment+0x89>
+        pte_t *ptep = get_pte(pgdir, la, 1);
+        assert(ptep != NULL);
+        *ptep = pa | PTE_P | perm;
+    }
+}
+c0103d22:	90                   	nop
+c0103d23:	c9                   	leave  
+c0103d24:	c3                   	ret    
+
+c0103d25 <boot_alloc_page>:
+
+//boot_alloc_page - allocate one page using pmm->alloc_pages(1) 
+// return value: the kernel virtual address of this allocated page
+//note: this function is used to get the memory for PDT(Page Directory Table)&PT(Page Table)
+static void *
+boot_alloc_page(void) {
+c0103d25:	55                   	push   %ebp
+c0103d26:	89 e5                	mov    %esp,%ebp
+c0103d28:	83 ec 18             	sub    $0x18,%esp
+    struct Page *p = alloc_page();
+c0103d2b:	83 ec 0c             	sub    $0xc,%esp
+c0103d2e:	6a 01                	push   $0x1
+c0103d30:	e8 8c fa ff ff       	call   c01037c1 <alloc_pages>
+c0103d35:	83 c4 10             	add    $0x10,%esp
+c0103d38:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if (p == NULL) {
+c0103d3b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0103d3f:	75 17                	jne    c0103d58 <boot_alloc_page+0x33>
+        panic("boot_alloc_page failed.\n");
+c0103d41:	83 ec 04             	sub    $0x4,%esp
+c0103d44:	68 af c3 10 c0       	push   $0xc010c3af
+c0103d49:	68 1a 01 00 00       	push   $0x11a
+c0103d4e:	68 68 c3 10 c0       	push   $0xc010c368
+c0103d53:	e8 9d c6 ff ff       	call   c01003f5 <__panic>
+    }
+    return page2kva(p);
+c0103d58:	83 ec 0c             	sub    $0xc,%esp
+c0103d5b:	ff 75 f4             	pushl  -0xc(%ebp)
+c0103d5e:	e8 b5 f7 ff ff       	call   c0103518 <page2kva>
+c0103d63:	83 c4 10             	add    $0x10,%esp
+}
+c0103d66:	c9                   	leave  
+c0103d67:	c3                   	ret    
+
+c0103d68 <pmm_init>:
+
+//pmm_init - setup a pmm to manage physical memory, build PDT&PT to setup paging mechanism 
+//         - check the correctness of pmm & paging mechanism, print PDT&PT
+void
+pmm_init(void) {
+c0103d68:	55                   	push   %ebp
+c0103d69:	89 e5                	mov    %esp,%ebp
+c0103d6b:	83 ec 18             	sub    $0x18,%esp
+    // We've already enabled paging
+    boot_cr3 = PADDR(boot_pgdir);
+c0103d6e:	a1 e0 c9 12 c0       	mov    0xc012c9e0,%eax
+c0103d73:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0103d76:	81 7d f4 ff ff ff bf 	cmpl   $0xbfffffff,-0xc(%ebp)
+c0103d7d:	77 17                	ja     c0103d96 <pmm_init+0x2e>
+c0103d7f:	ff 75 f4             	pushl  -0xc(%ebp)
+c0103d82:	68 44 c3 10 c0       	push   $0xc010c344
+c0103d87:	68 24 01 00 00       	push   $0x124
+c0103d8c:	68 68 c3 10 c0       	push   $0xc010c368
+c0103d91:	e8 5f c6 ff ff       	call   c01003f5 <__panic>
+c0103d96:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0103d99:	05 00 00 00 40       	add    $0x40000000,%eax
+c0103d9e:	a3 80 30 1b c0       	mov    %eax,0xc01b3080
+    //We need to alloc/free the physical memory (granularity is 4KB or other size). 
+    //So a framework of physical memory manager (struct pmm_manager)is defined in pmm.h
+    //First we should init a physical memory manager(pmm) based on the framework.
+    //Then pmm can alloc/free the physical memory. 
+    //Now the first_fit/best_fit/worst_fit/buddy_system pmm are available.
+    init_pmm_manager();
+c0103da3:	e8 c5 f9 ff ff       	call   c010376d <init_pmm_manager>
+
+    // detect physical memory space, reserve already used memory,
+    // then use pmm->init_memmap to create free page list
+    page_init();
+c0103da8:	e8 e3 fa ff ff       	call   c0103890 <page_init>
+
+    //use pmm->check to verify the correctness of the alloc/free function in a pmm
+    check_alloc_page();
+c0103dad:	e8 e6 07 00 00       	call   c0104598 <check_alloc_page>
+
+    check_pgdir();
+c0103db2:	e8 04 08 00 00       	call   c01045bb <check_pgdir>
+
+    static_assert(KERNBASE % PTSIZE == 0 && KERNTOP % PTSIZE == 0);
+
+    // recursively insert boot_pgdir in itself
+    // to form a virtual page table at virtual address VPT
+    boot_pgdir[PDX(VPT)] = PADDR(boot_pgdir) | PTE_P | PTE_W;
+c0103db7:	a1 e0 c9 12 c0       	mov    0xc012c9e0,%eax
+c0103dbc:	8d 90 ac 0f 00 00    	lea    0xfac(%eax),%edx
+c0103dc2:	a1 e0 c9 12 c0       	mov    0xc012c9e0,%eax
+c0103dc7:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0103dca:	81 7d f0 ff ff ff bf 	cmpl   $0xbfffffff,-0x10(%ebp)
+c0103dd1:	77 17                	ja     c0103dea <pmm_init+0x82>
+c0103dd3:	ff 75 f0             	pushl  -0x10(%ebp)
+c0103dd6:	68 44 c3 10 c0       	push   $0xc010c344
+c0103ddb:	68 3a 01 00 00       	push   $0x13a
+c0103de0:	68 68 c3 10 c0       	push   $0xc010c368
+c0103de5:	e8 0b c6 ff ff       	call   c01003f5 <__panic>
+c0103dea:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0103ded:	05 00 00 00 40       	add    $0x40000000,%eax
+c0103df2:	83 c8 03             	or     $0x3,%eax
+c0103df5:	89 02                	mov    %eax,(%edx)
+
+    // map all physical memory to linear memory with base linear addr KERNBASE
+    // linear_addr KERNBASE ~ KERNBASE + KMEMSIZE = phy_addr 0 ~ KMEMSIZE
+    boot_map_segment(boot_pgdir, KERNBASE, KMEMSIZE, 0, PTE_W);
+c0103df7:	a1 e0 c9 12 c0       	mov    0xc012c9e0,%eax
+c0103dfc:	83 ec 0c             	sub    $0xc,%esp
+c0103dff:	6a 02                	push   $0x2
+c0103e01:	6a 00                	push   $0x0
+c0103e03:	68 00 00 00 38       	push   $0x38000000
+c0103e08:	68 00 00 00 c0       	push   $0xc0000000
+c0103e0d:	50                   	push   %eax
+c0103e0e:	e8 29 fe ff ff       	call   c0103c3c <boot_map_segment>
+c0103e13:	83 c4 20             	add    $0x20,%esp
+
+    // Since we are using bootloader's GDT,
+    // we should reload gdt (second time, the last time) to get user segments and the TSS
+    // map virtual_addr 0 ~ 4G = linear_addr 0 ~ 4G
+    // then set kernel stack (ss:esp) in TSS, setup TSS in gdt, load TSS
+    gdt_init();
+c0103e16:	e8 60 f8 ff ff       	call   c010367b <gdt_init>
+
+    //now the basic virtual memory map(see memalyout.h) is established.
+    //check the correctness of the basic virtual memory map.
+    check_boot_pgdir();
+c0103e1b:	e8 01 0d 00 00       	call   c0104b21 <check_boot_pgdir>
+
+    print_pgdir();
+c0103e20:	e8 f7 10 00 00       	call   c0104f1c <print_pgdir>
+    
+    kmalloc_init();
+c0103e25:	e8 42 2c 00 00       	call   c0106a6c <kmalloc_init>
+
+}
+c0103e2a:	90                   	nop
+c0103e2b:	c9                   	leave  
+c0103e2c:	c3                   	ret    
+
+c0103e2d <get_pte>:
+//  pgdir:  the kernel virtual base address of PDT
+//  la:     the linear address need to map
+//  create: a logical value to decide if alloc a page for PT
+// return vaule: the kernel virtual address of this pte
+pte_t *
+get_pte(pde_t *pgdir, uintptr_t la, bool create) {
+c0103e2d:	55                   	push   %ebp
+c0103e2e:	89 e5                	mov    %esp,%ebp
+c0103e30:	83 ec 28             	sub    $0x28,%esp
+     * DEFINEs:
+     *   PTE_P           0x001                   // page table/directory entry flags bit : Present
+     *   PTE_W           0x002                   // page table/directory entry flags bit : Writeable
+     *   PTE_U           0x004                   // page table/directory entry flags bit : User can access
+     */
+    pde_t *pdep = &pgdir[PDX(la)];   // (1) find page directory entry
+c0103e33:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0103e36:	c1 e8 16             	shr    $0x16,%eax
+c0103e39:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+c0103e40:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103e43:	01 d0                	add    %edx,%eax
+c0103e45:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    struct Page *page;
+    if (!(*pdep & PTE_P) ) {              // (2) check if entry is not present
+c0103e48:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0103e4b:	8b 00                	mov    (%eax),%eax
+c0103e4d:	83 e0 01             	and    $0x1,%eax
+c0103e50:	85 c0                	test   %eax,%eax
+c0103e52:	0f 85 9f 00 00 00    	jne    c0103ef7 <get_pte+0xca>
+        if (!create || (page = alloc_page()) == NULL) {
+c0103e58:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+c0103e5c:	74 16                	je     c0103e74 <get_pte+0x47>
+c0103e5e:	83 ec 0c             	sub    $0xc,%esp
+c0103e61:	6a 01                	push   $0x1
+c0103e63:	e8 59 f9 ff ff       	call   c01037c1 <alloc_pages>
+c0103e68:	83 c4 10             	add    $0x10,%esp
+c0103e6b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0103e6e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c0103e72:	75 0a                	jne    c0103e7e <get_pte+0x51>
+            return NULL;
+c0103e74:	b8 00 00 00 00       	mov    $0x0,%eax
+c0103e79:	e9 ca 00 00 00       	jmp    c0103f48 <get_pte+0x11b>
+        }     // (3) check if creating is needed, then alloc page for page table
+              // CAUTION: this page is used for page table, not for common data page
+        set_page_ref(page, 1);       // (4) set page reference
+c0103e7e:	83 ec 08             	sub    $0x8,%esp
+c0103e81:	6a 01                	push   $0x1
+c0103e83:	ff 75 f0             	pushl  -0x10(%ebp)
+c0103e86:	e8 32 f7 ff ff       	call   c01035bd <set_page_ref>
+c0103e8b:	83 c4 10             	add    $0x10,%esp
+        uintptr_t pa = page2pa(page); // (5) get linear address of page
+c0103e8e:	83 ec 0c             	sub    $0xc,%esp
+c0103e91:	ff 75 f0             	pushl  -0x10(%ebp)
+c0103e94:	e8 2f f6 ff ff       	call   c01034c8 <page2pa>
+c0103e99:	83 c4 10             	add    $0x10,%esp
+c0103e9c:	89 45 ec             	mov    %eax,-0x14(%ebp)
+        memset(KADDR(pa),0,PGSIZE);                  // (6) clear page content using memset
+c0103e9f:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0103ea2:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c0103ea5:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0103ea8:	c1 e8 0c             	shr    $0xc,%eax
+c0103eab:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c0103eae:	a1 80 0f 1b c0       	mov    0xc01b0f80,%eax
+c0103eb3:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
+c0103eb6:	72 17                	jb     c0103ecf <get_pte+0xa2>
+c0103eb8:	ff 75 e8             	pushl  -0x18(%ebp)
+c0103ebb:	68 a0 c2 10 c0       	push   $0xc010c2a0
+c0103ec0:	68 77 01 00 00       	push   $0x177
+c0103ec5:	68 68 c3 10 c0       	push   $0xc010c368
+c0103eca:	e8 26 c5 ff ff       	call   c01003f5 <__panic>
+c0103ecf:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0103ed2:	2d 00 00 00 40       	sub    $0x40000000,%eax
+c0103ed7:	83 ec 04             	sub    $0x4,%esp
+c0103eda:	68 00 10 00 00       	push   $0x1000
+c0103edf:	6a 00                	push   $0x0
+c0103ee1:	50                   	push   %eax
+c0103ee2:	e8 71 71 00 00       	call   c010b058 <memset>
+c0103ee7:	83 c4 10             	add    $0x10,%esp
+        *pdep = pa | PTE_U | PTE_W | PTE_P;                  // (7) set page directory entry's permission
+c0103eea:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0103eed:	83 c8 07             	or     $0x7,%eax
+c0103ef0:	89 c2                	mov    %eax,%edx
+c0103ef2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0103ef5:	89 10                	mov    %edx,(%eax)
+    }
+    return &((pte_t *)KADDR(PDE_ADDR(*pdep)))[PTX(la)];          // (8) return page table entry
+c0103ef7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0103efa:	8b 00                	mov    (%eax),%eax
+c0103efc:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+c0103f01:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c0103f04:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0103f07:	c1 e8 0c             	shr    $0xc,%eax
+c0103f0a:	89 45 dc             	mov    %eax,-0x24(%ebp)
+c0103f0d:	a1 80 0f 1b c0       	mov    0xc01b0f80,%eax
+c0103f12:	39 45 dc             	cmp    %eax,-0x24(%ebp)
+c0103f15:	72 17                	jb     c0103f2e <get_pte+0x101>
+c0103f17:	ff 75 e0             	pushl  -0x20(%ebp)
+c0103f1a:	68 a0 c2 10 c0       	push   $0xc010c2a0
+c0103f1f:	68 7a 01 00 00       	push   $0x17a
+c0103f24:	68 68 c3 10 c0       	push   $0xc010c368
+c0103f29:	e8 c7 c4 ff ff       	call   c01003f5 <__panic>
+c0103f2e:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0103f31:	2d 00 00 00 40       	sub    $0x40000000,%eax
+c0103f36:	89 c2                	mov    %eax,%edx
+c0103f38:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0103f3b:	c1 e8 0c             	shr    $0xc,%eax
+c0103f3e:	25 ff 03 00 00       	and    $0x3ff,%eax
+c0103f43:	c1 e0 02             	shl    $0x2,%eax
+c0103f46:	01 d0                	add    %edx,%eax
+
+}
+c0103f48:	c9                   	leave  
+c0103f49:	c3                   	ret    
+
+c0103f4a <get_page>:
+
+//get_page - get related Page struct for linear address la using PDT pgdir
+struct Page *
+get_page(pde_t *pgdir, uintptr_t la, pte_t **ptep_store) {
+c0103f4a:	55                   	push   %ebp
+c0103f4b:	89 e5                	mov    %esp,%ebp
+c0103f4d:	83 ec 18             	sub    $0x18,%esp
+    pte_t *ptep = get_pte(pgdir, la, 0);
+c0103f50:	83 ec 04             	sub    $0x4,%esp
+c0103f53:	6a 00                	push   $0x0
+c0103f55:	ff 75 0c             	pushl  0xc(%ebp)
+c0103f58:	ff 75 08             	pushl  0x8(%ebp)
+c0103f5b:	e8 cd fe ff ff       	call   c0103e2d <get_pte>
+c0103f60:	83 c4 10             	add    $0x10,%esp
+c0103f63:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if (ptep_store != NULL) {
+c0103f66:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+c0103f6a:	74 08                	je     c0103f74 <get_page+0x2a>
+        *ptep_store = ptep;
+c0103f6c:	8b 45 10             	mov    0x10(%ebp),%eax
+c0103f6f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0103f72:	89 10                	mov    %edx,(%eax)
+    }
+    if (ptep != NULL && *ptep & PTE_P) {
+c0103f74:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0103f78:	74 1f                	je     c0103f99 <get_page+0x4f>
+c0103f7a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0103f7d:	8b 00                	mov    (%eax),%eax
+c0103f7f:	83 e0 01             	and    $0x1,%eax
+c0103f82:	85 c0                	test   %eax,%eax
+c0103f84:	74 13                	je     c0103f99 <get_page+0x4f>
+        return pte2page(*ptep);
+c0103f86:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0103f89:	8b 00                	mov    (%eax),%eax
+c0103f8b:	83 ec 0c             	sub    $0xc,%esp
+c0103f8e:	50                   	push   %eax
+c0103f8f:	e8 c9 f5 ff ff       	call   c010355d <pte2page>
+c0103f94:	83 c4 10             	add    $0x10,%esp
+c0103f97:	eb 05                	jmp    c0103f9e <get_page+0x54>
+    }
+    return NULL;
+c0103f99:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c0103f9e:	c9                   	leave  
+c0103f9f:	c3                   	ret    
+
+c0103fa0 <page_remove_pte>:
+
+//page_remove_pte - free an Page sturct which is related linear address la
+//                - and clean(invalidate) pte which is related linear address la
+//note: PT is changed, so the TLB need to be invalidate 
+static inline void
+page_remove_pte(pde_t *pgdir, uintptr_t la, pte_t *ptep) {
+c0103fa0:	55                   	push   %ebp
+c0103fa1:	89 e5                	mov    %esp,%ebp
+c0103fa3:	83 ec 18             	sub    $0x18,%esp
+     *   tlb_invalidate(pde_t *pgdir, uintptr_t la) : Invalidate a TLB entry, but only if the page tables being
+     *                        edited are the ones currently in use by the processor.
+     * DEFINEs:
+     *   PTE_P           0x001                   // page table/directory entry flags bit : Present
+     */
+    if (*ptep & PTE_P) {
+c0103fa6:	8b 45 10             	mov    0x10(%ebp),%eax
+c0103fa9:	8b 00                	mov    (%eax),%eax
+c0103fab:	83 e0 01             	and    $0x1,%eax
+c0103fae:	85 c0                	test   %eax,%eax
+c0103fb0:	74 50                	je     c0104002 <page_remove_pte+0x62>
+        struct Page *page = pte2page(*ptep);
+c0103fb2:	8b 45 10             	mov    0x10(%ebp),%eax
+c0103fb5:	8b 00                	mov    (%eax),%eax
+c0103fb7:	83 ec 0c             	sub    $0xc,%esp
+c0103fba:	50                   	push   %eax
+c0103fbb:	e8 9d f5 ff ff       	call   c010355d <pte2page>
+c0103fc0:	83 c4 10             	add    $0x10,%esp
+c0103fc3:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        if (page_ref_dec(page) == 0) {
+c0103fc6:	83 ec 0c             	sub    $0xc,%esp
+c0103fc9:	ff 75 f4             	pushl  -0xc(%ebp)
+c0103fcc:	e8 11 f6 ff ff       	call   c01035e2 <page_ref_dec>
+c0103fd1:	83 c4 10             	add    $0x10,%esp
+c0103fd4:	85 c0                	test   %eax,%eax
+c0103fd6:	75 10                	jne    c0103fe8 <page_remove_pte+0x48>
+            free_page(page);
+c0103fd8:	83 ec 08             	sub    $0x8,%esp
+c0103fdb:	6a 01                	push   $0x1
+c0103fdd:	ff 75 f4             	pushl  -0xc(%ebp)
+c0103fe0:	e8 48 f8 ff ff       	call   c010382d <free_pages>
+c0103fe5:	83 c4 10             	add    $0x10,%esp
+        }
+        *ptep = 0;
+c0103fe8:	8b 45 10             	mov    0x10(%ebp),%eax
+c0103feb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+        tlb_invalidate(pgdir, la);
+c0103ff1:	83 ec 08             	sub    $0x8,%esp
+c0103ff4:	ff 75 0c             	pushl  0xc(%ebp)
+c0103ff7:	ff 75 08             	pushl  0x8(%ebp)
+c0103ffa:	e8 98 04 00 00       	call   c0104497 <tlb_invalidate>
+c0103fff:	83 c4 10             	add    $0x10,%esp
+    }
+}
+c0104002:	90                   	nop
+c0104003:	c9                   	leave  
+c0104004:	c3                   	ret    
+
+c0104005 <unmap_range>:
+
+void
+unmap_range(pde_t *pgdir, uintptr_t start, uintptr_t end) {
+c0104005:	55                   	push   %ebp
+c0104006:	89 e5                	mov    %esp,%ebp
+c0104008:	83 ec 18             	sub    $0x18,%esp
+    assert(start % PGSIZE == 0 && end % PGSIZE == 0);
+c010400b:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010400e:	25 ff 0f 00 00       	and    $0xfff,%eax
+c0104013:	85 c0                	test   %eax,%eax
+c0104015:	75 0c                	jne    c0104023 <unmap_range+0x1e>
+c0104017:	8b 45 10             	mov    0x10(%ebp),%eax
+c010401a:	25 ff 0f 00 00       	and    $0xfff,%eax
+c010401f:	85 c0                	test   %eax,%eax
+c0104021:	74 19                	je     c010403c <unmap_range+0x37>
+c0104023:	68 c8 c3 10 c0       	push   $0xc010c3c8
+c0104028:	68 8d c3 10 c0       	push   $0xc010c38d
+c010402d:	68 ac 01 00 00       	push   $0x1ac
+c0104032:	68 68 c3 10 c0       	push   $0xc010c368
+c0104037:	e8 b9 c3 ff ff       	call   c01003f5 <__panic>
+    assert(USER_ACCESS(start, end));
+c010403c:	81 7d 0c ff ff 1f 00 	cmpl   $0x1fffff,0xc(%ebp)
+c0104043:	76 11                	jbe    c0104056 <unmap_range+0x51>
+c0104045:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0104048:	3b 45 10             	cmp    0x10(%ebp),%eax
+c010404b:	73 09                	jae    c0104056 <unmap_range+0x51>
+c010404d:	81 7d 10 00 00 00 b0 	cmpl   $0xb0000000,0x10(%ebp)
+c0104054:	76 19                	jbe    c010406f <unmap_range+0x6a>
+c0104056:	68 f1 c3 10 c0       	push   $0xc010c3f1
+c010405b:	68 8d c3 10 c0       	push   $0xc010c38d
+c0104060:	68 ad 01 00 00       	push   $0x1ad
+c0104065:	68 68 c3 10 c0       	push   $0xc010c368
+c010406a:	e8 86 c3 ff ff       	call   c01003f5 <__panic>
+
+    do {
+        pte_t *ptep = get_pte(pgdir, start, 0);
+c010406f:	83 ec 04             	sub    $0x4,%esp
+c0104072:	6a 00                	push   $0x0
+c0104074:	ff 75 0c             	pushl  0xc(%ebp)
+c0104077:	ff 75 08             	pushl  0x8(%ebp)
+c010407a:	e8 ae fd ff ff       	call   c0103e2d <get_pte>
+c010407f:	83 c4 10             	add    $0x10,%esp
+c0104082:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        if (ptep == NULL) {
+c0104085:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0104089:	75 18                	jne    c01040a3 <unmap_range+0x9e>
+            start = ROUNDDOWN(start + PTSIZE, PTSIZE);
+c010408b:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010408e:	05 00 00 40 00       	add    $0x400000,%eax
+c0104093:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0104096:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0104099:	25 00 00 c0 ff       	and    $0xffc00000,%eax
+c010409e:	89 45 0c             	mov    %eax,0xc(%ebp)
+            continue ;
+c01040a1:	eb 24                	jmp    c01040c7 <unmap_range+0xc2>
+        }
+        if (*ptep != 0) {
+c01040a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01040a6:	8b 00                	mov    (%eax),%eax
+c01040a8:	85 c0                	test   %eax,%eax
+c01040aa:	74 14                	je     c01040c0 <unmap_range+0xbb>
+            page_remove_pte(pgdir, start, ptep);
+c01040ac:	83 ec 04             	sub    $0x4,%esp
+c01040af:	ff 75 f4             	pushl  -0xc(%ebp)
+c01040b2:	ff 75 0c             	pushl  0xc(%ebp)
+c01040b5:	ff 75 08             	pushl  0x8(%ebp)
+c01040b8:	e8 e3 fe ff ff       	call   c0103fa0 <page_remove_pte>
+c01040bd:	83 c4 10             	add    $0x10,%esp
+        }
+        start += PGSIZE;
+c01040c0:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
+    } while (start != 0 && start < end);
+c01040c7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+c01040cb:	74 08                	je     c01040d5 <unmap_range+0xd0>
+c01040cd:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01040d0:	3b 45 10             	cmp    0x10(%ebp),%eax
+c01040d3:	72 9a                	jb     c010406f <unmap_range+0x6a>
+}
+c01040d5:	90                   	nop
+c01040d6:	c9                   	leave  
+c01040d7:	c3                   	ret    
+
+c01040d8 <exit_range>:
+
+void
+exit_range(pde_t *pgdir, uintptr_t start, uintptr_t end) {
+c01040d8:	55                   	push   %ebp
+c01040d9:	89 e5                	mov    %esp,%ebp
+c01040db:	83 ec 18             	sub    $0x18,%esp
+    assert(start % PGSIZE == 0 && end % PGSIZE == 0);
+c01040de:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01040e1:	25 ff 0f 00 00       	and    $0xfff,%eax
+c01040e6:	85 c0                	test   %eax,%eax
+c01040e8:	75 0c                	jne    c01040f6 <exit_range+0x1e>
+c01040ea:	8b 45 10             	mov    0x10(%ebp),%eax
+c01040ed:	25 ff 0f 00 00       	and    $0xfff,%eax
+c01040f2:	85 c0                	test   %eax,%eax
+c01040f4:	74 19                	je     c010410f <exit_range+0x37>
+c01040f6:	68 c8 c3 10 c0       	push   $0xc010c3c8
+c01040fb:	68 8d c3 10 c0       	push   $0xc010c38d
+c0104100:	68 be 01 00 00       	push   $0x1be
+c0104105:	68 68 c3 10 c0       	push   $0xc010c368
+c010410a:	e8 e6 c2 ff ff       	call   c01003f5 <__panic>
+    assert(USER_ACCESS(start, end));
+c010410f:	81 7d 0c ff ff 1f 00 	cmpl   $0x1fffff,0xc(%ebp)
+c0104116:	76 11                	jbe    c0104129 <exit_range+0x51>
+c0104118:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010411b:	3b 45 10             	cmp    0x10(%ebp),%eax
+c010411e:	73 09                	jae    c0104129 <exit_range+0x51>
+c0104120:	81 7d 10 00 00 00 b0 	cmpl   $0xb0000000,0x10(%ebp)
+c0104127:	76 19                	jbe    c0104142 <exit_range+0x6a>
+c0104129:	68 f1 c3 10 c0       	push   $0xc010c3f1
+c010412e:	68 8d c3 10 c0       	push   $0xc010c38d
+c0104133:	68 bf 01 00 00       	push   $0x1bf
+c0104138:	68 68 c3 10 c0       	push   $0xc010c368
+c010413d:	e8 b3 c2 ff ff       	call   c01003f5 <__panic>
+
+    start = ROUNDDOWN(start, PTSIZE);
+c0104142:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0104145:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0104148:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010414b:	25 00 00 c0 ff       	and    $0xffc00000,%eax
+c0104150:	89 45 0c             	mov    %eax,0xc(%ebp)
+    do {
+        int pde_idx = PDX(start);
+c0104153:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0104156:	c1 e8 16             	shr    $0x16,%eax
+c0104159:	89 45 f0             	mov    %eax,-0x10(%ebp)
+        if (pgdir[pde_idx] & PTE_P) {
+c010415c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010415f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+c0104166:	8b 45 08             	mov    0x8(%ebp),%eax
+c0104169:	01 d0                	add    %edx,%eax
+c010416b:	8b 00                	mov    (%eax),%eax
+c010416d:	83 e0 01             	and    $0x1,%eax
+c0104170:	85 c0                	test   %eax,%eax
+c0104172:	74 40                	je     c01041b4 <exit_range+0xdc>
+            free_page(pde2page(pgdir[pde_idx]));
+c0104174:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0104177:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+c010417e:	8b 45 08             	mov    0x8(%ebp),%eax
+c0104181:	01 d0                	add    %edx,%eax
+c0104183:	8b 00                	mov    (%eax),%eax
+c0104185:	83 ec 0c             	sub    $0xc,%esp
+c0104188:	50                   	push   %eax
+c0104189:	e8 09 f4 ff ff       	call   c0103597 <pde2page>
+c010418e:	83 c4 10             	add    $0x10,%esp
+c0104191:	83 ec 08             	sub    $0x8,%esp
+c0104194:	6a 01                	push   $0x1
+c0104196:	50                   	push   %eax
+c0104197:	e8 91 f6 ff ff       	call   c010382d <free_pages>
+c010419c:	83 c4 10             	add    $0x10,%esp
+            pgdir[pde_idx] = 0;
+c010419f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01041a2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+c01041a9:	8b 45 08             	mov    0x8(%ebp),%eax
+c01041ac:	01 d0                	add    %edx,%eax
+c01041ae:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+        }
+        start += PTSIZE;
+c01041b4:	81 45 0c 00 00 40 00 	addl   $0x400000,0xc(%ebp)
+    } while (start != 0 && start < end);
+c01041bb:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+c01041bf:	74 08                	je     c01041c9 <exit_range+0xf1>
+c01041c1:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01041c4:	3b 45 10             	cmp    0x10(%ebp),%eax
+c01041c7:	72 8a                	jb     c0104153 <exit_range+0x7b>
+}
+c01041c9:	90                   	nop
+c01041ca:	c9                   	leave  
+c01041cb:	c3                   	ret    
+
+c01041cc <copy_range>:
+ * @share: flags to indicate to dup OR share. We just use dup method, so it didn't be used.
+ *
+ * CALL GRAPH: copy_mm-->dup_mmap-->copy_range
+ */
+int
+copy_range(pde_t *to, pde_t *from, uintptr_t start, uintptr_t end, bool share) {
+c01041cc:	55                   	push   %ebp
+c01041cd:	89 e5                	mov    %esp,%ebp
+c01041cf:	83 ec 38             	sub    $0x38,%esp
+    assert(start % PGSIZE == 0 && end % PGSIZE == 0);
+c01041d2:	8b 45 10             	mov    0x10(%ebp),%eax
+c01041d5:	25 ff 0f 00 00       	and    $0xfff,%eax
+c01041da:	85 c0                	test   %eax,%eax
+c01041dc:	75 0c                	jne    c01041ea <copy_range+0x1e>
+c01041de:	8b 45 14             	mov    0x14(%ebp),%eax
+c01041e1:	25 ff 0f 00 00       	and    $0xfff,%eax
+c01041e6:	85 c0                	test   %eax,%eax
+c01041e8:	74 19                	je     c0104203 <copy_range+0x37>
+c01041ea:	68 c8 c3 10 c0       	push   $0xc010c3c8
+c01041ef:	68 8d c3 10 c0       	push   $0xc010c38d
+c01041f4:	68 d4 01 00 00       	push   $0x1d4
+c01041f9:	68 68 c3 10 c0       	push   $0xc010c368
+c01041fe:	e8 f2 c1 ff ff       	call   c01003f5 <__panic>
+    assert(USER_ACCESS(start, end));
+c0104203:	81 7d 10 ff ff 1f 00 	cmpl   $0x1fffff,0x10(%ebp)
+c010420a:	76 11                	jbe    c010421d <copy_range+0x51>
+c010420c:	8b 45 10             	mov    0x10(%ebp),%eax
+c010420f:	3b 45 14             	cmp    0x14(%ebp),%eax
+c0104212:	73 09                	jae    c010421d <copy_range+0x51>
+c0104214:	81 7d 14 00 00 00 b0 	cmpl   $0xb0000000,0x14(%ebp)
+c010421b:	76 19                	jbe    c0104236 <copy_range+0x6a>
+c010421d:	68 f1 c3 10 c0       	push   $0xc010c3f1
+c0104222:	68 8d c3 10 c0       	push   $0xc010c38d
+c0104227:	68 d5 01 00 00       	push   $0x1d5
+c010422c:	68 68 c3 10 c0       	push   $0xc010c368
+c0104231:	e8 bf c1 ff ff       	call   c01003f5 <__panic>
+    // copy content by page unit.
+    do {
+        //call get_pte to find process A's pte according to the addr start
+        pte_t *ptep = get_pte(from, start, 0), *nptep;
+c0104236:	83 ec 04             	sub    $0x4,%esp
+c0104239:	6a 00                	push   $0x0
+c010423b:	ff 75 10             	pushl  0x10(%ebp)
+c010423e:	ff 75 0c             	pushl  0xc(%ebp)
+c0104241:	e8 e7 fb ff ff       	call   c0103e2d <get_pte>
+c0104246:	83 c4 10             	add    $0x10,%esp
+c0104249:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        if (ptep == NULL) {
+c010424c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0104250:	75 1b                	jne    c010426d <copy_range+0xa1>
+            start = ROUNDDOWN(start + PTSIZE, PTSIZE);
+c0104252:	8b 45 10             	mov    0x10(%ebp),%eax
+c0104255:	05 00 00 40 00       	add    $0x400000,%eax
+c010425a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c010425d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0104260:	25 00 00 c0 ff       	and    $0xffc00000,%eax
+c0104265:	89 45 10             	mov    %eax,0x10(%ebp)
+            continue ;
+c0104268:	e9 1f 01 00 00       	jmp    c010438c <copy_range+0x1c0>
+        }
+        //call get_pte to find process B's pte according to the addr start. If pte is NULL, just alloc a PT
+        if (*ptep & PTE_P) {
+c010426d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104270:	8b 00                	mov    (%eax),%eax
+c0104272:	83 e0 01             	and    $0x1,%eax
+c0104275:	85 c0                	test   %eax,%eax
+c0104277:	0f 84 08 01 00 00    	je     c0104385 <copy_range+0x1b9>
+            if ((nptep = get_pte(to, start, 1)) == NULL) {
+c010427d:	83 ec 04             	sub    $0x4,%esp
+c0104280:	6a 01                	push   $0x1
+c0104282:	ff 75 10             	pushl  0x10(%ebp)
+c0104285:	ff 75 08             	pushl  0x8(%ebp)
+c0104288:	e8 a0 fb ff ff       	call   c0103e2d <get_pte>
+c010428d:	83 c4 10             	add    $0x10,%esp
+c0104290:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0104293:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+c0104297:	75 0a                	jne    c01042a3 <copy_range+0xd7>
+                return -E_NO_MEM;
+c0104299:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
+c010429e:	e9 00 01 00 00       	jmp    c01043a3 <copy_range+0x1d7>
+            }
+            uint32_t perm = (*ptep & PTE_USER);
+c01042a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01042a6:	8b 00                	mov    (%eax),%eax
+c01042a8:	83 e0 07             	and    $0x7,%eax
+c01042ab:	89 45 e8             	mov    %eax,-0x18(%ebp)
+            //get page from ptep
+            struct Page *page = pte2page(*ptep);
+c01042ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01042b1:	8b 00                	mov    (%eax),%eax
+c01042b3:	83 ec 0c             	sub    $0xc,%esp
+c01042b6:	50                   	push   %eax
+c01042b7:	e8 a1 f2 ff ff       	call   c010355d <pte2page>
+c01042bc:	83 c4 10             	add    $0x10,%esp
+c01042bf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+            // alloc a page for process B
+            struct Page *npage=alloc_page();
+c01042c2:	83 ec 0c             	sub    $0xc,%esp
+c01042c5:	6a 01                	push   $0x1
+c01042c7:	e8 f5 f4 ff ff       	call   c01037c1 <alloc_pages>
+c01042cc:	83 c4 10             	add    $0x10,%esp
+c01042cf:	89 45 e0             	mov    %eax,-0x20(%ebp)
+            assert(page!=NULL);
+c01042d2:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+c01042d6:	75 19                	jne    c01042f1 <copy_range+0x125>
+c01042d8:	68 09 c4 10 c0       	push   $0xc010c409
+c01042dd:	68 8d c3 10 c0       	push   $0xc010c38d
+c01042e2:	68 e8 01 00 00       	push   $0x1e8
+c01042e7:	68 68 c3 10 c0       	push   $0xc010c368
+c01042ec:	e8 04 c1 ff ff       	call   c01003f5 <__panic>
+            assert(npage!=NULL);
+c01042f1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+c01042f5:	75 19                	jne    c0104310 <copy_range+0x144>
+c01042f7:	68 14 c4 10 c0       	push   $0xc010c414
+c01042fc:	68 8d c3 10 c0       	push   $0xc010c38d
+c0104301:	68 e9 01 00 00       	push   $0x1e9
+c0104306:	68 68 c3 10 c0       	push   $0xc010c368
+c010430b:	e8 e5 c0 ff ff       	call   c01003f5 <__panic>
+            int ret=0;
+c0104310:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+         * (1) find src_kvaddr: the kernel virtual address of page
+         * (2) find dst_kvaddr: the kernel virtual address of npage
+         * (3) memory copy from src_kvaddr to dst_kvaddr, size is PGSIZE
+         * (4) build the map of phy addr of  nage with the linear addr start
+         */
+            char *src_kvaddr = page2kva(page); 
+c0104317:	83 ec 0c             	sub    $0xc,%esp
+c010431a:	ff 75 e4             	pushl  -0x1c(%ebp)
+c010431d:	e8 f6 f1 ff ff       	call   c0103518 <page2kva>
+c0104322:	83 c4 10             	add    $0x10,%esp
+c0104325:	89 45 d8             	mov    %eax,-0x28(%ebp)
+            char *dst_kvaddr = page2kva(npage); 
+c0104328:	83 ec 0c             	sub    $0xc,%esp
+c010432b:	ff 75 e0             	pushl  -0x20(%ebp)
+c010432e:	e8 e5 f1 ff ff       	call   c0103518 <page2kva>
+c0104333:	83 c4 10             	add    $0x10,%esp
+c0104336:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+            memcpy(dst_kvaddr, src_kvaddr, PGSIZE); 
+c0104339:	83 ec 04             	sub    $0x4,%esp
+c010433c:	68 00 10 00 00       	push   $0x1000
+c0104341:	ff 75 d8             	pushl  -0x28(%ebp)
+c0104344:	ff 75 d4             	pushl  -0x2c(%ebp)
+c0104347:	e8 ef 6d 00 00       	call   c010b13b <memcpy>
+c010434c:	83 c4 10             	add    $0x10,%esp
+            ret = page_insert(to, npage, start, perm); 
+c010434f:	ff 75 e8             	pushl  -0x18(%ebp)
+c0104352:	ff 75 10             	pushl  0x10(%ebp)
+c0104355:	ff 75 e0             	pushl  -0x20(%ebp)
+c0104358:	ff 75 08             	pushl  0x8(%ebp)
+c010435b:	e8 7e 00 00 00       	call   c01043de <page_insert>
+c0104360:	83 c4 10             	add    $0x10,%esp
+c0104363:	89 45 dc             	mov    %eax,-0x24(%ebp)
+            assert(ret == 0);
+c0104366:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+c010436a:	74 19                	je     c0104385 <copy_range+0x1b9>
+c010436c:	68 20 c4 10 c0       	push   $0xc010c420
+c0104371:	68 8d c3 10 c0       	push   $0xc010c38d
+c0104376:	68 fd 01 00 00       	push   $0x1fd
+c010437b:	68 68 c3 10 c0       	push   $0xc010c368
+c0104380:	e8 70 c0 ff ff       	call   c01003f5 <__panic>
+        }
+        start += PGSIZE;
+c0104385:	81 45 10 00 10 00 00 	addl   $0x1000,0x10(%ebp)
+    } while (start != 0 && start < end);
+c010438c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+c0104390:	74 0c                	je     c010439e <copy_range+0x1d2>
+c0104392:	8b 45 10             	mov    0x10(%ebp),%eax
+c0104395:	3b 45 14             	cmp    0x14(%ebp),%eax
+c0104398:	0f 82 98 fe ff ff    	jb     c0104236 <copy_range+0x6a>
+    return 0;
+c010439e:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c01043a3:	c9                   	leave  
+c01043a4:	c3                   	ret    
+
+c01043a5 <page_remove>:
+
+//page_remove - free an Page which is related linear address la and has an validated pte
+void
+page_remove(pde_t *pgdir, uintptr_t la) {
+c01043a5:	55                   	push   %ebp
+c01043a6:	89 e5                	mov    %esp,%ebp
+c01043a8:	83 ec 18             	sub    $0x18,%esp
+    pte_t *ptep = get_pte(pgdir, la, 0);
+c01043ab:	83 ec 04             	sub    $0x4,%esp
+c01043ae:	6a 00                	push   $0x0
+c01043b0:	ff 75 0c             	pushl  0xc(%ebp)
+c01043b3:	ff 75 08             	pushl  0x8(%ebp)
+c01043b6:	e8 72 fa ff ff       	call   c0103e2d <get_pte>
+c01043bb:	83 c4 10             	add    $0x10,%esp
+c01043be:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if (ptep != NULL) {
+c01043c1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c01043c5:	74 14                	je     c01043db <page_remove+0x36>
+        page_remove_pte(pgdir, la, ptep);
+c01043c7:	83 ec 04             	sub    $0x4,%esp
+c01043ca:	ff 75 f4             	pushl  -0xc(%ebp)
+c01043cd:	ff 75 0c             	pushl  0xc(%ebp)
+c01043d0:	ff 75 08             	pushl  0x8(%ebp)
+c01043d3:	e8 c8 fb ff ff       	call   c0103fa0 <page_remove_pte>
+c01043d8:	83 c4 10             	add    $0x10,%esp
+    }
+}
+c01043db:	90                   	nop
+c01043dc:	c9                   	leave  
+c01043dd:	c3                   	ret    
+
+c01043de <page_insert>:
+//  la:    the linear address need to map
+//  perm:  the permission of this Page which is setted in related pte
+// return value: always 0
+//note: PT is changed, so the TLB need to be invalidate 
+int
+page_insert(pde_t *pgdir, struct Page *page, uintptr_t la, uint32_t perm) {
+c01043de:	55                   	push   %ebp
+c01043df:	89 e5                	mov    %esp,%ebp
+c01043e1:	83 ec 18             	sub    $0x18,%esp
+    pte_t *ptep = get_pte(pgdir, la, 1);
+c01043e4:	83 ec 04             	sub    $0x4,%esp
+c01043e7:	6a 01                	push   $0x1
+c01043e9:	ff 75 10             	pushl  0x10(%ebp)
+c01043ec:	ff 75 08             	pushl  0x8(%ebp)
+c01043ef:	e8 39 fa ff ff       	call   c0103e2d <get_pte>
+c01043f4:	83 c4 10             	add    $0x10,%esp
+c01043f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if (ptep == NULL) {
+c01043fa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c01043fe:	75 0a                	jne    c010440a <page_insert+0x2c>
+        return -E_NO_MEM;
+c0104400:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
+c0104405:	e9 8b 00 00 00       	jmp    c0104495 <page_insert+0xb7>
+    }
+    page_ref_inc(page);
+c010440a:	83 ec 0c             	sub    $0xc,%esp
+c010440d:	ff 75 0c             	pushl  0xc(%ebp)
+c0104410:	e8 b6 f1 ff ff       	call   c01035cb <page_ref_inc>
+c0104415:	83 c4 10             	add    $0x10,%esp
+    if (*ptep & PTE_P) {
+c0104418:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010441b:	8b 00                	mov    (%eax),%eax
+c010441d:	83 e0 01             	and    $0x1,%eax
+c0104420:	85 c0                	test   %eax,%eax
+c0104422:	74 40                	je     c0104464 <page_insert+0x86>
+        struct Page *p = pte2page(*ptep);
+c0104424:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104427:	8b 00                	mov    (%eax),%eax
+c0104429:	83 ec 0c             	sub    $0xc,%esp
+c010442c:	50                   	push   %eax
+c010442d:	e8 2b f1 ff ff       	call   c010355d <pte2page>
+c0104432:	83 c4 10             	add    $0x10,%esp
+c0104435:	89 45 f0             	mov    %eax,-0x10(%ebp)
+        if (p == page) {
+c0104438:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010443b:	3b 45 0c             	cmp    0xc(%ebp),%eax
+c010443e:	75 10                	jne    c0104450 <page_insert+0x72>
+            page_ref_dec(page);
+c0104440:	83 ec 0c             	sub    $0xc,%esp
+c0104443:	ff 75 0c             	pushl  0xc(%ebp)
+c0104446:	e8 97 f1 ff ff       	call   c01035e2 <page_ref_dec>
+c010444b:	83 c4 10             	add    $0x10,%esp
+c010444e:	eb 14                	jmp    c0104464 <page_insert+0x86>
+        }
+        else {
+            page_remove_pte(pgdir, la, ptep);
+c0104450:	83 ec 04             	sub    $0x4,%esp
+c0104453:	ff 75 f4             	pushl  -0xc(%ebp)
+c0104456:	ff 75 10             	pushl  0x10(%ebp)
+c0104459:	ff 75 08             	pushl  0x8(%ebp)
+c010445c:	e8 3f fb ff ff       	call   c0103fa0 <page_remove_pte>
+c0104461:	83 c4 10             	add    $0x10,%esp
+        }
+    }
+    *ptep = page2pa(page) | PTE_P | perm;
+c0104464:	83 ec 0c             	sub    $0xc,%esp
+c0104467:	ff 75 0c             	pushl  0xc(%ebp)
+c010446a:	e8 59 f0 ff ff       	call   c01034c8 <page2pa>
+c010446f:	83 c4 10             	add    $0x10,%esp
+c0104472:	0b 45 14             	or     0x14(%ebp),%eax
+c0104475:	83 c8 01             	or     $0x1,%eax
+c0104478:	89 c2                	mov    %eax,%edx
+c010447a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010447d:	89 10                	mov    %edx,(%eax)
+    tlb_invalidate(pgdir, la);
+c010447f:	83 ec 08             	sub    $0x8,%esp
+c0104482:	ff 75 10             	pushl  0x10(%ebp)
+c0104485:	ff 75 08             	pushl  0x8(%ebp)
+c0104488:	e8 0a 00 00 00       	call   c0104497 <tlb_invalidate>
+c010448d:	83 c4 10             	add    $0x10,%esp
+    return 0;
+c0104490:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c0104495:	c9                   	leave  
+c0104496:	c3                   	ret    
+
+c0104497 <tlb_invalidate>:
+
+// invalidate a TLB entry, but only if the page tables being
+// edited are the ones currently in use by the processor.
+void
+tlb_invalidate(pde_t *pgdir, uintptr_t la) {
+c0104497:	55                   	push   %ebp
+c0104498:	89 e5                	mov    %esp,%ebp
+c010449a:	83 ec 18             	sub    $0x18,%esp
+}
+
+static inline uintptr_t
+rcr3(void) {
+    uintptr_t cr3;
+    asm volatile ("mov %%cr3, %0" : "=r" (cr3) :: "memory");
+c010449d:	0f 20 d8             	mov    %cr3,%eax
+c01044a0:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    return cr3;
+c01044a3:	8b 55 ec             	mov    -0x14(%ebp),%edx
+    if (rcr3() == PADDR(pgdir)) {
+c01044a6:	8b 45 08             	mov    0x8(%ebp),%eax
+c01044a9:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c01044ac:	81 7d f0 ff ff ff bf 	cmpl   $0xbfffffff,-0x10(%ebp)
+c01044b3:	77 17                	ja     c01044cc <tlb_invalidate+0x35>
+c01044b5:	ff 75 f0             	pushl  -0x10(%ebp)
+c01044b8:	68 44 c3 10 c0       	push   $0xc010c344
+c01044bd:	68 2e 02 00 00       	push   $0x22e
+c01044c2:	68 68 c3 10 c0       	push   $0xc010c368
+c01044c7:	e8 29 bf ff ff       	call   c01003f5 <__panic>
+c01044cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01044cf:	05 00 00 00 40       	add    $0x40000000,%eax
+c01044d4:	39 c2                	cmp    %eax,%edx
+c01044d6:	75 0c                	jne    c01044e4 <tlb_invalidate+0x4d>
+        invlpg((void *)la);
+c01044d8:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01044db:	89 45 f4             	mov    %eax,-0xc(%ebp)
+}
+
+static inline void
+invlpg(void *addr) {
+    asm volatile ("invlpg (%0)" :: "r" (addr) : "memory");
+c01044de:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01044e1:	0f 01 38             	invlpg (%eax)
+    }
+}
+c01044e4:	90                   	nop
+c01044e5:	c9                   	leave  
+c01044e6:	c3                   	ret    
+
+c01044e7 <pgdir_alloc_page>:
+
+// pgdir_alloc_page - call alloc_page & page_insert functions to 
+//                  - allocate a page size memory & setup an addr map
+//                  - pa<->la with linear address la and the PDT pgdir
+struct Page *
+pgdir_alloc_page(pde_t *pgdir, uintptr_t la, uint32_t perm) {
+c01044e7:	55                   	push   %ebp
+c01044e8:	89 e5                	mov    %esp,%ebp
+c01044ea:	83 ec 18             	sub    $0x18,%esp
+    struct Page *page = alloc_page();
+c01044ed:	83 ec 0c             	sub    $0xc,%esp
+c01044f0:	6a 01                	push   $0x1
+c01044f2:	e8 ca f2 ff ff       	call   c01037c1 <alloc_pages>
+c01044f7:	83 c4 10             	add    $0x10,%esp
+c01044fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if (page != NULL) {
+c01044fd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0104501:	0f 84 8c 00 00 00    	je     c0104593 <pgdir_alloc_page+0xac>
+        if (page_insert(pgdir, page, la, perm) != 0) {
+c0104507:	ff 75 10             	pushl  0x10(%ebp)
+c010450a:	ff 75 0c             	pushl  0xc(%ebp)
+c010450d:	ff 75 f4             	pushl  -0xc(%ebp)
+c0104510:	ff 75 08             	pushl  0x8(%ebp)
+c0104513:	e8 c6 fe ff ff       	call   c01043de <page_insert>
+c0104518:	83 c4 10             	add    $0x10,%esp
+c010451b:	85 c0                	test   %eax,%eax
+c010451d:	74 17                	je     c0104536 <pgdir_alloc_page+0x4f>
+            free_page(page);
+c010451f:	83 ec 08             	sub    $0x8,%esp
+c0104522:	6a 01                	push   $0x1
+c0104524:	ff 75 f4             	pushl  -0xc(%ebp)
+c0104527:	e8 01 f3 ff ff       	call   c010382d <free_pages>
+c010452c:	83 c4 10             	add    $0x10,%esp
+            return NULL;
+c010452f:	b8 00 00 00 00       	mov    $0x0,%eax
+c0104534:	eb 60                	jmp    c0104596 <pgdir_alloc_page+0xaf>
+        }
+        if (swap_init_ok){
+c0104536:	a1 14 10 1b c0       	mov    0xc01b1014,%eax
+c010453b:	85 c0                	test   %eax,%eax
+c010453d:	74 54                	je     c0104593 <pgdir_alloc_page+0xac>
+            if(check_mm_struct!=NULL) {
+c010453f:	a1 90 30 1b c0       	mov    0xc01b3090,%eax
+c0104544:	85 c0                	test   %eax,%eax
+c0104546:	74 4b                	je     c0104593 <pgdir_alloc_page+0xac>
+                swap_map_swappable(check_mm_struct, la, page, 0);
+c0104548:	a1 90 30 1b c0       	mov    0xc01b3090,%eax
+c010454d:	6a 00                	push   $0x0
+c010454f:	ff 75 f4             	pushl  -0xc(%ebp)
+c0104552:	ff 75 0c             	pushl  0xc(%ebp)
+c0104555:	50                   	push   %eax
+c0104556:	e8 08 29 00 00       	call   c0106e63 <swap_map_swappable>
+c010455b:	83 c4 10             	add    $0x10,%esp
+                page->pra_vaddr=la;
+c010455e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104561:	8b 55 0c             	mov    0xc(%ebp),%edx
+c0104564:	89 50 1c             	mov    %edx,0x1c(%eax)
+                assert(page_ref(page) == 1);
+c0104567:	83 ec 0c             	sub    $0xc,%esp
+c010456a:	ff 75 f4             	pushl  -0xc(%ebp)
+c010456d:	e8 41 f0 ff ff       	call   c01035b3 <page_ref>
+c0104572:	83 c4 10             	add    $0x10,%esp
+c0104575:	83 f8 01             	cmp    $0x1,%eax
+c0104578:	74 19                	je     c0104593 <pgdir_alloc_page+0xac>
+c010457a:	68 29 c4 10 c0       	push   $0xc010c429
+c010457f:	68 8d c3 10 c0       	push   $0xc010c38d
+c0104584:	68 42 02 00 00       	push   $0x242
+c0104589:	68 68 c3 10 c0       	push   $0xc010c368
+c010458e:	e8 62 be ff ff       	call   c01003f5 <__panic>
+            }
+        }
+
+    }
+
+    return page;
+c0104593:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+c0104596:	c9                   	leave  
+c0104597:	c3                   	ret    
+
+c0104598 <check_alloc_page>:
+
+static void
+check_alloc_page(void) {
+c0104598:	55                   	push   %ebp
+c0104599:	89 e5                	mov    %esp,%ebp
+c010459b:	83 ec 08             	sub    $0x8,%esp
+    pmm_manager->check();
+c010459e:	a1 7c 30 1b c0       	mov    0xc01b307c,%eax
+c01045a3:	8b 40 18             	mov    0x18(%eax),%eax
+c01045a6:	ff d0                	call   *%eax
+    cprintf("check_alloc_page() succeeded!\n");
+c01045a8:	83 ec 0c             	sub    $0xc,%esp
+c01045ab:	68 40 c4 10 c0       	push   $0xc010c440
+c01045b0:	e8 da bc ff ff       	call   c010028f <cprintf>
+c01045b5:	83 c4 10             	add    $0x10,%esp
+}
+c01045b8:	90                   	nop
+c01045b9:	c9                   	leave  
+c01045ba:	c3                   	ret    
+
+c01045bb <check_pgdir>:
+
+static void
+check_pgdir(void) {
+c01045bb:	55                   	push   %ebp
+c01045bc:	89 e5                	mov    %esp,%ebp
+c01045be:	83 ec 28             	sub    $0x28,%esp
+    assert(npage <= KMEMSIZE / PGSIZE);
+c01045c1:	a1 80 0f 1b c0       	mov    0xc01b0f80,%eax
+c01045c6:	3d 00 80 03 00       	cmp    $0x38000,%eax
+c01045cb:	76 19                	jbe    c01045e6 <check_pgdir+0x2b>
+c01045cd:	68 5f c4 10 c0       	push   $0xc010c45f
+c01045d2:	68 8d c3 10 c0       	push   $0xc010c38d
+c01045d7:	68 5a 02 00 00       	push   $0x25a
+c01045dc:	68 68 c3 10 c0       	push   $0xc010c368
+c01045e1:	e8 0f be ff ff       	call   c01003f5 <__panic>
+    assert(boot_pgdir != NULL && (uint32_t)PGOFF(boot_pgdir) == 0);
+c01045e6:	a1 e0 c9 12 c0       	mov    0xc012c9e0,%eax
+c01045eb:	85 c0                	test   %eax,%eax
+c01045ed:	74 0e                	je     c01045fd <check_pgdir+0x42>
+c01045ef:	a1 e0 c9 12 c0       	mov    0xc012c9e0,%eax
+c01045f4:	25 ff 0f 00 00       	and    $0xfff,%eax
+c01045f9:	85 c0                	test   %eax,%eax
+c01045fb:	74 19                	je     c0104616 <check_pgdir+0x5b>
+c01045fd:	68 7c c4 10 c0       	push   $0xc010c47c
+c0104602:	68 8d c3 10 c0       	push   $0xc010c38d
+c0104607:	68 5b 02 00 00       	push   $0x25b
+c010460c:	68 68 c3 10 c0       	push   $0xc010c368
+c0104611:	e8 df bd ff ff       	call   c01003f5 <__panic>
+    assert(get_page(boot_pgdir, 0x0, NULL) == NULL);
+c0104616:	a1 e0 c9 12 c0       	mov    0xc012c9e0,%eax
+c010461b:	83 ec 04             	sub    $0x4,%esp
+c010461e:	6a 00                	push   $0x0
+c0104620:	6a 00                	push   $0x0
+c0104622:	50                   	push   %eax
+c0104623:	e8 22 f9 ff ff       	call   c0103f4a <get_page>
+c0104628:	83 c4 10             	add    $0x10,%esp
+c010462b:	85 c0                	test   %eax,%eax
+c010462d:	74 19                	je     c0104648 <check_pgdir+0x8d>
+c010462f:	68 b4 c4 10 c0       	push   $0xc010c4b4
+c0104634:	68 8d c3 10 c0       	push   $0xc010c38d
+c0104639:	68 5c 02 00 00       	push   $0x25c
+c010463e:	68 68 c3 10 c0       	push   $0xc010c368
+c0104643:	e8 ad bd ff ff       	call   c01003f5 <__panic>
+
+    struct Page *p1, *p2;
+    p1 = alloc_page();
+c0104648:	83 ec 0c             	sub    $0xc,%esp
+c010464b:	6a 01                	push   $0x1
+c010464d:	e8 6f f1 ff ff       	call   c01037c1 <alloc_pages>
+c0104652:	83 c4 10             	add    $0x10,%esp
+c0104655:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    assert(page_insert(boot_pgdir, p1, 0x0, 0) == 0);
+c0104658:	a1 e0 c9 12 c0       	mov    0xc012c9e0,%eax
+c010465d:	6a 00                	push   $0x0
+c010465f:	6a 00                	push   $0x0
+c0104661:	ff 75 f4             	pushl  -0xc(%ebp)
+c0104664:	50                   	push   %eax
+c0104665:	e8 74 fd ff ff       	call   c01043de <page_insert>
+c010466a:	83 c4 10             	add    $0x10,%esp
+c010466d:	85 c0                	test   %eax,%eax
+c010466f:	74 19                	je     c010468a <check_pgdir+0xcf>
+c0104671:	68 dc c4 10 c0       	push   $0xc010c4dc
+c0104676:	68 8d c3 10 c0       	push   $0xc010c38d
+c010467b:	68 60 02 00 00       	push   $0x260
+c0104680:	68 68 c3 10 c0       	push   $0xc010c368
+c0104685:	e8 6b bd ff ff       	call   c01003f5 <__panic>
+
+    pte_t *ptep;
+    assert((ptep = get_pte(boot_pgdir, 0x0, 0)) != NULL);
+c010468a:	a1 e0 c9 12 c0       	mov    0xc012c9e0,%eax
+c010468f:	83 ec 04             	sub    $0x4,%esp
+c0104692:	6a 00                	push   $0x0
+c0104694:	6a 00                	push   $0x0
+c0104696:	50                   	push   %eax
+c0104697:	e8 91 f7 ff ff       	call   c0103e2d <get_pte>
+c010469c:	83 c4 10             	add    $0x10,%esp
+c010469f:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c01046a2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c01046a6:	75 19                	jne    c01046c1 <check_pgdir+0x106>
+c01046a8:	68 08 c5 10 c0       	push   $0xc010c508
+c01046ad:	68 8d c3 10 c0       	push   $0xc010c38d
+c01046b2:	68 63 02 00 00       	push   $0x263
+c01046b7:	68 68 c3 10 c0       	push   $0xc010c368
+c01046bc:	e8 34 bd ff ff       	call   c01003f5 <__panic>
+    assert(pte2page(*ptep) == p1);
+c01046c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01046c4:	8b 00                	mov    (%eax),%eax
+c01046c6:	83 ec 0c             	sub    $0xc,%esp
+c01046c9:	50                   	push   %eax
+c01046ca:	e8 8e ee ff ff       	call   c010355d <pte2page>
+c01046cf:	83 c4 10             	add    $0x10,%esp
+c01046d2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+c01046d5:	74 19                	je     c01046f0 <check_pgdir+0x135>
+c01046d7:	68 35 c5 10 c0       	push   $0xc010c535
+c01046dc:	68 8d c3 10 c0       	push   $0xc010c38d
+c01046e1:	68 64 02 00 00       	push   $0x264
+c01046e6:	68 68 c3 10 c0       	push   $0xc010c368
+c01046eb:	e8 05 bd ff ff       	call   c01003f5 <__panic>
+    assert(page_ref(p1) == 1);
+c01046f0:	83 ec 0c             	sub    $0xc,%esp
+c01046f3:	ff 75 f4             	pushl  -0xc(%ebp)
+c01046f6:	e8 b8 ee ff ff       	call   c01035b3 <page_ref>
+c01046fb:	83 c4 10             	add    $0x10,%esp
+c01046fe:	83 f8 01             	cmp    $0x1,%eax
+c0104701:	74 19                	je     c010471c <check_pgdir+0x161>
+c0104703:	68 4b c5 10 c0       	push   $0xc010c54b
+c0104708:	68 8d c3 10 c0       	push   $0xc010c38d
+c010470d:	68 65 02 00 00       	push   $0x265
+c0104712:	68 68 c3 10 c0       	push   $0xc010c368
+c0104717:	e8 d9 bc ff ff       	call   c01003f5 <__panic>
+
+    ptep = &((pte_t *)KADDR(PDE_ADDR(boot_pgdir[0])))[1];
+c010471c:	a1 e0 c9 12 c0       	mov    0xc012c9e0,%eax
+c0104721:	8b 00                	mov    (%eax),%eax
+c0104723:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+c0104728:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c010472b:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010472e:	c1 e8 0c             	shr    $0xc,%eax
+c0104731:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c0104734:	a1 80 0f 1b c0       	mov    0xc01b0f80,%eax
+c0104739:	39 45 e8             	cmp    %eax,-0x18(%ebp)
+c010473c:	72 17                	jb     c0104755 <check_pgdir+0x19a>
+c010473e:	ff 75 ec             	pushl  -0x14(%ebp)
+c0104741:	68 a0 c2 10 c0       	push   $0xc010c2a0
+c0104746:	68 67 02 00 00       	push   $0x267
+c010474b:	68 68 c3 10 c0       	push   $0xc010c368
+c0104750:	e8 a0 bc ff ff       	call   c01003f5 <__panic>
+c0104755:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0104758:	2d 00 00 00 40       	sub    $0x40000000,%eax
+c010475d:	83 c0 04             	add    $0x4,%eax
+c0104760:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    assert(get_pte(boot_pgdir, PGSIZE, 0) == ptep);
+c0104763:	a1 e0 c9 12 c0       	mov    0xc012c9e0,%eax
+c0104768:	83 ec 04             	sub    $0x4,%esp
+c010476b:	6a 00                	push   $0x0
+c010476d:	68 00 10 00 00       	push   $0x1000
+c0104772:	50                   	push   %eax
+c0104773:	e8 b5 f6 ff ff       	call   c0103e2d <get_pte>
+c0104778:	83 c4 10             	add    $0x10,%esp
+c010477b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+c010477e:	74 19                	je     c0104799 <check_pgdir+0x1de>
+c0104780:	68 60 c5 10 c0       	push   $0xc010c560
+c0104785:	68 8d c3 10 c0       	push   $0xc010c38d
+c010478a:	68 68 02 00 00       	push   $0x268
+c010478f:	68 68 c3 10 c0       	push   $0xc010c368
+c0104794:	e8 5c bc ff ff       	call   c01003f5 <__panic>
+
+    p2 = alloc_page();
+c0104799:	83 ec 0c             	sub    $0xc,%esp
+c010479c:	6a 01                	push   $0x1
+c010479e:	e8 1e f0 ff ff       	call   c01037c1 <alloc_pages>
+c01047a3:	83 c4 10             	add    $0x10,%esp
+c01047a6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    assert(page_insert(boot_pgdir, p2, PGSIZE, PTE_U | PTE_W) == 0);
+c01047a9:	a1 e0 c9 12 c0       	mov    0xc012c9e0,%eax
+c01047ae:	6a 06                	push   $0x6
+c01047b0:	68 00 10 00 00       	push   $0x1000
+c01047b5:	ff 75 e4             	pushl  -0x1c(%ebp)
+c01047b8:	50                   	push   %eax
+c01047b9:	e8 20 fc ff ff       	call   c01043de <page_insert>
+c01047be:	83 c4 10             	add    $0x10,%esp
+c01047c1:	85 c0                	test   %eax,%eax
+c01047c3:	74 19                	je     c01047de <check_pgdir+0x223>
+c01047c5:	68 88 c5 10 c0       	push   $0xc010c588
+c01047ca:	68 8d c3 10 c0       	push   $0xc010c38d
+c01047cf:	68 6b 02 00 00       	push   $0x26b
+c01047d4:	68 68 c3 10 c0       	push   $0xc010c368
+c01047d9:	e8 17 bc ff ff       	call   c01003f5 <__panic>
+    assert((ptep = get_pte(boot_pgdir, PGSIZE, 0)) != NULL);
+c01047de:	a1 e0 c9 12 c0       	mov    0xc012c9e0,%eax
+c01047e3:	83 ec 04             	sub    $0x4,%esp
+c01047e6:	6a 00                	push   $0x0
+c01047e8:	68 00 10 00 00       	push   $0x1000
+c01047ed:	50                   	push   %eax
+c01047ee:	e8 3a f6 ff ff       	call   c0103e2d <get_pte>
+c01047f3:	83 c4 10             	add    $0x10,%esp
+c01047f6:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c01047f9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c01047fd:	75 19                	jne    c0104818 <check_pgdir+0x25d>
+c01047ff:	68 c0 c5 10 c0       	push   $0xc010c5c0
+c0104804:	68 8d c3 10 c0       	push   $0xc010c38d
+c0104809:	68 6c 02 00 00       	push   $0x26c
+c010480e:	68 68 c3 10 c0       	push   $0xc010c368
+c0104813:	e8 dd bb ff ff       	call   c01003f5 <__panic>
+    assert(*ptep & PTE_U);
+c0104818:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010481b:	8b 00                	mov    (%eax),%eax
+c010481d:	83 e0 04             	and    $0x4,%eax
+c0104820:	85 c0                	test   %eax,%eax
+c0104822:	75 19                	jne    c010483d <check_pgdir+0x282>
+c0104824:	68 f0 c5 10 c0       	push   $0xc010c5f0
+c0104829:	68 8d c3 10 c0       	push   $0xc010c38d
+c010482e:	68 6d 02 00 00       	push   $0x26d
+c0104833:	68 68 c3 10 c0       	push   $0xc010c368
+c0104838:	e8 b8 bb ff ff       	call   c01003f5 <__panic>
+    assert(*ptep & PTE_W);
+c010483d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0104840:	8b 00                	mov    (%eax),%eax
+c0104842:	83 e0 02             	and    $0x2,%eax
+c0104845:	85 c0                	test   %eax,%eax
+c0104847:	75 19                	jne    c0104862 <check_pgdir+0x2a7>
+c0104849:	68 fe c5 10 c0       	push   $0xc010c5fe
+c010484e:	68 8d c3 10 c0       	push   $0xc010c38d
+c0104853:	68 6e 02 00 00       	push   $0x26e
+c0104858:	68 68 c3 10 c0       	push   $0xc010c368
+c010485d:	e8 93 bb ff ff       	call   c01003f5 <__panic>
+    assert(boot_pgdir[0] & PTE_U);
+c0104862:	a1 e0 c9 12 c0       	mov    0xc012c9e0,%eax
+c0104867:	8b 00                	mov    (%eax),%eax
+c0104869:	83 e0 04             	and    $0x4,%eax
+c010486c:	85 c0                	test   %eax,%eax
+c010486e:	75 19                	jne    c0104889 <check_pgdir+0x2ce>
+c0104870:	68 0c c6 10 c0       	push   $0xc010c60c
+c0104875:	68 8d c3 10 c0       	push   $0xc010c38d
+c010487a:	68 6f 02 00 00       	push   $0x26f
+c010487f:	68 68 c3 10 c0       	push   $0xc010c368
+c0104884:	e8 6c bb ff ff       	call   c01003f5 <__panic>
+    assert(page_ref(p2) == 1);
+c0104889:	83 ec 0c             	sub    $0xc,%esp
+c010488c:	ff 75 e4             	pushl  -0x1c(%ebp)
+c010488f:	e8 1f ed ff ff       	call   c01035b3 <page_ref>
+c0104894:	83 c4 10             	add    $0x10,%esp
+c0104897:	83 f8 01             	cmp    $0x1,%eax
+c010489a:	74 19                	je     c01048b5 <check_pgdir+0x2fa>
+c010489c:	68 22 c6 10 c0       	push   $0xc010c622
+c01048a1:	68 8d c3 10 c0       	push   $0xc010c38d
+c01048a6:	68 70 02 00 00       	push   $0x270
+c01048ab:	68 68 c3 10 c0       	push   $0xc010c368
+c01048b0:	e8 40 bb ff ff       	call   c01003f5 <__panic>
+
+    assert(page_insert(boot_pgdir, p1, PGSIZE, 0) == 0);
+c01048b5:	a1 e0 c9 12 c0       	mov    0xc012c9e0,%eax
+c01048ba:	6a 00                	push   $0x0
+c01048bc:	68 00 10 00 00       	push   $0x1000
+c01048c1:	ff 75 f4             	pushl  -0xc(%ebp)
+c01048c4:	50                   	push   %eax
+c01048c5:	e8 14 fb ff ff       	call   c01043de <page_insert>
+c01048ca:	83 c4 10             	add    $0x10,%esp
+c01048cd:	85 c0                	test   %eax,%eax
+c01048cf:	74 19                	je     c01048ea <check_pgdir+0x32f>
+c01048d1:	68 34 c6 10 c0       	push   $0xc010c634
+c01048d6:	68 8d c3 10 c0       	push   $0xc010c38d
+c01048db:	68 72 02 00 00       	push   $0x272
+c01048e0:	68 68 c3 10 c0       	push   $0xc010c368
+c01048e5:	e8 0b bb ff ff       	call   c01003f5 <__panic>
+    assert(page_ref(p1) == 2);
+c01048ea:	83 ec 0c             	sub    $0xc,%esp
+c01048ed:	ff 75 f4             	pushl  -0xc(%ebp)
+c01048f0:	e8 be ec ff ff       	call   c01035b3 <page_ref>
+c01048f5:	83 c4 10             	add    $0x10,%esp
+c01048f8:	83 f8 02             	cmp    $0x2,%eax
+c01048fb:	74 19                	je     c0104916 <check_pgdir+0x35b>
+c01048fd:	68 60 c6 10 c0       	push   $0xc010c660
+c0104902:	68 8d c3 10 c0       	push   $0xc010c38d
+c0104907:	68 73 02 00 00       	push   $0x273
+c010490c:	68 68 c3 10 c0       	push   $0xc010c368
+c0104911:	e8 df ba ff ff       	call   c01003f5 <__panic>
+    assert(page_ref(p2) == 0);
+c0104916:	83 ec 0c             	sub    $0xc,%esp
+c0104919:	ff 75 e4             	pushl  -0x1c(%ebp)
+c010491c:	e8 92 ec ff ff       	call   c01035b3 <page_ref>
+c0104921:	83 c4 10             	add    $0x10,%esp
+c0104924:	85 c0                	test   %eax,%eax
+c0104926:	74 19                	je     c0104941 <check_pgdir+0x386>
+c0104928:	68 72 c6 10 c0       	push   $0xc010c672
+c010492d:	68 8d c3 10 c0       	push   $0xc010c38d
+c0104932:	68 74 02 00 00       	push   $0x274
+c0104937:	68 68 c3 10 c0       	push   $0xc010c368
+c010493c:	e8 b4 ba ff ff       	call   c01003f5 <__panic>
+    assert((ptep = get_pte(boot_pgdir, PGSIZE, 0)) != NULL);
+c0104941:	a1 e0 c9 12 c0       	mov    0xc012c9e0,%eax
+c0104946:	83 ec 04             	sub    $0x4,%esp
+c0104949:	6a 00                	push   $0x0
+c010494b:	68 00 10 00 00       	push   $0x1000
+c0104950:	50                   	push   %eax
+c0104951:	e8 d7 f4 ff ff       	call   c0103e2d <get_pte>
+c0104956:	83 c4 10             	add    $0x10,%esp
+c0104959:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c010495c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c0104960:	75 19                	jne    c010497b <check_pgdir+0x3c0>
+c0104962:	68 c0 c5 10 c0       	push   $0xc010c5c0
+c0104967:	68 8d c3 10 c0       	push   $0xc010c38d
+c010496c:	68 75 02 00 00       	push   $0x275
+c0104971:	68 68 c3 10 c0       	push   $0xc010c368
+c0104976:	e8 7a ba ff ff       	call   c01003f5 <__panic>
+    assert(pte2page(*ptep) == p1);
+c010497b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010497e:	8b 00                	mov    (%eax),%eax
+c0104980:	83 ec 0c             	sub    $0xc,%esp
+c0104983:	50                   	push   %eax
+c0104984:	e8 d4 eb ff ff       	call   c010355d <pte2page>
+c0104989:	83 c4 10             	add    $0x10,%esp
+c010498c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+c010498f:	74 19                	je     c01049aa <check_pgdir+0x3ef>
+c0104991:	68 35 c5 10 c0       	push   $0xc010c535
+c0104996:	68 8d c3 10 c0       	push   $0xc010c38d
+c010499b:	68 76 02 00 00       	push   $0x276
+c01049a0:	68 68 c3 10 c0       	push   $0xc010c368
+c01049a5:	e8 4b ba ff ff       	call   c01003f5 <__panic>
+    assert((*ptep & PTE_U) == 0);
+c01049aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01049ad:	8b 00                	mov    (%eax),%eax
+c01049af:	83 e0 04             	and    $0x4,%eax
+c01049b2:	85 c0                	test   %eax,%eax
+c01049b4:	74 19                	je     c01049cf <check_pgdir+0x414>
+c01049b6:	68 84 c6 10 c0       	push   $0xc010c684
+c01049bb:	68 8d c3 10 c0       	push   $0xc010c38d
+c01049c0:	68 77 02 00 00       	push   $0x277
+c01049c5:	68 68 c3 10 c0       	push   $0xc010c368
+c01049ca:	e8 26 ba ff ff       	call   c01003f5 <__panic>
+
+    page_remove(boot_pgdir, 0x0);
+c01049cf:	a1 e0 c9 12 c0       	mov    0xc012c9e0,%eax
+c01049d4:	83 ec 08             	sub    $0x8,%esp
+c01049d7:	6a 00                	push   $0x0
+c01049d9:	50                   	push   %eax
+c01049da:	e8 c6 f9 ff ff       	call   c01043a5 <page_remove>
+c01049df:	83 c4 10             	add    $0x10,%esp
+    assert(page_ref(p1) == 1);
+c01049e2:	83 ec 0c             	sub    $0xc,%esp
+c01049e5:	ff 75 f4             	pushl  -0xc(%ebp)
+c01049e8:	e8 c6 eb ff ff       	call   c01035b3 <page_ref>
+c01049ed:	83 c4 10             	add    $0x10,%esp
+c01049f0:	83 f8 01             	cmp    $0x1,%eax
+c01049f3:	74 19                	je     c0104a0e <check_pgdir+0x453>
+c01049f5:	68 4b c5 10 c0       	push   $0xc010c54b
+c01049fa:	68 8d c3 10 c0       	push   $0xc010c38d
+c01049ff:	68 7a 02 00 00       	push   $0x27a
+c0104a04:	68 68 c3 10 c0       	push   $0xc010c368
+c0104a09:	e8 e7 b9 ff ff       	call   c01003f5 <__panic>
+    assert(page_ref(p2) == 0);
+c0104a0e:	83 ec 0c             	sub    $0xc,%esp
+c0104a11:	ff 75 e4             	pushl  -0x1c(%ebp)
+c0104a14:	e8 9a eb ff ff       	call   c01035b3 <page_ref>
+c0104a19:	83 c4 10             	add    $0x10,%esp
+c0104a1c:	85 c0                	test   %eax,%eax
+c0104a1e:	74 19                	je     c0104a39 <check_pgdir+0x47e>
+c0104a20:	68 72 c6 10 c0       	push   $0xc010c672
+c0104a25:	68 8d c3 10 c0       	push   $0xc010c38d
+c0104a2a:	68 7b 02 00 00       	push   $0x27b
+c0104a2f:	68 68 c3 10 c0       	push   $0xc010c368
+c0104a34:	e8 bc b9 ff ff       	call   c01003f5 <__panic>
+
+    page_remove(boot_pgdir, PGSIZE);
+c0104a39:	a1 e0 c9 12 c0       	mov    0xc012c9e0,%eax
+c0104a3e:	83 ec 08             	sub    $0x8,%esp
+c0104a41:	68 00 10 00 00       	push   $0x1000
+c0104a46:	50                   	push   %eax
+c0104a47:	e8 59 f9 ff ff       	call   c01043a5 <page_remove>
+c0104a4c:	83 c4 10             	add    $0x10,%esp
+    assert(page_ref(p1) == 0);
+c0104a4f:	83 ec 0c             	sub    $0xc,%esp
+c0104a52:	ff 75 f4             	pushl  -0xc(%ebp)
+c0104a55:	e8 59 eb ff ff       	call   c01035b3 <page_ref>
+c0104a5a:	83 c4 10             	add    $0x10,%esp
+c0104a5d:	85 c0                	test   %eax,%eax
+c0104a5f:	74 19                	je     c0104a7a <check_pgdir+0x4bf>
+c0104a61:	68 99 c6 10 c0       	push   $0xc010c699
+c0104a66:	68 8d c3 10 c0       	push   $0xc010c38d
+c0104a6b:	68 7e 02 00 00       	push   $0x27e
+c0104a70:	68 68 c3 10 c0       	push   $0xc010c368
+c0104a75:	e8 7b b9 ff ff       	call   c01003f5 <__panic>
+    assert(page_ref(p2) == 0);
+c0104a7a:	83 ec 0c             	sub    $0xc,%esp
+c0104a7d:	ff 75 e4             	pushl  -0x1c(%ebp)
+c0104a80:	e8 2e eb ff ff       	call   c01035b3 <page_ref>
+c0104a85:	83 c4 10             	add    $0x10,%esp
+c0104a88:	85 c0                	test   %eax,%eax
+c0104a8a:	74 19                	je     c0104aa5 <check_pgdir+0x4ea>
+c0104a8c:	68 72 c6 10 c0       	push   $0xc010c672
+c0104a91:	68 8d c3 10 c0       	push   $0xc010c38d
+c0104a96:	68 7f 02 00 00       	push   $0x27f
+c0104a9b:	68 68 c3 10 c0       	push   $0xc010c368
+c0104aa0:	e8 50 b9 ff ff       	call   c01003f5 <__panic>
+
+    assert(page_ref(pde2page(boot_pgdir[0])) == 1);
+c0104aa5:	a1 e0 c9 12 c0       	mov    0xc012c9e0,%eax
+c0104aaa:	8b 00                	mov    (%eax),%eax
+c0104aac:	83 ec 0c             	sub    $0xc,%esp
+c0104aaf:	50                   	push   %eax
+c0104ab0:	e8 e2 ea ff ff       	call   c0103597 <pde2page>
+c0104ab5:	83 c4 10             	add    $0x10,%esp
+c0104ab8:	83 ec 0c             	sub    $0xc,%esp
+c0104abb:	50                   	push   %eax
+c0104abc:	e8 f2 ea ff ff       	call   c01035b3 <page_ref>
+c0104ac1:	83 c4 10             	add    $0x10,%esp
+c0104ac4:	83 f8 01             	cmp    $0x1,%eax
+c0104ac7:	74 19                	je     c0104ae2 <check_pgdir+0x527>
+c0104ac9:	68 ac c6 10 c0       	push   $0xc010c6ac
+c0104ace:	68 8d c3 10 c0       	push   $0xc010c38d
+c0104ad3:	68 81 02 00 00       	push   $0x281
+c0104ad8:	68 68 c3 10 c0       	push   $0xc010c368
+c0104add:	e8 13 b9 ff ff       	call   c01003f5 <__panic>
+    free_page(pde2page(boot_pgdir[0]));
+c0104ae2:	a1 e0 c9 12 c0       	mov    0xc012c9e0,%eax
+c0104ae7:	8b 00                	mov    (%eax),%eax
+c0104ae9:	83 ec 0c             	sub    $0xc,%esp
+c0104aec:	50                   	push   %eax
+c0104aed:	e8 a5 ea ff ff       	call   c0103597 <pde2page>
+c0104af2:	83 c4 10             	add    $0x10,%esp
+c0104af5:	83 ec 08             	sub    $0x8,%esp
+c0104af8:	6a 01                	push   $0x1
+c0104afa:	50                   	push   %eax
+c0104afb:	e8 2d ed ff ff       	call   c010382d <free_pages>
+c0104b00:	83 c4 10             	add    $0x10,%esp
+    boot_pgdir[0] = 0;
+c0104b03:	a1 e0 c9 12 c0       	mov    0xc012c9e0,%eax
+c0104b08:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+
+    cprintf("check_pgdir() succeeded!\n");
+c0104b0e:	83 ec 0c             	sub    $0xc,%esp
+c0104b11:	68 d3 c6 10 c0       	push   $0xc010c6d3
+c0104b16:	e8 74 b7 ff ff       	call   c010028f <cprintf>
+c0104b1b:	83 c4 10             	add    $0x10,%esp
+}
+c0104b1e:	90                   	nop
+c0104b1f:	c9                   	leave  
+c0104b20:	c3                   	ret    
+
+c0104b21 <check_boot_pgdir>:
+
+static void
+check_boot_pgdir(void) {
+c0104b21:	55                   	push   %ebp
+c0104b22:	89 e5                	mov    %esp,%ebp
+c0104b24:	83 ec 28             	sub    $0x28,%esp
+    pte_t *ptep;
+    int i;
+    for (i = 0; i < npage; i += PGSIZE) {
+c0104b27:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c0104b2e:	e9 a3 00 00 00       	jmp    c0104bd6 <check_boot_pgdir+0xb5>
+        assert((ptep = get_pte(boot_pgdir, (uintptr_t)KADDR(i), 0)) != NULL);
+c0104b33:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104b36:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0104b39:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0104b3c:	c1 e8 0c             	shr    $0xc,%eax
+c0104b3f:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0104b42:	a1 80 0f 1b c0       	mov    0xc01b0f80,%eax
+c0104b47:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+c0104b4a:	72 17                	jb     c0104b63 <check_boot_pgdir+0x42>
+c0104b4c:	ff 75 f0             	pushl  -0x10(%ebp)
+c0104b4f:	68 a0 c2 10 c0       	push   $0xc010c2a0
+c0104b54:	68 8d 02 00 00       	push   $0x28d
+c0104b59:	68 68 c3 10 c0       	push   $0xc010c368
+c0104b5e:	e8 92 b8 ff ff       	call   c01003f5 <__panic>
+c0104b63:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0104b66:	2d 00 00 00 40       	sub    $0x40000000,%eax
+c0104b6b:	89 c2                	mov    %eax,%edx
+c0104b6d:	a1 e0 c9 12 c0       	mov    0xc012c9e0,%eax
+c0104b72:	83 ec 04             	sub    $0x4,%esp
+c0104b75:	6a 00                	push   $0x0
+c0104b77:	52                   	push   %edx
+c0104b78:	50                   	push   %eax
+c0104b79:	e8 af f2 ff ff       	call   c0103e2d <get_pte>
+c0104b7e:	83 c4 10             	add    $0x10,%esp
+c0104b81:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c0104b84:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+c0104b88:	75 19                	jne    c0104ba3 <check_boot_pgdir+0x82>
+c0104b8a:	68 f0 c6 10 c0       	push   $0xc010c6f0
+c0104b8f:	68 8d c3 10 c0       	push   $0xc010c38d
+c0104b94:	68 8d 02 00 00       	push   $0x28d
+c0104b99:	68 68 c3 10 c0       	push   $0xc010c368
+c0104b9e:	e8 52 b8 ff ff       	call   c01003f5 <__panic>
+        assert(PTE_ADDR(*ptep) == i);
+c0104ba3:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0104ba6:	8b 00                	mov    (%eax),%eax
+c0104ba8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+c0104bad:	89 c2                	mov    %eax,%edx
+c0104baf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104bb2:	39 c2                	cmp    %eax,%edx
+c0104bb4:	74 19                	je     c0104bcf <check_boot_pgdir+0xae>
+c0104bb6:	68 2d c7 10 c0       	push   $0xc010c72d
+c0104bbb:	68 8d c3 10 c0       	push   $0xc010c38d
+c0104bc0:	68 8e 02 00 00       	push   $0x28e
+c0104bc5:	68 68 c3 10 c0       	push   $0xc010c368
+c0104bca:	e8 26 b8 ff ff       	call   c01003f5 <__panic>
+
+static void
+check_boot_pgdir(void) {
+    pte_t *ptep;
+    int i;
+    for (i = 0; i < npage; i += PGSIZE) {
+c0104bcf:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
+c0104bd6:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0104bd9:	a1 80 0f 1b c0       	mov    0xc01b0f80,%eax
+c0104bde:	39 c2                	cmp    %eax,%edx
+c0104be0:	0f 82 4d ff ff ff    	jb     c0104b33 <check_boot_pgdir+0x12>
+        assert((ptep = get_pte(boot_pgdir, (uintptr_t)KADDR(i), 0)) != NULL);
+        assert(PTE_ADDR(*ptep) == i);
+    }
+
+    assert(PDE_ADDR(boot_pgdir[PDX(VPT)]) == PADDR(boot_pgdir));
+c0104be6:	a1 e0 c9 12 c0       	mov    0xc012c9e0,%eax
+c0104beb:	05 ac 0f 00 00       	add    $0xfac,%eax
+c0104bf0:	8b 00                	mov    (%eax),%eax
+c0104bf2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+c0104bf7:	89 c2                	mov    %eax,%edx
+c0104bf9:	a1 e0 c9 12 c0       	mov    0xc012c9e0,%eax
+c0104bfe:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c0104c01:	81 7d e4 ff ff ff bf 	cmpl   $0xbfffffff,-0x1c(%ebp)
+c0104c08:	77 17                	ja     c0104c21 <check_boot_pgdir+0x100>
+c0104c0a:	ff 75 e4             	pushl  -0x1c(%ebp)
+c0104c0d:	68 44 c3 10 c0       	push   $0xc010c344
+c0104c12:	68 91 02 00 00       	push   $0x291
+c0104c17:	68 68 c3 10 c0       	push   $0xc010c368
+c0104c1c:	e8 d4 b7 ff ff       	call   c01003f5 <__panic>
+c0104c21:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0104c24:	05 00 00 00 40       	add    $0x40000000,%eax
+c0104c29:	39 c2                	cmp    %eax,%edx
+c0104c2b:	74 19                	je     c0104c46 <check_boot_pgdir+0x125>
+c0104c2d:	68 44 c7 10 c0       	push   $0xc010c744
+c0104c32:	68 8d c3 10 c0       	push   $0xc010c38d
+c0104c37:	68 91 02 00 00       	push   $0x291
+c0104c3c:	68 68 c3 10 c0       	push   $0xc010c368
+c0104c41:	e8 af b7 ff ff       	call   c01003f5 <__panic>
+
+    assert(boot_pgdir[0] == 0);
+c0104c46:	a1 e0 c9 12 c0       	mov    0xc012c9e0,%eax
+c0104c4b:	8b 00                	mov    (%eax),%eax
+c0104c4d:	85 c0                	test   %eax,%eax
+c0104c4f:	74 19                	je     c0104c6a <check_boot_pgdir+0x149>
+c0104c51:	68 78 c7 10 c0       	push   $0xc010c778
+c0104c56:	68 8d c3 10 c0       	push   $0xc010c38d
+c0104c5b:	68 93 02 00 00       	push   $0x293
+c0104c60:	68 68 c3 10 c0       	push   $0xc010c368
+c0104c65:	e8 8b b7 ff ff       	call   c01003f5 <__panic>
+
+    struct Page *p;
+    p = alloc_page();
+c0104c6a:	83 ec 0c             	sub    $0xc,%esp
+c0104c6d:	6a 01                	push   $0x1
+c0104c6f:	e8 4d eb ff ff       	call   c01037c1 <alloc_pages>
+c0104c74:	83 c4 10             	add    $0x10,%esp
+c0104c77:	89 45 e0             	mov    %eax,-0x20(%ebp)
+    assert(page_insert(boot_pgdir, p, 0x100, PTE_W) == 0);
+c0104c7a:	a1 e0 c9 12 c0       	mov    0xc012c9e0,%eax
+c0104c7f:	6a 02                	push   $0x2
+c0104c81:	68 00 01 00 00       	push   $0x100
+c0104c86:	ff 75 e0             	pushl  -0x20(%ebp)
+c0104c89:	50                   	push   %eax
+c0104c8a:	e8 4f f7 ff ff       	call   c01043de <page_insert>
+c0104c8f:	83 c4 10             	add    $0x10,%esp
+c0104c92:	85 c0                	test   %eax,%eax
+c0104c94:	74 19                	je     c0104caf <check_boot_pgdir+0x18e>
+c0104c96:	68 8c c7 10 c0       	push   $0xc010c78c
+c0104c9b:	68 8d c3 10 c0       	push   $0xc010c38d
+c0104ca0:	68 97 02 00 00       	push   $0x297
+c0104ca5:	68 68 c3 10 c0       	push   $0xc010c368
+c0104caa:	e8 46 b7 ff ff       	call   c01003f5 <__panic>
+    assert(page_ref(p) == 1);
+c0104caf:	83 ec 0c             	sub    $0xc,%esp
+c0104cb2:	ff 75 e0             	pushl  -0x20(%ebp)
+c0104cb5:	e8 f9 e8 ff ff       	call   c01035b3 <page_ref>
+c0104cba:	83 c4 10             	add    $0x10,%esp
+c0104cbd:	83 f8 01             	cmp    $0x1,%eax
+c0104cc0:	74 19                	je     c0104cdb <check_boot_pgdir+0x1ba>
+c0104cc2:	68 ba c7 10 c0       	push   $0xc010c7ba
+c0104cc7:	68 8d c3 10 c0       	push   $0xc010c38d
+c0104ccc:	68 98 02 00 00       	push   $0x298
+c0104cd1:	68 68 c3 10 c0       	push   $0xc010c368
+c0104cd6:	e8 1a b7 ff ff       	call   c01003f5 <__panic>
+    assert(page_insert(boot_pgdir, p, 0x100 + PGSIZE, PTE_W) == 0);
+c0104cdb:	a1 e0 c9 12 c0       	mov    0xc012c9e0,%eax
+c0104ce0:	6a 02                	push   $0x2
+c0104ce2:	68 00 11 00 00       	push   $0x1100
+c0104ce7:	ff 75 e0             	pushl  -0x20(%ebp)
+c0104cea:	50                   	push   %eax
+c0104ceb:	e8 ee f6 ff ff       	call   c01043de <page_insert>
+c0104cf0:	83 c4 10             	add    $0x10,%esp
+c0104cf3:	85 c0                	test   %eax,%eax
+c0104cf5:	74 19                	je     c0104d10 <check_boot_pgdir+0x1ef>
+c0104cf7:	68 cc c7 10 c0       	push   $0xc010c7cc
+c0104cfc:	68 8d c3 10 c0       	push   $0xc010c38d
+c0104d01:	68 99 02 00 00       	push   $0x299
+c0104d06:	68 68 c3 10 c0       	push   $0xc010c368
+c0104d0b:	e8 e5 b6 ff ff       	call   c01003f5 <__panic>
+    assert(page_ref(p) == 2);
+c0104d10:	83 ec 0c             	sub    $0xc,%esp
+c0104d13:	ff 75 e0             	pushl  -0x20(%ebp)
+c0104d16:	e8 98 e8 ff ff       	call   c01035b3 <page_ref>
+c0104d1b:	83 c4 10             	add    $0x10,%esp
+c0104d1e:	83 f8 02             	cmp    $0x2,%eax
+c0104d21:	74 19                	je     c0104d3c <check_boot_pgdir+0x21b>
+c0104d23:	68 03 c8 10 c0       	push   $0xc010c803
+c0104d28:	68 8d c3 10 c0       	push   $0xc010c38d
+c0104d2d:	68 9a 02 00 00       	push   $0x29a
+c0104d32:	68 68 c3 10 c0       	push   $0xc010c368
+c0104d37:	e8 b9 b6 ff ff       	call   c01003f5 <__panic>
+
+    const char *str = "ucore: Hello world!!";
+c0104d3c:	c7 45 dc 14 c8 10 c0 	movl   $0xc010c814,-0x24(%ebp)
+    strcpy((void *)0x100, str);
+c0104d43:	83 ec 08             	sub    $0x8,%esp
+c0104d46:	ff 75 dc             	pushl  -0x24(%ebp)
+c0104d49:	68 00 01 00 00       	push   $0x100
+c0104d4e:	e8 2c 60 00 00       	call   c010ad7f <strcpy>
+c0104d53:	83 c4 10             	add    $0x10,%esp
+    assert(strcmp((void *)0x100, (void *)(0x100 + PGSIZE)) == 0);
+c0104d56:	83 ec 08             	sub    $0x8,%esp
+c0104d59:	68 00 11 00 00       	push   $0x1100
+c0104d5e:	68 00 01 00 00       	push   $0x100
+c0104d63:	e8 91 60 00 00       	call   c010adf9 <strcmp>
+c0104d68:	83 c4 10             	add    $0x10,%esp
+c0104d6b:	85 c0                	test   %eax,%eax
+c0104d6d:	74 19                	je     c0104d88 <check_boot_pgdir+0x267>
+c0104d6f:	68 2c c8 10 c0       	push   $0xc010c82c
+c0104d74:	68 8d c3 10 c0       	push   $0xc010c38d
+c0104d79:	68 9e 02 00 00       	push   $0x29e
+c0104d7e:	68 68 c3 10 c0       	push   $0xc010c368
+c0104d83:	e8 6d b6 ff ff       	call   c01003f5 <__panic>
+
+    *(char *)(page2kva(p) + 0x100) = '\0';
+c0104d88:	83 ec 0c             	sub    $0xc,%esp
+c0104d8b:	ff 75 e0             	pushl  -0x20(%ebp)
+c0104d8e:	e8 85 e7 ff ff       	call   c0103518 <page2kva>
+c0104d93:	83 c4 10             	add    $0x10,%esp
+c0104d96:	05 00 01 00 00       	add    $0x100,%eax
+c0104d9b:	c6 00 00             	movb   $0x0,(%eax)
+    assert(strlen((const char *)0x100) == 0);
+c0104d9e:	83 ec 0c             	sub    $0xc,%esp
+c0104da1:	68 00 01 00 00       	push   $0x100
+c0104da6:	e8 7c 5f 00 00       	call   c010ad27 <strlen>
+c0104dab:	83 c4 10             	add    $0x10,%esp
+c0104dae:	85 c0                	test   %eax,%eax
+c0104db0:	74 19                	je     c0104dcb <check_boot_pgdir+0x2aa>
+c0104db2:	68 64 c8 10 c0       	push   $0xc010c864
+c0104db7:	68 8d c3 10 c0       	push   $0xc010c38d
+c0104dbc:	68 a1 02 00 00       	push   $0x2a1
+c0104dc1:	68 68 c3 10 c0       	push   $0xc010c368
+c0104dc6:	e8 2a b6 ff ff       	call   c01003f5 <__panic>
+
+    free_page(p);
+c0104dcb:	83 ec 08             	sub    $0x8,%esp
+c0104dce:	6a 01                	push   $0x1
+c0104dd0:	ff 75 e0             	pushl  -0x20(%ebp)
+c0104dd3:	e8 55 ea ff ff       	call   c010382d <free_pages>
+c0104dd8:	83 c4 10             	add    $0x10,%esp
+    free_page(pde2page(boot_pgdir[0]));
+c0104ddb:	a1 e0 c9 12 c0       	mov    0xc012c9e0,%eax
+c0104de0:	8b 00                	mov    (%eax),%eax
+c0104de2:	83 ec 0c             	sub    $0xc,%esp
+c0104de5:	50                   	push   %eax
+c0104de6:	e8 ac e7 ff ff       	call   c0103597 <pde2page>
+c0104deb:	83 c4 10             	add    $0x10,%esp
+c0104dee:	83 ec 08             	sub    $0x8,%esp
+c0104df1:	6a 01                	push   $0x1
+c0104df3:	50                   	push   %eax
+c0104df4:	e8 34 ea ff ff       	call   c010382d <free_pages>
+c0104df9:	83 c4 10             	add    $0x10,%esp
+    boot_pgdir[0] = 0;
+c0104dfc:	a1 e0 c9 12 c0       	mov    0xc012c9e0,%eax
+c0104e01:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+
+    cprintf("check_boot_pgdir() succeeded!\n");
+c0104e07:	83 ec 0c             	sub    $0xc,%esp
+c0104e0a:	68 88 c8 10 c0       	push   $0xc010c888
+c0104e0f:	e8 7b b4 ff ff       	call   c010028f <cprintf>
+c0104e14:	83 c4 10             	add    $0x10,%esp
+}
+c0104e17:	90                   	nop
+c0104e18:	c9                   	leave  
+c0104e19:	c3                   	ret    
+
+c0104e1a <perm2str>:
+
+//perm2str - use string 'u,r,w,-' to present the permission
+static const char *
+perm2str(int perm) {
+c0104e1a:	55                   	push   %ebp
+c0104e1b:	89 e5                	mov    %esp,%ebp
+    static char str[4];
+    str[0] = (perm & PTE_U) ? 'u' : '-';
+c0104e1d:	8b 45 08             	mov    0x8(%ebp),%eax
+c0104e20:	83 e0 04             	and    $0x4,%eax
+c0104e23:	85 c0                	test   %eax,%eax
+c0104e25:	74 07                	je     c0104e2e <perm2str+0x14>
+c0104e27:	b8 75 00 00 00       	mov    $0x75,%eax
+c0104e2c:	eb 05                	jmp    c0104e33 <perm2str+0x19>
+c0104e2e:	b8 2d 00 00 00       	mov    $0x2d,%eax
+c0104e33:	a2 08 10 1b c0       	mov    %al,0xc01b1008
+    str[1] = 'r';
+c0104e38:	c6 05 09 10 1b c0 72 	movb   $0x72,0xc01b1009
+    str[2] = (perm & PTE_W) ? 'w' : '-';
+c0104e3f:	8b 45 08             	mov    0x8(%ebp),%eax
+c0104e42:	83 e0 02             	and    $0x2,%eax
+c0104e45:	85 c0                	test   %eax,%eax
+c0104e47:	74 07                	je     c0104e50 <perm2str+0x36>
+c0104e49:	b8 77 00 00 00       	mov    $0x77,%eax
+c0104e4e:	eb 05                	jmp    c0104e55 <perm2str+0x3b>
+c0104e50:	b8 2d 00 00 00       	mov    $0x2d,%eax
+c0104e55:	a2 0a 10 1b c0       	mov    %al,0xc01b100a
+    str[3] = '\0';
+c0104e5a:	c6 05 0b 10 1b c0 00 	movb   $0x0,0xc01b100b
+    return str;
+c0104e61:	b8 08 10 1b c0       	mov    $0xc01b1008,%eax
+}
+c0104e66:	5d                   	pop    %ebp
+c0104e67:	c3                   	ret    
+
+c0104e68 <get_pgtable_items>:
+//  table:       the beginning addr of table
+//  left_store:  the pointer of the high side of table's next range
+//  right_store: the pointer of the low side of table's next range
+// return value: 0 - not a invalid item range, perm - a valid item range with perm permission 
+static int
+get_pgtable_items(size_t left, size_t right, size_t start, uintptr_t *table, size_t *left_store, size_t *right_store) {
+c0104e68:	55                   	push   %ebp
+c0104e69:	89 e5                	mov    %esp,%ebp
+c0104e6b:	83 ec 10             	sub    $0x10,%esp
+    if (start >= right) {
+c0104e6e:	8b 45 10             	mov    0x10(%ebp),%eax
+c0104e71:	3b 45 0c             	cmp    0xc(%ebp),%eax
+c0104e74:	72 0e                	jb     c0104e84 <get_pgtable_items+0x1c>
+        return 0;
+c0104e76:	b8 00 00 00 00       	mov    $0x0,%eax
+c0104e7b:	e9 9a 00 00 00       	jmp    c0104f1a <get_pgtable_items+0xb2>
+    }
+    while (start < right && !(table[start] & PTE_P)) {
+        start ++;
+c0104e80:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+static int
+get_pgtable_items(size_t left, size_t right, size_t start, uintptr_t *table, size_t *left_store, size_t *right_store) {
+    if (start >= right) {
+        return 0;
+    }
+    while (start < right && !(table[start] & PTE_P)) {
+c0104e84:	8b 45 10             	mov    0x10(%ebp),%eax
+c0104e87:	3b 45 0c             	cmp    0xc(%ebp),%eax
+c0104e8a:	73 18                	jae    c0104ea4 <get_pgtable_items+0x3c>
+c0104e8c:	8b 45 10             	mov    0x10(%ebp),%eax
+c0104e8f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+c0104e96:	8b 45 14             	mov    0x14(%ebp),%eax
+c0104e99:	01 d0                	add    %edx,%eax
+c0104e9b:	8b 00                	mov    (%eax),%eax
+c0104e9d:	83 e0 01             	and    $0x1,%eax
+c0104ea0:	85 c0                	test   %eax,%eax
+c0104ea2:	74 dc                	je     c0104e80 <get_pgtable_items+0x18>
+        start ++;
+    }
+    if (start < right) {
+c0104ea4:	8b 45 10             	mov    0x10(%ebp),%eax
+c0104ea7:	3b 45 0c             	cmp    0xc(%ebp),%eax
+c0104eaa:	73 69                	jae    c0104f15 <get_pgtable_items+0xad>
+        if (left_store != NULL) {
+c0104eac:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
+c0104eb0:	74 08                	je     c0104eba <get_pgtable_items+0x52>
+            *left_store = start;
+c0104eb2:	8b 45 18             	mov    0x18(%ebp),%eax
+c0104eb5:	8b 55 10             	mov    0x10(%ebp),%edx
+c0104eb8:	89 10                	mov    %edx,(%eax)
+        }
+        int perm = (table[start ++] & PTE_USER);
+c0104eba:	8b 45 10             	mov    0x10(%ebp),%eax
+c0104ebd:	8d 50 01             	lea    0x1(%eax),%edx
+c0104ec0:	89 55 10             	mov    %edx,0x10(%ebp)
+c0104ec3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+c0104eca:	8b 45 14             	mov    0x14(%ebp),%eax
+c0104ecd:	01 d0                	add    %edx,%eax
+c0104ecf:	8b 00                	mov    (%eax),%eax
+c0104ed1:	83 e0 07             	and    $0x7,%eax
+c0104ed4:	89 45 fc             	mov    %eax,-0x4(%ebp)
+        while (start < right && (table[start] & PTE_USER) == perm) {
+c0104ed7:	eb 04                	jmp    c0104edd <get_pgtable_items+0x75>
+            start ++;
+c0104ed9:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+    if (start < right) {
+        if (left_store != NULL) {
+            *left_store = start;
+        }
+        int perm = (table[start ++] & PTE_USER);
+        while (start < right && (table[start] & PTE_USER) == perm) {
+c0104edd:	8b 45 10             	mov    0x10(%ebp),%eax
+c0104ee0:	3b 45 0c             	cmp    0xc(%ebp),%eax
+c0104ee3:	73 1d                	jae    c0104f02 <get_pgtable_items+0x9a>
+c0104ee5:	8b 45 10             	mov    0x10(%ebp),%eax
+c0104ee8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+c0104eef:	8b 45 14             	mov    0x14(%ebp),%eax
+c0104ef2:	01 d0                	add    %edx,%eax
+c0104ef4:	8b 00                	mov    (%eax),%eax
+c0104ef6:	83 e0 07             	and    $0x7,%eax
+c0104ef9:	89 c2                	mov    %eax,%edx
+c0104efb:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0104efe:	39 c2                	cmp    %eax,%edx
+c0104f00:	74 d7                	je     c0104ed9 <get_pgtable_items+0x71>
+            start ++;
+        }
+        if (right_store != NULL) {
+c0104f02:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+c0104f06:	74 08                	je     c0104f10 <get_pgtable_items+0xa8>
+            *right_store = start;
+c0104f08:	8b 45 1c             	mov    0x1c(%ebp),%eax
+c0104f0b:	8b 55 10             	mov    0x10(%ebp),%edx
+c0104f0e:	89 10                	mov    %edx,(%eax)
+        }
+        return perm;
+c0104f10:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0104f13:	eb 05                	jmp    c0104f1a <get_pgtable_items+0xb2>
+    }
+    return 0;
+c0104f15:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c0104f1a:	c9                   	leave  
+c0104f1b:	c3                   	ret    
+
+c0104f1c <print_pgdir>:
+
+//print_pgdir - print the PDT&PT
+void
+print_pgdir(void) {
+c0104f1c:	55                   	push   %ebp
+c0104f1d:	89 e5                	mov    %esp,%ebp
+c0104f1f:	57                   	push   %edi
+c0104f20:	56                   	push   %esi
+c0104f21:	53                   	push   %ebx
+c0104f22:	83 ec 2c             	sub    $0x2c,%esp
+    cprintf("-------------------- BEGIN --------------------\n");
+c0104f25:	83 ec 0c             	sub    $0xc,%esp
+c0104f28:	68 a8 c8 10 c0       	push   $0xc010c8a8
+c0104f2d:	e8 5d b3 ff ff       	call   c010028f <cprintf>
+c0104f32:	83 c4 10             	add    $0x10,%esp
+    size_t left, right = 0, perm;
+c0104f35:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+    while ((perm = get_pgtable_items(0, NPDEENTRY, right, vpd, &left, &right)) != 0) {
+c0104f3c:	e9 e5 00 00 00       	jmp    c0105026 <print_pgdir+0x10a>
+        cprintf("PDE(%03x) %08x-%08x %08x %s\n", right - left,
+c0104f41:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0104f44:	83 ec 0c             	sub    $0xc,%esp
+c0104f47:	50                   	push   %eax
+c0104f48:	e8 cd fe ff ff       	call   c0104e1a <perm2str>
+c0104f4d:	83 c4 10             	add    $0x10,%esp
+c0104f50:	89 c7                	mov    %eax,%edi
+                left * PTSIZE, right * PTSIZE, (right - left) * PTSIZE, perm2str(perm));
+c0104f52:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c0104f55:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0104f58:	29 c2                	sub    %eax,%edx
+c0104f5a:	89 d0                	mov    %edx,%eax
+void
+print_pgdir(void) {
+    cprintf("-------------------- BEGIN --------------------\n");
+    size_t left, right = 0, perm;
+    while ((perm = get_pgtable_items(0, NPDEENTRY, right, vpd, &left, &right)) != 0) {
+        cprintf("PDE(%03x) %08x-%08x %08x %s\n", right - left,
+c0104f5c:	c1 e0 16             	shl    $0x16,%eax
+c0104f5f:	89 c3                	mov    %eax,%ebx
+c0104f61:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0104f64:	c1 e0 16             	shl    $0x16,%eax
+c0104f67:	89 c1                	mov    %eax,%ecx
+c0104f69:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0104f6c:	c1 e0 16             	shl    $0x16,%eax
+c0104f6f:	89 c2                	mov    %eax,%edx
+c0104f71:	8b 75 dc             	mov    -0x24(%ebp),%esi
+c0104f74:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0104f77:	29 c6                	sub    %eax,%esi
+c0104f79:	89 f0                	mov    %esi,%eax
+c0104f7b:	83 ec 08             	sub    $0x8,%esp
+c0104f7e:	57                   	push   %edi
+c0104f7f:	53                   	push   %ebx
+c0104f80:	51                   	push   %ecx
+c0104f81:	52                   	push   %edx
+c0104f82:	50                   	push   %eax
+c0104f83:	68 d9 c8 10 c0       	push   $0xc010c8d9
+c0104f88:	e8 02 b3 ff ff       	call   c010028f <cprintf>
+c0104f8d:	83 c4 20             	add    $0x20,%esp
+                left * PTSIZE, right * PTSIZE, (right - left) * PTSIZE, perm2str(perm));
+        size_t l, r = left * NPTEENTRY;
+c0104f90:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0104f93:	c1 e0 0a             	shl    $0xa,%eax
+c0104f96:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+        while ((perm = get_pgtable_items(left * NPTEENTRY, right * NPTEENTRY, r, vpt, &l, &r)) != 0) {
+c0104f99:	eb 4f                	jmp    c0104fea <print_pgdir+0xce>
+            cprintf("  |-- PTE(%05x) %08x-%08x %08x %s\n", r - l,
+c0104f9b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0104f9e:	83 ec 0c             	sub    $0xc,%esp
+c0104fa1:	50                   	push   %eax
+c0104fa2:	e8 73 fe ff ff       	call   c0104e1a <perm2str>
+c0104fa7:	83 c4 10             	add    $0x10,%esp
+c0104faa:	89 c7                	mov    %eax,%edi
+                    l * PGSIZE, r * PGSIZE, (r - l) * PGSIZE, perm2str(perm));
+c0104fac:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c0104faf:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c0104fb2:	29 c2                	sub    %eax,%edx
+c0104fb4:	89 d0                	mov    %edx,%eax
+    while ((perm = get_pgtable_items(0, NPDEENTRY, right, vpd, &left, &right)) != 0) {
+        cprintf("PDE(%03x) %08x-%08x %08x %s\n", right - left,
+                left * PTSIZE, right * PTSIZE, (right - left) * PTSIZE, perm2str(perm));
+        size_t l, r = left * NPTEENTRY;
+        while ((perm = get_pgtable_items(left * NPTEENTRY, right * NPTEENTRY, r, vpt, &l, &r)) != 0) {
+            cprintf("  |-- PTE(%05x) %08x-%08x %08x %s\n", r - l,
+c0104fb6:	c1 e0 0c             	shl    $0xc,%eax
+c0104fb9:	89 c3                	mov    %eax,%ebx
+c0104fbb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c0104fbe:	c1 e0 0c             	shl    $0xc,%eax
+c0104fc1:	89 c1                	mov    %eax,%ecx
+c0104fc3:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c0104fc6:	c1 e0 0c             	shl    $0xc,%eax
+c0104fc9:	89 c2                	mov    %eax,%edx
+c0104fcb:	8b 75 d4             	mov    -0x2c(%ebp),%esi
+c0104fce:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c0104fd1:	29 c6                	sub    %eax,%esi
+c0104fd3:	89 f0                	mov    %esi,%eax
+c0104fd5:	83 ec 08             	sub    $0x8,%esp
+c0104fd8:	57                   	push   %edi
+c0104fd9:	53                   	push   %ebx
+c0104fda:	51                   	push   %ecx
+c0104fdb:	52                   	push   %edx
+c0104fdc:	50                   	push   %eax
+c0104fdd:	68 f8 c8 10 c0       	push   $0xc010c8f8
+c0104fe2:	e8 a8 b2 ff ff       	call   c010028f <cprintf>
+c0104fe7:	83 c4 20             	add    $0x20,%esp
+    size_t left, right = 0, perm;
+    while ((perm = get_pgtable_items(0, NPDEENTRY, right, vpd, &left, &right)) != 0) {
+        cprintf("PDE(%03x) %08x-%08x %08x %s\n", right - left,
+                left * PTSIZE, right * PTSIZE, (right - left) * PTSIZE, perm2str(perm));
+        size_t l, r = left * NPTEENTRY;
+        while ((perm = get_pgtable_items(left * NPTEENTRY, right * NPTEENTRY, r, vpt, &l, &r)) != 0) {
+c0104fea:	be 00 00 c0 fa       	mov    $0xfac00000,%esi
+c0104fef:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c0104ff2:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c0104ff5:	89 d3                	mov    %edx,%ebx
+c0104ff7:	c1 e3 0a             	shl    $0xa,%ebx
+c0104ffa:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c0104ffd:	89 d1                	mov    %edx,%ecx
+c0104fff:	c1 e1 0a             	shl    $0xa,%ecx
+c0105002:	83 ec 08             	sub    $0x8,%esp
+c0105005:	8d 55 d4             	lea    -0x2c(%ebp),%edx
+c0105008:	52                   	push   %edx
+c0105009:	8d 55 d8             	lea    -0x28(%ebp),%edx
+c010500c:	52                   	push   %edx
+c010500d:	56                   	push   %esi
+c010500e:	50                   	push   %eax
+c010500f:	53                   	push   %ebx
+c0105010:	51                   	push   %ecx
+c0105011:	e8 52 fe ff ff       	call   c0104e68 <get_pgtable_items>
+c0105016:	83 c4 20             	add    $0x20,%esp
+c0105019:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c010501c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+c0105020:	0f 85 75 ff ff ff    	jne    c0104f9b <print_pgdir+0x7f>
+//print_pgdir - print the PDT&PT
+void
+print_pgdir(void) {
+    cprintf("-------------------- BEGIN --------------------\n");
+    size_t left, right = 0, perm;
+    while ((perm = get_pgtable_items(0, NPDEENTRY, right, vpd, &left, &right)) != 0) {
+c0105026:	b9 00 b0 fe fa       	mov    $0xfafeb000,%ecx
+c010502b:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c010502e:	83 ec 08             	sub    $0x8,%esp
+c0105031:	8d 55 dc             	lea    -0x24(%ebp),%edx
+c0105034:	52                   	push   %edx
+c0105035:	8d 55 e0             	lea    -0x20(%ebp),%edx
+c0105038:	52                   	push   %edx
+c0105039:	51                   	push   %ecx
+c010503a:	50                   	push   %eax
+c010503b:	68 00 04 00 00       	push   $0x400
+c0105040:	6a 00                	push   $0x0
+c0105042:	e8 21 fe ff ff       	call   c0104e68 <get_pgtable_items>
+c0105047:	83 c4 20             	add    $0x20,%esp
+c010504a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c010504d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+c0105051:	0f 85 ea fe ff ff    	jne    c0104f41 <print_pgdir+0x25>
+        while ((perm = get_pgtable_items(left * NPTEENTRY, right * NPTEENTRY, r, vpt, &l, &r)) != 0) {
+            cprintf("  |-- PTE(%05x) %08x-%08x %08x %s\n", r - l,
+                    l * PGSIZE, r * PGSIZE, (r - l) * PGSIZE, perm2str(perm));
+        }
+    }
+    cprintf("--------------------- END ---------------------\n");
+c0105057:	83 ec 0c             	sub    $0xc,%esp
+c010505a:	68 1c c9 10 c0       	push   $0xc010c91c
+c010505f:	e8 2b b2 ff ff       	call   c010028f <cprintf>
+c0105064:	83 c4 10             	add    $0x10,%esp
+}
+c0105067:	90                   	nop
+c0105068:	8d 65 f4             	lea    -0xc(%ebp),%esp
+c010506b:	5b                   	pop    %ebx
+c010506c:	5e                   	pop    %esi
+c010506d:	5f                   	pop    %edi
+c010506e:	5d                   	pop    %ebp
+c010506f:	c3                   	ret    
+
+c0105070 <_fifo_init_mm>:
+ * (2) _fifo_init_mm: init pra_list_head and let  mm->sm_priv point to the addr of pra_list_head.
+ *              Now, From the memory control struct mm_struct, we can access FIFO PRA
+ */
+static int
+_fifo_init_mm(struct mm_struct *mm)
+{     
+c0105070:	55                   	push   %ebp
+c0105071:	89 e5                	mov    %esp,%ebp
+c0105073:	83 ec 10             	sub    $0x10,%esp
+c0105076:	c7 45 fc 88 30 1b c0 	movl   $0xc01b3088,-0x4(%ebp)
+ * list_init - initialize a new entry
+ * @elm:        new entry to be initialized
+ * */
+static inline void
+list_init(list_entry_t *elm) {
+    elm->prev = elm->next = elm;
+c010507d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0105080:	8b 55 fc             	mov    -0x4(%ebp),%edx
+c0105083:	89 50 04             	mov    %edx,0x4(%eax)
+c0105086:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0105089:	8b 50 04             	mov    0x4(%eax),%edx
+c010508c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c010508f:	89 10                	mov    %edx,(%eax)
+     list_init(&pra_list_head);
+     mm->sm_priv = &pra_list_head;
+c0105091:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105094:	c7 40 14 88 30 1b c0 	movl   $0xc01b3088,0x14(%eax)
+     //cprintf(" mm->sm_priv %x in fifo_init_mm\n",mm->sm_priv);
+     return 0;
+c010509b:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c01050a0:	c9                   	leave  
+c01050a1:	c3                   	ret    
+
+c01050a2 <_fifo_map_swappable>:
+/*
+ * (3)_fifo_map_swappable: According FIFO PRA, we should link the most recent arrival page at the back of pra_list_head qeueue
+ */
+static int
+_fifo_map_swappable(struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in)
+{
+c01050a2:	55                   	push   %ebp
+c01050a3:	89 e5                	mov    %esp,%ebp
+c01050a5:	83 ec 28             	sub    $0x28,%esp
+    list_entry_t *head=(list_entry_t*) mm->sm_priv;
+c01050a8:	8b 45 08             	mov    0x8(%ebp),%eax
+c01050ab:	8b 40 14             	mov    0x14(%eax),%eax
+c01050ae:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    list_entry_t *entry=&(page->pra_page_link);
+c01050b1:	8b 45 10             	mov    0x10(%ebp),%eax
+c01050b4:	83 c0 14             	add    $0x14,%eax
+c01050b7:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 
+    assert(entry != NULL && head != NULL);
+c01050ba:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c01050be:	74 06                	je     c01050c6 <_fifo_map_swappable+0x24>
+c01050c0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c01050c4:	75 16                	jne    c01050dc <_fifo_map_swappable+0x3a>
+c01050c6:	68 50 c9 10 c0       	push   $0xc010c950
+c01050cb:	68 6e c9 10 c0       	push   $0xc010c96e
+c01050d0:	6a 32                	push   $0x32
+c01050d2:	68 83 c9 10 c0       	push   $0xc010c983
+c01050d7:	e8 19 b3 ff ff       	call   c01003f5 <__panic>
+c01050dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01050df:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c01050e2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01050e5:	89 45 e8             	mov    %eax,-0x18(%ebp)
+ * Insert the new element @elm *before* the element @listelm which
+ * is already in the list.
+ * */
+static inline void
+list_add_before(list_entry_t *listelm, list_entry_t *elm) {
+    __list_add(elm, listelm->prev, listelm);
+c01050e8:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01050eb:	8b 00                	mov    (%eax),%eax
+c01050ed:	8b 55 e8             	mov    -0x18(%ebp),%edx
+c01050f0:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+c01050f3:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c01050f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01050f9:	89 45 dc             	mov    %eax,-0x24(%ebp)
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ * */
+static inline void
+__list_add(list_entry_t *elm, list_entry_t *prev, list_entry_t *next) {
+    prev->next = next->prev = elm;
+c01050fc:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c01050ff:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c0105102:	89 10                	mov    %edx,(%eax)
+c0105104:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0105107:	8b 10                	mov    (%eax),%edx
+c0105109:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c010510c:	89 50 04             	mov    %edx,0x4(%eax)
+    elm->next = next;
+c010510f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0105112:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c0105115:	89 50 04             	mov    %edx,0x4(%eax)
+    elm->prev = prev;
+c0105118:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c010511b:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c010511e:	89 10                	mov    %edx,(%eax)
+    //record the page access situlation
+    /*LAB3 EXERCISE 2: YOUR CODE*/ 
+    //(1)link the most recent arrival page at the back of the pra_list_head qeueue.
+    list_add_before(head, entry);
+    return 0;
+c0105120:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c0105125:	c9                   	leave  
+c0105126:	c3                   	ret    
+
+c0105127 <_fifo_swap_out_victim>:
+ *  (4)_fifo_swap_out_victim: According FIFO PRA, we should unlink the  earliest arrival page in front of pra_list_head qeueue,
+ *                            then assign the value of *ptr_page to the addr of this page.
+ */
+static int
+_fifo_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, int in_tick)
+{
+c0105127:	55                   	push   %ebp
+c0105128:	89 e5                	mov    %esp,%ebp
+c010512a:	83 ec 28             	sub    $0x28,%esp
+    list_entry_t *head=(list_entry_t*) mm->sm_priv;
+c010512d:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105130:	8b 40 14             	mov    0x14(%eax),%eax
+c0105133:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    assert(head != NULL);
+c0105136:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c010513a:	75 16                	jne    c0105152 <_fifo_swap_out_victim+0x2b>
+c010513c:	68 97 c9 10 c0       	push   $0xc010c997
+c0105141:	68 6e c9 10 c0       	push   $0xc010c96e
+c0105146:	6a 41                	push   $0x41
+c0105148:	68 83 c9 10 c0       	push   $0xc010c983
+c010514d:	e8 a3 b2 ff ff       	call   c01003f5 <__panic>
+    assert(in_tick==0);
+c0105152:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+c0105156:	74 16                	je     c010516e <_fifo_swap_out_victim+0x47>
+c0105158:	68 a4 c9 10 c0       	push   $0xc010c9a4
+c010515d:	68 6e c9 10 c0       	push   $0xc010c96e
+c0105162:	6a 42                	push   $0x42
+c0105164:	68 83 c9 10 c0       	push   $0xc010c983
+c0105169:	e8 87 b2 ff ff       	call   c01003f5 <__panic>
+c010516e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105171:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+ * list_next - get the next entry
+ * @listelm:    the list head
+ **/
+static inline list_entry_t *
+list_next(list_entry_t *listelm) {
+    return listelm->next;
+c0105174:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0105177:	8b 40 04             	mov    0x4(%eax),%eax
+    /* Select the victim */
+    /*LAB3 EXERCISE 2: YOUR CODE*/ 
+    //(1)  unlink the  earliest arrival page in front of pra_list_head qeueue
+    //(2)  assign the value of *ptr_page to the addr of this page
+    list_entry_t *le = list_next(head);
+c010517a:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    assert(le != NULL);
+c010517d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+c0105181:	75 16                	jne    c0105199 <_fifo_swap_out_victim+0x72>
+c0105183:	68 af c9 10 c0       	push   $0xc010c9af
+c0105188:	68 6e c9 10 c0       	push   $0xc010c96e
+c010518d:	6a 48                	push   $0x48
+c010518f:	68 83 c9 10 c0       	push   $0xc010c983
+c0105194:	e8 5c b2 ff ff       	call   c01003f5 <__panic>
+    struct Page *p = le2page(le,pra_page_link);
+c0105199:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010519c:	83 e8 14             	sub    $0x14,%eax
+c010519f:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c01051a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01051a5:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ * Note: list_empty() on @listelm does not return true after this, the entry is
+ * in an undefined state.
+ * */
+static inline void
+list_del(list_entry_t *listelm) {
+    __list_del(listelm->prev, listelm->next);
+c01051a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01051ab:	8b 40 04             	mov    0x4(%eax),%eax
+c01051ae:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c01051b1:	8b 12                	mov    (%edx),%edx
+c01051b3:	89 55 e0             	mov    %edx,-0x20(%ebp)
+c01051b6:	89 45 dc             	mov    %eax,-0x24(%ebp)
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ * */
+static inline void
+__list_del(list_entry_t *prev, list_entry_t *next) {
+    prev->next = next;
+c01051b9:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c01051bc:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c01051bf:	89 50 04             	mov    %edx,0x4(%eax)
+    next->prev = prev;
+c01051c2:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c01051c5:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c01051c8:	89 10                	mov    %edx,(%eax)
+    list_del(le);
+    assert(p != NULL);
+c01051ca:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+c01051ce:	75 16                	jne    c01051e6 <_fifo_swap_out_victim+0xbf>
+c01051d0:	68 ba c9 10 c0       	push   $0xc010c9ba
+c01051d5:	68 6e c9 10 c0       	push   $0xc010c96e
+c01051da:	6a 4b                	push   $0x4b
+c01051dc:	68 83 c9 10 c0       	push   $0xc010c983
+c01051e1:	e8 0f b2 ff ff       	call   c01003f5 <__panic>
+    *ptr_page = p;     
+c01051e6:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01051e9:	8b 55 e8             	mov    -0x18(%ebp),%edx
+c01051ec:	89 10                	mov    %edx,(%eax)
+    return 0;
+c01051ee:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c01051f3:	c9                   	leave  
+c01051f4:	c3                   	ret    
+
+c01051f5 <_fifo_check_swap>:
+
+static int
+_fifo_check_swap(void) {
+c01051f5:	55                   	push   %ebp
+c01051f6:	89 e5                	mov    %esp,%ebp
+c01051f8:	83 ec 08             	sub    $0x8,%esp
+    cprintf("write Virt Page c in fifo_check_swap\n");
+c01051fb:	83 ec 0c             	sub    $0xc,%esp
+c01051fe:	68 c4 c9 10 c0       	push   $0xc010c9c4
+c0105203:	e8 87 b0 ff ff       	call   c010028f <cprintf>
+c0105208:	83 c4 10             	add    $0x10,%esp
+    *(unsigned char *)0x3000 = 0x0c;
+c010520b:	b8 00 30 00 00       	mov    $0x3000,%eax
+c0105210:	c6 00 0c             	movb   $0xc,(%eax)
+    assert(pgfault_num==4);
+c0105213:	a1 0c 10 1b c0       	mov    0xc01b100c,%eax
+c0105218:	83 f8 04             	cmp    $0x4,%eax
+c010521b:	74 16                	je     c0105233 <_fifo_check_swap+0x3e>
+c010521d:	68 ea c9 10 c0       	push   $0xc010c9ea
+c0105222:	68 6e c9 10 c0       	push   $0xc010c96e
+c0105227:	6a 54                	push   $0x54
+c0105229:	68 83 c9 10 c0       	push   $0xc010c983
+c010522e:	e8 c2 b1 ff ff       	call   c01003f5 <__panic>
+    cprintf("write Virt Page a in fifo_check_swap\n");
+c0105233:	83 ec 0c             	sub    $0xc,%esp
+c0105236:	68 fc c9 10 c0       	push   $0xc010c9fc
+c010523b:	e8 4f b0 ff ff       	call   c010028f <cprintf>
+c0105240:	83 c4 10             	add    $0x10,%esp
+    *(unsigned char *)0x1000 = 0x0a;
+c0105243:	b8 00 10 00 00       	mov    $0x1000,%eax
+c0105248:	c6 00 0a             	movb   $0xa,(%eax)
+    assert(pgfault_num==4);
+c010524b:	a1 0c 10 1b c0       	mov    0xc01b100c,%eax
+c0105250:	83 f8 04             	cmp    $0x4,%eax
+c0105253:	74 16                	je     c010526b <_fifo_check_swap+0x76>
+c0105255:	68 ea c9 10 c0       	push   $0xc010c9ea
+c010525a:	68 6e c9 10 c0       	push   $0xc010c96e
+c010525f:	6a 57                	push   $0x57
+c0105261:	68 83 c9 10 c0       	push   $0xc010c983
+c0105266:	e8 8a b1 ff ff       	call   c01003f5 <__panic>
+    cprintf("write Virt Page d in fifo_check_swap\n");
+c010526b:	83 ec 0c             	sub    $0xc,%esp
+c010526e:	68 24 ca 10 c0       	push   $0xc010ca24
+c0105273:	e8 17 b0 ff ff       	call   c010028f <cprintf>
+c0105278:	83 c4 10             	add    $0x10,%esp
+    *(unsigned char *)0x4000 = 0x0d;
+c010527b:	b8 00 40 00 00       	mov    $0x4000,%eax
+c0105280:	c6 00 0d             	movb   $0xd,(%eax)
+    assert(pgfault_num==4);
+c0105283:	a1 0c 10 1b c0       	mov    0xc01b100c,%eax
+c0105288:	83 f8 04             	cmp    $0x4,%eax
+c010528b:	74 16                	je     c01052a3 <_fifo_check_swap+0xae>
+c010528d:	68 ea c9 10 c0       	push   $0xc010c9ea
+c0105292:	68 6e c9 10 c0       	push   $0xc010c96e
+c0105297:	6a 5a                	push   $0x5a
+c0105299:	68 83 c9 10 c0       	push   $0xc010c983
+c010529e:	e8 52 b1 ff ff       	call   c01003f5 <__panic>
+    cprintf("write Virt Page b in fifo_check_swap\n");
+c01052a3:	83 ec 0c             	sub    $0xc,%esp
+c01052a6:	68 4c ca 10 c0       	push   $0xc010ca4c
+c01052ab:	e8 df af ff ff       	call   c010028f <cprintf>
+c01052b0:	83 c4 10             	add    $0x10,%esp
+    *(unsigned char *)0x2000 = 0x0b;
+c01052b3:	b8 00 20 00 00       	mov    $0x2000,%eax
+c01052b8:	c6 00 0b             	movb   $0xb,(%eax)
+    assert(pgfault_num==4);
+c01052bb:	a1 0c 10 1b c0       	mov    0xc01b100c,%eax
+c01052c0:	83 f8 04             	cmp    $0x4,%eax
+c01052c3:	74 16                	je     c01052db <_fifo_check_swap+0xe6>
+c01052c5:	68 ea c9 10 c0       	push   $0xc010c9ea
+c01052ca:	68 6e c9 10 c0       	push   $0xc010c96e
+c01052cf:	6a 5d                	push   $0x5d
+c01052d1:	68 83 c9 10 c0       	push   $0xc010c983
+c01052d6:	e8 1a b1 ff ff       	call   c01003f5 <__panic>
+    cprintf("write Virt Page e in fifo_check_swap\n");
+c01052db:	83 ec 0c             	sub    $0xc,%esp
+c01052de:	68 74 ca 10 c0       	push   $0xc010ca74
+c01052e3:	e8 a7 af ff ff       	call   c010028f <cprintf>
+c01052e8:	83 c4 10             	add    $0x10,%esp
+    *(unsigned char *)0x5000 = 0x0e;
+c01052eb:	b8 00 50 00 00       	mov    $0x5000,%eax
+c01052f0:	c6 00 0e             	movb   $0xe,(%eax)
+    assert(pgfault_num==5);
+c01052f3:	a1 0c 10 1b c0       	mov    0xc01b100c,%eax
+c01052f8:	83 f8 05             	cmp    $0x5,%eax
+c01052fb:	74 16                	je     c0105313 <_fifo_check_swap+0x11e>
+c01052fd:	68 9a ca 10 c0       	push   $0xc010ca9a
+c0105302:	68 6e c9 10 c0       	push   $0xc010c96e
+c0105307:	6a 60                	push   $0x60
+c0105309:	68 83 c9 10 c0       	push   $0xc010c983
+c010530e:	e8 e2 b0 ff ff       	call   c01003f5 <__panic>
+    cprintf("write Virt Page b in fifo_check_swap\n");
+c0105313:	83 ec 0c             	sub    $0xc,%esp
+c0105316:	68 4c ca 10 c0       	push   $0xc010ca4c
+c010531b:	e8 6f af ff ff       	call   c010028f <cprintf>
+c0105320:	83 c4 10             	add    $0x10,%esp
+    *(unsigned char *)0x2000 = 0x0b;
+c0105323:	b8 00 20 00 00       	mov    $0x2000,%eax
+c0105328:	c6 00 0b             	movb   $0xb,(%eax)
+    assert(pgfault_num==5);
+c010532b:	a1 0c 10 1b c0       	mov    0xc01b100c,%eax
+c0105330:	83 f8 05             	cmp    $0x5,%eax
+c0105333:	74 16                	je     c010534b <_fifo_check_swap+0x156>
+c0105335:	68 9a ca 10 c0       	push   $0xc010ca9a
+c010533a:	68 6e c9 10 c0       	push   $0xc010c96e
+c010533f:	6a 63                	push   $0x63
+c0105341:	68 83 c9 10 c0       	push   $0xc010c983
+c0105346:	e8 aa b0 ff ff       	call   c01003f5 <__panic>
+    cprintf("write Virt Page a in fifo_check_swap\n");
+c010534b:	83 ec 0c             	sub    $0xc,%esp
+c010534e:	68 fc c9 10 c0       	push   $0xc010c9fc
+c0105353:	e8 37 af ff ff       	call   c010028f <cprintf>
+c0105358:	83 c4 10             	add    $0x10,%esp
+    *(unsigned char *)0x1000 = 0x0a;
+c010535b:	b8 00 10 00 00       	mov    $0x1000,%eax
+c0105360:	c6 00 0a             	movb   $0xa,(%eax)
+    assert(pgfault_num==6);
+c0105363:	a1 0c 10 1b c0       	mov    0xc01b100c,%eax
+c0105368:	83 f8 06             	cmp    $0x6,%eax
+c010536b:	74 16                	je     c0105383 <_fifo_check_swap+0x18e>
+c010536d:	68 a9 ca 10 c0       	push   $0xc010caa9
+c0105372:	68 6e c9 10 c0       	push   $0xc010c96e
+c0105377:	6a 66                	push   $0x66
+c0105379:	68 83 c9 10 c0       	push   $0xc010c983
+c010537e:	e8 72 b0 ff ff       	call   c01003f5 <__panic>
+    cprintf("write Virt Page b in fifo_check_swap\n");
+c0105383:	83 ec 0c             	sub    $0xc,%esp
+c0105386:	68 4c ca 10 c0       	push   $0xc010ca4c
+c010538b:	e8 ff ae ff ff       	call   c010028f <cprintf>
+c0105390:	83 c4 10             	add    $0x10,%esp
+    *(unsigned char *)0x2000 = 0x0b;
+c0105393:	b8 00 20 00 00       	mov    $0x2000,%eax
+c0105398:	c6 00 0b             	movb   $0xb,(%eax)
+    assert(pgfault_num==7);
+c010539b:	a1 0c 10 1b c0       	mov    0xc01b100c,%eax
+c01053a0:	83 f8 07             	cmp    $0x7,%eax
+c01053a3:	74 16                	je     c01053bb <_fifo_check_swap+0x1c6>
+c01053a5:	68 b8 ca 10 c0       	push   $0xc010cab8
+c01053aa:	68 6e c9 10 c0       	push   $0xc010c96e
+c01053af:	6a 69                	push   $0x69
+c01053b1:	68 83 c9 10 c0       	push   $0xc010c983
+c01053b6:	e8 3a b0 ff ff       	call   c01003f5 <__panic>
+    cprintf("write Virt Page c in fifo_check_swap\n");
+c01053bb:	83 ec 0c             	sub    $0xc,%esp
+c01053be:	68 c4 c9 10 c0       	push   $0xc010c9c4
+c01053c3:	e8 c7 ae ff ff       	call   c010028f <cprintf>
+c01053c8:	83 c4 10             	add    $0x10,%esp
+    *(unsigned char *)0x3000 = 0x0c;
+c01053cb:	b8 00 30 00 00       	mov    $0x3000,%eax
+c01053d0:	c6 00 0c             	movb   $0xc,(%eax)
+    assert(pgfault_num==8);
+c01053d3:	a1 0c 10 1b c0       	mov    0xc01b100c,%eax
+c01053d8:	83 f8 08             	cmp    $0x8,%eax
+c01053db:	74 16                	je     c01053f3 <_fifo_check_swap+0x1fe>
+c01053dd:	68 c7 ca 10 c0       	push   $0xc010cac7
+c01053e2:	68 6e c9 10 c0       	push   $0xc010c96e
+c01053e7:	6a 6c                	push   $0x6c
+c01053e9:	68 83 c9 10 c0       	push   $0xc010c983
+c01053ee:	e8 02 b0 ff ff       	call   c01003f5 <__panic>
+    cprintf("write Virt Page d in fifo_check_swap\n");
+c01053f3:	83 ec 0c             	sub    $0xc,%esp
+c01053f6:	68 24 ca 10 c0       	push   $0xc010ca24
+c01053fb:	e8 8f ae ff ff       	call   c010028f <cprintf>
+c0105400:	83 c4 10             	add    $0x10,%esp
+    *(unsigned char *)0x4000 = 0x0d;
+c0105403:	b8 00 40 00 00       	mov    $0x4000,%eax
+c0105408:	c6 00 0d             	movb   $0xd,(%eax)
+    assert(pgfault_num==9);
+c010540b:	a1 0c 10 1b c0       	mov    0xc01b100c,%eax
+c0105410:	83 f8 09             	cmp    $0x9,%eax
+c0105413:	74 16                	je     c010542b <_fifo_check_swap+0x236>
+c0105415:	68 d6 ca 10 c0       	push   $0xc010cad6
+c010541a:	68 6e c9 10 c0       	push   $0xc010c96e
+c010541f:	6a 6f                	push   $0x6f
+c0105421:	68 83 c9 10 c0       	push   $0xc010c983
+c0105426:	e8 ca af ff ff       	call   c01003f5 <__panic>
+    cprintf("write Virt Page e in fifo_check_swap\n");
+c010542b:	83 ec 0c             	sub    $0xc,%esp
+c010542e:	68 74 ca 10 c0       	push   $0xc010ca74
+c0105433:	e8 57 ae ff ff       	call   c010028f <cprintf>
+c0105438:	83 c4 10             	add    $0x10,%esp
+    *(unsigned char *)0x5000 = 0x0e;
+c010543b:	b8 00 50 00 00       	mov    $0x5000,%eax
+c0105440:	c6 00 0e             	movb   $0xe,(%eax)
+    assert(pgfault_num==10);
+c0105443:	a1 0c 10 1b c0       	mov    0xc01b100c,%eax
+c0105448:	83 f8 0a             	cmp    $0xa,%eax
+c010544b:	74 16                	je     c0105463 <_fifo_check_swap+0x26e>
+c010544d:	68 e5 ca 10 c0       	push   $0xc010cae5
+c0105452:	68 6e c9 10 c0       	push   $0xc010c96e
+c0105457:	6a 72                	push   $0x72
+c0105459:	68 83 c9 10 c0       	push   $0xc010c983
+c010545e:	e8 92 af ff ff       	call   c01003f5 <__panic>
+    cprintf("write Virt Page a in fifo_check_swap\n");
+c0105463:	83 ec 0c             	sub    $0xc,%esp
+c0105466:	68 fc c9 10 c0       	push   $0xc010c9fc
+c010546b:	e8 1f ae ff ff       	call   c010028f <cprintf>
+c0105470:	83 c4 10             	add    $0x10,%esp
+    assert(*(unsigned char *)0x1000 == 0x0a);
+c0105473:	b8 00 10 00 00       	mov    $0x1000,%eax
+c0105478:	0f b6 00             	movzbl (%eax),%eax
+c010547b:	3c 0a                	cmp    $0xa,%al
+c010547d:	74 16                	je     c0105495 <_fifo_check_swap+0x2a0>
+c010547f:	68 f8 ca 10 c0       	push   $0xc010caf8
+c0105484:	68 6e c9 10 c0       	push   $0xc010c96e
+c0105489:	6a 74                	push   $0x74
+c010548b:	68 83 c9 10 c0       	push   $0xc010c983
+c0105490:	e8 60 af ff ff       	call   c01003f5 <__panic>
+    *(unsigned char *)0x1000 = 0x0a;
+c0105495:	b8 00 10 00 00       	mov    $0x1000,%eax
+c010549a:	c6 00 0a             	movb   $0xa,(%eax)
+    assert(pgfault_num==11);
+c010549d:	a1 0c 10 1b c0       	mov    0xc01b100c,%eax
+c01054a2:	83 f8 0b             	cmp    $0xb,%eax
+c01054a5:	74 16                	je     c01054bd <_fifo_check_swap+0x2c8>
+c01054a7:	68 19 cb 10 c0       	push   $0xc010cb19
+c01054ac:	68 6e c9 10 c0       	push   $0xc010c96e
+c01054b1:	6a 76                	push   $0x76
+c01054b3:	68 83 c9 10 c0       	push   $0xc010c983
+c01054b8:	e8 38 af ff ff       	call   c01003f5 <__panic>
+    return 0;
+c01054bd:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c01054c2:	c9                   	leave  
+c01054c3:	c3                   	ret    
+
+c01054c4 <_fifo_init>:
+
+
+static int
+_fifo_init(void)
+{
+c01054c4:	55                   	push   %ebp
+c01054c5:	89 e5                	mov    %esp,%ebp
+    return 0;
+c01054c7:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c01054cc:	5d                   	pop    %ebp
+c01054cd:	c3                   	ret    
+
+c01054ce <_fifo_set_unswappable>:
+
+static int
+_fifo_set_unswappable(struct mm_struct *mm, uintptr_t addr)
+{
+c01054ce:	55                   	push   %ebp
+c01054cf:	89 e5                	mov    %esp,%ebp
+    return 0;
+c01054d1:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c01054d6:	5d                   	pop    %ebp
+c01054d7:	c3                   	ret    
+
+c01054d8 <_fifo_tick_event>:
+
+static int
+_fifo_tick_event(struct mm_struct *mm)
+{ return 0; }
+c01054d8:	55                   	push   %ebp
+c01054d9:	89 e5                	mov    %esp,%ebp
+c01054db:	b8 00 00 00 00       	mov    $0x0,%eax
+c01054e0:	5d                   	pop    %ebp
+c01054e1:	c3                   	ret    
+
+c01054e2 <lock_init>:
+#define local_intr_restore(x)   __intr_restore(x);
+
+typedef volatile bool lock_t;
+
+static inline void
+lock_init(lock_t *lock) {
+c01054e2:	55                   	push   %ebp
+c01054e3:	89 e5                	mov    %esp,%ebp
+    *lock = 0;
+c01054e5:	8b 45 08             	mov    0x8(%ebp),%eax
+c01054e8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+}
+c01054ee:	90                   	nop
+c01054ef:	5d                   	pop    %ebp
+c01054f0:	c3                   	ret    
+
+c01054f1 <mm_count>:
+bool user_mem_check(struct mm_struct *mm, uintptr_t start, size_t len, bool write);
+bool copy_from_user(struct mm_struct *mm, void *dst, const void *src, size_t len, bool writable);
+bool copy_to_user(struct mm_struct *mm, void *dst, const void *src, size_t len);
+
+static inline int
+mm_count(struct mm_struct *mm) {
+c01054f1:	55                   	push   %ebp
+c01054f2:	89 e5                	mov    %esp,%ebp
+    return mm->mm_count;
+c01054f4:	8b 45 08             	mov    0x8(%ebp),%eax
+c01054f7:	8b 40 18             	mov    0x18(%eax),%eax
+}
+c01054fa:	5d                   	pop    %ebp
+c01054fb:	c3                   	ret    
+
+c01054fc <set_mm_count>:
+
+static inline void
+set_mm_count(struct mm_struct *mm, int val) {
+c01054fc:	55                   	push   %ebp
+c01054fd:	89 e5                	mov    %esp,%ebp
+    mm->mm_count = val;
+c01054ff:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105502:	8b 55 0c             	mov    0xc(%ebp),%edx
+c0105505:	89 50 18             	mov    %edx,0x18(%eax)
+}
+c0105508:	90                   	nop
+c0105509:	5d                   	pop    %ebp
+c010550a:	c3                   	ret    
+
+c010550b <pa2page>:
+page2pa(struct Page *page) {
+    return page2ppn(page) << PGSHIFT;
+}
+
+static inline struct Page *
+pa2page(uintptr_t pa) {
+c010550b:	55                   	push   %ebp
+c010550c:	89 e5                	mov    %esp,%ebp
+c010550e:	83 ec 08             	sub    $0x8,%esp
+    if (PPN(pa) >= npage) {
+c0105511:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105514:	c1 e8 0c             	shr    $0xc,%eax
+c0105517:	89 c2                	mov    %eax,%edx
+c0105519:	a1 80 0f 1b c0       	mov    0xc01b0f80,%eax
+c010551e:	39 c2                	cmp    %eax,%edx
+c0105520:	72 14                	jb     c0105536 <pa2page+0x2b>
+        panic("pa2page called with invalid pa");
+c0105522:	83 ec 04             	sub    $0x4,%esp
+c0105525:	68 3c cb 10 c0       	push   $0xc010cb3c
+c010552a:	6a 5e                	push   $0x5e
+c010552c:	68 5b cb 10 c0       	push   $0xc010cb5b
+c0105531:	e8 bf ae ff ff       	call   c01003f5 <__panic>
+    }
+    return &pages[PPN(pa)];
+c0105536:	a1 84 30 1b c0       	mov    0xc01b3084,%eax
+c010553b:	8b 55 08             	mov    0x8(%ebp),%edx
+c010553e:	c1 ea 0c             	shr    $0xc,%edx
+c0105541:	c1 e2 05             	shl    $0x5,%edx
+c0105544:	01 d0                	add    %edx,%eax
+}
+c0105546:	c9                   	leave  
+c0105547:	c3                   	ret    
+
+c0105548 <pde2page>:
+    }
+    return pa2page(PTE_ADDR(pte));
+}
+
+static inline struct Page *
+pde2page(pde_t pde) {
+c0105548:	55                   	push   %ebp
+c0105549:	89 e5                	mov    %esp,%ebp
+c010554b:	83 ec 08             	sub    $0x8,%esp
+    return pa2page(PDE_ADDR(pde));
+c010554e:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105551:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+c0105556:	83 ec 0c             	sub    $0xc,%esp
+c0105559:	50                   	push   %eax
+c010555a:	e8 ac ff ff ff       	call   c010550b <pa2page>
+c010555f:	83 c4 10             	add    $0x10,%esp
+}
+c0105562:	c9                   	leave  
+c0105563:	c3                   	ret    
+
+c0105564 <mm_create>:
+static void check_vma_struct(void);
+static void check_pgfault(void);
+
+// mm_create -  alloc a mm_struct & initialize it.
+struct mm_struct *
+mm_create(void) {
+c0105564:	55                   	push   %ebp
+c0105565:	89 e5                	mov    %esp,%ebp
+c0105567:	83 ec 18             	sub    $0x18,%esp
+    struct mm_struct *mm = kmalloc(sizeof(struct mm_struct));
+c010556a:	83 ec 0c             	sub    $0xc,%esp
+c010556d:	6a 20                	push   $0x20
+c010556f:	e8 3d 16 00 00       	call   c0106bb1 <kmalloc>
+c0105574:	83 c4 10             	add    $0x10,%esp
+c0105577:	89 45 f4             	mov    %eax,-0xc(%ebp)
+
+    if (mm != NULL) {
+c010557a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c010557e:	74 7d                	je     c01055fd <mm_create+0x99>
+        list_init(&(mm->mmap_list));
+c0105580:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105583:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ * list_init - initialize a new entry
+ * @elm:        new entry to be initialized
+ * */
+static inline void
+list_init(list_entry_t *elm) {
+    elm->prev = elm->next = elm;
+c0105586:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0105589:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c010558c:	89 50 04             	mov    %edx,0x4(%eax)
+c010558f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0105592:	8b 50 04             	mov    0x4(%eax),%edx
+c0105595:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0105598:	89 10                	mov    %edx,(%eax)
+        mm->mmap_cache = NULL;
+c010559a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010559d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
+        mm->pgdir = NULL;
+c01055a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01055a7:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
+        mm->map_count = 0;
+c01055ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01055b1:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
+
+        if (swap_init_ok) swap_init_mm(mm);
+c01055b8:	a1 14 10 1b c0       	mov    0xc01b1014,%eax
+c01055bd:	85 c0                	test   %eax,%eax
+c01055bf:	74 10                	je     c01055d1 <mm_create+0x6d>
+c01055c1:	83 ec 0c             	sub    $0xc,%esp
+c01055c4:	ff 75 f4             	pushl  -0xc(%ebp)
+c01055c7:	e8 61 18 00 00       	call   c0106e2d <swap_init_mm>
+c01055cc:	83 c4 10             	add    $0x10,%esp
+c01055cf:	eb 0a                	jmp    c01055db <mm_create+0x77>
+        else mm->sm_priv = NULL;
+c01055d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01055d4:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
+        
+        set_mm_count(mm, 0);
+c01055db:	83 ec 08             	sub    $0x8,%esp
+c01055de:	6a 00                	push   $0x0
+c01055e0:	ff 75 f4             	pushl  -0xc(%ebp)
+c01055e3:	e8 14 ff ff ff       	call   c01054fc <set_mm_count>
+c01055e8:	83 c4 10             	add    $0x10,%esp
+        lock_init(&(mm->mm_lock));
+c01055eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01055ee:	83 c0 1c             	add    $0x1c,%eax
+c01055f1:	83 ec 0c             	sub    $0xc,%esp
+c01055f4:	50                   	push   %eax
+c01055f5:	e8 e8 fe ff ff       	call   c01054e2 <lock_init>
+c01055fa:	83 c4 10             	add    $0x10,%esp
+    }    
+    return mm;
+c01055fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+c0105600:	c9                   	leave  
+c0105601:	c3                   	ret    
+
+c0105602 <vma_create>:
+
+// vma_create - alloc a vma_struct & initialize it. (addr range: vm_start~vm_end)
+struct vma_struct *
+vma_create(uintptr_t vm_start, uintptr_t vm_end, uint32_t vm_flags) {
+c0105602:	55                   	push   %ebp
+c0105603:	89 e5                	mov    %esp,%ebp
+c0105605:	83 ec 18             	sub    $0x18,%esp
+    struct vma_struct *vma = kmalloc(sizeof(struct vma_struct));
+c0105608:	83 ec 0c             	sub    $0xc,%esp
+c010560b:	6a 18                	push   $0x18
+c010560d:	e8 9f 15 00 00       	call   c0106bb1 <kmalloc>
+c0105612:	83 c4 10             	add    $0x10,%esp
+c0105615:	89 45 f4             	mov    %eax,-0xc(%ebp)
+
+    if (vma != NULL) {
+c0105618:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c010561c:	74 1b                	je     c0105639 <vma_create+0x37>
+        vma->vm_start = vm_start;
+c010561e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105621:	8b 55 08             	mov    0x8(%ebp),%edx
+c0105624:	89 50 04             	mov    %edx,0x4(%eax)
+        vma->vm_end = vm_end;
+c0105627:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010562a:	8b 55 0c             	mov    0xc(%ebp),%edx
+c010562d:	89 50 08             	mov    %edx,0x8(%eax)
+        vma->vm_flags = vm_flags;
+c0105630:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105633:	8b 55 10             	mov    0x10(%ebp),%edx
+c0105636:	89 50 0c             	mov    %edx,0xc(%eax)
+    }
+    return vma;
+c0105639:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+c010563c:	c9                   	leave  
+c010563d:	c3                   	ret    
+
+c010563e <find_vma>:
+
+
+// find_vma - find a vma  (vma->vm_start <= addr <= vma_vm_end)
+struct vma_struct *
+find_vma(struct mm_struct *mm, uintptr_t addr) {
+c010563e:	55                   	push   %ebp
+c010563f:	89 e5                	mov    %esp,%ebp
+c0105641:	83 ec 20             	sub    $0x20,%esp
+    struct vma_struct *vma = NULL;
+c0105644:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    if (mm != NULL) {
+c010564b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c010564f:	0f 84 95 00 00 00    	je     c01056ea <find_vma+0xac>
+        vma = mm->mmap_cache;
+c0105655:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105658:	8b 40 08             	mov    0x8(%eax),%eax
+c010565b:	89 45 fc             	mov    %eax,-0x4(%ebp)
+        if (!(vma != NULL && vma->vm_start <= addr && vma->vm_end > addr)) {
+c010565e:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+c0105662:	74 16                	je     c010567a <find_vma+0x3c>
+c0105664:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0105667:	8b 40 04             	mov    0x4(%eax),%eax
+c010566a:	3b 45 0c             	cmp    0xc(%ebp),%eax
+c010566d:	77 0b                	ja     c010567a <find_vma+0x3c>
+c010566f:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0105672:	8b 40 08             	mov    0x8(%eax),%eax
+c0105675:	3b 45 0c             	cmp    0xc(%ebp),%eax
+c0105678:	77 61                	ja     c01056db <find_vma+0x9d>
+                bool found = 0;
+c010567a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+                list_entry_t *list = &(mm->mmap_list), *le = list;
+c0105681:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105684:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0105687:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010568a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+                while ((le = list_next(le)) != list) {
+c010568d:	eb 28                	jmp    c01056b7 <find_vma+0x79>
+                    vma = le2vma(le, list_link);
+c010568f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105692:	83 e8 10             	sub    $0x10,%eax
+c0105695:	89 45 fc             	mov    %eax,-0x4(%ebp)
+                    if (vma->vm_start<=addr && addr < vma->vm_end) {
+c0105698:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c010569b:	8b 40 04             	mov    0x4(%eax),%eax
+c010569e:	3b 45 0c             	cmp    0xc(%ebp),%eax
+c01056a1:	77 14                	ja     c01056b7 <find_vma+0x79>
+c01056a3:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c01056a6:	8b 40 08             	mov    0x8(%eax),%eax
+c01056a9:	3b 45 0c             	cmp    0xc(%ebp),%eax
+c01056ac:	76 09                	jbe    c01056b7 <find_vma+0x79>
+                        found = 1;
+c01056ae:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
+                        break;
+c01056b5:	eb 17                	jmp    c01056ce <find_vma+0x90>
+c01056b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01056ba:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ * list_next - get the next entry
+ * @listelm:    the list head
+ **/
+static inline list_entry_t *
+list_next(list_entry_t *listelm) {
+    return listelm->next;
+c01056bd:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01056c0:	8b 40 04             	mov    0x4(%eax),%eax
+    if (mm != NULL) {
+        vma = mm->mmap_cache;
+        if (!(vma != NULL && vma->vm_start <= addr && vma->vm_end > addr)) {
+                bool found = 0;
+                list_entry_t *list = &(mm->mmap_list), *le = list;
+                while ((le = list_next(le)) != list) {
+c01056c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c01056c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01056c9:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+c01056cc:	75 c1                	jne    c010568f <find_vma+0x51>
+                    if (vma->vm_start<=addr && addr < vma->vm_end) {
+                        found = 1;
+                        break;
+                    }
+                }
+                if (!found) {
+c01056ce:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
+c01056d2:	75 07                	jne    c01056db <find_vma+0x9d>
+                    vma = NULL;
+c01056d4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+                }
+        }
+        if (vma != NULL) {
+c01056db:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+c01056df:	74 09                	je     c01056ea <find_vma+0xac>
+            mm->mmap_cache = vma;
+c01056e1:	8b 45 08             	mov    0x8(%ebp),%eax
+c01056e4:	8b 55 fc             	mov    -0x4(%ebp),%edx
+c01056e7:	89 50 08             	mov    %edx,0x8(%eax)
+        }
+    }
+    return vma;
+c01056ea:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+c01056ed:	c9                   	leave  
+c01056ee:	c3                   	ret    
+
+c01056ef <check_vma_overlap>:
+
+
+// check_vma_overlap - check if vma1 overlaps vma2 ?
+static inline void
+check_vma_overlap(struct vma_struct *prev, struct vma_struct *next) {
+c01056ef:	55                   	push   %ebp
+c01056f0:	89 e5                	mov    %esp,%ebp
+c01056f2:	83 ec 08             	sub    $0x8,%esp
+    assert(prev->vm_start < prev->vm_end);
+c01056f5:	8b 45 08             	mov    0x8(%ebp),%eax
+c01056f8:	8b 50 04             	mov    0x4(%eax),%edx
+c01056fb:	8b 45 08             	mov    0x8(%ebp),%eax
+c01056fe:	8b 40 08             	mov    0x8(%eax),%eax
+c0105701:	39 c2                	cmp    %eax,%edx
+c0105703:	72 16                	jb     c010571b <check_vma_overlap+0x2c>
+c0105705:	68 69 cb 10 c0       	push   $0xc010cb69
+c010570a:	68 87 cb 10 c0       	push   $0xc010cb87
+c010570f:	6a 6b                	push   $0x6b
+c0105711:	68 9c cb 10 c0       	push   $0xc010cb9c
+c0105716:	e8 da ac ff ff       	call   c01003f5 <__panic>
+    assert(prev->vm_end <= next->vm_start);
+c010571b:	8b 45 08             	mov    0x8(%ebp),%eax
+c010571e:	8b 50 08             	mov    0x8(%eax),%edx
+c0105721:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0105724:	8b 40 04             	mov    0x4(%eax),%eax
+c0105727:	39 c2                	cmp    %eax,%edx
+c0105729:	76 16                	jbe    c0105741 <check_vma_overlap+0x52>
+c010572b:	68 ac cb 10 c0       	push   $0xc010cbac
+c0105730:	68 87 cb 10 c0       	push   $0xc010cb87
+c0105735:	6a 6c                	push   $0x6c
+c0105737:	68 9c cb 10 c0       	push   $0xc010cb9c
+c010573c:	e8 b4 ac ff ff       	call   c01003f5 <__panic>
+    assert(next->vm_start < next->vm_end);
+c0105741:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0105744:	8b 50 04             	mov    0x4(%eax),%edx
+c0105747:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010574a:	8b 40 08             	mov    0x8(%eax),%eax
+c010574d:	39 c2                	cmp    %eax,%edx
+c010574f:	72 16                	jb     c0105767 <check_vma_overlap+0x78>
+c0105751:	68 cb cb 10 c0       	push   $0xc010cbcb
+c0105756:	68 87 cb 10 c0       	push   $0xc010cb87
+c010575b:	6a 6d                	push   $0x6d
+c010575d:	68 9c cb 10 c0       	push   $0xc010cb9c
+c0105762:	e8 8e ac ff ff       	call   c01003f5 <__panic>
+}
+c0105767:	90                   	nop
+c0105768:	c9                   	leave  
+c0105769:	c3                   	ret    
+
+c010576a <insert_vma_struct>:
+
+
+// insert_vma_struct -insert vma in mm's list link
+void
+insert_vma_struct(struct mm_struct *mm, struct vma_struct *vma) {
+c010576a:	55                   	push   %ebp
+c010576b:	89 e5                	mov    %esp,%ebp
+c010576d:	83 ec 38             	sub    $0x38,%esp
+    assert(vma->vm_start < vma->vm_end);
+c0105770:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0105773:	8b 50 04             	mov    0x4(%eax),%edx
+c0105776:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0105779:	8b 40 08             	mov    0x8(%eax),%eax
+c010577c:	39 c2                	cmp    %eax,%edx
+c010577e:	72 16                	jb     c0105796 <insert_vma_struct+0x2c>
+c0105780:	68 e9 cb 10 c0       	push   $0xc010cbe9
+c0105785:	68 87 cb 10 c0       	push   $0xc010cb87
+c010578a:	6a 74                	push   $0x74
+c010578c:	68 9c cb 10 c0       	push   $0xc010cb9c
+c0105791:	e8 5f ac ff ff       	call   c01003f5 <__panic>
+    list_entry_t *list = &(mm->mmap_list);
+c0105796:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105799:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    list_entry_t *le_prev = list, *le_next;
+c010579c:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010579f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+
+        list_entry_t *le = list;
+c01057a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01057a5:	89 45 f0             	mov    %eax,-0x10(%ebp)
+        while ((le = list_next(le)) != list) {
+c01057a8:	eb 1f                	jmp    c01057c9 <insert_vma_struct+0x5f>
+            struct vma_struct *mmap_prev = le2vma(le, list_link);
+c01057aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01057ad:	83 e8 10             	sub    $0x10,%eax
+c01057b0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+            if (mmap_prev->vm_start > vma->vm_start) {
+c01057b3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01057b6:	8b 50 04             	mov    0x4(%eax),%edx
+c01057b9:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01057bc:	8b 40 04             	mov    0x4(%eax),%eax
+c01057bf:	39 c2                	cmp    %eax,%edx
+c01057c1:	77 1f                	ja     c01057e2 <insert_vma_struct+0x78>
+                break;
+            }
+            le_prev = le;
+c01057c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01057c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c01057c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01057cc:	89 45 d8             	mov    %eax,-0x28(%ebp)
+c01057cf:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c01057d2:	8b 40 04             	mov    0x4(%eax),%eax
+    assert(vma->vm_start < vma->vm_end);
+    list_entry_t *list = &(mm->mmap_list);
+    list_entry_t *le_prev = list, *le_next;
+
+        list_entry_t *le = list;
+        while ((le = list_next(le)) != list) {
+c01057d5:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c01057d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01057db:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+c01057de:	75 ca                	jne    c01057aa <insert_vma_struct+0x40>
+c01057e0:	eb 01                	jmp    c01057e3 <insert_vma_struct+0x79>
+            struct vma_struct *mmap_prev = le2vma(le, list_link);
+            if (mmap_prev->vm_start > vma->vm_start) {
+                break;
+c01057e2:	90                   	nop
+c01057e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01057e6:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c01057e9:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c01057ec:	8b 40 04             	mov    0x4(%eax),%eax
+            }
+            le_prev = le;
+        }
+
+    le_next = list_next(le_prev);
+c01057ef:	89 45 dc             	mov    %eax,-0x24(%ebp)
+
+    /* check overlap */
+    if (le_prev != list) {
+c01057f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01057f5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+c01057f8:	74 15                	je     c010580f <insert_vma_struct+0xa5>
+        check_vma_overlap(le2vma(le_prev, list_link), vma);
+c01057fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01057fd:	83 e8 10             	sub    $0x10,%eax
+c0105800:	83 ec 08             	sub    $0x8,%esp
+c0105803:	ff 75 0c             	pushl  0xc(%ebp)
+c0105806:	50                   	push   %eax
+c0105807:	e8 e3 fe ff ff       	call   c01056ef <check_vma_overlap>
+c010580c:	83 c4 10             	add    $0x10,%esp
+    }
+    if (le_next != list) {
+c010580f:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0105812:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+c0105815:	74 15                	je     c010582c <insert_vma_struct+0xc2>
+        check_vma_overlap(vma, le2vma(le_next, list_link));
+c0105817:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c010581a:	83 e8 10             	sub    $0x10,%eax
+c010581d:	83 ec 08             	sub    $0x8,%esp
+c0105820:	50                   	push   %eax
+c0105821:	ff 75 0c             	pushl  0xc(%ebp)
+c0105824:	e8 c6 fe ff ff       	call   c01056ef <check_vma_overlap>
+c0105829:	83 c4 10             	add    $0x10,%esp
+    }
+
+    vma->vm_mm = mm;
+c010582c:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010582f:	8b 55 08             	mov    0x8(%ebp),%edx
+c0105832:	89 10                	mov    %edx,(%eax)
+    list_add_after(le_prev, &(vma->list_link));
+c0105834:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0105837:	8d 50 10             	lea    0x10(%eax),%edx
+c010583a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010583d:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c0105840:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+ * Insert the new element @elm *after* the element @listelm which
+ * is already in the list.
+ * */
+static inline void
+list_add_after(list_entry_t *listelm, list_entry_t *elm) {
+    __list_add(elm, listelm, listelm->next);
+c0105843:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0105846:	8b 40 04             	mov    0x4(%eax),%eax
+c0105849:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c010584c:	89 55 d0             	mov    %edx,-0x30(%ebp)
+c010584f:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c0105852:	89 55 cc             	mov    %edx,-0x34(%ebp)
+c0105855:	89 45 c8             	mov    %eax,-0x38(%ebp)
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ * */
+static inline void
+__list_add(list_entry_t *elm, list_entry_t *prev, list_entry_t *next) {
+    prev->next = next->prev = elm;
+c0105858:	8b 45 c8             	mov    -0x38(%ebp),%eax
+c010585b:	8b 55 d0             	mov    -0x30(%ebp),%edx
+c010585e:	89 10                	mov    %edx,(%eax)
+c0105860:	8b 45 c8             	mov    -0x38(%ebp),%eax
+c0105863:	8b 10                	mov    (%eax),%edx
+c0105865:	8b 45 cc             	mov    -0x34(%ebp),%eax
+c0105868:	89 50 04             	mov    %edx,0x4(%eax)
+    elm->next = next;
+c010586b:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c010586e:	8b 55 c8             	mov    -0x38(%ebp),%edx
+c0105871:	89 50 04             	mov    %edx,0x4(%eax)
+    elm->prev = prev;
+c0105874:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c0105877:	8b 55 cc             	mov    -0x34(%ebp),%edx
+c010587a:	89 10                	mov    %edx,(%eax)
+
+    mm->map_count ++;
+c010587c:	8b 45 08             	mov    0x8(%ebp),%eax
+c010587f:	8b 40 10             	mov    0x10(%eax),%eax
+c0105882:	8d 50 01             	lea    0x1(%eax),%edx
+c0105885:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105888:	89 50 10             	mov    %edx,0x10(%eax)
+}
+c010588b:	90                   	nop
+c010588c:	c9                   	leave  
+c010588d:	c3                   	ret    
+
+c010588e <mm_destroy>:
+
+// mm_destroy - free mm and mm internal fields
+void
+mm_destroy(struct mm_struct *mm) {
+c010588e:	55                   	push   %ebp
+c010588f:	89 e5                	mov    %esp,%ebp
+c0105891:	83 ec 28             	sub    $0x28,%esp
+    assert(mm_count(mm) == 0);
+c0105894:	ff 75 08             	pushl  0x8(%ebp)
+c0105897:	e8 55 fc ff ff       	call   c01054f1 <mm_count>
+c010589c:	83 c4 04             	add    $0x4,%esp
+c010589f:	85 c0                	test   %eax,%eax
+c01058a1:	74 19                	je     c01058bc <mm_destroy+0x2e>
+c01058a3:	68 05 cc 10 c0       	push   $0xc010cc05
+c01058a8:	68 87 cb 10 c0       	push   $0xc010cb87
+c01058ad:	68 94 00 00 00       	push   $0x94
+c01058b2:	68 9c cb 10 c0       	push   $0xc010cb9c
+c01058b7:	e8 39 ab ff ff       	call   c01003f5 <__panic>
+
+    list_entry_t *list = &(mm->mmap_list), *le;
+c01058bc:	8b 45 08             	mov    0x8(%ebp),%eax
+c01058bf:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    while ((le = list_next(list)) != list) {
+c01058c2:	eb 3a                	jmp    c01058fe <mm_destroy+0x70>
+c01058c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01058c7:	89 45 e8             	mov    %eax,-0x18(%ebp)
+ * Note: list_empty() on @listelm does not return true after this, the entry is
+ * in an undefined state.
+ * */
+static inline void
+list_del(list_entry_t *listelm) {
+    __list_del(listelm->prev, listelm->next);
+c01058ca:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c01058cd:	8b 40 04             	mov    0x4(%eax),%eax
+c01058d0:	8b 55 e8             	mov    -0x18(%ebp),%edx
+c01058d3:	8b 12                	mov    (%edx),%edx
+c01058d5:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+c01058d8:	89 45 e0             	mov    %eax,-0x20(%ebp)
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ * */
+static inline void
+__list_del(list_entry_t *prev, list_entry_t *next) {
+    prev->next = next;
+c01058db:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01058de:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c01058e1:	89 50 04             	mov    %edx,0x4(%eax)
+    next->prev = prev;
+c01058e4:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c01058e7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c01058ea:	89 10                	mov    %edx,(%eax)
+        list_del(le);
+        kfree(le2vma(le, list_link));  //kfree vma        
+c01058ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01058ef:	83 e8 10             	sub    $0x10,%eax
+c01058f2:	83 ec 0c             	sub    $0xc,%esp
+c01058f5:	50                   	push   %eax
+c01058f6:	e8 ce 12 00 00       	call   c0106bc9 <kfree>
+c01058fb:	83 c4 10             	add    $0x10,%esp
+c01058fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105901:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ * list_next - get the next entry
+ * @listelm:    the list head
+ **/
+static inline list_entry_t *
+list_next(list_entry_t *listelm) {
+    return listelm->next;
+c0105904:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0105907:	8b 40 04             	mov    0x4(%eax),%eax
+void
+mm_destroy(struct mm_struct *mm) {
+    assert(mm_count(mm) == 0);
+
+    list_entry_t *list = &(mm->mmap_list), *le;
+    while ((le = list_next(list)) != list) {
+c010590a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c010590d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0105910:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+c0105913:	75 af                	jne    c01058c4 <mm_destroy+0x36>
+        list_del(le);
+        kfree(le2vma(le, list_link));  //kfree vma        
+    }
+    kfree(mm); //kfree mm
+c0105915:	83 ec 0c             	sub    $0xc,%esp
+c0105918:	ff 75 08             	pushl  0x8(%ebp)
+c010591b:	e8 a9 12 00 00       	call   c0106bc9 <kfree>
+c0105920:	83 c4 10             	add    $0x10,%esp
+    mm=NULL;
+c0105923:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
+}
+c010592a:	90                   	nop
+c010592b:	c9                   	leave  
+c010592c:	c3                   	ret    
+
+c010592d <mm_map>:
+
+int
+mm_map(struct mm_struct *mm, uintptr_t addr, size_t len, uint32_t vm_flags,
+       struct vma_struct **vma_store) {
+c010592d:	55                   	push   %ebp
+c010592e:	89 e5                	mov    %esp,%ebp
+c0105930:	83 ec 28             	sub    $0x28,%esp
+    uintptr_t start = ROUNDDOWN(addr, PGSIZE), end = ROUNDUP(addr + len, PGSIZE);
+c0105933:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0105936:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0105939:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010593c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+c0105941:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0105944:	c7 45 e8 00 10 00 00 	movl   $0x1000,-0x18(%ebp)
+c010594b:	8b 55 0c             	mov    0xc(%ebp),%edx
+c010594e:	8b 45 10             	mov    0x10(%ebp),%eax
+c0105951:	01 c2                	add    %eax,%edx
+c0105953:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0105956:	01 d0                	add    %edx,%eax
+c0105958:	83 e8 01             	sub    $0x1,%eax
+c010595b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c010595e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0105961:	ba 00 00 00 00       	mov    $0x0,%edx
+c0105966:	f7 75 e8             	divl   -0x18(%ebp)
+c0105969:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c010596c:	29 d0                	sub    %edx,%eax
+c010596e:	89 45 e0             	mov    %eax,-0x20(%ebp)
+    if (!USER_ACCESS(start, end)) {
+c0105971:	81 7d ec ff ff 1f 00 	cmpl   $0x1fffff,-0x14(%ebp)
+c0105978:	76 11                	jbe    c010598b <mm_map+0x5e>
+c010597a:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010597d:	3b 45 e0             	cmp    -0x20(%ebp),%eax
+c0105980:	73 09                	jae    c010598b <mm_map+0x5e>
+c0105982:	81 7d e0 00 00 00 b0 	cmpl   $0xb0000000,-0x20(%ebp)
+c0105989:	76 0a                	jbe    c0105995 <mm_map+0x68>
+        return -E_INVAL;
+c010598b:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+c0105990:	e9 9e 00 00 00       	jmp    c0105a33 <mm_map+0x106>
+    }
+
+    assert(mm != NULL);
+c0105995:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c0105999:	75 19                	jne    c01059b4 <mm_map+0x87>
+c010599b:	68 17 cc 10 c0       	push   $0xc010cc17
+c01059a0:	68 87 cb 10 c0       	push   $0xc010cb87
+c01059a5:	68 a7 00 00 00       	push   $0xa7
+c01059aa:	68 9c cb 10 c0       	push   $0xc010cb9c
+c01059af:	e8 41 aa ff ff       	call   c01003f5 <__panic>
+
+    int ret = -E_INVAL;
+c01059b4:	c7 45 f4 fd ff ff ff 	movl   $0xfffffffd,-0xc(%ebp)
+
+    struct vma_struct *vma;
+    if ((vma = find_vma(mm, start)) != NULL && end > vma->vm_start) {
+c01059bb:	83 ec 08             	sub    $0x8,%esp
+c01059be:	ff 75 ec             	pushl  -0x14(%ebp)
+c01059c1:	ff 75 08             	pushl  0x8(%ebp)
+c01059c4:	e8 75 fc ff ff       	call   c010563e <find_vma>
+c01059c9:	83 c4 10             	add    $0x10,%esp
+c01059cc:	89 45 dc             	mov    %eax,-0x24(%ebp)
+c01059cf:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+c01059d3:	74 0b                	je     c01059e0 <mm_map+0xb3>
+c01059d5:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c01059d8:	8b 40 04             	mov    0x4(%eax),%eax
+c01059db:	3b 45 e0             	cmp    -0x20(%ebp),%eax
+c01059de:	72 4c                	jb     c0105a2c <mm_map+0xff>
+        goto out;
+    }
+    ret = -E_NO_MEM;
+c01059e0:	c7 45 f4 fc ff ff ff 	movl   $0xfffffffc,-0xc(%ebp)
+
+    if ((vma = vma_create(start, end, vm_flags)) == NULL) {
+c01059e7:	83 ec 04             	sub    $0x4,%esp
+c01059ea:	ff 75 14             	pushl  0x14(%ebp)
+c01059ed:	ff 75 e0             	pushl  -0x20(%ebp)
+c01059f0:	ff 75 ec             	pushl  -0x14(%ebp)
+c01059f3:	e8 0a fc ff ff       	call   c0105602 <vma_create>
+c01059f8:	83 c4 10             	add    $0x10,%esp
+c01059fb:	89 45 dc             	mov    %eax,-0x24(%ebp)
+c01059fe:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+c0105a02:	74 2b                	je     c0105a2f <mm_map+0x102>
+        goto out;
+    }
+    insert_vma_struct(mm, vma);
+c0105a04:	83 ec 08             	sub    $0x8,%esp
+c0105a07:	ff 75 dc             	pushl  -0x24(%ebp)
+c0105a0a:	ff 75 08             	pushl  0x8(%ebp)
+c0105a0d:	e8 58 fd ff ff       	call   c010576a <insert_vma_struct>
+c0105a12:	83 c4 10             	add    $0x10,%esp
+    if (vma_store != NULL) {
+c0105a15:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
+c0105a19:	74 08                	je     c0105a23 <mm_map+0xf6>
+        *vma_store = vma;
+c0105a1b:	8b 45 18             	mov    0x18(%ebp),%eax
+c0105a1e:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c0105a21:	89 10                	mov    %edx,(%eax)
+    }
+    ret = 0;
+c0105a23:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c0105a2a:	eb 04                	jmp    c0105a30 <mm_map+0x103>
+
+    int ret = -E_INVAL;
+
+    struct vma_struct *vma;
+    if ((vma = find_vma(mm, start)) != NULL && end > vma->vm_start) {
+        goto out;
+c0105a2c:	90                   	nop
+c0105a2d:	eb 01                	jmp    c0105a30 <mm_map+0x103>
+    }
+    ret = -E_NO_MEM;
+
+    if ((vma = vma_create(start, end, vm_flags)) == NULL) {
+        goto out;
+c0105a2f:	90                   	nop
+        *vma_store = vma;
+    }
+    ret = 0;
+
+out:
+    return ret;
+c0105a30:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+c0105a33:	c9                   	leave  
+c0105a34:	c3                   	ret    
+
+c0105a35 <dup_mmap>:
+
+int
+dup_mmap(struct mm_struct *to, struct mm_struct *from) {
+c0105a35:	55                   	push   %ebp
+c0105a36:	89 e5                	mov    %esp,%ebp
+c0105a38:	53                   	push   %ebx
+c0105a39:	83 ec 24             	sub    $0x24,%esp
+    assert(to != NULL && from != NULL);
+c0105a3c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c0105a40:	74 06                	je     c0105a48 <dup_mmap+0x13>
+c0105a42:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+c0105a46:	75 19                	jne    c0105a61 <dup_mmap+0x2c>
+c0105a48:	68 22 cc 10 c0       	push   $0xc010cc22
+c0105a4d:	68 87 cb 10 c0       	push   $0xc010cb87
+c0105a52:	68 c0 00 00 00       	push   $0xc0
+c0105a57:	68 9c cb 10 c0       	push   $0xc010cb9c
+c0105a5c:	e8 94 a9 ff ff       	call   c01003f5 <__panic>
+    list_entry_t *list = &(from->mmap_list), *le = list;
+c0105a61:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0105a64:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0105a67:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0105a6a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    while ((le = list_prev(le)) != list) {
+c0105a6d:	e9 86 00 00 00       	jmp    c0105af8 <dup_mmap+0xc3>
+        struct vma_struct *vma, *nvma;
+        vma = le2vma(le, list_link);
+c0105a72:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105a75:	83 e8 10             	sub    $0x10,%eax
+c0105a78:	89 45 ec             	mov    %eax,-0x14(%ebp)
+        nvma = vma_create(vma->vm_start, vma->vm_end, vma->vm_flags);
+c0105a7b:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0105a7e:	8b 48 0c             	mov    0xc(%eax),%ecx
+c0105a81:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0105a84:	8b 50 08             	mov    0x8(%eax),%edx
+c0105a87:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0105a8a:	8b 40 04             	mov    0x4(%eax),%eax
+c0105a8d:	83 ec 04             	sub    $0x4,%esp
+c0105a90:	51                   	push   %ecx
+c0105a91:	52                   	push   %edx
+c0105a92:	50                   	push   %eax
+c0105a93:	e8 6a fb ff ff       	call   c0105602 <vma_create>
+c0105a98:	83 c4 10             	add    $0x10,%esp
+c0105a9b:	89 45 e8             	mov    %eax,-0x18(%ebp)
+        if (nvma == NULL) {
+c0105a9e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+c0105aa2:	75 07                	jne    c0105aab <dup_mmap+0x76>
+            return -E_NO_MEM;
+c0105aa4:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
+c0105aa9:	eb 6c                	jmp    c0105b17 <dup_mmap+0xe2>
+        }
+
+        insert_vma_struct(to, nvma);
+c0105aab:	83 ec 08             	sub    $0x8,%esp
+c0105aae:	ff 75 e8             	pushl  -0x18(%ebp)
+c0105ab1:	ff 75 08             	pushl  0x8(%ebp)
+c0105ab4:	e8 b1 fc ff ff       	call   c010576a <insert_vma_struct>
+c0105ab9:	83 c4 10             	add    $0x10,%esp
+
+        bool share = 0;
+c0105abc:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+        if (copy_range(to->pgdir, from->pgdir, vma->vm_start, vma->vm_end, share) != 0) {
+c0105ac3:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0105ac6:	8b 58 08             	mov    0x8(%eax),%ebx
+c0105ac9:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0105acc:	8b 48 04             	mov    0x4(%eax),%ecx
+c0105acf:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0105ad2:	8b 50 0c             	mov    0xc(%eax),%edx
+c0105ad5:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105ad8:	8b 40 0c             	mov    0xc(%eax),%eax
+c0105adb:	83 ec 0c             	sub    $0xc,%esp
+c0105ade:	ff 75 e4             	pushl  -0x1c(%ebp)
+c0105ae1:	53                   	push   %ebx
+c0105ae2:	51                   	push   %ecx
+c0105ae3:	52                   	push   %edx
+c0105ae4:	50                   	push   %eax
+c0105ae5:	e8 e2 e6 ff ff       	call   c01041cc <copy_range>
+c0105aea:	83 c4 20             	add    $0x20,%esp
+c0105aed:	85 c0                	test   %eax,%eax
+c0105aef:	74 07                	je     c0105af8 <dup_mmap+0xc3>
+            return -E_NO_MEM;
+c0105af1:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
+c0105af6:	eb 1f                	jmp    c0105b17 <dup_mmap+0xe2>
+c0105af8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105afb:	89 45 e0             	mov    %eax,-0x20(%ebp)
+ * list_prev - get the previous entry
+ * @listelm:    the list head
+ **/
+static inline list_entry_t *
+list_prev(list_entry_t *listelm) {
+    return listelm->prev;
+c0105afe:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0105b01:	8b 00                	mov    (%eax),%eax
+
+int
+dup_mmap(struct mm_struct *to, struct mm_struct *from) {
+    assert(to != NULL && from != NULL);
+    list_entry_t *list = &(from->mmap_list), *le = list;
+    while ((le = list_prev(le)) != list) {
+c0105b03:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0105b06:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105b09:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+c0105b0c:	0f 85 60 ff ff ff    	jne    c0105a72 <dup_mmap+0x3d>
+        bool share = 0;
+        if (copy_range(to->pgdir, from->pgdir, vma->vm_start, vma->vm_end, share) != 0) {
+            return -E_NO_MEM;
+        }
+    }
+    return 0;
+c0105b12:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c0105b17:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+c0105b1a:	c9                   	leave  
+c0105b1b:	c3                   	ret    
+
+c0105b1c <exit_mmap>:
+
+void
+exit_mmap(struct mm_struct *mm) {
+c0105b1c:	55                   	push   %ebp
+c0105b1d:	89 e5                	mov    %esp,%ebp
+c0105b1f:	83 ec 28             	sub    $0x28,%esp
+    assert(mm != NULL && mm_count(mm) == 0);
+c0105b22:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c0105b26:	74 0f                	je     c0105b37 <exit_mmap+0x1b>
+c0105b28:	ff 75 08             	pushl  0x8(%ebp)
+c0105b2b:	e8 c1 f9 ff ff       	call   c01054f1 <mm_count>
+c0105b30:	83 c4 04             	add    $0x4,%esp
+c0105b33:	85 c0                	test   %eax,%eax
+c0105b35:	74 19                	je     c0105b50 <exit_mmap+0x34>
+c0105b37:	68 40 cc 10 c0       	push   $0xc010cc40
+c0105b3c:	68 87 cb 10 c0       	push   $0xc010cb87
+c0105b41:	68 d6 00 00 00       	push   $0xd6
+c0105b46:	68 9c cb 10 c0       	push   $0xc010cb9c
+c0105b4b:	e8 a5 a8 ff ff       	call   c01003f5 <__panic>
+    pde_t *pgdir = mm->pgdir;
+c0105b50:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105b53:	8b 40 0c             	mov    0xc(%eax),%eax
+c0105b56:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    list_entry_t *list = &(mm->mmap_list), *le = list;
+c0105b59:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105b5c:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0105b5f:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0105b62:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    while ((le = list_next(le)) != list) {
+c0105b65:	eb 25                	jmp    c0105b8c <exit_mmap+0x70>
+        struct vma_struct *vma = le2vma(le, list_link);
+c0105b67:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105b6a:	83 e8 10             	sub    $0x10,%eax
+c0105b6d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+        unmap_range(pgdir, vma->vm_start, vma->vm_end);
+c0105b70:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0105b73:	8b 50 08             	mov    0x8(%eax),%edx
+c0105b76:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0105b79:	8b 40 04             	mov    0x4(%eax),%eax
+c0105b7c:	83 ec 04             	sub    $0x4,%esp
+c0105b7f:	52                   	push   %edx
+c0105b80:	50                   	push   %eax
+c0105b81:	ff 75 f0             	pushl  -0x10(%ebp)
+c0105b84:	e8 7c e4 ff ff       	call   c0104005 <unmap_range>
+c0105b89:	83 c4 10             	add    $0x10,%esp
+c0105b8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105b8f:	89 45 dc             	mov    %eax,-0x24(%ebp)
+ * list_next - get the next entry
+ * @listelm:    the list head
+ **/
+static inline list_entry_t *
+list_next(list_entry_t *listelm) {
+    return listelm->next;
+c0105b92:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0105b95:	8b 40 04             	mov    0x4(%eax),%eax
+void
+exit_mmap(struct mm_struct *mm) {
+    assert(mm != NULL && mm_count(mm) == 0);
+    pde_t *pgdir = mm->pgdir;
+    list_entry_t *list = &(mm->mmap_list), *le = list;
+    while ((le = list_next(le)) != list) {
+c0105b98:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0105b9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105b9e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+c0105ba1:	75 c4                	jne    c0105b67 <exit_mmap+0x4b>
+        struct vma_struct *vma = le2vma(le, list_link);
+        unmap_range(pgdir, vma->vm_start, vma->vm_end);
+    }
+    while ((le = list_next(le)) != list) {
+c0105ba3:	eb 25                	jmp    c0105bca <exit_mmap+0xae>
+        struct vma_struct *vma = le2vma(le, list_link);
+c0105ba5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105ba8:	83 e8 10             	sub    $0x10,%eax
+c0105bab:	89 45 e0             	mov    %eax,-0x20(%ebp)
+        exit_range(pgdir, vma->vm_start, vma->vm_end);
+c0105bae:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0105bb1:	8b 50 08             	mov    0x8(%eax),%edx
+c0105bb4:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0105bb7:	8b 40 04             	mov    0x4(%eax),%eax
+c0105bba:	83 ec 04             	sub    $0x4,%esp
+c0105bbd:	52                   	push   %edx
+c0105bbe:	50                   	push   %eax
+c0105bbf:	ff 75 f0             	pushl  -0x10(%ebp)
+c0105bc2:	e8 11 e5 ff ff       	call   c01040d8 <exit_range>
+c0105bc7:	83 c4 10             	add    $0x10,%esp
+c0105bca:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105bcd:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c0105bd0:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0105bd3:	8b 40 04             	mov    0x4(%eax),%eax
+    list_entry_t *list = &(mm->mmap_list), *le = list;
+    while ((le = list_next(le)) != list) {
+        struct vma_struct *vma = le2vma(le, list_link);
+        unmap_range(pgdir, vma->vm_start, vma->vm_end);
+    }
+    while ((le = list_next(le)) != list) {
+c0105bd6:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0105bd9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105bdc:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+c0105bdf:	75 c4                	jne    c0105ba5 <exit_mmap+0x89>
+        struct vma_struct *vma = le2vma(le, list_link);
+        exit_range(pgdir, vma->vm_start, vma->vm_end);
+    }
+}
+c0105be1:	90                   	nop
+c0105be2:	c9                   	leave  
+c0105be3:	c3                   	ret    
+
+c0105be4 <copy_from_user>:
+
+bool
+copy_from_user(struct mm_struct *mm, void *dst, const void *src, size_t len, bool writable) {
+c0105be4:	55                   	push   %ebp
+c0105be5:	89 e5                	mov    %esp,%ebp
+c0105be7:	83 ec 08             	sub    $0x8,%esp
+    if (!user_mem_check(mm, (uintptr_t)src, len, writable)) {
+c0105bea:	8b 45 10             	mov    0x10(%ebp),%eax
+c0105bed:	ff 75 18             	pushl  0x18(%ebp)
+c0105bf0:	ff 75 14             	pushl  0x14(%ebp)
+c0105bf3:	50                   	push   %eax
+c0105bf4:	ff 75 08             	pushl  0x8(%ebp)
+c0105bf7:	e8 ac 08 00 00       	call   c01064a8 <user_mem_check>
+c0105bfc:	83 c4 10             	add    $0x10,%esp
+c0105bff:	85 c0                	test   %eax,%eax
+c0105c01:	75 07                	jne    c0105c0a <copy_from_user+0x26>
+        return 0;
+c0105c03:	b8 00 00 00 00       	mov    $0x0,%eax
+c0105c08:	eb 19                	jmp    c0105c23 <copy_from_user+0x3f>
+    }
+    memcpy(dst, src, len);
+c0105c0a:	83 ec 04             	sub    $0x4,%esp
+c0105c0d:	ff 75 14             	pushl  0x14(%ebp)
+c0105c10:	ff 75 10             	pushl  0x10(%ebp)
+c0105c13:	ff 75 0c             	pushl  0xc(%ebp)
+c0105c16:	e8 20 55 00 00       	call   c010b13b <memcpy>
+c0105c1b:	83 c4 10             	add    $0x10,%esp
+    return 1;
+c0105c1e:	b8 01 00 00 00       	mov    $0x1,%eax
+}
+c0105c23:	c9                   	leave  
+c0105c24:	c3                   	ret    
+
+c0105c25 <copy_to_user>:
+
+bool
+copy_to_user(struct mm_struct *mm, void *dst, const void *src, size_t len) {
+c0105c25:	55                   	push   %ebp
+c0105c26:	89 e5                	mov    %esp,%ebp
+c0105c28:	83 ec 08             	sub    $0x8,%esp
+    if (!user_mem_check(mm, (uintptr_t)dst, len, 1)) {
+c0105c2b:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0105c2e:	6a 01                	push   $0x1
+c0105c30:	ff 75 14             	pushl  0x14(%ebp)
+c0105c33:	50                   	push   %eax
+c0105c34:	ff 75 08             	pushl  0x8(%ebp)
+c0105c37:	e8 6c 08 00 00       	call   c01064a8 <user_mem_check>
+c0105c3c:	83 c4 10             	add    $0x10,%esp
+c0105c3f:	85 c0                	test   %eax,%eax
+c0105c41:	75 07                	jne    c0105c4a <copy_to_user+0x25>
+        return 0;
+c0105c43:	b8 00 00 00 00       	mov    $0x0,%eax
+c0105c48:	eb 19                	jmp    c0105c63 <copy_to_user+0x3e>
+    }
+    memcpy(dst, src, len);
+c0105c4a:	83 ec 04             	sub    $0x4,%esp
+c0105c4d:	ff 75 14             	pushl  0x14(%ebp)
+c0105c50:	ff 75 10             	pushl  0x10(%ebp)
+c0105c53:	ff 75 0c             	pushl  0xc(%ebp)
+c0105c56:	e8 e0 54 00 00       	call   c010b13b <memcpy>
+c0105c5b:	83 c4 10             	add    $0x10,%esp
+    return 1;
+c0105c5e:	b8 01 00 00 00       	mov    $0x1,%eax
+}
+c0105c63:	c9                   	leave  
+c0105c64:	c3                   	ret    
+
+c0105c65 <vmm_init>:
+
+// vmm_init - initialize virtual memory management
+//          - now just call check_vmm to check correctness of vmm
+void
+vmm_init(void) {
+c0105c65:	55                   	push   %ebp
+c0105c66:	89 e5                	mov    %esp,%ebp
+c0105c68:	83 ec 08             	sub    $0x8,%esp
+    check_vmm();
+c0105c6b:	e8 03 00 00 00       	call   c0105c73 <check_vmm>
+}
+c0105c70:	90                   	nop
+c0105c71:	c9                   	leave  
+c0105c72:	c3                   	ret    
+
+c0105c73 <check_vmm>:
+
+// check_vmm - check correctness of vmm
+static void
+check_vmm(void) {
+c0105c73:	55                   	push   %ebp
+c0105c74:	89 e5                	mov    %esp,%ebp
+c0105c76:	83 ec 18             	sub    $0x18,%esp
+    size_t nr_free_pages_store = nr_free_pages();
+c0105c79:	e8 e4 db ff ff       	call   c0103862 <nr_free_pages>
+c0105c7e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    
+    check_vma_struct();
+c0105c81:	e8 18 00 00 00       	call   c0105c9e <check_vma_struct>
+    check_pgfault();
+c0105c86:	e8 10 04 00 00       	call   c010609b <check_pgfault>
+
+    cprintf("check_vmm() succeeded.\n");
+c0105c8b:	83 ec 0c             	sub    $0xc,%esp
+c0105c8e:	68 60 cc 10 c0       	push   $0xc010cc60
+c0105c93:	e8 f7 a5 ff ff       	call   c010028f <cprintf>
+c0105c98:	83 c4 10             	add    $0x10,%esp
+}
+c0105c9b:	90                   	nop
+c0105c9c:	c9                   	leave  
+c0105c9d:	c3                   	ret    
+
+c0105c9e <check_vma_struct>:
+
+static void
+check_vma_struct(void) {
+c0105c9e:	55                   	push   %ebp
+c0105c9f:	89 e5                	mov    %esp,%ebp
+c0105ca1:	83 ec 58             	sub    $0x58,%esp
+    size_t nr_free_pages_store = nr_free_pages();
+c0105ca4:	e8 b9 db ff ff       	call   c0103862 <nr_free_pages>
+c0105ca9:	89 45 ec             	mov    %eax,-0x14(%ebp)
+
+    struct mm_struct *mm = mm_create();
+c0105cac:	e8 b3 f8 ff ff       	call   c0105564 <mm_create>
+c0105cb1:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    assert(mm != NULL);
+c0105cb4:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+c0105cb8:	75 19                	jne    c0105cd3 <check_vma_struct+0x35>
+c0105cba:	68 17 cc 10 c0       	push   $0xc010cc17
+c0105cbf:	68 87 cb 10 c0       	push   $0xc010cb87
+c0105cc4:	68 0c 01 00 00       	push   $0x10c
+c0105cc9:	68 9c cb 10 c0       	push   $0xc010cb9c
+c0105cce:	e8 22 a7 ff ff       	call   c01003f5 <__panic>
+
+    int step1 = 10, step2 = step1 * 10;
+c0105cd3:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%ebp)
+c0105cda:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c0105cdd:	89 d0                	mov    %edx,%eax
+c0105cdf:	c1 e0 02             	shl    $0x2,%eax
+c0105ce2:	01 d0                	add    %edx,%eax
+c0105ce4:	01 c0                	add    %eax,%eax
+c0105ce6:	89 45 e0             	mov    %eax,-0x20(%ebp)
+
+    int i;
+    for (i = step1; i >= 1; i --) {
+c0105ce9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0105cec:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0105cef:	eb 5f                	jmp    c0105d50 <check_vma_struct+0xb2>
+        struct vma_struct *vma = vma_create(i * 5, i * 5 + 2, 0);
+c0105cf1:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0105cf4:	89 d0                	mov    %edx,%eax
+c0105cf6:	c1 e0 02             	shl    $0x2,%eax
+c0105cf9:	01 d0                	add    %edx,%eax
+c0105cfb:	83 c0 02             	add    $0x2,%eax
+c0105cfe:	89 c1                	mov    %eax,%ecx
+c0105d00:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0105d03:	89 d0                	mov    %edx,%eax
+c0105d05:	c1 e0 02             	shl    $0x2,%eax
+c0105d08:	01 d0                	add    %edx,%eax
+c0105d0a:	83 ec 04             	sub    $0x4,%esp
+c0105d0d:	6a 00                	push   $0x0
+c0105d0f:	51                   	push   %ecx
+c0105d10:	50                   	push   %eax
+c0105d11:	e8 ec f8 ff ff       	call   c0105602 <vma_create>
+c0105d16:	83 c4 10             	add    $0x10,%esp
+c0105d19:	89 45 dc             	mov    %eax,-0x24(%ebp)
+        assert(vma != NULL);
+c0105d1c:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+c0105d20:	75 19                	jne    c0105d3b <check_vma_struct+0x9d>
+c0105d22:	68 78 cc 10 c0       	push   $0xc010cc78
+c0105d27:	68 87 cb 10 c0       	push   $0xc010cb87
+c0105d2c:	68 13 01 00 00       	push   $0x113
+c0105d31:	68 9c cb 10 c0       	push   $0xc010cb9c
+c0105d36:	e8 ba a6 ff ff       	call   c01003f5 <__panic>
+        insert_vma_struct(mm, vma);
+c0105d3b:	83 ec 08             	sub    $0x8,%esp
+c0105d3e:	ff 75 dc             	pushl  -0x24(%ebp)
+c0105d41:	ff 75 e8             	pushl  -0x18(%ebp)
+c0105d44:	e8 21 fa ff ff       	call   c010576a <insert_vma_struct>
+c0105d49:	83 c4 10             	add    $0x10,%esp
+    assert(mm != NULL);
+
+    int step1 = 10, step2 = step1 * 10;
+
+    int i;
+    for (i = step1; i >= 1; i --) {
+c0105d4c:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+c0105d50:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0105d54:	7f 9b                	jg     c0105cf1 <check_vma_struct+0x53>
+        struct vma_struct *vma = vma_create(i * 5, i * 5 + 2, 0);
+        assert(vma != NULL);
+        insert_vma_struct(mm, vma);
+    }
+
+    for (i = step1 + 1; i <= step2; i ++) {
+c0105d56:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0105d59:	83 c0 01             	add    $0x1,%eax
+c0105d5c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0105d5f:	eb 5f                	jmp    c0105dc0 <check_vma_struct+0x122>
+        struct vma_struct *vma = vma_create(i * 5, i * 5 + 2, 0);
+c0105d61:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0105d64:	89 d0                	mov    %edx,%eax
+c0105d66:	c1 e0 02             	shl    $0x2,%eax
+c0105d69:	01 d0                	add    %edx,%eax
+c0105d6b:	83 c0 02             	add    $0x2,%eax
+c0105d6e:	89 c1                	mov    %eax,%ecx
+c0105d70:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0105d73:	89 d0                	mov    %edx,%eax
+c0105d75:	c1 e0 02             	shl    $0x2,%eax
+c0105d78:	01 d0                	add    %edx,%eax
+c0105d7a:	83 ec 04             	sub    $0x4,%esp
+c0105d7d:	6a 00                	push   $0x0
+c0105d7f:	51                   	push   %ecx
+c0105d80:	50                   	push   %eax
+c0105d81:	e8 7c f8 ff ff       	call   c0105602 <vma_create>
+c0105d86:	83 c4 10             	add    $0x10,%esp
+c0105d89:	89 45 d8             	mov    %eax,-0x28(%ebp)
+        assert(vma != NULL);
+c0105d8c:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
+c0105d90:	75 19                	jne    c0105dab <check_vma_struct+0x10d>
+c0105d92:	68 78 cc 10 c0       	push   $0xc010cc78
+c0105d97:	68 87 cb 10 c0       	push   $0xc010cb87
+c0105d9c:	68 19 01 00 00       	push   $0x119
+c0105da1:	68 9c cb 10 c0       	push   $0xc010cb9c
+c0105da6:	e8 4a a6 ff ff       	call   c01003f5 <__panic>
+        insert_vma_struct(mm, vma);
+c0105dab:	83 ec 08             	sub    $0x8,%esp
+c0105dae:	ff 75 d8             	pushl  -0x28(%ebp)
+c0105db1:	ff 75 e8             	pushl  -0x18(%ebp)
+c0105db4:	e8 b1 f9 ff ff       	call   c010576a <insert_vma_struct>
+c0105db9:	83 c4 10             	add    $0x10,%esp
+        struct vma_struct *vma = vma_create(i * 5, i * 5 + 2, 0);
+        assert(vma != NULL);
+        insert_vma_struct(mm, vma);
+    }
+
+    for (i = step1 + 1; i <= step2; i ++) {
+c0105dbc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+c0105dc0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105dc3:	3b 45 e0             	cmp    -0x20(%ebp),%eax
+c0105dc6:	7e 99                	jle    c0105d61 <check_vma_struct+0xc3>
+        struct vma_struct *vma = vma_create(i * 5, i * 5 + 2, 0);
+        assert(vma != NULL);
+        insert_vma_struct(mm, vma);
+    }
+
+    list_entry_t *le = list_next(&(mm->mmap_list));
+c0105dc8:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0105dcb:	89 45 b4             	mov    %eax,-0x4c(%ebp)
+c0105dce:	8b 45 b4             	mov    -0x4c(%ebp),%eax
+c0105dd1:	8b 40 04             	mov    0x4(%eax),%eax
+c0105dd4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+
+    for (i = 1; i <= step2; i ++) {
+c0105dd7:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
+c0105dde:	e9 81 00 00 00       	jmp    c0105e64 <check_vma_struct+0x1c6>
+        assert(le != &(mm->mmap_list));
+c0105de3:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0105de6:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+c0105de9:	75 19                	jne    c0105e04 <check_vma_struct+0x166>
+c0105deb:	68 84 cc 10 c0       	push   $0xc010cc84
+c0105df0:	68 87 cb 10 c0       	push   $0xc010cb87
+c0105df5:	68 20 01 00 00       	push   $0x120
+c0105dfa:	68 9c cb 10 c0       	push   $0xc010cb9c
+c0105dff:	e8 f1 a5 ff ff       	call   c01003f5 <__panic>
+        struct vma_struct *mmap = le2vma(le, list_link);
+c0105e04:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0105e07:	83 e8 10             	sub    $0x10,%eax
+c0105e0a:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        assert(mmap->vm_start == i * 5 && mmap->vm_end == i * 5 + 2);
+c0105e0d:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c0105e10:	8b 48 04             	mov    0x4(%eax),%ecx
+c0105e13:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0105e16:	89 d0                	mov    %edx,%eax
+c0105e18:	c1 e0 02             	shl    $0x2,%eax
+c0105e1b:	01 d0                	add    %edx,%eax
+c0105e1d:	39 c1                	cmp    %eax,%ecx
+c0105e1f:	75 17                	jne    c0105e38 <check_vma_struct+0x19a>
+c0105e21:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c0105e24:	8b 48 08             	mov    0x8(%eax),%ecx
+c0105e27:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0105e2a:	89 d0                	mov    %edx,%eax
+c0105e2c:	c1 e0 02             	shl    $0x2,%eax
+c0105e2f:	01 d0                	add    %edx,%eax
+c0105e31:	83 c0 02             	add    $0x2,%eax
+c0105e34:	39 c1                	cmp    %eax,%ecx
+c0105e36:	74 19                	je     c0105e51 <check_vma_struct+0x1b3>
+c0105e38:	68 9c cc 10 c0       	push   $0xc010cc9c
+c0105e3d:	68 87 cb 10 c0       	push   $0xc010cb87
+c0105e42:	68 22 01 00 00       	push   $0x122
+c0105e47:	68 9c cb 10 c0       	push   $0xc010cb9c
+c0105e4c:	e8 a4 a5 ff ff       	call   c01003f5 <__panic>
+c0105e51:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0105e54:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+c0105e57:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c0105e5a:	8b 40 04             	mov    0x4(%eax),%eax
+        le = list_next(le);
+c0105e5d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+        insert_vma_struct(mm, vma);
+    }
+
+    list_entry_t *le = list_next(&(mm->mmap_list));
+
+    for (i = 1; i <= step2; i ++) {
+c0105e60:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+c0105e64:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105e67:	3b 45 e0             	cmp    -0x20(%ebp),%eax
+c0105e6a:	0f 8e 73 ff ff ff    	jle    c0105de3 <check_vma_struct+0x145>
+        struct vma_struct *mmap = le2vma(le, list_link);
+        assert(mmap->vm_start == i * 5 && mmap->vm_end == i * 5 + 2);
+        le = list_next(le);
+    }
+
+    for (i = 5; i <= 5 * step2; i +=5) {
+c0105e70:	c7 45 f4 05 00 00 00 	movl   $0x5,-0xc(%ebp)
+c0105e77:	e9 80 01 00 00       	jmp    c0105ffc <check_vma_struct+0x35e>
+        struct vma_struct *vma1 = find_vma(mm, i);
+c0105e7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105e7f:	83 ec 08             	sub    $0x8,%esp
+c0105e82:	50                   	push   %eax
+c0105e83:	ff 75 e8             	pushl  -0x18(%ebp)
+c0105e86:	e8 b3 f7 ff ff       	call   c010563e <find_vma>
+c0105e8b:	83 c4 10             	add    $0x10,%esp
+c0105e8e:	89 45 cc             	mov    %eax,-0x34(%ebp)
+        assert(vma1 != NULL);
+c0105e91:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
+c0105e95:	75 19                	jne    c0105eb0 <check_vma_struct+0x212>
+c0105e97:	68 d1 cc 10 c0       	push   $0xc010ccd1
+c0105e9c:	68 87 cb 10 c0       	push   $0xc010cb87
+c0105ea1:	68 28 01 00 00       	push   $0x128
+c0105ea6:	68 9c cb 10 c0       	push   $0xc010cb9c
+c0105eab:	e8 45 a5 ff ff       	call   c01003f5 <__panic>
+        struct vma_struct *vma2 = find_vma(mm, i+1);
+c0105eb0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105eb3:	83 c0 01             	add    $0x1,%eax
+c0105eb6:	83 ec 08             	sub    $0x8,%esp
+c0105eb9:	50                   	push   %eax
+c0105eba:	ff 75 e8             	pushl  -0x18(%ebp)
+c0105ebd:	e8 7c f7 ff ff       	call   c010563e <find_vma>
+c0105ec2:	83 c4 10             	add    $0x10,%esp
+c0105ec5:	89 45 c8             	mov    %eax,-0x38(%ebp)
+        assert(vma2 != NULL);
+c0105ec8:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
+c0105ecc:	75 19                	jne    c0105ee7 <check_vma_struct+0x249>
+c0105ece:	68 de cc 10 c0       	push   $0xc010ccde
+c0105ed3:	68 87 cb 10 c0       	push   $0xc010cb87
+c0105ed8:	68 2a 01 00 00       	push   $0x12a
+c0105edd:	68 9c cb 10 c0       	push   $0xc010cb9c
+c0105ee2:	e8 0e a5 ff ff       	call   c01003f5 <__panic>
+        struct vma_struct *vma3 = find_vma(mm, i+2);
+c0105ee7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105eea:	83 c0 02             	add    $0x2,%eax
+c0105eed:	83 ec 08             	sub    $0x8,%esp
+c0105ef0:	50                   	push   %eax
+c0105ef1:	ff 75 e8             	pushl  -0x18(%ebp)
+c0105ef4:	e8 45 f7 ff ff       	call   c010563e <find_vma>
+c0105ef9:	83 c4 10             	add    $0x10,%esp
+c0105efc:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+        assert(vma3 == NULL);
+c0105eff:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
+c0105f03:	74 19                	je     c0105f1e <check_vma_struct+0x280>
+c0105f05:	68 eb cc 10 c0       	push   $0xc010cceb
+c0105f0a:	68 87 cb 10 c0       	push   $0xc010cb87
+c0105f0f:	68 2c 01 00 00       	push   $0x12c
+c0105f14:	68 9c cb 10 c0       	push   $0xc010cb9c
+c0105f19:	e8 d7 a4 ff ff       	call   c01003f5 <__panic>
+        struct vma_struct *vma4 = find_vma(mm, i+3);
+c0105f1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105f21:	83 c0 03             	add    $0x3,%eax
+c0105f24:	83 ec 08             	sub    $0x8,%esp
+c0105f27:	50                   	push   %eax
+c0105f28:	ff 75 e8             	pushl  -0x18(%ebp)
+c0105f2b:	e8 0e f7 ff ff       	call   c010563e <find_vma>
+c0105f30:	83 c4 10             	add    $0x10,%esp
+c0105f33:	89 45 c0             	mov    %eax,-0x40(%ebp)
+        assert(vma4 == NULL);
+c0105f36:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
+c0105f3a:	74 19                	je     c0105f55 <check_vma_struct+0x2b7>
+c0105f3c:	68 f8 cc 10 c0       	push   $0xc010ccf8
+c0105f41:	68 87 cb 10 c0       	push   $0xc010cb87
+c0105f46:	68 2e 01 00 00       	push   $0x12e
+c0105f4b:	68 9c cb 10 c0       	push   $0xc010cb9c
+c0105f50:	e8 a0 a4 ff ff       	call   c01003f5 <__panic>
+        struct vma_struct *vma5 = find_vma(mm, i+4);
+c0105f55:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105f58:	83 c0 04             	add    $0x4,%eax
+c0105f5b:	83 ec 08             	sub    $0x8,%esp
+c0105f5e:	50                   	push   %eax
+c0105f5f:	ff 75 e8             	pushl  -0x18(%ebp)
+c0105f62:	e8 d7 f6 ff ff       	call   c010563e <find_vma>
+c0105f67:	83 c4 10             	add    $0x10,%esp
+c0105f6a:	89 45 bc             	mov    %eax,-0x44(%ebp)
+        assert(vma5 == NULL);
+c0105f6d:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
+c0105f71:	74 19                	je     c0105f8c <check_vma_struct+0x2ee>
+c0105f73:	68 05 cd 10 c0       	push   $0xc010cd05
+c0105f78:	68 87 cb 10 c0       	push   $0xc010cb87
+c0105f7d:	68 30 01 00 00       	push   $0x130
+c0105f82:	68 9c cb 10 c0       	push   $0xc010cb9c
+c0105f87:	e8 69 a4 ff ff       	call   c01003f5 <__panic>
+
+        assert(vma1->vm_start == i  && vma1->vm_end == i  + 2);
+c0105f8c:	8b 45 cc             	mov    -0x34(%ebp),%eax
+c0105f8f:	8b 50 04             	mov    0x4(%eax),%edx
+c0105f92:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105f95:	39 c2                	cmp    %eax,%edx
+c0105f97:	75 10                	jne    c0105fa9 <check_vma_struct+0x30b>
+c0105f99:	8b 45 cc             	mov    -0x34(%ebp),%eax
+c0105f9c:	8b 40 08             	mov    0x8(%eax),%eax
+c0105f9f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0105fa2:	83 c2 02             	add    $0x2,%edx
+c0105fa5:	39 d0                	cmp    %edx,%eax
+c0105fa7:	74 19                	je     c0105fc2 <check_vma_struct+0x324>
+c0105fa9:	68 14 cd 10 c0       	push   $0xc010cd14
+c0105fae:	68 87 cb 10 c0       	push   $0xc010cb87
+c0105fb3:	68 32 01 00 00       	push   $0x132
+c0105fb8:	68 9c cb 10 c0       	push   $0xc010cb9c
+c0105fbd:	e8 33 a4 ff ff       	call   c01003f5 <__panic>
+        assert(vma2->vm_start == i  && vma2->vm_end == i  + 2);
+c0105fc2:	8b 45 c8             	mov    -0x38(%ebp),%eax
+c0105fc5:	8b 50 04             	mov    0x4(%eax),%edx
+c0105fc8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105fcb:	39 c2                	cmp    %eax,%edx
+c0105fcd:	75 10                	jne    c0105fdf <check_vma_struct+0x341>
+c0105fcf:	8b 45 c8             	mov    -0x38(%ebp),%eax
+c0105fd2:	8b 40 08             	mov    0x8(%eax),%eax
+c0105fd5:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0105fd8:	83 c2 02             	add    $0x2,%edx
+c0105fdb:	39 d0                	cmp    %edx,%eax
+c0105fdd:	74 19                	je     c0105ff8 <check_vma_struct+0x35a>
+c0105fdf:	68 44 cd 10 c0       	push   $0xc010cd44
+c0105fe4:	68 87 cb 10 c0       	push   $0xc010cb87
+c0105fe9:	68 33 01 00 00       	push   $0x133
+c0105fee:	68 9c cb 10 c0       	push   $0xc010cb9c
+c0105ff3:	e8 fd a3 ff ff       	call   c01003f5 <__panic>
+        struct vma_struct *mmap = le2vma(le, list_link);
+        assert(mmap->vm_start == i * 5 && mmap->vm_end == i * 5 + 2);
+        le = list_next(le);
+    }
+
+    for (i = 5; i <= 5 * step2; i +=5) {
+c0105ff8:	83 45 f4 05          	addl   $0x5,-0xc(%ebp)
+c0105ffc:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c0105fff:	89 d0                	mov    %edx,%eax
+c0106001:	c1 e0 02             	shl    $0x2,%eax
+c0106004:	01 d0                	add    %edx,%eax
+c0106006:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+c0106009:	0f 8d 6d fe ff ff    	jge    c0105e7c <check_vma_struct+0x1de>
+
+        assert(vma1->vm_start == i  && vma1->vm_end == i  + 2);
+        assert(vma2->vm_start == i  && vma2->vm_end == i  + 2);
+    }
+
+    for (i =4; i>=0; i--) {
+c010600f:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
+c0106016:	eb 5c                	jmp    c0106074 <check_vma_struct+0x3d6>
+        struct vma_struct *vma_below_5= find_vma(mm,i);
+c0106018:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010601b:	83 ec 08             	sub    $0x8,%esp
+c010601e:	50                   	push   %eax
+c010601f:	ff 75 e8             	pushl  -0x18(%ebp)
+c0106022:	e8 17 f6 ff ff       	call   c010563e <find_vma>
+c0106027:	83 c4 10             	add    $0x10,%esp
+c010602a:	89 45 b8             	mov    %eax,-0x48(%ebp)
+        if (vma_below_5 != NULL ) {
+c010602d:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
+c0106031:	74 1e                	je     c0106051 <check_vma_struct+0x3b3>
+           cprintf("vma_below_5: i %x, start %x, end %x\n",i, vma_below_5->vm_start, vma_below_5->vm_end); 
+c0106033:	8b 45 b8             	mov    -0x48(%ebp),%eax
+c0106036:	8b 50 08             	mov    0x8(%eax),%edx
+c0106039:	8b 45 b8             	mov    -0x48(%ebp),%eax
+c010603c:	8b 40 04             	mov    0x4(%eax),%eax
+c010603f:	52                   	push   %edx
+c0106040:	50                   	push   %eax
+c0106041:	ff 75 f4             	pushl  -0xc(%ebp)
+c0106044:	68 74 cd 10 c0       	push   $0xc010cd74
+c0106049:	e8 41 a2 ff ff       	call   c010028f <cprintf>
+c010604e:	83 c4 10             	add    $0x10,%esp
+        }
+        assert(vma_below_5 == NULL);
+c0106051:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
+c0106055:	74 19                	je     c0106070 <check_vma_struct+0x3d2>
+c0106057:	68 99 cd 10 c0       	push   $0xc010cd99
+c010605c:	68 87 cb 10 c0       	push   $0xc010cb87
+c0106061:	68 3b 01 00 00       	push   $0x13b
+c0106066:	68 9c cb 10 c0       	push   $0xc010cb9c
+c010606b:	e8 85 a3 ff ff       	call   c01003f5 <__panic>
+
+        assert(vma1->vm_start == i  && vma1->vm_end == i  + 2);
+        assert(vma2->vm_start == i  && vma2->vm_end == i  + 2);
+    }
+
+    for (i =4; i>=0; i--) {
+c0106070:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+c0106074:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0106078:	79 9e                	jns    c0106018 <check_vma_struct+0x37a>
+           cprintf("vma_below_5: i %x, start %x, end %x\n",i, vma_below_5->vm_start, vma_below_5->vm_end); 
+        }
+        assert(vma_below_5 == NULL);
+    }
+
+    mm_destroy(mm);
+c010607a:	83 ec 0c             	sub    $0xc,%esp
+c010607d:	ff 75 e8             	pushl  -0x18(%ebp)
+c0106080:	e8 09 f8 ff ff       	call   c010588e <mm_destroy>
+c0106085:	83 c4 10             	add    $0x10,%esp
+
+    cprintf("check_vma_struct() succeeded!\n");
+c0106088:	83 ec 0c             	sub    $0xc,%esp
+c010608b:	68 b0 cd 10 c0       	push   $0xc010cdb0
+c0106090:	e8 fa a1 ff ff       	call   c010028f <cprintf>
+c0106095:	83 c4 10             	add    $0x10,%esp
+}
+c0106098:	90                   	nop
+c0106099:	c9                   	leave  
+c010609a:	c3                   	ret    
+
+c010609b <check_pgfault>:
+
+struct mm_struct *check_mm_struct;
+
+// check_pgfault - check correctness of pgfault handler
+static void
+check_pgfault(void) {
+c010609b:	55                   	push   %ebp
+c010609c:	89 e5                	mov    %esp,%ebp
+c010609e:	83 ec 28             	sub    $0x28,%esp
+    size_t nr_free_pages_store = nr_free_pages();
+c01060a1:	e8 bc d7 ff ff       	call   c0103862 <nr_free_pages>
+c01060a6:	89 45 ec             	mov    %eax,-0x14(%ebp)
+
+    check_mm_struct = mm_create();
+c01060a9:	e8 b6 f4 ff ff       	call   c0105564 <mm_create>
+c01060ae:	a3 90 30 1b c0       	mov    %eax,0xc01b3090
+    assert(check_mm_struct != NULL);
+c01060b3:	a1 90 30 1b c0       	mov    0xc01b3090,%eax
+c01060b8:	85 c0                	test   %eax,%eax
+c01060ba:	75 19                	jne    c01060d5 <check_pgfault+0x3a>
+c01060bc:	68 cf cd 10 c0       	push   $0xc010cdcf
+c01060c1:	68 87 cb 10 c0       	push   $0xc010cb87
+c01060c6:	68 4b 01 00 00       	push   $0x14b
+c01060cb:	68 9c cb 10 c0       	push   $0xc010cb9c
+c01060d0:	e8 20 a3 ff ff       	call   c01003f5 <__panic>
+
+    struct mm_struct *mm = check_mm_struct;
+c01060d5:	a1 90 30 1b c0       	mov    0xc01b3090,%eax
+c01060da:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    pde_t *pgdir = mm->pgdir = boot_pgdir;
+c01060dd:	8b 15 e0 c9 12 c0    	mov    0xc012c9e0,%edx
+c01060e3:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c01060e6:	89 50 0c             	mov    %edx,0xc(%eax)
+c01060e9:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c01060ec:	8b 40 0c             	mov    0xc(%eax),%eax
+c01060ef:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    assert(pgdir[0] == 0);
+c01060f2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01060f5:	8b 00                	mov    (%eax),%eax
+c01060f7:	85 c0                	test   %eax,%eax
+c01060f9:	74 19                	je     c0106114 <check_pgfault+0x79>
+c01060fb:	68 e7 cd 10 c0       	push   $0xc010cde7
+c0106100:	68 87 cb 10 c0       	push   $0xc010cb87
+c0106105:	68 4f 01 00 00       	push   $0x14f
+c010610a:	68 9c cb 10 c0       	push   $0xc010cb9c
+c010610f:	e8 e1 a2 ff ff       	call   c01003f5 <__panic>
+
+    struct vma_struct *vma = vma_create(0, PTSIZE, VM_WRITE);
+c0106114:	83 ec 04             	sub    $0x4,%esp
+c0106117:	6a 02                	push   $0x2
+c0106119:	68 00 00 40 00       	push   $0x400000
+c010611e:	6a 00                	push   $0x0
+c0106120:	e8 dd f4 ff ff       	call   c0105602 <vma_create>
+c0106125:	83 c4 10             	add    $0x10,%esp
+c0106128:	89 45 e0             	mov    %eax,-0x20(%ebp)
+    assert(vma != NULL);
+c010612b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+c010612f:	75 19                	jne    c010614a <check_pgfault+0xaf>
+c0106131:	68 78 cc 10 c0       	push   $0xc010cc78
+c0106136:	68 87 cb 10 c0       	push   $0xc010cb87
+c010613b:	68 52 01 00 00       	push   $0x152
+c0106140:	68 9c cb 10 c0       	push   $0xc010cb9c
+c0106145:	e8 ab a2 ff ff       	call   c01003f5 <__panic>
+
+    insert_vma_struct(mm, vma);
+c010614a:	83 ec 08             	sub    $0x8,%esp
+c010614d:	ff 75 e0             	pushl  -0x20(%ebp)
+c0106150:	ff 75 e8             	pushl  -0x18(%ebp)
+c0106153:	e8 12 f6 ff ff       	call   c010576a <insert_vma_struct>
+c0106158:	83 c4 10             	add    $0x10,%esp
+
+    uintptr_t addr = 0x100;
+c010615b:	c7 45 dc 00 01 00 00 	movl   $0x100,-0x24(%ebp)
+    assert(find_vma(mm, addr) == vma);
+c0106162:	83 ec 08             	sub    $0x8,%esp
+c0106165:	ff 75 dc             	pushl  -0x24(%ebp)
+c0106168:	ff 75 e8             	pushl  -0x18(%ebp)
+c010616b:	e8 ce f4 ff ff       	call   c010563e <find_vma>
+c0106170:	83 c4 10             	add    $0x10,%esp
+c0106173:	3b 45 e0             	cmp    -0x20(%ebp),%eax
+c0106176:	74 19                	je     c0106191 <check_pgfault+0xf6>
+c0106178:	68 f5 cd 10 c0       	push   $0xc010cdf5
+c010617d:	68 87 cb 10 c0       	push   $0xc010cb87
+c0106182:	68 57 01 00 00       	push   $0x157
+c0106187:	68 9c cb 10 c0       	push   $0xc010cb9c
+c010618c:	e8 64 a2 ff ff       	call   c01003f5 <__panic>
+
+    int i, sum = 0;
+c0106191:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    for (i = 0; i < 100; i ++) {
+c0106198:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c010619f:	eb 19                	jmp    c01061ba <check_pgfault+0x11f>
+        *(char *)(addr + i) = i;
+c01061a1:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c01061a4:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c01061a7:	01 d0                	add    %edx,%eax
+c01061a9:	89 c2                	mov    %eax,%edx
+c01061ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01061ae:	88 02                	mov    %al,(%edx)
+        sum += i;
+c01061b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01061b3:	01 45 f0             	add    %eax,-0x10(%ebp)
+
+    uintptr_t addr = 0x100;
+    assert(find_vma(mm, addr) == vma);
+
+    int i, sum = 0;
+    for (i = 0; i < 100; i ++) {
+c01061b6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+c01061ba:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
+c01061be:	7e e1                	jle    c01061a1 <check_pgfault+0x106>
+        *(char *)(addr + i) = i;
+        sum += i;
+    }
+    for (i = 0; i < 100; i ++) {
+c01061c0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c01061c7:	eb 15                	jmp    c01061de <check_pgfault+0x143>
+        sum -= *(char *)(addr + i);
+c01061c9:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c01061cc:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c01061cf:	01 d0                	add    %edx,%eax
+c01061d1:	0f b6 00             	movzbl (%eax),%eax
+c01061d4:	0f be c0             	movsbl %al,%eax
+c01061d7:	29 45 f0             	sub    %eax,-0x10(%ebp)
+    int i, sum = 0;
+    for (i = 0; i < 100; i ++) {
+        *(char *)(addr + i) = i;
+        sum += i;
+    }
+    for (i = 0; i < 100; i ++) {
+c01061da:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+c01061de:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
+c01061e2:	7e e5                	jle    c01061c9 <check_pgfault+0x12e>
+        sum -= *(char *)(addr + i);
+    }
+    assert(sum == 0);
+c01061e4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c01061e8:	74 19                	je     c0106203 <check_pgfault+0x168>
+c01061ea:	68 0f ce 10 c0       	push   $0xc010ce0f
+c01061ef:	68 87 cb 10 c0       	push   $0xc010cb87
+c01061f4:	68 61 01 00 00       	push   $0x161
+c01061f9:	68 9c cb 10 c0       	push   $0xc010cb9c
+c01061fe:	e8 f2 a1 ff ff       	call   c01003f5 <__panic>
+
+    page_remove(pgdir, ROUNDDOWN(addr, PGSIZE));
+c0106203:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0106206:	89 45 d8             	mov    %eax,-0x28(%ebp)
+c0106209:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c010620c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+c0106211:	83 ec 08             	sub    $0x8,%esp
+c0106214:	50                   	push   %eax
+c0106215:	ff 75 e4             	pushl  -0x1c(%ebp)
+c0106218:	e8 88 e1 ff ff       	call   c01043a5 <page_remove>
+c010621d:	83 c4 10             	add    $0x10,%esp
+    free_page(pde2page(pgdir[0]));
+c0106220:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0106223:	8b 00                	mov    (%eax),%eax
+c0106225:	83 ec 0c             	sub    $0xc,%esp
+c0106228:	50                   	push   %eax
+c0106229:	e8 1a f3 ff ff       	call   c0105548 <pde2page>
+c010622e:	83 c4 10             	add    $0x10,%esp
+c0106231:	83 ec 08             	sub    $0x8,%esp
+c0106234:	6a 01                	push   $0x1
+c0106236:	50                   	push   %eax
+c0106237:	e8 f1 d5 ff ff       	call   c010382d <free_pages>
+c010623c:	83 c4 10             	add    $0x10,%esp
+    pgdir[0] = 0;
+c010623f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0106242:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+
+    mm->pgdir = NULL;
+c0106248:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010624b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
+    mm_destroy(mm);
+c0106252:	83 ec 0c             	sub    $0xc,%esp
+c0106255:	ff 75 e8             	pushl  -0x18(%ebp)
+c0106258:	e8 31 f6 ff ff       	call   c010588e <mm_destroy>
+c010625d:	83 c4 10             	add    $0x10,%esp
+    check_mm_struct = NULL;
+c0106260:	c7 05 90 30 1b c0 00 	movl   $0x0,0xc01b3090
+c0106267:	00 00 00 
+
+    assert(nr_free_pages_store == nr_free_pages());
+c010626a:	e8 f3 d5 ff ff       	call   c0103862 <nr_free_pages>
+c010626f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+c0106272:	74 19                	je     c010628d <check_pgfault+0x1f2>
+c0106274:	68 18 ce 10 c0       	push   $0xc010ce18
+c0106279:	68 87 cb 10 c0       	push   $0xc010cb87
+c010627e:	68 6b 01 00 00       	push   $0x16b
+c0106283:	68 9c cb 10 c0       	push   $0xc010cb9c
+c0106288:	e8 68 a1 ff ff       	call   c01003f5 <__panic>
+
+    cprintf("check_pgfault() succeeded!\n");
+c010628d:	83 ec 0c             	sub    $0xc,%esp
+c0106290:	68 3f ce 10 c0       	push   $0xc010ce3f
+c0106295:	e8 f5 9f ff ff       	call   c010028f <cprintf>
+c010629a:	83 c4 10             	add    $0x10,%esp
+}
+c010629d:	90                   	nop
+c010629e:	c9                   	leave  
+c010629f:	c3                   	ret    
+
+c01062a0 <do_pgfault>:
+ *            was a read (0) or write (1).
+ *         -- The U/S flag (bit 2) indicates whether the processor was executing at user mode (1)
+ *            or supervisor mode (0) at the time of the exception.
+ */
+int
+do_pgfault(struct mm_struct *mm, uint32_t error_code, uintptr_t addr) {
+c01062a0:	55                   	push   %ebp
+c01062a1:	89 e5                	mov    %esp,%ebp
+c01062a3:	83 ec 28             	sub    $0x28,%esp
+    int ret = -E_INVAL;
+c01062a6:	c7 45 f4 fd ff ff ff 	movl   $0xfffffffd,-0xc(%ebp)
+    //try to find a vma which include addr
+    struct vma_struct *vma = find_vma(mm, addr);
+c01062ad:	ff 75 10             	pushl  0x10(%ebp)
+c01062b0:	ff 75 08             	pushl  0x8(%ebp)
+c01062b3:	e8 86 f3 ff ff       	call   c010563e <find_vma>
+c01062b8:	83 c4 08             	add    $0x8,%esp
+c01062bb:	89 45 ec             	mov    %eax,-0x14(%ebp)
+
+    pgfault_num++;
+c01062be:	a1 0c 10 1b c0       	mov    0xc01b100c,%eax
+c01062c3:	83 c0 01             	add    $0x1,%eax
+c01062c6:	a3 0c 10 1b c0       	mov    %eax,0xc01b100c
+    //If the addr is in the range of a mm's vma?
+    if (vma == NULL || vma->vm_start > addr) {
+c01062cb:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+c01062cf:	74 0b                	je     c01062dc <do_pgfault+0x3c>
+c01062d1:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01062d4:	8b 40 04             	mov    0x4(%eax),%eax
+c01062d7:	3b 45 10             	cmp    0x10(%ebp),%eax
+c01062da:	76 18                	jbe    c01062f4 <do_pgfault+0x54>
+        cprintf("not valid addr %x, and  can not find it in vma\n", addr);
+c01062dc:	83 ec 08             	sub    $0x8,%esp
+c01062df:	ff 75 10             	pushl  0x10(%ebp)
+c01062e2:	68 5c ce 10 c0       	push   $0xc010ce5c
+c01062e7:	e8 a3 9f ff ff       	call   c010028f <cprintf>
+c01062ec:	83 c4 10             	add    $0x10,%esp
+        goto failed;
+c01062ef:	e9 af 01 00 00       	jmp    c01064a3 <do_pgfault+0x203>
+    }
+    //check the error_code
+    switch (error_code & 3) {
+c01062f4:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01062f7:	83 e0 03             	and    $0x3,%eax
+c01062fa:	85 c0                	test   %eax,%eax
+c01062fc:	74 3c                	je     c010633a <do_pgfault+0x9a>
+c01062fe:	83 f8 01             	cmp    $0x1,%eax
+c0106301:	74 22                	je     c0106325 <do_pgfault+0x85>
+    default:
+            /* error code flag : default is 3 ( W/R=1, P=1): write, present */
+    case 2: /* error code flag : (W/R=1, P=0): write, not present */
+        if (!(vma->vm_flags & VM_WRITE)) {
+c0106303:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0106306:	8b 40 0c             	mov    0xc(%eax),%eax
+c0106309:	83 e0 02             	and    $0x2,%eax
+c010630c:	85 c0                	test   %eax,%eax
+c010630e:	75 4c                	jne    c010635c <do_pgfault+0xbc>
+            cprintf("do_pgfault failed: error code flag = write AND not present, but the addr's vma cannot write\n");
+c0106310:	83 ec 0c             	sub    $0xc,%esp
+c0106313:	68 8c ce 10 c0       	push   $0xc010ce8c
+c0106318:	e8 72 9f ff ff       	call   c010028f <cprintf>
+c010631d:	83 c4 10             	add    $0x10,%esp
+            goto failed;
+c0106320:	e9 7e 01 00 00       	jmp    c01064a3 <do_pgfault+0x203>
+        }
+        break;
+    case 1: /* error code flag : (W/R=0, P=1): read, present */
+        cprintf("do_pgfault failed: error code flag = read AND present\n");
+c0106325:	83 ec 0c             	sub    $0xc,%esp
+c0106328:	68 ec ce 10 c0       	push   $0xc010ceec
+c010632d:	e8 5d 9f ff ff       	call   c010028f <cprintf>
+c0106332:	83 c4 10             	add    $0x10,%esp
+        goto failed;
+c0106335:	e9 69 01 00 00       	jmp    c01064a3 <do_pgfault+0x203>
+    case 0: /* error code flag : (W/R=0, P=0): read, not present */
+        if (!(vma->vm_flags & (VM_READ | VM_EXEC))) {
+c010633a:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010633d:	8b 40 0c             	mov    0xc(%eax),%eax
+c0106340:	83 e0 05             	and    $0x5,%eax
+c0106343:	85 c0                	test   %eax,%eax
+c0106345:	75 16                	jne    c010635d <do_pgfault+0xbd>
+            cprintf("do_pgfault failed: error code flag = read AND not present, but the addr's vma cannot read or exec\n");
+c0106347:	83 ec 0c             	sub    $0xc,%esp
+c010634a:	68 24 cf 10 c0       	push   $0xc010cf24
+c010634f:	e8 3b 9f ff ff       	call   c010028f <cprintf>
+c0106354:	83 c4 10             	add    $0x10,%esp
+            goto failed;
+c0106357:	e9 47 01 00 00       	jmp    c01064a3 <do_pgfault+0x203>
+    case 2: /* error code flag : (W/R=1, P=0): write, not present */
+        if (!(vma->vm_flags & VM_WRITE)) {
+            cprintf("do_pgfault failed: error code flag = write AND not present, but the addr's vma cannot write\n");
+            goto failed;
+        }
+        break;
+c010635c:	90                   	nop
+     *    (write an non_existed addr && addr is writable) OR
+     *    (read  an non_existed addr && addr is readable)
+     * THEN
+     *    continue process
+     */
+    uint32_t perm = PTE_U;
+c010635d:	c7 45 f0 04 00 00 00 	movl   $0x4,-0x10(%ebp)
+    if (vma->vm_flags & VM_WRITE) {
+c0106364:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0106367:	8b 40 0c             	mov    0xc(%eax),%eax
+c010636a:	83 e0 02             	and    $0x2,%eax
+c010636d:	85 c0                	test   %eax,%eax
+c010636f:	74 04                	je     c0106375 <do_pgfault+0xd5>
+        perm |= PTE_W;
+c0106371:	83 4d f0 02          	orl    $0x2,-0x10(%ebp)
+    }
+    addr = ROUNDDOWN(addr, PGSIZE);
+c0106375:	8b 45 10             	mov    0x10(%ebp),%eax
+c0106378:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c010637b:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010637e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+c0106383:	89 45 10             	mov    %eax,0x10(%ebp)
+
+    ret = -E_NO_MEM;
+c0106386:	c7 45 f4 fc ff ff ff 	movl   $0xfffffffc,-0xc(%ebp)
+
+    pte_t *ptep=NULL;
+c010638d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+    *   PTE_U           0x004                   // page table/directory entry flags bit : User can access
+    * VARIABLES:
+    *   mm->pgdir : the PDT of these vma
+    *
+    */
+    ptep = get_pte(mm->pgdir, addr, 1);
+c0106394:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106397:	8b 40 0c             	mov    0xc(%eax),%eax
+c010639a:	83 ec 04             	sub    $0x4,%esp
+c010639d:	6a 01                	push   $0x1
+c010639f:	ff 75 10             	pushl  0x10(%ebp)
+c01063a2:	50                   	push   %eax
+c01063a3:	e8 85 da ff ff       	call   c0103e2d <get_pte>
+c01063a8:	83 c4 10             	add    $0x10,%esp
+c01063ab:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if (ptep == NULL) {
+c01063ae:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+c01063b2:	75 15                	jne    c01063c9 <do_pgfault+0x129>
+        cprintf("get_pte return a NULL.\n");
+c01063b4:	83 ec 0c             	sub    $0xc,%esp
+c01063b7:	68 87 cf 10 c0       	push   $0xc010cf87
+c01063bc:	e8 ce 9e ff ff       	call   c010028f <cprintf>
+c01063c1:	83 c4 10             	add    $0x10,%esp
+        goto failed;
+c01063c4:	e9 da 00 00 00       	jmp    c01064a3 <do_pgfault+0x203>
+    }
+    //(1) try to find a pte, if pte's PT(Page Table) isn't existed, then create a PT.
+    if (*ptep == 0) {
+c01063c9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01063cc:	8b 00                	mov    (%eax),%eax
+c01063ce:	85 c0                	test   %eax,%eax
+c01063d0:	75 3a                	jne    c010640c <do_pgfault+0x16c>
+        struct Page* page = pgdir_alloc_page(mm->pgdir, addr, perm); 
+c01063d2:	8b 45 08             	mov    0x8(%ebp),%eax
+c01063d5:	8b 40 0c             	mov    0xc(%eax),%eax
+c01063d8:	83 ec 04             	sub    $0x4,%esp
+c01063db:	ff 75 f0             	pushl  -0x10(%ebp)
+c01063de:	ff 75 10             	pushl  0x10(%ebp)
+c01063e1:	50                   	push   %eax
+c01063e2:	e8 00 e1 ff ff       	call   c01044e7 <pgdir_alloc_page>
+c01063e7:	83 c4 10             	add    $0x10,%esp
+c01063ea:	89 45 e0             	mov    %eax,-0x20(%ebp)
+        if(page == NULL) {
+c01063ed:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+c01063f1:	0f 85 a5 00 00 00    	jne    c010649c <do_pgfault+0x1fc>
+            cprintf("pgdir_alloc_page return a NULL.\n");
+c01063f7:	83 ec 0c             	sub    $0xc,%esp
+c01063fa:	68 a0 cf 10 c0       	push   $0xc010cfa0
+c01063ff:	e8 8b 9e ff ff       	call   c010028f <cprintf>
+c0106404:	83 c4 10             	add    $0x10,%esp
+            goto failed;
+c0106407:	e9 97 00 00 00       	jmp    c01064a3 <do_pgfault+0x203>
+             If the vma includes this addr is writable, then we can set the page writable by rewrite the *ptep.
+             This method could be used to implement the Copy on Write (COW) thchnology(a fast fork process method).
+          2) *ptep & PTE_P == 0 & but *ptep!=0, it means this pte is a  swap entry.
+             We should add the LAB3's results here.
+     */
+        if(swap_init_ok) {
+c010640c:	a1 14 10 1b c0       	mov    0xc01b1014,%eax
+c0106411:	85 c0                	test   %eax,%eax
+c0106413:	74 6f                	je     c0106484 <do_pgfault+0x1e4>
+            struct Page *page=NULL;
+c0106415:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+            ret = swap_in(mm, addr, &page);
+c010641c:	83 ec 04             	sub    $0x4,%esp
+c010641f:	8d 45 dc             	lea    -0x24(%ebp),%eax
+c0106422:	50                   	push   %eax
+c0106423:	ff 75 10             	pushl  0x10(%ebp)
+c0106426:	ff 75 08             	pushl  0x8(%ebp)
+c0106429:	e8 c5 0b 00 00       	call   c0106ff3 <swap_in>
+c010642e:	83 c4 10             	add    $0x10,%esp
+c0106431:	89 45 f4             	mov    %eax,-0xc(%ebp)
+            if (ret != 0) {
+c0106434:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0106438:	74 12                	je     c010644c <do_pgfault+0x1ac>
+                cprintf("swap_in failed.\n");
+c010643a:	83 ec 0c             	sub    $0xc,%esp
+c010643d:	68 c1 cf 10 c0       	push   $0xc010cfc1
+c0106442:	e8 48 9e ff ff       	call   c010028f <cprintf>
+c0106447:	83 c4 10             	add    $0x10,%esp
+c010644a:	eb 57                	jmp    c01064a3 <do_pgfault+0x203>
+                goto failed;
+            }    
+//(1）According to the mm AND addr, try to load the content of right disk page
+//    into the memory which page man
+            page_insert(mm->pgdir, page, addr, perm);
+c010644c:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c010644f:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106452:	8b 40 0c             	mov    0xc(%eax),%eax
+c0106455:	ff 75 f0             	pushl  -0x10(%ebp)
+c0106458:	ff 75 10             	pushl  0x10(%ebp)
+c010645b:	52                   	push   %edx
+c010645c:	50                   	push   %eax
+c010645d:	e8 7c df ff ff       	call   c01043de <page_insert>
+c0106462:	83 c4 10             	add    $0x10,%esp
+//(2) According to the mm, addr AND page, setup the map of phy addr <---> logical addr
+            swap_map_swappable(mm, addr, page, 1);
+c0106465:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0106468:	6a 01                	push   $0x1
+c010646a:	50                   	push   %eax
+c010646b:	ff 75 10             	pushl  0x10(%ebp)
+c010646e:	ff 75 08             	pushl  0x8(%ebp)
+c0106471:	e8 ed 09 00 00       	call   c0106e63 <swap_map_swappable>
+c0106476:	83 c4 10             	add    $0x10,%esp
+//(3) make the page swappable.
+            page->pra_vaddr = addr;
+c0106479:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c010647c:	8b 55 10             	mov    0x10(%ebp),%edx
+c010647f:	89 50 1c             	mov    %edx,0x1c(%eax)
+c0106482:	eb 18                	jmp    c010649c <do_pgfault+0x1fc>
+        }
+        else {
+            cprintf("no swap_init_ok but ptep is %x, failed\n",*ptep);
+c0106484:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0106487:	8b 00                	mov    (%eax),%eax
+c0106489:	83 ec 08             	sub    $0x8,%esp
+c010648c:	50                   	push   %eax
+c010648d:	68 d4 cf 10 c0       	push   $0xc010cfd4
+c0106492:	e8 f8 9d ff ff       	call   c010028f <cprintf>
+c0106497:	83 c4 10             	add    $0x10,%esp
+            goto failed;
+c010649a:	eb 07                	jmp    c01064a3 <do_pgfault+0x203>
+        }
+   }
+
+   ret = 0;
+c010649c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+failed:
+    return ret;
+c01064a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+c01064a6:	c9                   	leave  
+c01064a7:	c3                   	ret    
+
+c01064a8 <user_mem_check>:
+
+bool
+user_mem_check(struct mm_struct *mm, uintptr_t addr, size_t len, bool write) {
+c01064a8:	55                   	push   %ebp
+c01064a9:	89 e5                	mov    %esp,%ebp
+c01064ab:	83 ec 10             	sub    $0x10,%esp
+    if (mm != NULL) {
+c01064ae:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c01064b2:	0f 84 dc 00 00 00    	je     c0106594 <user_mem_check+0xec>
+        if (!USER_ACCESS(addr, addr + len)) {
+c01064b8:	81 7d 0c ff ff 1f 00 	cmpl   $0x1fffff,0xc(%ebp)
+c01064bf:	76 1c                	jbe    c01064dd <user_mem_check+0x35>
+c01064c1:	8b 55 0c             	mov    0xc(%ebp),%edx
+c01064c4:	8b 45 10             	mov    0x10(%ebp),%eax
+c01064c7:	01 d0                	add    %edx,%eax
+c01064c9:	3b 45 0c             	cmp    0xc(%ebp),%eax
+c01064cc:	76 0f                	jbe    c01064dd <user_mem_check+0x35>
+c01064ce:	8b 55 0c             	mov    0xc(%ebp),%edx
+c01064d1:	8b 45 10             	mov    0x10(%ebp),%eax
+c01064d4:	01 d0                	add    %edx,%eax
+c01064d6:	3d 00 00 00 b0       	cmp    $0xb0000000,%eax
+c01064db:	76 0a                	jbe    c01064e7 <user_mem_check+0x3f>
+            return 0;
+c01064dd:	b8 00 00 00 00       	mov    $0x0,%eax
+c01064e2:	e9 df 00 00 00       	jmp    c01065c6 <user_mem_check+0x11e>
+        }
+        struct vma_struct *vma;
+        uintptr_t start = addr, end = addr + len;
+c01064e7:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01064ea:	89 45 fc             	mov    %eax,-0x4(%ebp)
+c01064ed:	8b 55 0c             	mov    0xc(%ebp),%edx
+c01064f0:	8b 45 10             	mov    0x10(%ebp),%eax
+c01064f3:	01 d0                	add    %edx,%eax
+c01064f5:	89 45 f8             	mov    %eax,-0x8(%ebp)
+        while (start < end) {
+c01064f8:	e9 84 00 00 00       	jmp    c0106581 <user_mem_check+0xd9>
+            if ((vma = find_vma(mm, start)) == NULL || start < vma->vm_start) {
+c01064fd:	ff 75 fc             	pushl  -0x4(%ebp)
+c0106500:	ff 75 08             	pushl  0x8(%ebp)
+c0106503:	e8 36 f1 ff ff       	call   c010563e <find_vma>
+c0106508:	83 c4 08             	add    $0x8,%esp
+c010650b:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c010650e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0106512:	74 0b                	je     c010651f <user_mem_check+0x77>
+c0106514:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106517:	8b 40 04             	mov    0x4(%eax),%eax
+c010651a:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+c010651d:	76 0a                	jbe    c0106529 <user_mem_check+0x81>
+                return 0;
+c010651f:	b8 00 00 00 00       	mov    $0x0,%eax
+c0106524:	e9 9d 00 00 00       	jmp    c01065c6 <user_mem_check+0x11e>
+            }
+            if (!(vma->vm_flags & ((write) ? VM_WRITE : VM_READ))) {
+c0106529:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010652c:	8b 40 0c             	mov    0xc(%eax),%eax
+c010652f:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+c0106533:	74 07                	je     c010653c <user_mem_check+0x94>
+c0106535:	ba 02 00 00 00       	mov    $0x2,%edx
+c010653a:	eb 05                	jmp    c0106541 <user_mem_check+0x99>
+c010653c:	ba 01 00 00 00       	mov    $0x1,%edx
+c0106541:	21 d0                	and    %edx,%eax
+c0106543:	85 c0                	test   %eax,%eax
+c0106545:	75 07                	jne    c010654e <user_mem_check+0xa6>
+                return 0;
+c0106547:	b8 00 00 00 00       	mov    $0x0,%eax
+c010654c:	eb 78                	jmp    c01065c6 <user_mem_check+0x11e>
+            }
+            if (write && (vma->vm_flags & VM_STACK)) {
+c010654e:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+c0106552:	74 24                	je     c0106578 <user_mem_check+0xd0>
+c0106554:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106557:	8b 40 0c             	mov    0xc(%eax),%eax
+c010655a:	83 e0 08             	and    $0x8,%eax
+c010655d:	85 c0                	test   %eax,%eax
+c010655f:	74 17                	je     c0106578 <user_mem_check+0xd0>
+                if (start < vma->vm_start + PGSIZE) { //check stack start & size
+c0106561:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106564:	8b 40 04             	mov    0x4(%eax),%eax
+c0106567:	05 00 10 00 00       	add    $0x1000,%eax
+c010656c:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+c010656f:	76 07                	jbe    c0106578 <user_mem_check+0xd0>
+                    return 0;
+c0106571:	b8 00 00 00 00       	mov    $0x0,%eax
+c0106576:	eb 4e                	jmp    c01065c6 <user_mem_check+0x11e>
+                }
+            }
+            start = vma->vm_end;
+c0106578:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010657b:	8b 40 08             	mov    0x8(%eax),%eax
+c010657e:	89 45 fc             	mov    %eax,-0x4(%ebp)
+        if (!USER_ACCESS(addr, addr + len)) {
+            return 0;
+        }
+        struct vma_struct *vma;
+        uintptr_t start = addr, end = addr + len;
+        while (start < end) {
+c0106581:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0106584:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+c0106587:	0f 82 70 ff ff ff    	jb     c01064fd <user_mem_check+0x55>
+                    return 0;
+                }
+            }
+            start = vma->vm_end;
+        }
+        return 1;
+c010658d:	b8 01 00 00 00       	mov    $0x1,%eax
+c0106592:	eb 32                	jmp    c01065c6 <user_mem_check+0x11e>
+    }
+    return KERN_ACCESS(addr, addr + len);
+c0106594:	81 7d 0c ff ff ff bf 	cmpl   $0xbfffffff,0xc(%ebp)
+c010659b:	76 23                	jbe    c01065c0 <user_mem_check+0x118>
+c010659d:	8b 55 0c             	mov    0xc(%ebp),%edx
+c01065a0:	8b 45 10             	mov    0x10(%ebp),%eax
+c01065a3:	01 d0                	add    %edx,%eax
+c01065a5:	3b 45 0c             	cmp    0xc(%ebp),%eax
+c01065a8:	76 16                	jbe    c01065c0 <user_mem_check+0x118>
+c01065aa:	8b 55 0c             	mov    0xc(%ebp),%edx
+c01065ad:	8b 45 10             	mov    0x10(%ebp),%eax
+c01065b0:	01 d0                	add    %edx,%eax
+c01065b2:	3d 00 00 00 f8       	cmp    $0xf8000000,%eax
+c01065b7:	77 07                	ja     c01065c0 <user_mem_check+0x118>
+c01065b9:	b8 01 00 00 00       	mov    $0x1,%eax
+c01065be:	eb 05                	jmp    c01065c5 <user_mem_check+0x11d>
+c01065c0:	b8 00 00 00 00       	mov    $0x0,%eax
+c01065c5:	90                   	nop
+}
+c01065c6:	c9                   	leave  
+c01065c7:	c3                   	ret    
+
+c01065c8 <__intr_save>:
+#include <assert.h>
+#include <atomic.h>
+#include <sched.h>
+
+static inline bool
+__intr_save(void) {
+c01065c8:	55                   	push   %ebp
+c01065c9:	89 e5                	mov    %esp,%ebp
+c01065cb:	83 ec 18             	sub    $0x18,%esp
+}
+
+static inline uint32_t
+read_eflags(void) {
+    uint32_t eflags;
+    asm volatile ("pushfl; popl %0" : "=r" (eflags));
+c01065ce:	9c                   	pushf  
+c01065cf:	58                   	pop    %eax
+c01065d0:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    return eflags;
+c01065d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    if (read_eflags() & FL_IF) {
+c01065d6:	25 00 02 00 00       	and    $0x200,%eax
+c01065db:	85 c0                	test   %eax,%eax
+c01065dd:	74 0c                	je     c01065eb <__intr_save+0x23>
+        intr_disable();
+c01065df:	e8 c9 bb ff ff       	call   c01021ad <intr_disable>
+        return 1;
+c01065e4:	b8 01 00 00 00       	mov    $0x1,%eax
+c01065e9:	eb 05                	jmp    c01065f0 <__intr_save+0x28>
+    }
+    return 0;
+c01065eb:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c01065f0:	c9                   	leave  
+c01065f1:	c3                   	ret    
+
+c01065f2 <__intr_restore>:
+
+static inline void
+__intr_restore(bool flag) {
+c01065f2:	55                   	push   %ebp
+c01065f3:	89 e5                	mov    %esp,%ebp
+c01065f5:	83 ec 08             	sub    $0x8,%esp
+    if (flag) {
+c01065f8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c01065fc:	74 05                	je     c0106603 <__intr_restore+0x11>
+        intr_enable();
+c01065fe:	e8 a3 bb ff ff       	call   c01021a6 <intr_enable>
+    }
+}
+c0106603:	90                   	nop
+c0106604:	c9                   	leave  
+c0106605:	c3                   	ret    
+
+c0106606 <page2ppn>:
+
+extern struct Page *pages;
+extern size_t npage;
+
+static inline ppn_t
+page2ppn(struct Page *page) {
+c0106606:	55                   	push   %ebp
+c0106607:	89 e5                	mov    %esp,%ebp
+    return page - pages;
+c0106609:	8b 45 08             	mov    0x8(%ebp),%eax
+c010660c:	8b 15 84 30 1b c0    	mov    0xc01b3084,%edx
+c0106612:	29 d0                	sub    %edx,%eax
+c0106614:	c1 f8 05             	sar    $0x5,%eax
+}
+c0106617:	5d                   	pop    %ebp
+c0106618:	c3                   	ret    
+
+c0106619 <page2pa>:
+
+static inline uintptr_t
+page2pa(struct Page *page) {
+c0106619:	55                   	push   %ebp
+c010661a:	89 e5                	mov    %esp,%ebp
+    return page2ppn(page) << PGSHIFT;
+c010661c:	ff 75 08             	pushl  0x8(%ebp)
+c010661f:	e8 e2 ff ff ff       	call   c0106606 <page2ppn>
+c0106624:	83 c4 04             	add    $0x4,%esp
+c0106627:	c1 e0 0c             	shl    $0xc,%eax
+}
+c010662a:	c9                   	leave  
+c010662b:	c3                   	ret    
+
+c010662c <pa2page>:
+
+static inline struct Page *
+pa2page(uintptr_t pa) {
+c010662c:	55                   	push   %ebp
+c010662d:	89 e5                	mov    %esp,%ebp
+c010662f:	83 ec 08             	sub    $0x8,%esp
+    if (PPN(pa) >= npage) {
+c0106632:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106635:	c1 e8 0c             	shr    $0xc,%eax
+c0106638:	89 c2                	mov    %eax,%edx
+c010663a:	a1 80 0f 1b c0       	mov    0xc01b0f80,%eax
+c010663f:	39 c2                	cmp    %eax,%edx
+c0106641:	72 14                	jb     c0106657 <pa2page+0x2b>
+        panic("pa2page called with invalid pa");
+c0106643:	83 ec 04             	sub    $0x4,%esp
+c0106646:	68 fc cf 10 c0       	push   $0xc010cffc
+c010664b:	6a 5e                	push   $0x5e
+c010664d:	68 1b d0 10 c0       	push   $0xc010d01b
+c0106652:	e8 9e 9d ff ff       	call   c01003f5 <__panic>
+    }
+    return &pages[PPN(pa)];
+c0106657:	a1 84 30 1b c0       	mov    0xc01b3084,%eax
+c010665c:	8b 55 08             	mov    0x8(%ebp),%edx
+c010665f:	c1 ea 0c             	shr    $0xc,%edx
+c0106662:	c1 e2 05             	shl    $0x5,%edx
+c0106665:	01 d0                	add    %edx,%eax
+}
+c0106667:	c9                   	leave  
+c0106668:	c3                   	ret    
+
+c0106669 <page2kva>:
+
+static inline void *
+page2kva(struct Page *page) {
+c0106669:	55                   	push   %ebp
+c010666a:	89 e5                	mov    %esp,%ebp
+c010666c:	83 ec 18             	sub    $0x18,%esp
+    return KADDR(page2pa(page));
+c010666f:	ff 75 08             	pushl  0x8(%ebp)
+c0106672:	e8 a2 ff ff ff       	call   c0106619 <page2pa>
+c0106677:	83 c4 04             	add    $0x4,%esp
+c010667a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c010667d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106680:	c1 e8 0c             	shr    $0xc,%eax
+c0106683:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0106686:	a1 80 0f 1b c0       	mov    0xc01b0f80,%eax
+c010668b:	39 45 f0             	cmp    %eax,-0x10(%ebp)
+c010668e:	72 14                	jb     c01066a4 <page2kva+0x3b>
+c0106690:	ff 75 f4             	pushl  -0xc(%ebp)
+c0106693:	68 2c d0 10 c0       	push   $0xc010d02c
+c0106698:	6a 65                	push   $0x65
+c010669a:	68 1b d0 10 c0       	push   $0xc010d01b
+c010669f:	e8 51 9d ff ff       	call   c01003f5 <__panic>
+c01066a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01066a7:	2d 00 00 00 40       	sub    $0x40000000,%eax
+}
+c01066ac:	c9                   	leave  
+c01066ad:	c3                   	ret    
+
+c01066ae <kva2page>:
+
+static inline struct Page *
+kva2page(void *kva) {
+c01066ae:	55                   	push   %ebp
+c01066af:	89 e5                	mov    %esp,%ebp
+c01066b1:	83 ec 18             	sub    $0x18,%esp
+    return pa2page(PADDR(kva));
+c01066b4:	8b 45 08             	mov    0x8(%ebp),%eax
+c01066b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c01066ba:	81 7d f4 ff ff ff bf 	cmpl   $0xbfffffff,-0xc(%ebp)
+c01066c1:	77 14                	ja     c01066d7 <kva2page+0x29>
+c01066c3:	ff 75 f4             	pushl  -0xc(%ebp)
+c01066c6:	68 50 d0 10 c0       	push   $0xc010d050
+c01066cb:	6a 6a                	push   $0x6a
+c01066cd:	68 1b d0 10 c0       	push   $0xc010d01b
+c01066d2:	e8 1e 9d ff ff       	call   c01003f5 <__panic>
+c01066d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01066da:	05 00 00 00 40       	add    $0x40000000,%eax
+c01066df:	83 ec 0c             	sub    $0xc,%esp
+c01066e2:	50                   	push   %eax
+c01066e3:	e8 44 ff ff ff       	call   c010662c <pa2page>
+c01066e8:	83 c4 10             	add    $0x10,%esp
+}
+c01066eb:	c9                   	leave  
+c01066ec:	c3                   	ret    
+
+c01066ed <__slob_get_free_pages>:
+static slob_t *slobfree = &arena;
+static bigblock_t *bigblocks;
+
+
+static void* __slob_get_free_pages(gfp_t gfp, int order)
+{
+c01066ed:	55                   	push   %ebp
+c01066ee:	89 e5                	mov    %esp,%ebp
+c01066f0:	83 ec 18             	sub    $0x18,%esp
+  struct Page * page = alloc_pages(1 << order);
+c01066f3:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01066f6:	ba 01 00 00 00       	mov    $0x1,%edx
+c01066fb:	89 c1                	mov    %eax,%ecx
+c01066fd:	d3 e2                	shl    %cl,%edx
+c01066ff:	89 d0                	mov    %edx,%eax
+c0106701:	83 ec 0c             	sub    $0xc,%esp
+c0106704:	50                   	push   %eax
+c0106705:	e8 b7 d0 ff ff       	call   c01037c1 <alloc_pages>
+c010670a:	83 c4 10             	add    $0x10,%esp
+c010670d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(!page)
+c0106710:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0106714:	75 07                	jne    c010671d <__slob_get_free_pages+0x30>
+    return NULL;
+c0106716:	b8 00 00 00 00       	mov    $0x0,%eax
+c010671b:	eb 0e                	jmp    c010672b <__slob_get_free_pages+0x3e>
+  return page2kva(page);
+c010671d:	83 ec 0c             	sub    $0xc,%esp
+c0106720:	ff 75 f4             	pushl  -0xc(%ebp)
+c0106723:	e8 41 ff ff ff       	call   c0106669 <page2kva>
+c0106728:	83 c4 10             	add    $0x10,%esp
+}
+c010672b:	c9                   	leave  
+c010672c:	c3                   	ret    
+
+c010672d <__slob_free_pages>:
+
+#define __slob_get_free_page(gfp) __slob_get_free_pages(gfp, 0)
+
+static inline void __slob_free_pages(unsigned long kva, int order)
+{
+c010672d:	55                   	push   %ebp
+c010672e:	89 e5                	mov    %esp,%ebp
+c0106730:	53                   	push   %ebx
+c0106731:	83 ec 04             	sub    $0x4,%esp
+  free_pages(kva2page(kva), 1 << order);
+c0106734:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0106737:	ba 01 00 00 00       	mov    $0x1,%edx
+c010673c:	89 c1                	mov    %eax,%ecx
+c010673e:	d3 e2                	shl    %cl,%edx
+c0106740:	89 d0                	mov    %edx,%eax
+c0106742:	89 c3                	mov    %eax,%ebx
+c0106744:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106747:	83 ec 0c             	sub    $0xc,%esp
+c010674a:	50                   	push   %eax
+c010674b:	e8 5e ff ff ff       	call   c01066ae <kva2page>
+c0106750:	83 c4 10             	add    $0x10,%esp
+c0106753:	83 ec 08             	sub    $0x8,%esp
+c0106756:	53                   	push   %ebx
+c0106757:	50                   	push   %eax
+c0106758:	e8 d0 d0 ff ff       	call   c010382d <free_pages>
+c010675d:	83 c4 10             	add    $0x10,%esp
+}
+c0106760:	90                   	nop
+c0106761:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+c0106764:	c9                   	leave  
+c0106765:	c3                   	ret    
+
+c0106766 <slob_alloc>:
+
+static void slob_free(void *b, int size);
+
+static void *slob_alloc(size_t size, gfp_t gfp, int align)
+{
+c0106766:	55                   	push   %ebp
+c0106767:	89 e5                	mov    %esp,%ebp
+c0106769:	83 ec 28             	sub    $0x28,%esp
+  assert( (size + SLOB_UNIT) < PAGE_SIZE );
+c010676c:	8b 45 08             	mov    0x8(%ebp),%eax
+c010676f:	83 c0 08             	add    $0x8,%eax
+c0106772:	3d ff 0f 00 00       	cmp    $0xfff,%eax
+c0106777:	76 16                	jbe    c010678f <slob_alloc+0x29>
+c0106779:	68 74 d0 10 c0       	push   $0xc010d074
+c010677e:	68 93 d0 10 c0       	push   $0xc010d093
+c0106783:	6a 64                	push   $0x64
+c0106785:	68 a8 d0 10 c0       	push   $0xc010d0a8
+c010678a:	e8 66 9c ff ff       	call   c01003f5 <__panic>
+
+	slob_t *prev, *cur, *aligned = 0;
+c010678f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+	int delta = 0, units = SLOB_UNITS(size);
+c0106796:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+c010679d:	8b 45 08             	mov    0x8(%ebp),%eax
+c01067a0:	83 c0 07             	add    $0x7,%eax
+c01067a3:	c1 e8 03             	shr    $0x3,%eax
+c01067a6:	89 45 e0             	mov    %eax,-0x20(%ebp)
+	unsigned long flags;
+
+	spin_lock_irqsave(&slob_lock, flags);
+c01067a9:	e8 1a fe ff ff       	call   c01065c8 <__intr_save>
+c01067ae:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+	prev = slobfree;
+c01067b1:	a1 68 ca 12 c0       	mov    0xc012ca68,%eax
+c01067b6:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	for (cur = prev->next; ; prev = cur, cur = cur->next) {
+c01067b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01067bc:	8b 40 04             	mov    0x4(%eax),%eax
+c01067bf:	89 45 f0             	mov    %eax,-0x10(%ebp)
+		if (align) {
+c01067c2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+c01067c6:	74 25                	je     c01067ed <slob_alloc+0x87>
+			aligned = (slob_t *)ALIGN((unsigned long)cur, align);
+c01067c8:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c01067cb:	8b 45 10             	mov    0x10(%ebp),%eax
+c01067ce:	01 d0                	add    %edx,%eax
+c01067d0:	8d 50 ff             	lea    -0x1(%eax),%edx
+c01067d3:	8b 45 10             	mov    0x10(%ebp),%eax
+c01067d6:	f7 d8                	neg    %eax
+c01067d8:	21 d0                	and    %edx,%eax
+c01067da:	89 45 ec             	mov    %eax,-0x14(%ebp)
+			delta = aligned - cur;
+c01067dd:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c01067e0:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01067e3:	29 c2                	sub    %eax,%edx
+c01067e5:	89 d0                	mov    %edx,%eax
+c01067e7:	c1 f8 03             	sar    $0x3,%eax
+c01067ea:	89 45 e8             	mov    %eax,-0x18(%ebp)
+		}
+		if (cur->units >= units + delta) { /* room enough? */
+c01067ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01067f0:	8b 00                	mov    (%eax),%eax
+c01067f2:	8b 4d e0             	mov    -0x20(%ebp),%ecx
+c01067f5:	8b 55 e8             	mov    -0x18(%ebp),%edx
+c01067f8:	01 ca                	add    %ecx,%edx
+c01067fa:	39 d0                	cmp    %edx,%eax
+c01067fc:	0f 8c b1 00 00 00    	jl     c01068b3 <slob_alloc+0x14d>
+			if (delta) { /* need to fragment head to align? */
+c0106802:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+c0106806:	74 38                	je     c0106840 <slob_alloc+0xda>
+				aligned->units = cur->units - delta;
+c0106808:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010680b:	8b 00                	mov    (%eax),%eax
+c010680d:	2b 45 e8             	sub    -0x18(%ebp),%eax
+c0106810:	89 c2                	mov    %eax,%edx
+c0106812:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0106815:	89 10                	mov    %edx,(%eax)
+				aligned->next = cur->next;
+c0106817:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010681a:	8b 50 04             	mov    0x4(%eax),%edx
+c010681d:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0106820:	89 50 04             	mov    %edx,0x4(%eax)
+				cur->next = aligned;
+c0106823:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0106826:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c0106829:	89 50 04             	mov    %edx,0x4(%eax)
+				cur->units = delta;
+c010682c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010682f:	8b 55 e8             	mov    -0x18(%ebp),%edx
+c0106832:	89 10                	mov    %edx,(%eax)
+				prev = cur;
+c0106834:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0106837:	89 45 f4             	mov    %eax,-0xc(%ebp)
+				cur = aligned;
+c010683a:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010683d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+			}
+
+			if (cur->units == units) /* exact fit? */
+c0106840:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0106843:	8b 00                	mov    (%eax),%eax
+c0106845:	3b 45 e0             	cmp    -0x20(%ebp),%eax
+c0106848:	75 0e                	jne    c0106858 <slob_alloc+0xf2>
+				prev->next = cur->next; /* unlink */
+c010684a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010684d:	8b 50 04             	mov    0x4(%eax),%edx
+c0106850:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106853:	89 50 04             	mov    %edx,0x4(%eax)
+c0106856:	eb 3c                	jmp    c0106894 <slob_alloc+0x12e>
+			else { /* fragment */
+				prev->next = cur + units;
+c0106858:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c010685b:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+c0106862:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0106865:	01 c2                	add    %eax,%edx
+c0106867:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010686a:	89 50 04             	mov    %edx,0x4(%eax)
+				prev->next->units = cur->units - units;
+c010686d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106870:	8b 40 04             	mov    0x4(%eax),%eax
+c0106873:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c0106876:	8b 12                	mov    (%edx),%edx
+c0106878:	2b 55 e0             	sub    -0x20(%ebp),%edx
+c010687b:	89 10                	mov    %edx,(%eax)
+				prev->next->next = cur->next;
+c010687d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106880:	8b 40 04             	mov    0x4(%eax),%eax
+c0106883:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c0106886:	8b 52 04             	mov    0x4(%edx),%edx
+c0106889:	89 50 04             	mov    %edx,0x4(%eax)
+				cur->units = units;
+c010688c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010688f:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c0106892:	89 10                	mov    %edx,(%eax)
+			}
+
+			slobfree = prev;
+c0106894:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106897:	a3 68 ca 12 c0       	mov    %eax,0xc012ca68
+			spin_unlock_irqrestore(&slob_lock, flags);
+c010689c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c010689f:	83 ec 0c             	sub    $0xc,%esp
+c01068a2:	50                   	push   %eax
+c01068a3:	e8 4a fd ff ff       	call   c01065f2 <__intr_restore>
+c01068a8:	83 c4 10             	add    $0x10,%esp
+			return cur;
+c01068ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01068ae:	e9 80 00 00 00       	jmp    c0106933 <slob_alloc+0x1cd>
+		}
+		if (cur == slobfree) {
+c01068b3:	a1 68 ca 12 c0       	mov    0xc012ca68,%eax
+c01068b8:	39 45 f0             	cmp    %eax,-0x10(%ebp)
+c01068bb:	75 62                	jne    c010691f <slob_alloc+0x1b9>
+			spin_unlock_irqrestore(&slob_lock, flags);
+c01068bd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01068c0:	83 ec 0c             	sub    $0xc,%esp
+c01068c3:	50                   	push   %eax
+c01068c4:	e8 29 fd ff ff       	call   c01065f2 <__intr_restore>
+c01068c9:	83 c4 10             	add    $0x10,%esp
+
+			if (size == PAGE_SIZE) /* trying to shrink arena? */
+c01068cc:	81 7d 08 00 10 00 00 	cmpl   $0x1000,0x8(%ebp)
+c01068d3:	75 07                	jne    c01068dc <slob_alloc+0x176>
+				return 0;
+c01068d5:	b8 00 00 00 00       	mov    $0x0,%eax
+c01068da:	eb 57                	jmp    c0106933 <slob_alloc+0x1cd>
+
+			cur = (slob_t *)__slob_get_free_page(gfp);
+c01068dc:	83 ec 08             	sub    $0x8,%esp
+c01068df:	6a 00                	push   $0x0
+c01068e1:	ff 75 0c             	pushl  0xc(%ebp)
+c01068e4:	e8 04 fe ff ff       	call   c01066ed <__slob_get_free_pages>
+c01068e9:	83 c4 10             	add    $0x10,%esp
+c01068ec:	89 45 f0             	mov    %eax,-0x10(%ebp)
+			if (!cur)
+c01068ef:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c01068f3:	75 07                	jne    c01068fc <slob_alloc+0x196>
+				return 0;
+c01068f5:	b8 00 00 00 00       	mov    $0x0,%eax
+c01068fa:	eb 37                	jmp    c0106933 <slob_alloc+0x1cd>
+
+			slob_free(cur, PAGE_SIZE);
+c01068fc:	83 ec 08             	sub    $0x8,%esp
+c01068ff:	68 00 10 00 00       	push   $0x1000
+c0106904:	ff 75 f0             	pushl  -0x10(%ebp)
+c0106907:	e8 29 00 00 00       	call   c0106935 <slob_free>
+c010690c:	83 c4 10             	add    $0x10,%esp
+			spin_lock_irqsave(&slob_lock, flags);
+c010690f:	e8 b4 fc ff ff       	call   c01065c8 <__intr_save>
+c0106914:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+			cur = slobfree;
+c0106917:	a1 68 ca 12 c0       	mov    0xc012ca68,%eax
+c010691c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	int delta = 0, units = SLOB_UNITS(size);
+	unsigned long flags;
+
+	spin_lock_irqsave(&slob_lock, flags);
+	prev = slobfree;
+	for (cur = prev->next; ; prev = cur, cur = cur->next) {
+c010691f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0106922:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0106925:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0106928:	8b 40 04             	mov    0x4(%eax),%eax
+c010692b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+
+			slob_free(cur, PAGE_SIZE);
+			spin_lock_irqsave(&slob_lock, flags);
+			cur = slobfree;
+		}
+	}
+c010692e:	e9 8f fe ff ff       	jmp    c01067c2 <slob_alloc+0x5c>
+}
+c0106933:	c9                   	leave  
+c0106934:	c3                   	ret    
+
+c0106935 <slob_free>:
+
+static void slob_free(void *block, int size)
+{
+c0106935:	55                   	push   %ebp
+c0106936:	89 e5                	mov    %esp,%ebp
+c0106938:	83 ec 18             	sub    $0x18,%esp
+	slob_t *cur, *b = (slob_t *)block;
+c010693b:	8b 45 08             	mov    0x8(%ebp),%eax
+c010693e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	unsigned long flags;
+
+	if (!block)
+c0106941:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c0106945:	0f 84 05 01 00 00    	je     c0106a50 <slob_free+0x11b>
+		return;
+
+	if (size)
+c010694b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+c010694f:	74 10                	je     c0106961 <slob_free+0x2c>
+		b->units = SLOB_UNITS(size);
+c0106951:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0106954:	83 c0 07             	add    $0x7,%eax
+c0106957:	c1 e8 03             	shr    $0x3,%eax
+c010695a:	89 c2                	mov    %eax,%edx
+c010695c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010695f:	89 10                	mov    %edx,(%eax)
+
+	/* Find reinsertion point */
+	spin_lock_irqsave(&slob_lock, flags);
+c0106961:	e8 62 fc ff ff       	call   c01065c8 <__intr_save>
+c0106966:	89 45 ec             	mov    %eax,-0x14(%ebp)
+	for (cur = slobfree; !(b > cur && b < cur->next); cur = cur->next)
+c0106969:	a1 68 ca 12 c0       	mov    0xc012ca68,%eax
+c010696e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0106971:	eb 27                	jmp    c010699a <slob_free+0x65>
+		if (cur >= cur->next && (b > cur || b < cur->next))
+c0106973:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106976:	8b 40 04             	mov    0x4(%eax),%eax
+c0106979:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+c010697c:	77 13                	ja     c0106991 <slob_free+0x5c>
+c010697e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0106981:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+c0106984:	77 27                	ja     c01069ad <slob_free+0x78>
+c0106986:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106989:	8b 40 04             	mov    0x4(%eax),%eax
+c010698c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+c010698f:	77 1c                	ja     c01069ad <slob_free+0x78>
+	if (size)
+		b->units = SLOB_UNITS(size);
+
+	/* Find reinsertion point */
+	spin_lock_irqsave(&slob_lock, flags);
+	for (cur = slobfree; !(b > cur && b < cur->next); cur = cur->next)
+c0106991:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106994:	8b 40 04             	mov    0x4(%eax),%eax
+c0106997:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c010699a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010699d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+c01069a0:	76 d1                	jbe    c0106973 <slob_free+0x3e>
+c01069a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01069a5:	8b 40 04             	mov    0x4(%eax),%eax
+c01069a8:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+c01069ab:	76 c6                	jbe    c0106973 <slob_free+0x3e>
+		if (cur >= cur->next && (b > cur || b < cur->next))
+			break;
+
+	if (b + b->units == cur->next) {
+c01069ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01069b0:	8b 00                	mov    (%eax),%eax
+c01069b2:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+c01069b9:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01069bc:	01 c2                	add    %eax,%edx
+c01069be:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01069c1:	8b 40 04             	mov    0x4(%eax),%eax
+c01069c4:	39 c2                	cmp    %eax,%edx
+c01069c6:	75 25                	jne    c01069ed <slob_free+0xb8>
+		b->units += cur->next->units;
+c01069c8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01069cb:	8b 10                	mov    (%eax),%edx
+c01069cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01069d0:	8b 40 04             	mov    0x4(%eax),%eax
+c01069d3:	8b 00                	mov    (%eax),%eax
+c01069d5:	01 c2                	add    %eax,%edx
+c01069d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01069da:	89 10                	mov    %edx,(%eax)
+		b->next = cur->next->next;
+c01069dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01069df:	8b 40 04             	mov    0x4(%eax),%eax
+c01069e2:	8b 50 04             	mov    0x4(%eax),%edx
+c01069e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01069e8:	89 50 04             	mov    %edx,0x4(%eax)
+c01069eb:	eb 0c                	jmp    c01069f9 <slob_free+0xc4>
+	} else
+		b->next = cur->next;
+c01069ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01069f0:	8b 50 04             	mov    0x4(%eax),%edx
+c01069f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01069f6:	89 50 04             	mov    %edx,0x4(%eax)
+
+	if (cur + cur->units == b) {
+c01069f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01069fc:	8b 00                	mov    (%eax),%eax
+c01069fe:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+c0106a05:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106a08:	01 d0                	add    %edx,%eax
+c0106a0a:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+c0106a0d:	75 1f                	jne    c0106a2e <slob_free+0xf9>
+		cur->units += b->units;
+c0106a0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106a12:	8b 10                	mov    (%eax),%edx
+c0106a14:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0106a17:	8b 00                	mov    (%eax),%eax
+c0106a19:	01 c2                	add    %eax,%edx
+c0106a1b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106a1e:	89 10                	mov    %edx,(%eax)
+		cur->next = b->next;
+c0106a20:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0106a23:	8b 50 04             	mov    0x4(%eax),%edx
+c0106a26:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106a29:	89 50 04             	mov    %edx,0x4(%eax)
+c0106a2c:	eb 09                	jmp    c0106a37 <slob_free+0x102>
+	} else
+		cur->next = b;
+c0106a2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106a31:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c0106a34:	89 50 04             	mov    %edx,0x4(%eax)
+
+	slobfree = cur;
+c0106a37:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106a3a:	a3 68 ca 12 c0       	mov    %eax,0xc012ca68
+
+	spin_unlock_irqrestore(&slob_lock, flags);
+c0106a3f:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0106a42:	83 ec 0c             	sub    $0xc,%esp
+c0106a45:	50                   	push   %eax
+c0106a46:	e8 a7 fb ff ff       	call   c01065f2 <__intr_restore>
+c0106a4b:	83 c4 10             	add    $0x10,%esp
+c0106a4e:	eb 01                	jmp    c0106a51 <slob_free+0x11c>
+{
+	slob_t *cur, *b = (slob_t *)block;
+	unsigned long flags;
+
+	if (!block)
+		return;
+c0106a50:	90                   	nop
+		cur->next = b;
+
+	slobfree = cur;
+
+	spin_unlock_irqrestore(&slob_lock, flags);
+}
+c0106a51:	c9                   	leave  
+c0106a52:	c3                   	ret    
+
+c0106a53 <slob_init>:
+
+
+
+void
+slob_init(void) {
+c0106a53:	55                   	push   %ebp
+c0106a54:	89 e5                	mov    %esp,%ebp
+c0106a56:	83 ec 08             	sub    $0x8,%esp
+  cprintf("use SLOB allocator\n");
+c0106a59:	83 ec 0c             	sub    $0xc,%esp
+c0106a5c:	68 ba d0 10 c0       	push   $0xc010d0ba
+c0106a61:	e8 29 98 ff ff       	call   c010028f <cprintf>
+c0106a66:	83 c4 10             	add    $0x10,%esp
+}
+c0106a69:	90                   	nop
+c0106a6a:	c9                   	leave  
+c0106a6b:	c3                   	ret    
+
+c0106a6c <kmalloc_init>:
+
+inline void 
+kmalloc_init(void) {
+c0106a6c:	55                   	push   %ebp
+c0106a6d:	89 e5                	mov    %esp,%ebp
+c0106a6f:	83 ec 08             	sub    $0x8,%esp
+    slob_init();
+c0106a72:	e8 dc ff ff ff       	call   c0106a53 <slob_init>
+    cprintf("kmalloc_init() succeeded!\n");
+c0106a77:	83 ec 0c             	sub    $0xc,%esp
+c0106a7a:	68 ce d0 10 c0       	push   $0xc010d0ce
+c0106a7f:	e8 0b 98 ff ff       	call   c010028f <cprintf>
+c0106a84:	83 c4 10             	add    $0x10,%esp
+}
+c0106a87:	90                   	nop
+c0106a88:	c9                   	leave  
+c0106a89:	c3                   	ret    
+
+c0106a8a <slob_allocated>:
+
+size_t
+slob_allocated(void) {
+c0106a8a:	55                   	push   %ebp
+c0106a8b:	89 e5                	mov    %esp,%ebp
+  return 0;
+c0106a8d:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c0106a92:	5d                   	pop    %ebp
+c0106a93:	c3                   	ret    
+
+c0106a94 <kallocated>:
+
+size_t
+kallocated(void) {
+c0106a94:	55                   	push   %ebp
+c0106a95:	89 e5                	mov    %esp,%ebp
+   return slob_allocated();
+c0106a97:	e8 ee ff ff ff       	call   c0106a8a <slob_allocated>
+}
+c0106a9c:	5d                   	pop    %ebp
+c0106a9d:	c3                   	ret    
+
+c0106a9e <find_order>:
+
+static int find_order(int size)
+{
+c0106a9e:	55                   	push   %ebp
+c0106a9f:	89 e5                	mov    %esp,%ebp
+c0106aa1:	83 ec 10             	sub    $0x10,%esp
+	int order = 0;
+c0106aa4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+	for ( ; size > 4096 ; size >>=1)
+c0106aab:	eb 07                	jmp    c0106ab4 <find_order+0x16>
+		order++;
+c0106aad:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+}
+
+static int find_order(int size)
+{
+	int order = 0;
+	for ( ; size > 4096 ; size >>=1)
+c0106ab1:	d1 7d 08             	sarl   0x8(%ebp)
+c0106ab4:	81 7d 08 00 10 00 00 	cmpl   $0x1000,0x8(%ebp)
+c0106abb:	7f f0                	jg     c0106aad <find_order+0xf>
+		order++;
+	return order;
+c0106abd:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+c0106ac0:	c9                   	leave  
+c0106ac1:	c3                   	ret    
+
+c0106ac2 <__kmalloc>:
+
+static void *__kmalloc(size_t size, gfp_t gfp)
+{
+c0106ac2:	55                   	push   %ebp
+c0106ac3:	89 e5                	mov    %esp,%ebp
+c0106ac5:	83 ec 18             	sub    $0x18,%esp
+	slob_t *m;
+	bigblock_t *bb;
+	unsigned long flags;
+
+	if (size < PAGE_SIZE - SLOB_UNIT) {
+c0106ac8:	81 7d 08 f7 0f 00 00 	cmpl   $0xff7,0x8(%ebp)
+c0106acf:	77 35                	ja     c0106b06 <__kmalloc+0x44>
+		m = slob_alloc(size + SLOB_UNIT, gfp, 0);
+c0106ad1:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106ad4:	83 c0 08             	add    $0x8,%eax
+c0106ad7:	83 ec 04             	sub    $0x4,%esp
+c0106ada:	6a 00                	push   $0x0
+c0106adc:	ff 75 0c             	pushl  0xc(%ebp)
+c0106adf:	50                   	push   %eax
+c0106ae0:	e8 81 fc ff ff       	call   c0106766 <slob_alloc>
+c0106ae5:	83 c4 10             	add    $0x10,%esp
+c0106ae8:	89 45 f4             	mov    %eax,-0xc(%ebp)
+		return m ? (void *)(m + 1) : 0;
+c0106aeb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0106aef:	74 0b                	je     c0106afc <__kmalloc+0x3a>
+c0106af1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106af4:	83 c0 08             	add    $0x8,%eax
+c0106af7:	e9 b3 00 00 00       	jmp    c0106baf <__kmalloc+0xed>
+c0106afc:	b8 00 00 00 00       	mov    $0x0,%eax
+c0106b01:	e9 a9 00 00 00       	jmp    c0106baf <__kmalloc+0xed>
+	}
+
+	bb = slob_alloc(sizeof(bigblock_t), gfp, 0);
+c0106b06:	83 ec 04             	sub    $0x4,%esp
+c0106b09:	6a 00                	push   $0x0
+c0106b0b:	ff 75 0c             	pushl  0xc(%ebp)
+c0106b0e:	6a 0c                	push   $0xc
+c0106b10:	e8 51 fc ff ff       	call   c0106766 <slob_alloc>
+c0106b15:	83 c4 10             	add    $0x10,%esp
+c0106b18:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	if (!bb)
+c0106b1b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c0106b1f:	75 0a                	jne    c0106b2b <__kmalloc+0x69>
+		return 0;
+c0106b21:	b8 00 00 00 00       	mov    $0x0,%eax
+c0106b26:	e9 84 00 00 00       	jmp    c0106baf <__kmalloc+0xed>
+
+	bb->order = find_order(size);
+c0106b2b:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106b2e:	83 ec 0c             	sub    $0xc,%esp
+c0106b31:	50                   	push   %eax
+c0106b32:	e8 67 ff ff ff       	call   c0106a9e <find_order>
+c0106b37:	83 c4 10             	add    $0x10,%esp
+c0106b3a:	89 c2                	mov    %eax,%edx
+c0106b3c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0106b3f:	89 10                	mov    %edx,(%eax)
+	bb->pages = (void *)__slob_get_free_pages(gfp, bb->order);
+c0106b41:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0106b44:	8b 00                	mov    (%eax),%eax
+c0106b46:	83 ec 08             	sub    $0x8,%esp
+c0106b49:	50                   	push   %eax
+c0106b4a:	ff 75 0c             	pushl  0xc(%ebp)
+c0106b4d:	e8 9b fb ff ff       	call   c01066ed <__slob_get_free_pages>
+c0106b52:	83 c4 10             	add    $0x10,%esp
+c0106b55:	89 c2                	mov    %eax,%edx
+c0106b57:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0106b5a:	89 50 04             	mov    %edx,0x4(%eax)
+
+	if (bb->pages) {
+c0106b5d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0106b60:	8b 40 04             	mov    0x4(%eax),%eax
+c0106b63:	85 c0                	test   %eax,%eax
+c0106b65:	74 33                	je     c0106b9a <__kmalloc+0xd8>
+		spin_lock_irqsave(&block_lock, flags);
+c0106b67:	e8 5c fa ff ff       	call   c01065c8 <__intr_save>
+c0106b6c:	89 45 ec             	mov    %eax,-0x14(%ebp)
+		bb->next = bigblocks;
+c0106b6f:	8b 15 10 10 1b c0    	mov    0xc01b1010,%edx
+c0106b75:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0106b78:	89 50 08             	mov    %edx,0x8(%eax)
+		bigblocks = bb;
+c0106b7b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0106b7e:	a3 10 10 1b c0       	mov    %eax,0xc01b1010
+		spin_unlock_irqrestore(&block_lock, flags);
+c0106b83:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0106b86:	83 ec 0c             	sub    $0xc,%esp
+c0106b89:	50                   	push   %eax
+c0106b8a:	e8 63 fa ff ff       	call   c01065f2 <__intr_restore>
+c0106b8f:	83 c4 10             	add    $0x10,%esp
+		return bb->pages;
+c0106b92:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0106b95:	8b 40 04             	mov    0x4(%eax),%eax
+c0106b98:	eb 15                	jmp    c0106baf <__kmalloc+0xed>
+	}
+
+	slob_free(bb, sizeof(bigblock_t));
+c0106b9a:	83 ec 08             	sub    $0x8,%esp
+c0106b9d:	6a 0c                	push   $0xc
+c0106b9f:	ff 75 f0             	pushl  -0x10(%ebp)
+c0106ba2:	e8 8e fd ff ff       	call   c0106935 <slob_free>
+c0106ba7:	83 c4 10             	add    $0x10,%esp
+	return 0;
+c0106baa:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c0106baf:	c9                   	leave  
+c0106bb0:	c3                   	ret    
+
+c0106bb1 <kmalloc>:
+
+void *
+kmalloc(size_t size)
+{
+c0106bb1:	55                   	push   %ebp
+c0106bb2:	89 e5                	mov    %esp,%ebp
+c0106bb4:	83 ec 08             	sub    $0x8,%esp
+  return __kmalloc(size, 0);
+c0106bb7:	83 ec 08             	sub    $0x8,%esp
+c0106bba:	6a 00                	push   $0x0
+c0106bbc:	ff 75 08             	pushl  0x8(%ebp)
+c0106bbf:	e8 fe fe ff ff       	call   c0106ac2 <__kmalloc>
+c0106bc4:	83 c4 10             	add    $0x10,%esp
+}
+c0106bc7:	c9                   	leave  
+c0106bc8:	c3                   	ret    
+
+c0106bc9 <kfree>:
+
+
+void kfree(void *block)
+{
+c0106bc9:	55                   	push   %ebp
+c0106bca:	89 e5                	mov    %esp,%ebp
+c0106bcc:	83 ec 18             	sub    $0x18,%esp
+	bigblock_t *bb, **last = &bigblocks;
+c0106bcf:	c7 45 f0 10 10 1b c0 	movl   $0xc01b1010,-0x10(%ebp)
+	unsigned long flags;
+
+	if (!block)
+c0106bd6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c0106bda:	0f 84 ac 00 00 00    	je     c0106c8c <kfree+0xc3>
+		return;
+
+	if (!((unsigned long)block & (PAGE_SIZE-1))) {
+c0106be0:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106be3:	25 ff 0f 00 00       	and    $0xfff,%eax
+c0106be8:	85 c0                	test   %eax,%eax
+c0106bea:	0f 85 85 00 00 00    	jne    c0106c75 <kfree+0xac>
+		/* might be on the big block list */
+		spin_lock_irqsave(&block_lock, flags);
+c0106bf0:	e8 d3 f9 ff ff       	call   c01065c8 <__intr_save>
+c0106bf5:	89 45 ec             	mov    %eax,-0x14(%ebp)
+		for (bb = bigblocks; bb; last = &bb->next, bb = bb->next) {
+c0106bf8:	a1 10 10 1b c0       	mov    0xc01b1010,%eax
+c0106bfd:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0106c00:	eb 5e                	jmp    c0106c60 <kfree+0x97>
+			if (bb->pages == block) {
+c0106c02:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106c05:	8b 40 04             	mov    0x4(%eax),%eax
+c0106c08:	3b 45 08             	cmp    0x8(%ebp),%eax
+c0106c0b:	75 41                	jne    c0106c4e <kfree+0x85>
+				*last = bb->next;
+c0106c0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106c10:	8b 50 08             	mov    0x8(%eax),%edx
+c0106c13:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0106c16:	89 10                	mov    %edx,(%eax)
+				spin_unlock_irqrestore(&block_lock, flags);
+c0106c18:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0106c1b:	83 ec 0c             	sub    $0xc,%esp
+c0106c1e:	50                   	push   %eax
+c0106c1f:	e8 ce f9 ff ff       	call   c01065f2 <__intr_restore>
+c0106c24:	83 c4 10             	add    $0x10,%esp
+				__slob_free_pages((unsigned long)block, bb->order);
+c0106c27:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106c2a:	8b 10                	mov    (%eax),%edx
+c0106c2c:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106c2f:	83 ec 08             	sub    $0x8,%esp
+c0106c32:	52                   	push   %edx
+c0106c33:	50                   	push   %eax
+c0106c34:	e8 f4 fa ff ff       	call   c010672d <__slob_free_pages>
+c0106c39:	83 c4 10             	add    $0x10,%esp
+				slob_free(bb, sizeof(bigblock_t));
+c0106c3c:	83 ec 08             	sub    $0x8,%esp
+c0106c3f:	6a 0c                	push   $0xc
+c0106c41:	ff 75 f4             	pushl  -0xc(%ebp)
+c0106c44:	e8 ec fc ff ff       	call   c0106935 <slob_free>
+c0106c49:	83 c4 10             	add    $0x10,%esp
+				return;
+c0106c4c:	eb 3f                	jmp    c0106c8d <kfree+0xc4>
+		return;
+
+	if (!((unsigned long)block & (PAGE_SIZE-1))) {
+		/* might be on the big block list */
+		spin_lock_irqsave(&block_lock, flags);
+		for (bb = bigblocks; bb; last = &bb->next, bb = bb->next) {
+c0106c4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106c51:	83 c0 08             	add    $0x8,%eax
+c0106c54:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0106c57:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106c5a:	8b 40 08             	mov    0x8(%eax),%eax
+c0106c5d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0106c60:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0106c64:	75 9c                	jne    c0106c02 <kfree+0x39>
+				__slob_free_pages((unsigned long)block, bb->order);
+				slob_free(bb, sizeof(bigblock_t));
+				return;
+			}
+		}
+		spin_unlock_irqrestore(&block_lock, flags);
+c0106c66:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0106c69:	83 ec 0c             	sub    $0xc,%esp
+c0106c6c:	50                   	push   %eax
+c0106c6d:	e8 80 f9 ff ff       	call   c01065f2 <__intr_restore>
+c0106c72:	83 c4 10             	add    $0x10,%esp
+	}
+
+	slob_free((slob_t *)block - 1, 0);
+c0106c75:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106c78:	83 e8 08             	sub    $0x8,%eax
+c0106c7b:	83 ec 08             	sub    $0x8,%esp
+c0106c7e:	6a 00                	push   $0x0
+c0106c80:	50                   	push   %eax
+c0106c81:	e8 af fc ff ff       	call   c0106935 <slob_free>
+c0106c86:	83 c4 10             	add    $0x10,%esp
+	return;
+c0106c89:	90                   	nop
+c0106c8a:	eb 01                	jmp    c0106c8d <kfree+0xc4>
+{
+	bigblock_t *bb, **last = &bigblocks;
+	unsigned long flags;
+
+	if (!block)
+		return;
+c0106c8c:	90                   	nop
+		spin_unlock_irqrestore(&block_lock, flags);
+	}
+
+	slob_free((slob_t *)block - 1, 0);
+	return;
+}
+c0106c8d:	c9                   	leave  
+c0106c8e:	c3                   	ret    
+
+c0106c8f <ksize>:
+
+
+unsigned int ksize(const void *block)
+{
+c0106c8f:	55                   	push   %ebp
+c0106c90:	89 e5                	mov    %esp,%ebp
+c0106c92:	83 ec 18             	sub    $0x18,%esp
+	bigblock_t *bb;
+	unsigned long flags;
+
+	if (!block)
+c0106c95:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c0106c99:	75 07                	jne    c0106ca2 <ksize+0x13>
+		return 0;
+c0106c9b:	b8 00 00 00 00       	mov    $0x0,%eax
+c0106ca0:	eb 73                	jmp    c0106d15 <ksize+0x86>
+
+	if (!((unsigned long)block & (PAGE_SIZE-1))) {
+c0106ca2:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106ca5:	25 ff 0f 00 00       	and    $0xfff,%eax
+c0106caa:	85 c0                	test   %eax,%eax
+c0106cac:	75 5c                	jne    c0106d0a <ksize+0x7b>
+		spin_lock_irqsave(&block_lock, flags);
+c0106cae:	e8 15 f9 ff ff       	call   c01065c8 <__intr_save>
+c0106cb3:	89 45 f0             	mov    %eax,-0x10(%ebp)
+		for (bb = bigblocks; bb; bb = bb->next)
+c0106cb6:	a1 10 10 1b c0       	mov    0xc01b1010,%eax
+c0106cbb:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0106cbe:	eb 35                	jmp    c0106cf5 <ksize+0x66>
+			if (bb->pages == block) {
+c0106cc0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106cc3:	8b 40 04             	mov    0x4(%eax),%eax
+c0106cc6:	3b 45 08             	cmp    0x8(%ebp),%eax
+c0106cc9:	75 21                	jne    c0106cec <ksize+0x5d>
+				spin_unlock_irqrestore(&slob_lock, flags);
+c0106ccb:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0106cce:	83 ec 0c             	sub    $0xc,%esp
+c0106cd1:	50                   	push   %eax
+c0106cd2:	e8 1b f9 ff ff       	call   c01065f2 <__intr_restore>
+c0106cd7:	83 c4 10             	add    $0x10,%esp
+				return PAGE_SIZE << bb->order;
+c0106cda:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106cdd:	8b 00                	mov    (%eax),%eax
+c0106cdf:	ba 00 10 00 00       	mov    $0x1000,%edx
+c0106ce4:	89 c1                	mov    %eax,%ecx
+c0106ce6:	d3 e2                	shl    %cl,%edx
+c0106ce8:	89 d0                	mov    %edx,%eax
+c0106cea:	eb 29                	jmp    c0106d15 <ksize+0x86>
+	if (!block)
+		return 0;
+
+	if (!((unsigned long)block & (PAGE_SIZE-1))) {
+		spin_lock_irqsave(&block_lock, flags);
+		for (bb = bigblocks; bb; bb = bb->next)
+c0106cec:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106cef:	8b 40 08             	mov    0x8(%eax),%eax
+c0106cf2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0106cf5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0106cf9:	75 c5                	jne    c0106cc0 <ksize+0x31>
+			if (bb->pages == block) {
+				spin_unlock_irqrestore(&slob_lock, flags);
+				return PAGE_SIZE << bb->order;
+			}
+		spin_unlock_irqrestore(&block_lock, flags);
+c0106cfb:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0106cfe:	83 ec 0c             	sub    $0xc,%esp
+c0106d01:	50                   	push   %eax
+c0106d02:	e8 eb f8 ff ff       	call   c01065f2 <__intr_restore>
+c0106d07:	83 c4 10             	add    $0x10,%esp
+	}
+
+	return ((slob_t *)block - 1)->units * SLOB_UNIT;
+c0106d0a:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106d0d:	83 e8 08             	sub    $0x8,%eax
+c0106d10:	8b 00                	mov    (%eax),%eax
+c0106d12:	c1 e0 03             	shl    $0x3,%eax
+}
+c0106d15:	c9                   	leave  
+c0106d16:	c3                   	ret    
+
+c0106d17 <pa2page>:
+page2pa(struct Page *page) {
+    return page2ppn(page) << PGSHIFT;
+}
+
+static inline struct Page *
+pa2page(uintptr_t pa) {
+c0106d17:	55                   	push   %ebp
+c0106d18:	89 e5                	mov    %esp,%ebp
+c0106d1a:	83 ec 08             	sub    $0x8,%esp
+    if (PPN(pa) >= npage) {
+c0106d1d:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106d20:	c1 e8 0c             	shr    $0xc,%eax
+c0106d23:	89 c2                	mov    %eax,%edx
+c0106d25:	a1 80 0f 1b c0       	mov    0xc01b0f80,%eax
+c0106d2a:	39 c2                	cmp    %eax,%edx
+c0106d2c:	72 14                	jb     c0106d42 <pa2page+0x2b>
+        panic("pa2page called with invalid pa");
+c0106d2e:	83 ec 04             	sub    $0x4,%esp
+c0106d31:	68 ec d0 10 c0       	push   $0xc010d0ec
+c0106d36:	6a 5e                	push   $0x5e
+c0106d38:	68 0b d1 10 c0       	push   $0xc010d10b
+c0106d3d:	e8 b3 96 ff ff       	call   c01003f5 <__panic>
+    }
+    return &pages[PPN(pa)];
+c0106d42:	a1 84 30 1b c0       	mov    0xc01b3084,%eax
+c0106d47:	8b 55 08             	mov    0x8(%ebp),%edx
+c0106d4a:	c1 ea 0c             	shr    $0xc,%edx
+c0106d4d:	c1 e2 05             	shl    $0x5,%edx
+c0106d50:	01 d0                	add    %edx,%eax
+}
+c0106d52:	c9                   	leave  
+c0106d53:	c3                   	ret    
+
+c0106d54 <pte2page>:
+kva2page(void *kva) {
+    return pa2page(PADDR(kva));
+}
+
+static inline struct Page *
+pte2page(pte_t pte) {
+c0106d54:	55                   	push   %ebp
+c0106d55:	89 e5                	mov    %esp,%ebp
+c0106d57:	83 ec 08             	sub    $0x8,%esp
+    if (!(pte & PTE_P)) {
+c0106d5a:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106d5d:	83 e0 01             	and    $0x1,%eax
+c0106d60:	85 c0                	test   %eax,%eax
+c0106d62:	75 14                	jne    c0106d78 <pte2page+0x24>
+        panic("pte2page called with invalid pte");
+c0106d64:	83 ec 04             	sub    $0x4,%esp
+c0106d67:	68 1c d1 10 c0       	push   $0xc010d11c
+c0106d6c:	6a 70                	push   $0x70
+c0106d6e:	68 0b d1 10 c0       	push   $0xc010d10b
+c0106d73:	e8 7d 96 ff ff       	call   c01003f5 <__panic>
+    }
+    return pa2page(PTE_ADDR(pte));
+c0106d78:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106d7b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+c0106d80:	83 ec 0c             	sub    $0xc,%esp
+c0106d83:	50                   	push   %eax
+c0106d84:	e8 8e ff ff ff       	call   c0106d17 <pa2page>
+c0106d89:	83 c4 10             	add    $0x10,%esp
+}
+c0106d8c:	c9                   	leave  
+c0106d8d:	c3                   	ret    
+
+c0106d8e <pde2page>:
+
+static inline struct Page *
+pde2page(pde_t pde) {
+c0106d8e:	55                   	push   %ebp
+c0106d8f:	89 e5                	mov    %esp,%ebp
+c0106d91:	83 ec 08             	sub    $0x8,%esp
+    return pa2page(PDE_ADDR(pde));
+c0106d94:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106d97:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+c0106d9c:	83 ec 0c             	sub    $0xc,%esp
+c0106d9f:	50                   	push   %eax
+c0106da0:	e8 72 ff ff ff       	call   c0106d17 <pa2page>
+c0106da5:	83 c4 10             	add    $0x10,%esp
+}
+c0106da8:	c9                   	leave  
+c0106da9:	c3                   	ret    
+
+c0106daa <swap_init>:
+
+static void check_swap(void);
+
+int
+swap_init(void)
+{
+c0106daa:	55                   	push   %ebp
+c0106dab:	89 e5                	mov    %esp,%ebp
+c0106dad:	83 ec 18             	sub    $0x18,%esp
+     swapfs_init();
+c0106db0:	e8 9a 19 00 00       	call   c010874f <swapfs_init>
+
+     if (!(1024 <= max_swap_offset && max_swap_offset < MAX_SWAP_OFFSET_LIMIT))
+c0106db5:	a1 3c 31 1b c0       	mov    0xc01b313c,%eax
+c0106dba:	3d ff 03 00 00       	cmp    $0x3ff,%eax
+c0106dbf:	76 0c                	jbe    c0106dcd <swap_init+0x23>
+c0106dc1:	a1 3c 31 1b c0       	mov    0xc01b313c,%eax
+c0106dc6:	3d ff ff ff 00       	cmp    $0xffffff,%eax
+c0106dcb:	76 17                	jbe    c0106de4 <swap_init+0x3a>
+     {
+          panic("bad max_swap_offset %08x.\n", max_swap_offset);
+c0106dcd:	a1 3c 31 1b c0       	mov    0xc01b313c,%eax
+c0106dd2:	50                   	push   %eax
+c0106dd3:	68 3d d1 10 c0       	push   $0xc010d13d
+c0106dd8:	6a 27                	push   $0x27
+c0106dda:	68 58 d1 10 c0       	push   $0xc010d158
+c0106ddf:	e8 11 96 ff ff       	call   c01003f5 <__panic>
+     }
+     
+
+     sm = &swap_manager_fifo;
+c0106de4:	c7 05 1c 10 1b c0 40 	movl   $0xc012ca40,0xc01b101c
+c0106deb:	ca 12 c0 
+     int r = sm->init();
+c0106dee:	a1 1c 10 1b c0       	mov    0xc01b101c,%eax
+c0106df3:	8b 40 04             	mov    0x4(%eax),%eax
+c0106df6:	ff d0                	call   *%eax
+c0106df8:	89 45 f4             	mov    %eax,-0xc(%ebp)
+     
+     if (r == 0)
+c0106dfb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0106dff:	75 27                	jne    c0106e28 <swap_init+0x7e>
+     {
+          swap_init_ok = 1;
+c0106e01:	c7 05 14 10 1b c0 01 	movl   $0x1,0xc01b1014
+c0106e08:	00 00 00 
+          cprintf("SWAP: manager = %s\n", sm->name);
+c0106e0b:	a1 1c 10 1b c0       	mov    0xc01b101c,%eax
+c0106e10:	8b 00                	mov    (%eax),%eax
+c0106e12:	83 ec 08             	sub    $0x8,%esp
+c0106e15:	50                   	push   %eax
+c0106e16:	68 67 d1 10 c0       	push   $0xc010d167
+c0106e1b:	e8 6f 94 ff ff       	call   c010028f <cprintf>
+c0106e20:	83 c4 10             	add    $0x10,%esp
+          check_swap();
+c0106e23:	e8 f7 03 00 00       	call   c010721f <check_swap>
+     }
+
+     return r;
+c0106e28:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+c0106e2b:	c9                   	leave  
+c0106e2c:	c3                   	ret    
+
+c0106e2d <swap_init_mm>:
+
+int
+swap_init_mm(struct mm_struct *mm)
+{
+c0106e2d:	55                   	push   %ebp
+c0106e2e:	89 e5                	mov    %esp,%ebp
+c0106e30:	83 ec 08             	sub    $0x8,%esp
+     return sm->init_mm(mm);
+c0106e33:	a1 1c 10 1b c0       	mov    0xc01b101c,%eax
+c0106e38:	8b 40 08             	mov    0x8(%eax),%eax
+c0106e3b:	83 ec 0c             	sub    $0xc,%esp
+c0106e3e:	ff 75 08             	pushl  0x8(%ebp)
+c0106e41:	ff d0                	call   *%eax
+c0106e43:	83 c4 10             	add    $0x10,%esp
+}
+c0106e46:	c9                   	leave  
+c0106e47:	c3                   	ret    
+
+c0106e48 <swap_tick_event>:
+
+int
+swap_tick_event(struct mm_struct *mm)
+{
+c0106e48:	55                   	push   %ebp
+c0106e49:	89 e5                	mov    %esp,%ebp
+c0106e4b:	83 ec 08             	sub    $0x8,%esp
+     return sm->tick_event(mm);
+c0106e4e:	a1 1c 10 1b c0       	mov    0xc01b101c,%eax
+c0106e53:	8b 40 0c             	mov    0xc(%eax),%eax
+c0106e56:	83 ec 0c             	sub    $0xc,%esp
+c0106e59:	ff 75 08             	pushl  0x8(%ebp)
+c0106e5c:	ff d0                	call   *%eax
+c0106e5e:	83 c4 10             	add    $0x10,%esp
+}
+c0106e61:	c9                   	leave  
+c0106e62:	c3                   	ret    
+
+c0106e63 <swap_map_swappable>:
+
+int
+swap_map_swappable(struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in)
+{
+c0106e63:	55                   	push   %ebp
+c0106e64:	89 e5                	mov    %esp,%ebp
+c0106e66:	83 ec 08             	sub    $0x8,%esp
+     return sm->map_swappable(mm, addr, page, swap_in);
+c0106e69:	a1 1c 10 1b c0       	mov    0xc01b101c,%eax
+c0106e6e:	8b 40 10             	mov    0x10(%eax),%eax
+c0106e71:	ff 75 14             	pushl  0x14(%ebp)
+c0106e74:	ff 75 10             	pushl  0x10(%ebp)
+c0106e77:	ff 75 0c             	pushl  0xc(%ebp)
+c0106e7a:	ff 75 08             	pushl  0x8(%ebp)
+c0106e7d:	ff d0                	call   *%eax
+c0106e7f:	83 c4 10             	add    $0x10,%esp
+}
+c0106e82:	c9                   	leave  
+c0106e83:	c3                   	ret    
+
+c0106e84 <swap_set_unswappable>:
+
+int
+swap_set_unswappable(struct mm_struct *mm, uintptr_t addr)
+{
+c0106e84:	55                   	push   %ebp
+c0106e85:	89 e5                	mov    %esp,%ebp
+c0106e87:	83 ec 08             	sub    $0x8,%esp
+     return sm->set_unswappable(mm, addr);
+c0106e8a:	a1 1c 10 1b c0       	mov    0xc01b101c,%eax
+c0106e8f:	8b 40 14             	mov    0x14(%eax),%eax
+c0106e92:	83 ec 08             	sub    $0x8,%esp
+c0106e95:	ff 75 0c             	pushl  0xc(%ebp)
+c0106e98:	ff 75 08             	pushl  0x8(%ebp)
+c0106e9b:	ff d0                	call   *%eax
+c0106e9d:	83 c4 10             	add    $0x10,%esp
+}
+c0106ea0:	c9                   	leave  
+c0106ea1:	c3                   	ret    
+
+c0106ea2 <swap_out>:
+
+volatile unsigned int swap_out_num=0;
+
+int
+swap_out(struct mm_struct *mm, int n, int in_tick)
+{
+c0106ea2:	55                   	push   %ebp
+c0106ea3:	89 e5                	mov    %esp,%ebp
+c0106ea5:	83 ec 28             	sub    $0x28,%esp
+     int i;
+     for (i = 0; i != n; ++ i)
+c0106ea8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c0106eaf:	e9 2e 01 00 00       	jmp    c0106fe2 <swap_out+0x140>
+     {
+          uintptr_t v;
+          //struct Page **ptr_page=NULL;
+          struct Page *page;
+          // cprintf("i %d, SWAP: call swap_out_victim\n",i);
+          int r = sm->swap_out_victim(mm, &page, in_tick);
+c0106eb4:	a1 1c 10 1b c0       	mov    0xc01b101c,%eax
+c0106eb9:	8b 40 18             	mov    0x18(%eax),%eax
+c0106ebc:	83 ec 04             	sub    $0x4,%esp
+c0106ebf:	ff 75 10             	pushl  0x10(%ebp)
+c0106ec2:	8d 55 e4             	lea    -0x1c(%ebp),%edx
+c0106ec5:	52                   	push   %edx
+c0106ec6:	ff 75 08             	pushl  0x8(%ebp)
+c0106ec9:	ff d0                	call   *%eax
+c0106ecb:	83 c4 10             	add    $0x10,%esp
+c0106ece:	89 45 f0             	mov    %eax,-0x10(%ebp)
+          if (r != 0) {
+c0106ed1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c0106ed5:	74 18                	je     c0106eef <swap_out+0x4d>
+                    cprintf("i %d, swap_out: call swap_out_victim failed\n",i);
+c0106ed7:	83 ec 08             	sub    $0x8,%esp
+c0106eda:	ff 75 f4             	pushl  -0xc(%ebp)
+c0106edd:	68 7c d1 10 c0       	push   $0xc010d17c
+c0106ee2:	e8 a8 93 ff ff       	call   c010028f <cprintf>
+c0106ee7:	83 c4 10             	add    $0x10,%esp
+c0106eea:	e9 ff 00 00 00       	jmp    c0106fee <swap_out+0x14c>
+          }          
+          //assert(!PageReserved(page));
+
+          //cprintf("SWAP: choose victim page 0x%08x\n", page);
+          
+          v=page->pra_vaddr; 
+c0106eef:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0106ef2:	8b 40 1c             	mov    0x1c(%eax),%eax
+c0106ef5:	89 45 ec             	mov    %eax,-0x14(%ebp)
+          pte_t *ptep = get_pte(mm->pgdir, v, 0);
+c0106ef8:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106efb:	8b 40 0c             	mov    0xc(%eax),%eax
+c0106efe:	83 ec 04             	sub    $0x4,%esp
+c0106f01:	6a 00                	push   $0x0
+c0106f03:	ff 75 ec             	pushl  -0x14(%ebp)
+c0106f06:	50                   	push   %eax
+c0106f07:	e8 21 cf ff ff       	call   c0103e2d <get_pte>
+c0106f0c:	83 c4 10             	add    $0x10,%esp
+c0106f0f:	89 45 e8             	mov    %eax,-0x18(%ebp)
+          assert((*ptep & PTE_P) != 0);
+c0106f12:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0106f15:	8b 00                	mov    (%eax),%eax
+c0106f17:	83 e0 01             	and    $0x1,%eax
+c0106f1a:	85 c0                	test   %eax,%eax
+c0106f1c:	75 16                	jne    c0106f34 <swap_out+0x92>
+c0106f1e:	68 a9 d1 10 c0       	push   $0xc010d1a9
+c0106f23:	68 be d1 10 c0       	push   $0xc010d1be
+c0106f28:	6a 67                	push   $0x67
+c0106f2a:	68 58 d1 10 c0       	push   $0xc010d158
+c0106f2f:	e8 c1 94 ff ff       	call   c01003f5 <__panic>
+
+          if (swapfs_write( (page->pra_vaddr/PGSIZE+1)<<8, page) != 0) {
+c0106f34:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0106f37:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c0106f3a:	8b 52 1c             	mov    0x1c(%edx),%edx
+c0106f3d:	c1 ea 0c             	shr    $0xc,%edx
+c0106f40:	83 c2 01             	add    $0x1,%edx
+c0106f43:	c1 e2 08             	shl    $0x8,%edx
+c0106f46:	83 ec 08             	sub    $0x8,%esp
+c0106f49:	50                   	push   %eax
+c0106f4a:	52                   	push   %edx
+c0106f4b:	e8 9b 18 00 00       	call   c01087eb <swapfs_write>
+c0106f50:	83 c4 10             	add    $0x10,%esp
+c0106f53:	85 c0                	test   %eax,%eax
+c0106f55:	74 2b                	je     c0106f82 <swap_out+0xe0>
+                    cprintf("SWAP: failed to save\n");
+c0106f57:	83 ec 0c             	sub    $0xc,%esp
+c0106f5a:	68 d3 d1 10 c0       	push   $0xc010d1d3
+c0106f5f:	e8 2b 93 ff ff       	call   c010028f <cprintf>
+c0106f64:	83 c4 10             	add    $0x10,%esp
+                    sm->map_swappable(mm, v, page, 0);
+c0106f67:	a1 1c 10 1b c0       	mov    0xc01b101c,%eax
+c0106f6c:	8b 40 10             	mov    0x10(%eax),%eax
+c0106f6f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c0106f72:	6a 00                	push   $0x0
+c0106f74:	52                   	push   %edx
+c0106f75:	ff 75 ec             	pushl  -0x14(%ebp)
+c0106f78:	ff 75 08             	pushl  0x8(%ebp)
+c0106f7b:	ff d0                	call   *%eax
+c0106f7d:	83 c4 10             	add    $0x10,%esp
+c0106f80:	eb 5c                	jmp    c0106fde <swap_out+0x13c>
+                    continue;
+          }
+          else {
+                    cprintf("swap_out: i %d, store page in vaddr 0x%x to disk swap entry %d\n", i, v, page->pra_vaddr/PGSIZE+1);
+c0106f82:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0106f85:	8b 40 1c             	mov    0x1c(%eax),%eax
+c0106f88:	c1 e8 0c             	shr    $0xc,%eax
+c0106f8b:	83 c0 01             	add    $0x1,%eax
+c0106f8e:	50                   	push   %eax
+c0106f8f:	ff 75 ec             	pushl  -0x14(%ebp)
+c0106f92:	ff 75 f4             	pushl  -0xc(%ebp)
+c0106f95:	68 ec d1 10 c0       	push   $0xc010d1ec
+c0106f9a:	e8 f0 92 ff ff       	call   c010028f <cprintf>
+c0106f9f:	83 c4 10             	add    $0x10,%esp
+                    *ptep = (page->pra_vaddr/PGSIZE+1)<<8;
+c0106fa2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0106fa5:	8b 40 1c             	mov    0x1c(%eax),%eax
+c0106fa8:	c1 e8 0c             	shr    $0xc,%eax
+c0106fab:	83 c0 01             	add    $0x1,%eax
+c0106fae:	c1 e0 08             	shl    $0x8,%eax
+c0106fb1:	89 c2                	mov    %eax,%edx
+c0106fb3:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0106fb6:	89 10                	mov    %edx,(%eax)
+                    free_page(page);
+c0106fb8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0106fbb:	83 ec 08             	sub    $0x8,%esp
+c0106fbe:	6a 01                	push   $0x1
+c0106fc0:	50                   	push   %eax
+c0106fc1:	e8 67 c8 ff ff       	call   c010382d <free_pages>
+c0106fc6:	83 c4 10             	add    $0x10,%esp
+          }
+          
+          tlb_invalidate(mm->pgdir, v);
+c0106fc9:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106fcc:	8b 40 0c             	mov    0xc(%eax),%eax
+c0106fcf:	83 ec 08             	sub    $0x8,%esp
+c0106fd2:	ff 75 ec             	pushl  -0x14(%ebp)
+c0106fd5:	50                   	push   %eax
+c0106fd6:	e8 bc d4 ff ff       	call   c0104497 <tlb_invalidate>
+c0106fdb:	83 c4 10             	add    $0x10,%esp
+
+int
+swap_out(struct mm_struct *mm, int n, int in_tick)
+{
+     int i;
+     for (i = 0; i != n; ++ i)
+c0106fde:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+c0106fe2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106fe5:	3b 45 0c             	cmp    0xc(%ebp),%eax
+c0106fe8:	0f 85 c6 fe ff ff    	jne    c0106eb4 <swap_out+0x12>
+                    free_page(page);
+          }
+          
+          tlb_invalidate(mm->pgdir, v);
+     }
+     return i;
+c0106fee:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+c0106ff1:	c9                   	leave  
+c0106ff2:	c3                   	ret    
+
+c0106ff3 <swap_in>:
+
+int
+swap_in(struct mm_struct *mm, uintptr_t addr, struct Page **ptr_result)
+{
+c0106ff3:	55                   	push   %ebp
+c0106ff4:	89 e5                	mov    %esp,%ebp
+c0106ff6:	83 ec 18             	sub    $0x18,%esp
+     struct Page *result = alloc_page();
+c0106ff9:	83 ec 0c             	sub    $0xc,%esp
+c0106ffc:	6a 01                	push   $0x1
+c0106ffe:	e8 be c7 ff ff       	call   c01037c1 <alloc_pages>
+c0107003:	83 c4 10             	add    $0x10,%esp
+c0107006:	89 45 f4             	mov    %eax,-0xc(%ebp)
+     assert(result!=NULL);
+c0107009:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c010700d:	75 16                	jne    c0107025 <swap_in+0x32>
+c010700f:	68 2c d2 10 c0       	push   $0xc010d22c
+c0107014:	68 be d1 10 c0       	push   $0xc010d1be
+c0107019:	6a 7d                	push   $0x7d
+c010701b:	68 58 d1 10 c0       	push   $0xc010d158
+c0107020:	e8 d0 93 ff ff       	call   c01003f5 <__panic>
+
+     pte_t *ptep = get_pte(mm->pgdir, addr, 0);
+c0107025:	8b 45 08             	mov    0x8(%ebp),%eax
+c0107028:	8b 40 0c             	mov    0xc(%eax),%eax
+c010702b:	83 ec 04             	sub    $0x4,%esp
+c010702e:	6a 00                	push   $0x0
+c0107030:	ff 75 0c             	pushl  0xc(%ebp)
+c0107033:	50                   	push   %eax
+c0107034:	e8 f4 cd ff ff       	call   c0103e2d <get_pte>
+c0107039:	83 c4 10             	add    $0x10,%esp
+c010703c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+     // cprintf("SWAP: load ptep %x swap entry %d to vaddr 0x%08x, page %x, No %d\n", ptep, (*ptep)>>8, addr, result, (result-pages));
+    
+     int r;
+     if ((r = swapfs_read((*ptep), result)) != 0)
+c010703f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0107042:	8b 00                	mov    (%eax),%eax
+c0107044:	83 ec 08             	sub    $0x8,%esp
+c0107047:	ff 75 f4             	pushl  -0xc(%ebp)
+c010704a:	50                   	push   %eax
+c010704b:	e8 42 17 00 00       	call   c0108792 <swapfs_read>
+c0107050:	83 c4 10             	add    $0x10,%esp
+c0107053:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0107056:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+c010705a:	74 1f                	je     c010707b <swap_in+0x88>
+     {
+        assert(r!=0);
+c010705c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+c0107060:	75 19                	jne    c010707b <swap_in+0x88>
+c0107062:	68 39 d2 10 c0       	push   $0xc010d239
+c0107067:	68 be d1 10 c0       	push   $0xc010d1be
+c010706c:	68 85 00 00 00       	push   $0x85
+c0107071:	68 58 d1 10 c0       	push   $0xc010d158
+c0107076:	e8 7a 93 ff ff       	call   c01003f5 <__panic>
+     }
+     cprintf("swap_in: load disk swap entry %d with swap_page in vadr 0x%x\n", (*ptep)>>8, addr);
+c010707b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010707e:	8b 00                	mov    (%eax),%eax
+c0107080:	c1 e8 08             	shr    $0x8,%eax
+c0107083:	83 ec 04             	sub    $0x4,%esp
+c0107086:	ff 75 0c             	pushl  0xc(%ebp)
+c0107089:	50                   	push   %eax
+c010708a:	68 40 d2 10 c0       	push   $0xc010d240
+c010708f:	e8 fb 91 ff ff       	call   c010028f <cprintf>
+c0107094:	83 c4 10             	add    $0x10,%esp
+     *ptr_result=result;
+c0107097:	8b 45 10             	mov    0x10(%ebp),%eax
+c010709a:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c010709d:	89 10                	mov    %edx,(%eax)
+     return 0;
+c010709f:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c01070a4:	c9                   	leave  
+c01070a5:	c3                   	ret    
+
+c01070a6 <check_content_set>:
+
+
+
+static inline void
+check_content_set(void)
+{
+c01070a6:	55                   	push   %ebp
+c01070a7:	89 e5                	mov    %esp,%ebp
+c01070a9:	83 ec 08             	sub    $0x8,%esp
+     *(unsigned char *)0x1000 = 0x0a;
+c01070ac:	b8 00 10 00 00       	mov    $0x1000,%eax
+c01070b1:	c6 00 0a             	movb   $0xa,(%eax)
+     assert(pgfault_num==1);
+c01070b4:	a1 0c 10 1b c0       	mov    0xc01b100c,%eax
+c01070b9:	83 f8 01             	cmp    $0x1,%eax
+c01070bc:	74 19                	je     c01070d7 <check_content_set+0x31>
+c01070be:	68 7e d2 10 c0       	push   $0xc010d27e
+c01070c3:	68 be d1 10 c0       	push   $0xc010d1be
+c01070c8:	68 92 00 00 00       	push   $0x92
+c01070cd:	68 58 d1 10 c0       	push   $0xc010d158
+c01070d2:	e8 1e 93 ff ff       	call   c01003f5 <__panic>
+     *(unsigned char *)0x1010 = 0x0a;
+c01070d7:	b8 10 10 00 00       	mov    $0x1010,%eax
+c01070dc:	c6 00 0a             	movb   $0xa,(%eax)
+     assert(pgfault_num==1);
+c01070df:	a1 0c 10 1b c0       	mov    0xc01b100c,%eax
+c01070e4:	83 f8 01             	cmp    $0x1,%eax
+c01070e7:	74 19                	je     c0107102 <check_content_set+0x5c>
+c01070e9:	68 7e d2 10 c0       	push   $0xc010d27e
+c01070ee:	68 be d1 10 c0       	push   $0xc010d1be
+c01070f3:	68 94 00 00 00       	push   $0x94
+c01070f8:	68 58 d1 10 c0       	push   $0xc010d158
+c01070fd:	e8 f3 92 ff ff       	call   c01003f5 <__panic>
+     *(unsigned char *)0x2000 = 0x0b;
+c0107102:	b8 00 20 00 00       	mov    $0x2000,%eax
+c0107107:	c6 00 0b             	movb   $0xb,(%eax)
+     assert(pgfault_num==2);
+c010710a:	a1 0c 10 1b c0       	mov    0xc01b100c,%eax
+c010710f:	83 f8 02             	cmp    $0x2,%eax
+c0107112:	74 19                	je     c010712d <check_content_set+0x87>
+c0107114:	68 8d d2 10 c0       	push   $0xc010d28d
+c0107119:	68 be d1 10 c0       	push   $0xc010d1be
+c010711e:	68 96 00 00 00       	push   $0x96
+c0107123:	68 58 d1 10 c0       	push   $0xc010d158
+c0107128:	e8 c8 92 ff ff       	call   c01003f5 <__panic>
+     *(unsigned char *)0x2010 = 0x0b;
+c010712d:	b8 10 20 00 00       	mov    $0x2010,%eax
+c0107132:	c6 00 0b             	movb   $0xb,(%eax)
+     assert(pgfault_num==2);
+c0107135:	a1 0c 10 1b c0       	mov    0xc01b100c,%eax
+c010713a:	83 f8 02             	cmp    $0x2,%eax
+c010713d:	74 19                	je     c0107158 <check_content_set+0xb2>
+c010713f:	68 8d d2 10 c0       	push   $0xc010d28d
+c0107144:	68 be d1 10 c0       	push   $0xc010d1be
+c0107149:	68 98 00 00 00       	push   $0x98
+c010714e:	68 58 d1 10 c0       	push   $0xc010d158
+c0107153:	e8 9d 92 ff ff       	call   c01003f5 <__panic>
+     *(unsigned char *)0x3000 = 0x0c;
+c0107158:	b8 00 30 00 00       	mov    $0x3000,%eax
+c010715d:	c6 00 0c             	movb   $0xc,(%eax)
+     assert(pgfault_num==3);
+c0107160:	a1 0c 10 1b c0       	mov    0xc01b100c,%eax
+c0107165:	83 f8 03             	cmp    $0x3,%eax
+c0107168:	74 19                	je     c0107183 <check_content_set+0xdd>
+c010716a:	68 9c d2 10 c0       	push   $0xc010d29c
+c010716f:	68 be d1 10 c0       	push   $0xc010d1be
+c0107174:	68 9a 00 00 00       	push   $0x9a
+c0107179:	68 58 d1 10 c0       	push   $0xc010d158
+c010717e:	e8 72 92 ff ff       	call   c01003f5 <__panic>
+     *(unsigned char *)0x3010 = 0x0c;
+c0107183:	b8 10 30 00 00       	mov    $0x3010,%eax
+c0107188:	c6 00 0c             	movb   $0xc,(%eax)
+     assert(pgfault_num==3);
+c010718b:	a1 0c 10 1b c0       	mov    0xc01b100c,%eax
+c0107190:	83 f8 03             	cmp    $0x3,%eax
+c0107193:	74 19                	je     c01071ae <check_content_set+0x108>
+c0107195:	68 9c d2 10 c0       	push   $0xc010d29c
+c010719a:	68 be d1 10 c0       	push   $0xc010d1be
+c010719f:	68 9c 00 00 00       	push   $0x9c
+c01071a4:	68 58 d1 10 c0       	push   $0xc010d158
+c01071a9:	e8 47 92 ff ff       	call   c01003f5 <__panic>
+     *(unsigned char *)0x4000 = 0x0d;
+c01071ae:	b8 00 40 00 00       	mov    $0x4000,%eax
+c01071b3:	c6 00 0d             	movb   $0xd,(%eax)
+     assert(pgfault_num==4);
+c01071b6:	a1 0c 10 1b c0       	mov    0xc01b100c,%eax
+c01071bb:	83 f8 04             	cmp    $0x4,%eax
+c01071be:	74 19                	je     c01071d9 <check_content_set+0x133>
+c01071c0:	68 ab d2 10 c0       	push   $0xc010d2ab
+c01071c5:	68 be d1 10 c0       	push   $0xc010d1be
+c01071ca:	68 9e 00 00 00       	push   $0x9e
+c01071cf:	68 58 d1 10 c0       	push   $0xc010d158
+c01071d4:	e8 1c 92 ff ff       	call   c01003f5 <__panic>
+     *(unsigned char *)0x4010 = 0x0d;
+c01071d9:	b8 10 40 00 00       	mov    $0x4010,%eax
+c01071de:	c6 00 0d             	movb   $0xd,(%eax)
+     assert(pgfault_num==4);
+c01071e1:	a1 0c 10 1b c0       	mov    0xc01b100c,%eax
+c01071e6:	83 f8 04             	cmp    $0x4,%eax
+c01071e9:	74 19                	je     c0107204 <check_content_set+0x15e>
+c01071eb:	68 ab d2 10 c0       	push   $0xc010d2ab
+c01071f0:	68 be d1 10 c0       	push   $0xc010d1be
+c01071f5:	68 a0 00 00 00       	push   $0xa0
+c01071fa:	68 58 d1 10 c0       	push   $0xc010d158
+c01071ff:	e8 f1 91 ff ff       	call   c01003f5 <__panic>
+}
+c0107204:	90                   	nop
+c0107205:	c9                   	leave  
+c0107206:	c3                   	ret    
+
+c0107207 <check_content_access>:
+
+static inline int
+check_content_access(void)
+{
+c0107207:	55                   	push   %ebp
+c0107208:	89 e5                	mov    %esp,%ebp
+c010720a:	83 ec 18             	sub    $0x18,%esp
+    int ret = sm->check_swap();
+c010720d:	a1 1c 10 1b c0       	mov    0xc01b101c,%eax
+c0107212:	8b 40 1c             	mov    0x1c(%eax),%eax
+c0107215:	ff d0                	call   *%eax
+c0107217:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    return ret;
+c010721a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+c010721d:	c9                   	leave  
+c010721e:	c3                   	ret    
+
+c010721f <check_swap>:
+#define free_list (free_area.free_list)
+#define nr_free (free_area.nr_free)
+
+static void
+check_swap(void)
+{
+c010721f:	55                   	push   %ebp
+c0107220:	89 e5                	mov    %esp,%ebp
+c0107222:	83 ec 68             	sub    $0x68,%esp
+    //backup mem env
+     int ret, count = 0, total = 0, i;
+c0107225:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c010722c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+     list_entry_t *le = &free_list;
+c0107233:	c7 45 e8 64 31 1b c0 	movl   $0xc01b3164,-0x18(%ebp)
+     while ((le = list_next(le)) != &free_list) {
+c010723a:	eb 60                	jmp    c010729c <check_swap+0x7d>
+        struct Page *p = le2page(le, page_link);
+c010723c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010723f:	83 e8 0c             	sub    $0xc,%eax
+c0107242:	89 45 e0             	mov    %eax,-0x20(%ebp)
+        assert(PageProperty(p));
+c0107245:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0107248:	83 c0 04             	add    $0x4,%eax
+c010724b:	c7 45 b0 01 00 00 00 	movl   $0x1,-0x50(%ebp)
+c0107252:	89 45 ac             	mov    %eax,-0x54(%ebp)
+ * @addr:   the address to count from
+ * */
+static inline bool
+test_bit(int nr, volatile void *addr) {
+    int oldbit;
+    asm volatile ("btl %2, %1; sbbl %0,%0" : "=r" (oldbit) : "m" (*(volatile long *)addr), "Ir" (nr));
+c0107255:	8b 45 ac             	mov    -0x54(%ebp),%eax
+c0107258:	8b 55 b0             	mov    -0x50(%ebp),%edx
+c010725b:	0f a3 10             	bt     %edx,(%eax)
+c010725e:	19 c0                	sbb    %eax,%eax
+c0107260:	89 45 a8             	mov    %eax,-0x58(%ebp)
+    return oldbit != 0;
+c0107263:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
+c0107267:	0f 95 c0             	setne  %al
+c010726a:	0f b6 c0             	movzbl %al,%eax
+c010726d:	85 c0                	test   %eax,%eax
+c010726f:	75 19                	jne    c010728a <check_swap+0x6b>
+c0107271:	68 ba d2 10 c0       	push   $0xc010d2ba
+c0107276:	68 be d1 10 c0       	push   $0xc010d1be
+c010727b:	68 bb 00 00 00       	push   $0xbb
+c0107280:	68 58 d1 10 c0       	push   $0xc010d158
+c0107285:	e8 6b 91 ff ff       	call   c01003f5 <__panic>
+        count ++, total += p->property;
+c010728a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+c010728e:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0107291:	8b 50 08             	mov    0x8(%eax),%edx
+c0107294:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0107297:	01 d0                	add    %edx,%eax
+c0107299:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c010729c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010729f:	89 45 dc             	mov    %eax,-0x24(%ebp)
+c01072a2:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c01072a5:	8b 40 04             	mov    0x4(%eax),%eax
+check_swap(void)
+{
+    //backup mem env
+     int ret, count = 0, total = 0, i;
+     list_entry_t *le = &free_list;
+     while ((le = list_next(le)) != &free_list) {
+c01072a8:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c01072ab:	81 7d e8 64 31 1b c0 	cmpl   $0xc01b3164,-0x18(%ebp)
+c01072b2:	75 88                	jne    c010723c <check_swap+0x1d>
+        struct Page *p = le2page(le, page_link);
+        assert(PageProperty(p));
+        count ++, total += p->property;
+     }
+     assert(total == nr_free_pages());
+c01072b4:	e8 a9 c5 ff ff       	call   c0103862 <nr_free_pages>
+c01072b9:	89 c2                	mov    %eax,%edx
+c01072bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01072be:	39 c2                	cmp    %eax,%edx
+c01072c0:	74 19                	je     c01072db <check_swap+0xbc>
+c01072c2:	68 ca d2 10 c0       	push   $0xc010d2ca
+c01072c7:	68 be d1 10 c0       	push   $0xc010d1be
+c01072cc:	68 be 00 00 00       	push   $0xbe
+c01072d1:	68 58 d1 10 c0       	push   $0xc010d158
+c01072d6:	e8 1a 91 ff ff       	call   c01003f5 <__panic>
+     cprintf("BEGIN check_swap: count %d, total %d\n",count,total);
+c01072db:	83 ec 04             	sub    $0x4,%esp
+c01072de:	ff 75 f0             	pushl  -0x10(%ebp)
+c01072e1:	ff 75 f4             	pushl  -0xc(%ebp)
+c01072e4:	68 e4 d2 10 c0       	push   $0xc010d2e4
+c01072e9:	e8 a1 8f ff ff       	call   c010028f <cprintf>
+c01072ee:	83 c4 10             	add    $0x10,%esp
+     
+     //now we set the phy pages env     
+     struct mm_struct *mm = mm_create();
+c01072f1:	e8 6e e2 ff ff       	call   c0105564 <mm_create>
+c01072f6:	89 45 d8             	mov    %eax,-0x28(%ebp)
+     assert(mm != NULL);
+c01072f9:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
+c01072fd:	75 19                	jne    c0107318 <check_swap+0xf9>
+c01072ff:	68 0a d3 10 c0       	push   $0xc010d30a
+c0107304:	68 be d1 10 c0       	push   $0xc010d1be
+c0107309:	68 c3 00 00 00       	push   $0xc3
+c010730e:	68 58 d1 10 c0       	push   $0xc010d158
+c0107313:	e8 dd 90 ff ff       	call   c01003f5 <__panic>
+
+     extern struct mm_struct *check_mm_struct;
+     assert(check_mm_struct == NULL);
+c0107318:	a1 90 30 1b c0       	mov    0xc01b3090,%eax
+c010731d:	85 c0                	test   %eax,%eax
+c010731f:	74 19                	je     c010733a <check_swap+0x11b>
+c0107321:	68 15 d3 10 c0       	push   $0xc010d315
+c0107326:	68 be d1 10 c0       	push   $0xc010d1be
+c010732b:	68 c6 00 00 00       	push   $0xc6
+c0107330:	68 58 d1 10 c0       	push   $0xc010d158
+c0107335:	e8 bb 90 ff ff       	call   c01003f5 <__panic>
+
+     check_mm_struct = mm;
+c010733a:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c010733d:	a3 90 30 1b c0       	mov    %eax,0xc01b3090
+
+     pde_t *pgdir = mm->pgdir = boot_pgdir;
+c0107342:	8b 15 e0 c9 12 c0    	mov    0xc012c9e0,%edx
+c0107348:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c010734b:	89 50 0c             	mov    %edx,0xc(%eax)
+c010734e:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c0107351:	8b 40 0c             	mov    0xc(%eax),%eax
+c0107354:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+     assert(pgdir[0] == 0);
+c0107357:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c010735a:	8b 00                	mov    (%eax),%eax
+c010735c:	85 c0                	test   %eax,%eax
+c010735e:	74 19                	je     c0107379 <check_swap+0x15a>
+c0107360:	68 2d d3 10 c0       	push   $0xc010d32d
+c0107365:	68 be d1 10 c0       	push   $0xc010d1be
+c010736a:	68 cb 00 00 00       	push   $0xcb
+c010736f:	68 58 d1 10 c0       	push   $0xc010d158
+c0107374:	e8 7c 90 ff ff       	call   c01003f5 <__panic>
+
+     struct vma_struct *vma = vma_create(BEING_CHECK_VALID_VADDR, CHECK_VALID_VADDR, VM_WRITE | VM_READ);
+c0107379:	83 ec 04             	sub    $0x4,%esp
+c010737c:	6a 03                	push   $0x3
+c010737e:	68 00 60 00 00       	push   $0x6000
+c0107383:	68 00 10 00 00       	push   $0x1000
+c0107388:	e8 75 e2 ff ff       	call   c0105602 <vma_create>
+c010738d:	83 c4 10             	add    $0x10,%esp
+c0107390:	89 45 d0             	mov    %eax,-0x30(%ebp)
+     assert(vma != NULL);
+c0107393:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
+c0107397:	75 19                	jne    c01073b2 <check_swap+0x193>
+c0107399:	68 3b d3 10 c0       	push   $0xc010d33b
+c010739e:	68 be d1 10 c0       	push   $0xc010d1be
+c01073a3:	68 ce 00 00 00       	push   $0xce
+c01073a8:	68 58 d1 10 c0       	push   $0xc010d158
+c01073ad:	e8 43 90 ff ff       	call   c01003f5 <__panic>
+
+     insert_vma_struct(mm, vma);
+c01073b2:	83 ec 08             	sub    $0x8,%esp
+c01073b5:	ff 75 d0             	pushl  -0x30(%ebp)
+c01073b8:	ff 75 d8             	pushl  -0x28(%ebp)
+c01073bb:	e8 aa e3 ff ff       	call   c010576a <insert_vma_struct>
+c01073c0:	83 c4 10             	add    $0x10,%esp
+
+     //setup the temp Page Table vaddr 0~4MB
+     cprintf("setup Page Table for vaddr 0X1000, so alloc a page\n");
+c01073c3:	83 ec 0c             	sub    $0xc,%esp
+c01073c6:	68 48 d3 10 c0       	push   $0xc010d348
+c01073cb:	e8 bf 8e ff ff       	call   c010028f <cprintf>
+c01073d0:	83 c4 10             	add    $0x10,%esp
+     pte_t *temp_ptep=NULL;
+c01073d3:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
+     temp_ptep = get_pte(mm->pgdir, BEING_CHECK_VALID_VADDR, 1);
+c01073da:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c01073dd:	8b 40 0c             	mov    0xc(%eax),%eax
+c01073e0:	83 ec 04             	sub    $0x4,%esp
+c01073e3:	6a 01                	push   $0x1
+c01073e5:	68 00 10 00 00       	push   $0x1000
+c01073ea:	50                   	push   %eax
+c01073eb:	e8 3d ca ff ff       	call   c0103e2d <get_pte>
+c01073f0:	83 c4 10             	add    $0x10,%esp
+c01073f3:	89 45 cc             	mov    %eax,-0x34(%ebp)
+     assert(temp_ptep!= NULL);
+c01073f6:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
+c01073fa:	75 19                	jne    c0107415 <check_swap+0x1f6>
+c01073fc:	68 7c d3 10 c0       	push   $0xc010d37c
+c0107401:	68 be d1 10 c0       	push   $0xc010d1be
+c0107406:	68 d6 00 00 00       	push   $0xd6
+c010740b:	68 58 d1 10 c0       	push   $0xc010d158
+c0107410:	e8 e0 8f ff ff       	call   c01003f5 <__panic>
+     cprintf("setup Page Table vaddr 0~4MB OVER!\n");
+c0107415:	83 ec 0c             	sub    $0xc,%esp
+c0107418:	68 90 d3 10 c0       	push   $0xc010d390
+c010741d:	e8 6d 8e ff ff       	call   c010028f <cprintf>
+c0107422:	83 c4 10             	add    $0x10,%esp
+     
+     for (i=0;i<CHECK_VALID_PHY_PAGE_NUM;i++) {
+c0107425:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+c010742c:	e9 90 00 00 00       	jmp    c01074c1 <check_swap+0x2a2>
+          check_rp[i] = alloc_page();
+c0107431:	83 ec 0c             	sub    $0xc,%esp
+c0107434:	6a 01                	push   $0x1
+c0107436:	e8 86 c3 ff ff       	call   c01037c1 <alloc_pages>
+c010743b:	83 c4 10             	add    $0x10,%esp
+c010743e:	89 c2                	mov    %eax,%edx
+c0107440:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0107443:	89 14 85 a0 30 1b c0 	mov    %edx,-0x3fe4cf60(,%eax,4)
+          assert(check_rp[i] != NULL );
+c010744a:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010744d:	8b 04 85 a0 30 1b c0 	mov    -0x3fe4cf60(,%eax,4),%eax
+c0107454:	85 c0                	test   %eax,%eax
+c0107456:	75 19                	jne    c0107471 <check_swap+0x252>
+c0107458:	68 b4 d3 10 c0       	push   $0xc010d3b4
+c010745d:	68 be d1 10 c0       	push   $0xc010d1be
+c0107462:	68 db 00 00 00       	push   $0xdb
+c0107467:	68 58 d1 10 c0       	push   $0xc010d158
+c010746c:	e8 84 8f ff ff       	call   c01003f5 <__panic>
+          assert(!PageProperty(check_rp[i]));
+c0107471:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0107474:	8b 04 85 a0 30 1b c0 	mov    -0x3fe4cf60(,%eax,4),%eax
+c010747b:	83 c0 04             	add    $0x4,%eax
+c010747e:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
+c0107485:	89 45 a4             	mov    %eax,-0x5c(%ebp)
+ * @addr:   the address to count from
+ * */
+static inline bool
+test_bit(int nr, volatile void *addr) {
+    int oldbit;
+    asm volatile ("btl %2, %1; sbbl %0,%0" : "=r" (oldbit) : "m" (*(volatile long *)addr), "Ir" (nr));
+c0107488:	8b 45 a4             	mov    -0x5c(%ebp),%eax
+c010748b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c010748e:	0f a3 10             	bt     %edx,(%eax)
+c0107491:	19 c0                	sbb    %eax,%eax
+c0107493:	89 45 a0             	mov    %eax,-0x60(%ebp)
+    return oldbit != 0;
+c0107496:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
+c010749a:	0f 95 c0             	setne  %al
+c010749d:	0f b6 c0             	movzbl %al,%eax
+c01074a0:	85 c0                	test   %eax,%eax
+c01074a2:	74 19                	je     c01074bd <check_swap+0x29e>
+c01074a4:	68 c8 d3 10 c0       	push   $0xc010d3c8
+c01074a9:	68 be d1 10 c0       	push   $0xc010d1be
+c01074ae:	68 dc 00 00 00       	push   $0xdc
+c01074b3:	68 58 d1 10 c0       	push   $0xc010d158
+c01074b8:	e8 38 8f ff ff       	call   c01003f5 <__panic>
+     pte_t *temp_ptep=NULL;
+     temp_ptep = get_pte(mm->pgdir, BEING_CHECK_VALID_VADDR, 1);
+     assert(temp_ptep!= NULL);
+     cprintf("setup Page Table vaddr 0~4MB OVER!\n");
+     
+     for (i=0;i<CHECK_VALID_PHY_PAGE_NUM;i++) {
+c01074bd:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
+c01074c1:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
+c01074c5:	0f 8e 66 ff ff ff    	jle    c0107431 <check_swap+0x212>
+          check_rp[i] = alloc_page();
+          assert(check_rp[i] != NULL );
+          assert(!PageProperty(check_rp[i]));
+     }
+     list_entry_t free_list_store = free_list;
+c01074cb:	a1 64 31 1b c0       	mov    0xc01b3164,%eax
+c01074d0:	8b 15 68 31 1b c0    	mov    0xc01b3168,%edx
+c01074d6:	89 45 98             	mov    %eax,-0x68(%ebp)
+c01074d9:	89 55 9c             	mov    %edx,-0x64(%ebp)
+c01074dc:	c7 45 c0 64 31 1b c0 	movl   $0xc01b3164,-0x40(%ebp)
+ * list_init - initialize a new entry
+ * @elm:        new entry to be initialized
+ * */
+static inline void
+list_init(list_entry_t *elm) {
+    elm->prev = elm->next = elm;
+c01074e3:	8b 45 c0             	mov    -0x40(%ebp),%eax
+c01074e6:	8b 55 c0             	mov    -0x40(%ebp),%edx
+c01074e9:	89 50 04             	mov    %edx,0x4(%eax)
+c01074ec:	8b 45 c0             	mov    -0x40(%ebp),%eax
+c01074ef:	8b 50 04             	mov    0x4(%eax),%edx
+c01074f2:	8b 45 c0             	mov    -0x40(%ebp),%eax
+c01074f5:	89 10                	mov    %edx,(%eax)
+c01074f7:	c7 45 c8 64 31 1b c0 	movl   $0xc01b3164,-0x38(%ebp)
+ * list_empty - tests whether a list is empty
+ * @list:       the list to test.
+ * */
+static inline bool
+list_empty(list_entry_t *list) {
+    return list->next == list;
+c01074fe:	8b 45 c8             	mov    -0x38(%ebp),%eax
+c0107501:	8b 40 04             	mov    0x4(%eax),%eax
+c0107504:	39 45 c8             	cmp    %eax,-0x38(%ebp)
+c0107507:	0f 94 c0             	sete   %al
+c010750a:	0f b6 c0             	movzbl %al,%eax
+     list_init(&free_list);
+     assert(list_empty(&free_list));
+c010750d:	85 c0                	test   %eax,%eax
+c010750f:	75 19                	jne    c010752a <check_swap+0x30b>
+c0107511:	68 e3 d3 10 c0       	push   $0xc010d3e3
+c0107516:	68 be d1 10 c0       	push   $0xc010d1be
+c010751b:	68 e0 00 00 00       	push   $0xe0
+c0107520:	68 58 d1 10 c0       	push   $0xc010d158
+c0107525:	e8 cb 8e ff ff       	call   c01003f5 <__panic>
+     
+     //assert(alloc_page() == NULL);
+     
+     unsigned int nr_free_store = nr_free;
+c010752a:	a1 6c 31 1b c0       	mov    0xc01b316c,%eax
+c010752f:	89 45 bc             	mov    %eax,-0x44(%ebp)
+     nr_free = 0;
+c0107532:	c7 05 6c 31 1b c0 00 	movl   $0x0,0xc01b316c
+c0107539:	00 00 00 
+     for (i=0;i<CHECK_VALID_PHY_PAGE_NUM;i++) {
+c010753c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+c0107543:	eb 1c                	jmp    c0107561 <check_swap+0x342>
+        free_pages(check_rp[i],1);
+c0107545:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0107548:	8b 04 85 a0 30 1b c0 	mov    -0x3fe4cf60(,%eax,4),%eax
+c010754f:	83 ec 08             	sub    $0x8,%esp
+c0107552:	6a 01                	push   $0x1
+c0107554:	50                   	push   %eax
+c0107555:	e8 d3 c2 ff ff       	call   c010382d <free_pages>
+c010755a:	83 c4 10             	add    $0x10,%esp
+     
+     //assert(alloc_page() == NULL);
+     
+     unsigned int nr_free_store = nr_free;
+     nr_free = 0;
+     for (i=0;i<CHECK_VALID_PHY_PAGE_NUM;i++) {
+c010755d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
+c0107561:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
+c0107565:	7e de                	jle    c0107545 <check_swap+0x326>
+        free_pages(check_rp[i],1);
+     }
+     assert(nr_free==CHECK_VALID_PHY_PAGE_NUM);
+c0107567:	a1 6c 31 1b c0       	mov    0xc01b316c,%eax
+c010756c:	83 f8 04             	cmp    $0x4,%eax
+c010756f:	74 19                	je     c010758a <check_swap+0x36b>
+c0107571:	68 fc d3 10 c0       	push   $0xc010d3fc
+c0107576:	68 be d1 10 c0       	push   $0xc010d1be
+c010757b:	68 e9 00 00 00       	push   $0xe9
+c0107580:	68 58 d1 10 c0       	push   $0xc010d158
+c0107585:	e8 6b 8e ff ff       	call   c01003f5 <__panic>
+     
+     cprintf("set up init env for check_swap begin!\n");
+c010758a:	83 ec 0c             	sub    $0xc,%esp
+c010758d:	68 20 d4 10 c0       	push   $0xc010d420
+c0107592:	e8 f8 8c ff ff       	call   c010028f <cprintf>
+c0107597:	83 c4 10             	add    $0x10,%esp
+     //setup initial vir_page<->phy_page environment for page relpacement algorithm 
+
+     
+     pgfault_num=0;
+c010759a:	c7 05 0c 10 1b c0 00 	movl   $0x0,0xc01b100c
+c01075a1:	00 00 00 
+     
+     check_content_set();
+c01075a4:	e8 fd fa ff ff       	call   c01070a6 <check_content_set>
+     assert( nr_free == 0);         
+c01075a9:	a1 6c 31 1b c0       	mov    0xc01b316c,%eax
+c01075ae:	85 c0                	test   %eax,%eax
+c01075b0:	74 19                	je     c01075cb <check_swap+0x3ac>
+c01075b2:	68 47 d4 10 c0       	push   $0xc010d447
+c01075b7:	68 be d1 10 c0       	push   $0xc010d1be
+c01075bc:	68 f2 00 00 00       	push   $0xf2
+c01075c1:	68 58 d1 10 c0       	push   $0xc010d158
+c01075c6:	e8 2a 8e ff ff       	call   c01003f5 <__panic>
+     for(i = 0; i<MAX_SEQ_NO ; i++) 
+c01075cb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+c01075d2:	eb 26                	jmp    c01075fa <check_swap+0x3db>
+         swap_out_seq_no[i]=swap_in_seq_no[i]=-1;
+c01075d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01075d7:	c7 04 85 c0 30 1b c0 	movl   $0xffffffff,-0x3fe4cf40(,%eax,4)
+c01075de:	ff ff ff ff 
+c01075e2:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01075e5:	8b 14 85 c0 30 1b c0 	mov    -0x3fe4cf40(,%eax,4),%edx
+c01075ec:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01075ef:	89 14 85 00 31 1b c0 	mov    %edx,-0x3fe4cf00(,%eax,4)
+     
+     pgfault_num=0;
+     
+     check_content_set();
+     assert( nr_free == 0);         
+     for(i = 0; i<MAX_SEQ_NO ; i++) 
+c01075f6:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
+c01075fa:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
+c01075fe:	7e d4                	jle    c01075d4 <check_swap+0x3b5>
+         swap_out_seq_no[i]=swap_in_seq_no[i]=-1;
+     
+     for (i= 0;i<CHECK_VALID_PHY_PAGE_NUM;i++) {
+c0107600:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+c0107607:	e9 cc 00 00 00       	jmp    c01076d8 <check_swap+0x4b9>
+         check_ptep[i]=0;
+c010760c:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010760f:	c7 04 85 54 31 1b c0 	movl   $0x0,-0x3fe4ceac(,%eax,4)
+c0107616:	00 00 00 00 
+         check_ptep[i] = get_pte(pgdir, (i+1)*0x1000, 0);
+c010761a:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010761d:	83 c0 01             	add    $0x1,%eax
+c0107620:	c1 e0 0c             	shl    $0xc,%eax
+c0107623:	83 ec 04             	sub    $0x4,%esp
+c0107626:	6a 00                	push   $0x0
+c0107628:	50                   	push   %eax
+c0107629:	ff 75 d4             	pushl  -0x2c(%ebp)
+c010762c:	e8 fc c7 ff ff       	call   c0103e2d <get_pte>
+c0107631:	83 c4 10             	add    $0x10,%esp
+c0107634:	89 c2                	mov    %eax,%edx
+c0107636:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0107639:	89 14 85 54 31 1b c0 	mov    %edx,-0x3fe4ceac(,%eax,4)
+         //cprintf("i %d, check_ptep addr %x, value %x\n", i, check_ptep[i], *check_ptep[i]);
+         assert(check_ptep[i] != NULL);
+c0107640:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0107643:	8b 04 85 54 31 1b c0 	mov    -0x3fe4ceac(,%eax,4),%eax
+c010764a:	85 c0                	test   %eax,%eax
+c010764c:	75 19                	jne    c0107667 <check_swap+0x448>
+c010764e:	68 54 d4 10 c0       	push   $0xc010d454
+c0107653:	68 be d1 10 c0       	push   $0xc010d1be
+c0107658:	68 fa 00 00 00       	push   $0xfa
+c010765d:	68 58 d1 10 c0       	push   $0xc010d158
+c0107662:	e8 8e 8d ff ff       	call   c01003f5 <__panic>
+         assert(pte2page(*check_ptep[i]) == check_rp[i]);
+c0107667:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010766a:	8b 04 85 54 31 1b c0 	mov    -0x3fe4ceac(,%eax,4),%eax
+c0107671:	8b 00                	mov    (%eax),%eax
+c0107673:	83 ec 0c             	sub    $0xc,%esp
+c0107676:	50                   	push   %eax
+c0107677:	e8 d8 f6 ff ff       	call   c0106d54 <pte2page>
+c010767c:	83 c4 10             	add    $0x10,%esp
+c010767f:	89 c2                	mov    %eax,%edx
+c0107681:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0107684:	8b 04 85 a0 30 1b c0 	mov    -0x3fe4cf60(,%eax,4),%eax
+c010768b:	39 c2                	cmp    %eax,%edx
+c010768d:	74 19                	je     c01076a8 <check_swap+0x489>
+c010768f:	68 6c d4 10 c0       	push   $0xc010d46c
+c0107694:	68 be d1 10 c0       	push   $0xc010d1be
+c0107699:	68 fb 00 00 00       	push   $0xfb
+c010769e:	68 58 d1 10 c0       	push   $0xc010d158
+c01076a3:	e8 4d 8d ff ff       	call   c01003f5 <__panic>
+         assert((*check_ptep[i] & PTE_P));          
+c01076a8:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01076ab:	8b 04 85 54 31 1b c0 	mov    -0x3fe4ceac(,%eax,4),%eax
+c01076b2:	8b 00                	mov    (%eax),%eax
+c01076b4:	83 e0 01             	and    $0x1,%eax
+c01076b7:	85 c0                	test   %eax,%eax
+c01076b9:	75 19                	jne    c01076d4 <check_swap+0x4b5>
+c01076bb:	68 94 d4 10 c0       	push   $0xc010d494
+c01076c0:	68 be d1 10 c0       	push   $0xc010d1be
+c01076c5:	68 fc 00 00 00       	push   $0xfc
+c01076ca:	68 58 d1 10 c0       	push   $0xc010d158
+c01076cf:	e8 21 8d ff ff       	call   c01003f5 <__panic>
+     check_content_set();
+     assert( nr_free == 0);         
+     for(i = 0; i<MAX_SEQ_NO ; i++) 
+         swap_out_seq_no[i]=swap_in_seq_no[i]=-1;
+     
+     for (i= 0;i<CHECK_VALID_PHY_PAGE_NUM;i++) {
+c01076d4:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
+c01076d8:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
+c01076dc:	0f 8e 2a ff ff ff    	jle    c010760c <check_swap+0x3ed>
+         //cprintf("i %d, check_ptep addr %x, value %x\n", i, check_ptep[i], *check_ptep[i]);
+         assert(check_ptep[i] != NULL);
+         assert(pte2page(*check_ptep[i]) == check_rp[i]);
+         assert((*check_ptep[i] & PTE_P));          
+     }
+     cprintf("set up init env for check_swap over!\n");
+c01076e2:	83 ec 0c             	sub    $0xc,%esp
+c01076e5:	68 b0 d4 10 c0       	push   $0xc010d4b0
+c01076ea:	e8 a0 8b ff ff       	call   c010028f <cprintf>
+c01076ef:	83 c4 10             	add    $0x10,%esp
+     // now access the virt pages to test  page relpacement algorithm 
+     ret=check_content_access();
+c01076f2:	e8 10 fb ff ff       	call   c0107207 <check_content_access>
+c01076f7:	89 45 b8             	mov    %eax,-0x48(%ebp)
+     assert(ret==0);
+c01076fa:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
+c01076fe:	74 19                	je     c0107719 <check_swap+0x4fa>
+c0107700:	68 d6 d4 10 c0       	push   $0xc010d4d6
+c0107705:	68 be d1 10 c0       	push   $0xc010d1be
+c010770a:	68 01 01 00 00       	push   $0x101
+c010770f:	68 58 d1 10 c0       	push   $0xc010d158
+c0107714:	e8 dc 8c ff ff       	call   c01003f5 <__panic>
+     
+     //restore kernel mem env
+     for (i=0;i<CHECK_VALID_PHY_PAGE_NUM;i++) {
+c0107719:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+c0107720:	eb 1c                	jmp    c010773e <check_swap+0x51f>
+         free_pages(check_rp[i],1);
+c0107722:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0107725:	8b 04 85 a0 30 1b c0 	mov    -0x3fe4cf60(,%eax,4),%eax
+c010772c:	83 ec 08             	sub    $0x8,%esp
+c010772f:	6a 01                	push   $0x1
+c0107731:	50                   	push   %eax
+c0107732:	e8 f6 c0 ff ff       	call   c010382d <free_pages>
+c0107737:	83 c4 10             	add    $0x10,%esp
+     // now access the virt pages to test  page relpacement algorithm 
+     ret=check_content_access();
+     assert(ret==0);
+     
+     //restore kernel mem env
+     for (i=0;i<CHECK_VALID_PHY_PAGE_NUM;i++) {
+c010773a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
+c010773e:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
+c0107742:	7e de                	jle    c0107722 <check_swap+0x503>
+         free_pages(check_rp[i],1);
+     } 
+
+     //free_page(pte2page(*temp_ptep));
+    free_page(pde2page(pgdir[0]));
+c0107744:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c0107747:	8b 00                	mov    (%eax),%eax
+c0107749:	83 ec 0c             	sub    $0xc,%esp
+c010774c:	50                   	push   %eax
+c010774d:	e8 3c f6 ff ff       	call   c0106d8e <pde2page>
+c0107752:	83 c4 10             	add    $0x10,%esp
+c0107755:	83 ec 08             	sub    $0x8,%esp
+c0107758:	6a 01                	push   $0x1
+c010775a:	50                   	push   %eax
+c010775b:	e8 cd c0 ff ff       	call   c010382d <free_pages>
+c0107760:	83 c4 10             	add    $0x10,%esp
+     pgdir[0] = 0;
+c0107763:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c0107766:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+     mm->pgdir = NULL;
+c010776c:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c010776f:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
+     mm_destroy(mm);
+c0107776:	83 ec 0c             	sub    $0xc,%esp
+c0107779:	ff 75 d8             	pushl  -0x28(%ebp)
+c010777c:	e8 0d e1 ff ff       	call   c010588e <mm_destroy>
+c0107781:	83 c4 10             	add    $0x10,%esp
+     check_mm_struct = NULL;
+c0107784:	c7 05 90 30 1b c0 00 	movl   $0x0,0xc01b3090
+c010778b:	00 00 00 
+     
+     nr_free = nr_free_store;
+c010778e:	8b 45 bc             	mov    -0x44(%ebp),%eax
+c0107791:	a3 6c 31 1b c0       	mov    %eax,0xc01b316c
+     free_list = free_list_store;
+c0107796:	8b 45 98             	mov    -0x68(%ebp),%eax
+c0107799:	8b 55 9c             	mov    -0x64(%ebp),%edx
+c010779c:	a3 64 31 1b c0       	mov    %eax,0xc01b3164
+c01077a1:	89 15 68 31 1b c0    	mov    %edx,0xc01b3168
+
+     
+     le = &free_list;
+c01077a7:	c7 45 e8 64 31 1b c0 	movl   $0xc01b3164,-0x18(%ebp)
+     while ((le = list_next(le)) != &free_list) {
+c01077ae:	eb 1d                	jmp    c01077cd <check_swap+0x5ae>
+         struct Page *p = le2page(le, page_link);
+c01077b0:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c01077b3:	83 e8 0c             	sub    $0xc,%eax
+c01077b6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
+         count --, total -= p->property;
+c01077b9:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+c01077bd:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c01077c0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
+c01077c3:	8b 40 08             	mov    0x8(%eax),%eax
+c01077c6:	29 c2                	sub    %eax,%edx
+c01077c8:	89 d0                	mov    %edx,%eax
+c01077ca:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c01077cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c01077d0:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+ * list_next - get the next entry
+ * @listelm:    the list head
+ **/
+static inline list_entry_t *
+list_next(list_entry_t *listelm) {
+    return listelm->next;
+c01077d3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+c01077d6:	8b 40 04             	mov    0x4(%eax),%eax
+     nr_free = nr_free_store;
+     free_list = free_list_store;
+
+     
+     le = &free_list;
+     while ((le = list_next(le)) != &free_list) {
+c01077d9:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c01077dc:	81 7d e8 64 31 1b c0 	cmpl   $0xc01b3164,-0x18(%ebp)
+c01077e3:	75 cb                	jne    c01077b0 <check_swap+0x591>
+         struct Page *p = le2page(le, page_link);
+         count --, total -= p->property;
+     }
+     cprintf("count is %d, total is %d\n",count,total);
+c01077e5:	83 ec 04             	sub    $0x4,%esp
+c01077e8:	ff 75 f0             	pushl  -0x10(%ebp)
+c01077eb:	ff 75 f4             	pushl  -0xc(%ebp)
+c01077ee:	68 dd d4 10 c0       	push   $0xc010d4dd
+c01077f3:	e8 97 8a ff ff       	call   c010028f <cprintf>
+c01077f8:	83 c4 10             	add    $0x10,%esp
+     //assert(count == 0);
+     
+     cprintf("check_swap() succeeded!\n");
+c01077fb:	83 ec 0c             	sub    $0xc,%esp
+c01077fe:	68 f7 d4 10 c0       	push   $0xc010d4f7
+c0107803:	e8 87 8a ff ff       	call   c010028f <cprintf>
+c0107808:	83 c4 10             	add    $0x10,%esp
+}
+c010780b:	90                   	nop
+c010780c:	c9                   	leave  
+c010780d:	c3                   	ret    
+
+c010780e <page2ppn>:
+
+extern struct Page *pages;
+extern size_t npage;
+
+static inline ppn_t
+page2ppn(struct Page *page) {
+c010780e:	55                   	push   %ebp
+c010780f:	89 e5                	mov    %esp,%ebp
+    return page - pages;
+c0107811:	8b 45 08             	mov    0x8(%ebp),%eax
+c0107814:	8b 15 84 30 1b c0    	mov    0xc01b3084,%edx
+c010781a:	29 d0                	sub    %edx,%eax
+c010781c:	c1 f8 05             	sar    $0x5,%eax
+}
+c010781f:	5d                   	pop    %ebp
+c0107820:	c3                   	ret    
+
+c0107821 <page2pa>:
+
+static inline uintptr_t
+page2pa(struct Page *page) {
+c0107821:	55                   	push   %ebp
+c0107822:	89 e5                	mov    %esp,%ebp
+    return page2ppn(page) << PGSHIFT;
+c0107824:	ff 75 08             	pushl  0x8(%ebp)
+c0107827:	e8 e2 ff ff ff       	call   c010780e <page2ppn>
+c010782c:	83 c4 04             	add    $0x4,%esp
+c010782f:	c1 e0 0c             	shl    $0xc,%eax
+}
+c0107832:	c9                   	leave  
+c0107833:	c3                   	ret    
+
+c0107834 <page_ref>:
+pde2page(pde_t pde) {
+    return pa2page(PDE_ADDR(pde));
+}
+
+static inline int
+page_ref(struct Page *page) {
+c0107834:	55                   	push   %ebp
+c0107835:	89 e5                	mov    %esp,%ebp
+    return page->ref;
+c0107837:	8b 45 08             	mov    0x8(%ebp),%eax
+c010783a:	8b 00                	mov    (%eax),%eax
+}
+c010783c:	5d                   	pop    %ebp
+c010783d:	c3                   	ret    
+
+c010783e <set_page_ref>:
+
+static inline void
+set_page_ref(struct Page *page, int val) {
+c010783e:	55                   	push   %ebp
+c010783f:	89 e5                	mov    %esp,%ebp
+    page->ref = val;
+c0107841:	8b 45 08             	mov    0x8(%ebp),%eax
+c0107844:	8b 55 0c             	mov    0xc(%ebp),%edx
+c0107847:	89 10                	mov    %edx,(%eax)
+}
+c0107849:	90                   	nop
+c010784a:	5d                   	pop    %ebp
+c010784b:	c3                   	ret    
+
+c010784c <default_init>:
+free_area_t free_area;
+
+#define free_list (free_area.free_list)
+#define nr_free (free_area.nr_free)
+static void
+default_init(void) {
+c010784c:	55                   	push   %ebp
+c010784d:	89 e5                	mov    %esp,%ebp
+c010784f:	83 ec 10             	sub    $0x10,%esp
+c0107852:	c7 45 fc 64 31 1b c0 	movl   $0xc01b3164,-0x4(%ebp)
+ * list_init - initialize a new entry
+ * @elm:        new entry to be initialized
+ * */
+static inline void
+list_init(list_entry_t *elm) {
+    elm->prev = elm->next = elm;
+c0107859:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c010785c:	8b 55 fc             	mov    -0x4(%ebp),%edx
+c010785f:	89 50 04             	mov    %edx,0x4(%eax)
+c0107862:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0107865:	8b 50 04             	mov    0x4(%eax),%edx
+c0107868:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c010786b:	89 10                	mov    %edx,(%eax)
+    list_init(&free_list);
+    nr_free = 0;
+c010786d:	c7 05 6c 31 1b c0 00 	movl   $0x0,0xc01b316c
+c0107874:	00 00 00 
+}
+c0107877:	90                   	nop
+c0107878:	c9                   	leave  
+c0107879:	c3                   	ret    
+
+c010787a <default_init_memmap>:
+
+static void
+default_init_memmap(struct Page *base, size_t n) {
+c010787a:	55                   	push   %ebp
+c010787b:	89 e5                	mov    %esp,%ebp
+c010787d:	83 ec 38             	sub    $0x38,%esp
+    assert(n > 0);
+c0107880:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+c0107884:	75 16                	jne    c010789c <default_init_memmap+0x22>
+c0107886:	68 10 d5 10 c0       	push   $0xc010d510
+c010788b:	68 16 d5 10 c0       	push   $0xc010d516
+c0107890:	6a 6c                	push   $0x6c
+c0107892:	68 2b d5 10 c0       	push   $0xc010d52b
+c0107897:	e8 59 8b ff ff       	call   c01003f5 <__panic>
+    struct Page *p = base;
+c010789c:	8b 45 08             	mov    0x8(%ebp),%eax
+c010789f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    for (; p != base + n; p ++) {
+c01078a2:	e9 cb 00 00 00       	jmp    c0107972 <default_init_memmap+0xf8>
+        assert(PageReserved(p));
+c01078a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01078aa:	83 c0 04             	add    $0x4,%eax
+c01078ad:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+c01078b4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+ * @addr:   the address to count from
+ * */
+static inline bool
+test_bit(int nr, volatile void *addr) {
+    int oldbit;
+    asm volatile ("btl %2, %1; sbbl %0,%0" : "=r" (oldbit) : "m" (*(volatile long *)addr), "Ir" (nr));
+c01078b7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01078ba:	8b 55 e8             	mov    -0x18(%ebp),%edx
+c01078bd:	0f a3 10             	bt     %edx,(%eax)
+c01078c0:	19 c0                	sbb    %eax,%eax
+c01078c2:	89 45 e0             	mov    %eax,-0x20(%ebp)
+    return oldbit != 0;
+c01078c5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+c01078c9:	0f 95 c0             	setne  %al
+c01078cc:	0f b6 c0             	movzbl %al,%eax
+c01078cf:	85 c0                	test   %eax,%eax
+c01078d1:	75 16                	jne    c01078e9 <default_init_memmap+0x6f>
+c01078d3:	68 41 d5 10 c0       	push   $0xc010d541
+c01078d8:	68 16 d5 10 c0       	push   $0xc010d516
+c01078dd:	6a 6f                	push   $0x6f
+c01078df:	68 2b d5 10 c0       	push   $0xc010d52b
+c01078e4:	e8 0c 8b ff ff       	call   c01003f5 <__panic>
+        p->flags =0;
+c01078e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01078ec:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
+        SetPageProperty(p);
+c01078f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01078f6:	83 c0 04             	add    $0x4,%eax
+c01078f9:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
+c0107900:	89 45 cc             	mov    %eax,-0x34(%ebp)
+ * Note that @nr may be almost arbitrarily large; this function is not
+ * restricted to acting on a single-word quantity.
+ * */
+static inline void
+set_bit(int nr, volatile void *addr) {
+    asm volatile ("btsl %1, %0" :"=m" (*(volatile long *)addr) : "Ir" (nr));
+c0107903:	8b 45 cc             	mov    -0x34(%ebp),%eax
+c0107906:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c0107909:	0f ab 10             	bts    %edx,(%eax)
+        p->property = 0;
+c010790c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010790f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
+        set_page_ref(p, 0);
+c0107916:	83 ec 08             	sub    $0x8,%esp
+c0107919:	6a 00                	push   $0x0
+c010791b:	ff 75 f4             	pushl  -0xc(%ebp)
+c010791e:	e8 1b ff ff ff       	call   c010783e <set_page_ref>
+c0107923:	83 c4 10             	add    $0x10,%esp
+    list_add_before(&free_list,&(p->page_link));
+c0107926:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0107929:	83 c0 0c             	add    $0xc,%eax
+c010792c:	c7 45 f0 64 31 1b c0 	movl   $0xc01b3164,-0x10(%ebp)
+c0107933:	89 45 dc             	mov    %eax,-0x24(%ebp)
+ * Insert the new element @elm *before* the element @listelm which
+ * is already in the list.
+ * */
+static inline void
+list_add_before(list_entry_t *listelm, list_entry_t *elm) {
+    __list_add(elm, listelm->prev, listelm);
+c0107936:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0107939:	8b 00                	mov    (%eax),%eax
+c010793b:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c010793e:	89 55 d8             	mov    %edx,-0x28(%ebp)
+c0107941:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+c0107944:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0107947:	89 45 d0             	mov    %eax,-0x30(%ebp)
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ * */
+static inline void
+__list_add(list_entry_t *elm, list_entry_t *prev, list_entry_t *next) {
+    prev->next = next->prev = elm;
+c010794a:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c010794d:	8b 55 d8             	mov    -0x28(%ebp),%edx
+c0107950:	89 10                	mov    %edx,(%eax)
+c0107952:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c0107955:	8b 10                	mov    (%eax),%edx
+c0107957:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c010795a:	89 50 04             	mov    %edx,0x4(%eax)
+    elm->next = next;
+c010795d:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c0107960:	8b 55 d0             	mov    -0x30(%ebp),%edx
+c0107963:	89 50 04             	mov    %edx,0x4(%eax)
+    elm->prev = prev;
+c0107966:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c0107969:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c010796c:	89 10                	mov    %edx,(%eax)
+
+static void
+default_init_memmap(struct Page *base, size_t n) {
+    assert(n > 0);
+    struct Page *p = base;
+    for (; p != base + n; p ++) {
+c010796e:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
+c0107972:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0107975:	c1 e0 05             	shl    $0x5,%eax
+c0107978:	89 c2                	mov    %eax,%edx
+c010797a:	8b 45 08             	mov    0x8(%ebp),%eax
+c010797d:	01 d0                	add    %edx,%eax
+c010797f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+c0107982:	0f 85 1f ff ff ff    	jne    c01078a7 <default_init_memmap+0x2d>
+        SetPageProperty(p);
+        p->property = 0;
+        set_page_ref(p, 0);
+    list_add_before(&free_list,&(p->page_link));
+    }
+    nr_free += n;
+c0107988:	8b 15 6c 31 1b c0    	mov    0xc01b316c,%edx
+c010798e:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0107991:	01 d0                	add    %edx,%eax
+c0107993:	a3 6c 31 1b c0       	mov    %eax,0xc01b316c
+    base->property=n;
+c0107998:	8b 45 08             	mov    0x8(%ebp),%eax
+c010799b:	8b 55 0c             	mov    0xc(%ebp),%edx
+c010799e:	89 50 08             	mov    %edx,0x8(%eax)
+}
+c01079a1:	90                   	nop
+c01079a2:	c9                   	leave  
+c01079a3:	c3                   	ret    
+
+c01079a4 <default_alloc_pages>:
+
+static struct Page *
+default_alloc_pages(size_t n) {
+c01079a4:	55                   	push   %ebp
+c01079a5:	89 e5                	mov    %esp,%ebp
+c01079a7:	83 ec 58             	sub    $0x58,%esp
+    assert(n > 0);
+c01079aa:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c01079ae:	75 16                	jne    c01079c6 <default_alloc_pages+0x22>
+c01079b0:	68 10 d5 10 c0       	push   $0xc010d510
+c01079b5:	68 16 d5 10 c0       	push   $0xc010d516
+c01079ba:	6a 7c                	push   $0x7c
+c01079bc:	68 2b d5 10 c0       	push   $0xc010d52b
+c01079c1:	e8 2f 8a ff ff       	call   c01003f5 <__panic>
+    if (n > nr_free) {
+c01079c6:	a1 6c 31 1b c0       	mov    0xc01b316c,%eax
+c01079cb:	3b 45 08             	cmp    0x8(%ebp),%eax
+c01079ce:	73 0a                	jae    c01079da <default_alloc_pages+0x36>
+        return NULL;
+c01079d0:	b8 00 00 00 00       	mov    $0x0,%eax
+c01079d5:	e9 40 01 00 00       	jmp    c0107b1a <default_alloc_pages+0x176>
+    }
+    list_entry_t *le, *len;
+    le = &free_list;
+c01079da:	c7 45 f4 64 31 1b c0 	movl   $0xc01b3164,-0xc(%ebp)
+    struct Page *p=NULL;
+c01079e1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    while((le=list_next(le)) != &free_list) {
+c01079e8:	eb 14                	jmp    c01079fe <default_alloc_pages+0x5a>
+        p = le2page(le, page_link);
+c01079ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01079ed:	83 e8 0c             	sub    $0xc,%eax
+c01079f0:	89 45 f0             	mov    %eax,-0x10(%ebp)
+        if(p->property>=n)
+c01079f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01079f6:	8b 40 08             	mov    0x8(%eax),%eax
+c01079f9:	3b 45 08             	cmp    0x8(%ebp),%eax
+c01079fc:	73 1a                	jae    c0107a18 <default_alloc_pages+0x74>
+c01079fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0107a01:	89 45 c8             	mov    %eax,-0x38(%ebp)
+ * list_next - get the next entry
+ * @listelm:    the list head
+ **/
+static inline list_entry_t *
+list_next(list_entry_t *listelm) {
+    return listelm->next;
+c0107a04:	8b 45 c8             	mov    -0x38(%ebp),%eax
+c0107a07:	8b 40 04             	mov    0x4(%eax),%eax
+        return NULL;
+    }
+    list_entry_t *le, *len;
+    le = &free_list;
+    struct Page *p=NULL;
+    while((le=list_next(le)) != &free_list) {
+c0107a0a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0107a0d:	81 7d f4 64 31 1b c0 	cmpl   $0xc01b3164,-0xc(%ebp)
+c0107a14:	75 d4                	jne    c01079ea <default_alloc_pages+0x46>
+c0107a16:	eb 01                	jmp    c0107a19 <default_alloc_pages+0x75>
+        p = le2page(le, page_link);
+        if(p->property>=n)
+        break;
+c0107a18:	90                   	nop
+    }
+    if(p != NULL){
+c0107a19:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c0107a1d:	0f 84 f2 00 00 00    	je     c0107b15 <default_alloc_pages+0x171>
+        int i;
+        for(i=0;i<n;i++){
+c0107a23:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+c0107a2a:	eb 7c                	jmp    c0107aa8 <default_alloc_pages+0x104>
+c0107a2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0107a2f:	89 45 d8             	mov    %eax,-0x28(%ebp)
+c0107a32:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c0107a35:	8b 40 04             	mov    0x4(%eax),%eax
+            len = list_next(le);
+c0107a38:	89 45 e0             	mov    %eax,-0x20(%ebp)
+            struct Page *pp = le2page(le, page_link);
+c0107a3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0107a3e:	83 e8 0c             	sub    $0xc,%eax
+c0107a41:	89 45 dc             	mov    %eax,-0x24(%ebp)
+            SetPageReserved(pp);
+c0107a44:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0107a47:	83 c0 04             	add    $0x4,%eax
+c0107a4a:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
+c0107a51:	89 45 b8             	mov    %eax,-0x48(%ebp)
+c0107a54:	8b 45 b8             	mov    -0x48(%ebp),%eax
+c0107a57:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c0107a5a:	0f ab 10             	bts    %edx,(%eax)
+            ClearPageProperty(pp);
+c0107a5d:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0107a60:	83 c0 04             	add    $0x4,%eax
+c0107a63:	c7 45 d0 01 00 00 00 	movl   $0x1,-0x30(%ebp)
+c0107a6a:	89 45 bc             	mov    %eax,-0x44(%ebp)
+ * @nr:     the bit to clear
+ * @addr:   the address to start counting from
+ * */
+static inline void
+clear_bit(int nr, volatile void *addr) {
+    asm volatile ("btrl %1, %0" :"=m" (*(volatile long *)addr) : "Ir" (nr));
+c0107a6d:	8b 45 bc             	mov    -0x44(%ebp),%eax
+c0107a70:	8b 55 d0             	mov    -0x30(%ebp),%edx
+c0107a73:	0f b3 10             	btr    %edx,(%eax)
+c0107a76:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0107a79:	89 45 e8             	mov    %eax,-0x18(%ebp)
+ * Note: list_empty() on @listelm does not return true after this, the entry is
+ * in an undefined state.
+ * */
+static inline void
+list_del(list_entry_t *listelm) {
+    __list_del(listelm->prev, listelm->next);
+c0107a7c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0107a7f:	8b 40 04             	mov    0x4(%eax),%eax
+c0107a82:	8b 55 e8             	mov    -0x18(%ebp),%edx
+c0107a85:	8b 12                	mov    (%edx),%edx
+c0107a87:	89 55 c4             	mov    %edx,-0x3c(%ebp)
+c0107a8a:	89 45 c0             	mov    %eax,-0x40(%ebp)
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ * */
+static inline void
+__list_del(list_entry_t *prev, list_entry_t *next) {
+    prev->next = next;
+c0107a8d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+c0107a90:	8b 55 c0             	mov    -0x40(%ebp),%edx
+c0107a93:	89 50 04             	mov    %edx,0x4(%eax)
+    next->prev = prev;
+c0107a96:	8b 45 c0             	mov    -0x40(%ebp),%eax
+c0107a99:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+c0107a9c:	89 10                	mov    %edx,(%eax)
+            list_del(le);
+            le = len;
+c0107a9e:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0107aa1:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        if(p->property>=n)
+        break;
+    }
+    if(p != NULL){
+        int i;
+        for(i=0;i<n;i++){
+c0107aa4:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
+c0107aa8:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0107aab:	3b 45 08             	cmp    0x8(%ebp),%eax
+c0107aae:	0f 82 78 ff ff ff    	jb     c0107a2c <default_alloc_pages+0x88>
+            SetPageReserved(pp);
+            ClearPageProperty(pp);
+            list_del(le);
+            le = len;
+        }
+        if(p->property>n){
+c0107ab4:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0107ab7:	8b 40 08             	mov    0x8(%eax),%eax
+c0107aba:	3b 45 08             	cmp    0x8(%ebp),%eax
+c0107abd:	76 12                	jbe    c0107ad1 <default_alloc_pages+0x12d>
+            (le2page(le,page_link))->property = p->property - n;
+c0107abf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0107ac2:	8d 50 f4             	lea    -0xc(%eax),%edx
+c0107ac5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0107ac8:	8b 40 08             	mov    0x8(%eax),%eax
+c0107acb:	2b 45 08             	sub    0x8(%ebp),%eax
+c0107ace:	89 42 08             	mov    %eax,0x8(%edx)
+        }
+        ClearPageProperty(p);
+c0107ad1:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0107ad4:	83 c0 04             	add    $0x4,%eax
+c0107ad7:	c7 45 cc 01 00 00 00 	movl   $0x1,-0x34(%ebp)
+c0107ade:	89 45 b0             	mov    %eax,-0x50(%ebp)
+c0107ae1:	8b 45 b0             	mov    -0x50(%ebp),%eax
+c0107ae4:	8b 55 cc             	mov    -0x34(%ebp),%edx
+c0107ae7:	0f b3 10             	btr    %edx,(%eax)
+        SetPageReserved(p);
+c0107aea:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0107aed:	83 c0 04             	add    $0x4,%eax
+c0107af0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+c0107af7:	89 45 b4             	mov    %eax,-0x4c(%ebp)
+ * Note that @nr may be almost arbitrarily large; this function is not
+ * restricted to acting on a single-word quantity.
+ * */
+static inline void
+set_bit(int nr, volatile void *addr) {
+    asm volatile ("btsl %1, %0" :"=m" (*(volatile long *)addr) : "Ir" (nr));
+c0107afa:	8b 45 b4             	mov    -0x4c(%ebp),%eax
+c0107afd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c0107b00:	0f ab 10             	bts    %edx,(%eax)
+        nr_free -= n;
+c0107b03:	a1 6c 31 1b c0       	mov    0xc01b316c,%eax
+c0107b08:	2b 45 08             	sub    0x8(%ebp),%eax
+c0107b0b:	a3 6c 31 1b c0       	mov    %eax,0xc01b316c
+        return p;
+c0107b10:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0107b13:	eb 05                	jmp    c0107b1a <default_alloc_pages+0x176>
+      }
+    return NULL;
+c0107b15:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c0107b1a:	c9                   	leave  
+c0107b1b:	c3                   	ret    
+
+c0107b1c <default_free_pages>:
+
+static void
+default_free_pages(struct Page *base, size_t n) {
+c0107b1c:	55                   	push   %ebp
+c0107b1d:	89 e5                	mov    %esp,%ebp
+c0107b1f:	83 ec 48             	sub    $0x48,%esp
+    assert(n > 0);
+c0107b22:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+c0107b26:	75 19                	jne    c0107b41 <default_free_pages+0x25>
+c0107b28:	68 10 d5 10 c0       	push   $0xc010d510
+c0107b2d:	68 16 d5 10 c0       	push   $0xc010d516
+c0107b32:	68 9f 00 00 00       	push   $0x9f
+c0107b37:	68 2b d5 10 c0       	push   $0xc010d52b
+c0107b3c:	e8 b4 88 ff ff       	call   c01003f5 <__panic>
+    list_entry_t *le = &free_list;
+c0107b41:	c7 45 f4 64 31 1b c0 	movl   $0xc01b3164,-0xc(%ebp)
+    struct Page *p = base;
+c0107b48:	8b 45 08             	mov    0x8(%ebp),%eax
+c0107b4b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    while((le=list_next(le)) != &free_list){
+c0107b4e:	eb 11                	jmp    c0107b61 <default_free_pages+0x45>
+        p = le2page(le,page_link);
+c0107b50:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0107b53:	83 e8 0c             	sub    $0xc,%eax
+c0107b56:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(p>base)
+c0107b59:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0107b5c:	3b 45 08             	cmp    0x8(%ebp),%eax
+c0107b5f:	77 1a                	ja     c0107b7b <default_free_pages+0x5f>
+c0107b61:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0107b64:	89 45 d8             	mov    %eax,-0x28(%ebp)
+ * list_next - get the next entry
+ * @listelm:    the list head
+ **/
+static inline list_entry_t *
+list_next(list_entry_t *listelm) {
+    return listelm->next;
+c0107b67:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c0107b6a:	8b 40 04             	mov    0x4(%eax),%eax
+static void
+default_free_pages(struct Page *base, size_t n) {
+    assert(n > 0);
+    list_entry_t *le = &free_list;
+    struct Page *p = base;
+    while((le=list_next(le)) != &free_list){
+c0107b6d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0107b70:	81 7d f4 64 31 1b c0 	cmpl   $0xc01b3164,-0xc(%ebp)
+c0107b77:	75 d7                	jne    c0107b50 <default_free_pages+0x34>
+c0107b79:	eb 01                	jmp    c0107b7c <default_free_pages+0x60>
+        p = le2page(le,page_link);
+    if(p>base)
+        break;
+c0107b7b:	90                   	nop
+    }
+    //found where to insert
+    for(p=base;p<base+n;p++){
+c0107b7c:	8b 45 08             	mov    0x8(%ebp),%eax
+c0107b7f:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0107b82:	eb 4b                	jmp    c0107bcf <default_free_pages+0xb3>
+        //cprintf("%x\n",p);
+        list_add_before(le,&(p->page_link));
+c0107b84:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0107b87:	8d 50 0c             	lea    0xc(%eax),%edx
+c0107b8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0107b8d:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0107b90:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+ * Insert the new element @elm *before* the element @listelm which
+ * is already in the list.
+ * */
+static inline void
+list_add_before(list_entry_t *listelm, list_entry_t *elm) {
+    __list_add(elm, listelm->prev, listelm);
+c0107b93:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0107b96:	8b 00                	mov    (%eax),%eax
+c0107b98:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c0107b9b:	89 55 d0             	mov    %edx,-0x30(%ebp)
+c0107b9e:	89 45 cc             	mov    %eax,-0x34(%ebp)
+c0107ba1:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0107ba4:	89 45 c8             	mov    %eax,-0x38(%ebp)
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ * */
+static inline void
+__list_add(list_entry_t *elm, list_entry_t *prev, list_entry_t *next) {
+    prev->next = next->prev = elm;
+c0107ba7:	8b 45 c8             	mov    -0x38(%ebp),%eax
+c0107baa:	8b 55 d0             	mov    -0x30(%ebp),%edx
+c0107bad:	89 10                	mov    %edx,(%eax)
+c0107baf:	8b 45 c8             	mov    -0x38(%ebp),%eax
+c0107bb2:	8b 10                	mov    (%eax),%edx
+c0107bb4:	8b 45 cc             	mov    -0x34(%ebp),%eax
+c0107bb7:	89 50 04             	mov    %edx,0x4(%eax)
+    elm->next = next;
+c0107bba:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c0107bbd:	8b 55 c8             	mov    -0x38(%ebp),%edx
+c0107bc0:	89 50 04             	mov    %edx,0x4(%eax)
+    elm->prev = prev;
+c0107bc3:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c0107bc6:	8b 55 cc             	mov    -0x34(%ebp),%edx
+c0107bc9:	89 10                	mov    %edx,(%eax)
+        p = le2page(le,page_link);
+    if(p>base)
+        break;
+    }
+    //found where to insert
+    for(p=base;p<base+n;p++){
+c0107bcb:	83 45 f0 20          	addl   $0x20,-0x10(%ebp)
+c0107bcf:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0107bd2:	c1 e0 05             	shl    $0x5,%eax
+c0107bd5:	89 c2                	mov    %eax,%edx
+c0107bd7:	8b 45 08             	mov    0x8(%ebp),%eax
+c0107bda:	01 d0                	add    %edx,%eax
+c0107bdc:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+c0107bdf:	77 a3                	ja     c0107b84 <default_free_pages+0x68>
+        //cprintf("%x\n",p);
+        list_add_before(le,&(p->page_link));
+    }
+    base->flags=0;
+c0107be1:	8b 45 08             	mov    0x8(%ebp),%eax
+c0107be4:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
+    set_page_ref(base,0);
+c0107beb:	83 ec 08             	sub    $0x8,%esp
+c0107bee:	6a 00                	push   $0x0
+c0107bf0:	ff 75 08             	pushl  0x8(%ebp)
+c0107bf3:	e8 46 fc ff ff       	call   c010783e <set_page_ref>
+c0107bf8:	83 c4 10             	add    $0x10,%esp
+    ClearPageProperty(base);
+c0107bfb:	8b 45 08             	mov    0x8(%ebp),%eax
+c0107bfe:	83 c0 04             	add    $0x4,%eax
+c0107c01:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
+c0107c08:	89 45 c0             	mov    %eax,-0x40(%ebp)
+ * @nr:     the bit to clear
+ * @addr:   the address to start counting from
+ * */
+static inline void
+clear_bit(int nr, volatile void *addr) {
+    asm volatile ("btrl %1, %0" :"=m" (*(volatile long *)addr) : "Ir" (nr));
+c0107c0b:	8b 45 c0             	mov    -0x40(%ebp),%eax
+c0107c0e:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c0107c11:	0f b3 10             	btr    %edx,(%eax)
+    SetPageProperty(base);
+c0107c14:	8b 45 08             	mov    0x8(%ebp),%eax
+c0107c17:	83 c0 04             	add    $0x4,%eax
+c0107c1a:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
+c0107c21:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+ * Note that @nr may be almost arbitrarily large; this function is not
+ * restricted to acting on a single-word quantity.
+ * */
+static inline void
+set_bit(int nr, volatile void *addr) {
+    asm volatile ("btsl %1, %0" :"=m" (*(volatile long *)addr) : "Ir" (nr));
+c0107c24:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+c0107c27:	8b 55 e8             	mov    -0x18(%ebp),%edx
+c0107c2a:	0f ab 10             	bts    %edx,(%eax)
+    base->property = n;
+c0107c2d:	8b 45 08             	mov    0x8(%ebp),%eax
+c0107c30:	8b 55 0c             	mov    0xc(%ebp),%edx
+c0107c33:	89 50 08             	mov    %edx,0x8(%eax)
+    p = le2page(le,page_link);
+c0107c36:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0107c39:	83 e8 0c             	sub    $0xc,%eax
+c0107c3c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(base+n == p){
+c0107c3f:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0107c42:	c1 e0 05             	shl    $0x5,%eax
+c0107c45:	89 c2                	mov    %eax,%edx
+c0107c47:	8b 45 08             	mov    0x8(%ebp),%eax
+c0107c4a:	01 d0                	add    %edx,%eax
+c0107c4c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+c0107c4f:	75 1e                	jne    c0107c6f <default_free_pages+0x153>
+        base->property+=p->property;
+c0107c51:	8b 45 08             	mov    0x8(%ebp),%eax
+c0107c54:	8b 50 08             	mov    0x8(%eax),%edx
+c0107c57:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0107c5a:	8b 40 08             	mov    0x8(%eax),%eax
+c0107c5d:	01 c2                	add    %eax,%edx
+c0107c5f:	8b 45 08             	mov    0x8(%ebp),%eax
+c0107c62:	89 50 08             	mov    %edx,0x8(%eax)
+    p->property=0;
+c0107c65:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0107c68:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
+    }
+    le=list_prev(&(base->page_link));
+c0107c6f:	8b 45 08             	mov    0x8(%ebp),%eax
+c0107c72:	83 c0 0c             	add    $0xc,%eax
+c0107c75:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+ * list_prev - get the previous entry
+ * @listelm:    the list head
+ **/
+static inline list_entry_t *
+list_prev(list_entry_t *listelm) {
+    return listelm->prev;
+c0107c78:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0107c7b:	8b 00                	mov    (%eax),%eax
+c0107c7d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    p = le2page(le, page_link);
+c0107c80:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0107c83:	83 e8 0c             	sub    $0xc,%eax
+c0107c86:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(le!=&free_list && p==base-1){
+c0107c89:	81 7d f4 64 31 1b c0 	cmpl   $0xc01b3164,-0xc(%ebp)
+c0107c90:	74 57                	je     c0107ce9 <default_free_pages+0x1cd>
+c0107c92:	8b 45 08             	mov    0x8(%ebp),%eax
+c0107c95:	83 e8 20             	sub    $0x20,%eax
+c0107c98:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+c0107c9b:	75 4c                	jne    c0107ce9 <default_free_pages+0x1cd>
+        while(le!=&free_list){
+c0107c9d:	eb 41                	jmp    c0107ce0 <default_free_pages+0x1c4>
+            if(p->property){
+c0107c9f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0107ca2:	8b 40 08             	mov    0x8(%eax),%eax
+c0107ca5:	85 c0                	test   %eax,%eax
+c0107ca7:	74 20                	je     c0107cc9 <default_free_pages+0x1ad>
+                p->property+=base->property;
+c0107ca9:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0107cac:	8b 50 08             	mov    0x8(%eax),%edx
+c0107caf:	8b 45 08             	mov    0x8(%ebp),%eax
+c0107cb2:	8b 40 08             	mov    0x8(%eax),%eax
+c0107cb5:	01 c2                	add    %eax,%edx
+c0107cb7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0107cba:	89 50 08             	mov    %edx,0x8(%eax)
+                base->property=0;
+c0107cbd:	8b 45 08             	mov    0x8(%ebp),%eax
+c0107cc0:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
+                break;
+c0107cc7:	eb 20                	jmp    c0107ce9 <default_free_pages+0x1cd>
+c0107cc9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0107ccc:	89 45 dc             	mov    %eax,-0x24(%ebp)
+c0107ccf:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0107cd2:	8b 00                	mov    (%eax),%eax
+            }
+            le = list_prev(le);
+c0107cd4:	89 45 f4             	mov    %eax,-0xc(%ebp)
+            p=le2page(le,page_link);
+c0107cd7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0107cda:	83 e8 0c             	sub    $0xc,%eax
+c0107cdd:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    p->property=0;
+    }
+    le=list_prev(&(base->page_link));
+    p = le2page(le, page_link);
+    if(le!=&free_list && p==base-1){
+        while(le!=&free_list){
+c0107ce0:	81 7d f4 64 31 1b c0 	cmpl   $0xc01b3164,-0xc(%ebp)
+c0107ce7:	75 b6                	jne    c0107c9f <default_free_pages+0x183>
+            }
+            le = list_prev(le);
+            p=le2page(le,page_link);
+        }
+    }
+    nr_free +=n;
+c0107ce9:	8b 15 6c 31 1b c0    	mov    0xc01b316c,%edx
+c0107cef:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0107cf2:	01 d0                	add    %edx,%eax
+c0107cf4:	a3 6c 31 1b c0       	mov    %eax,0xc01b316c
+    //cprintf("release %d page,last %d.\n",n,nr_free);
+}
+c0107cf9:	90                   	nop
+c0107cfa:	c9                   	leave  
+c0107cfb:	c3                   	ret    
+
+c0107cfc <default_nr_free_pages>:
+
+static size_t
+default_nr_free_pages(void) {
+c0107cfc:	55                   	push   %ebp
+c0107cfd:	89 e5                	mov    %esp,%ebp
+    return nr_free;
+c0107cff:	a1 6c 31 1b c0       	mov    0xc01b316c,%eax
+}
+c0107d04:	5d                   	pop    %ebp
+c0107d05:	c3                   	ret    
+
+c0107d06 <basic_check>:
+
+static void
+basic_check(void) {
+c0107d06:	55                   	push   %ebp
+c0107d07:	89 e5                	mov    %esp,%ebp
+c0107d09:	83 ec 38             	sub    $0x38,%esp
+    struct Page *p0, *p1, *p2;
+    p0 = p1 = p2 = NULL;
+c0107d0c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c0107d13:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0107d16:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0107d19:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0107d1c:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    assert((p0 = alloc_page()) != NULL);
+c0107d1f:	83 ec 0c             	sub    $0xc,%esp
+c0107d22:	6a 01                	push   $0x1
+c0107d24:	e8 98 ba ff ff       	call   c01037c1 <alloc_pages>
+c0107d29:	83 c4 10             	add    $0x10,%esp
+c0107d2c:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0107d2f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+c0107d33:	75 19                	jne    c0107d4e <basic_check+0x48>
+c0107d35:	68 51 d5 10 c0       	push   $0xc010d551
+c0107d3a:	68 16 d5 10 c0       	push   $0xc010d516
+c0107d3f:	68 d0 00 00 00       	push   $0xd0
+c0107d44:	68 2b d5 10 c0       	push   $0xc010d52b
+c0107d49:	e8 a7 86 ff ff       	call   c01003f5 <__panic>
+    assert((p1 = alloc_page()) != NULL);
+c0107d4e:	83 ec 0c             	sub    $0xc,%esp
+c0107d51:	6a 01                	push   $0x1
+c0107d53:	e8 69 ba ff ff       	call   c01037c1 <alloc_pages>
+c0107d58:	83 c4 10             	add    $0x10,%esp
+c0107d5b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0107d5e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c0107d62:	75 19                	jne    c0107d7d <basic_check+0x77>
+c0107d64:	68 6d d5 10 c0       	push   $0xc010d56d
+c0107d69:	68 16 d5 10 c0       	push   $0xc010d516
+c0107d6e:	68 d1 00 00 00       	push   $0xd1
+c0107d73:	68 2b d5 10 c0       	push   $0xc010d52b
+c0107d78:	e8 78 86 ff ff       	call   c01003f5 <__panic>
+    assert((p2 = alloc_page()) != NULL);
+c0107d7d:	83 ec 0c             	sub    $0xc,%esp
+c0107d80:	6a 01                	push   $0x1
+c0107d82:	e8 3a ba ff ff       	call   c01037c1 <alloc_pages>
+c0107d87:	83 c4 10             	add    $0x10,%esp
+c0107d8a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0107d8d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0107d91:	75 19                	jne    c0107dac <basic_check+0xa6>
+c0107d93:	68 89 d5 10 c0       	push   $0xc010d589
+c0107d98:	68 16 d5 10 c0       	push   $0xc010d516
+c0107d9d:	68 d2 00 00 00       	push   $0xd2
+c0107da2:	68 2b d5 10 c0       	push   $0xc010d52b
+c0107da7:	e8 49 86 ff ff       	call   c01003f5 <__panic>
+
+    assert(p0 != p1 && p0 != p2 && p1 != p2);
+c0107dac:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0107daf:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+c0107db2:	74 10                	je     c0107dc4 <basic_check+0xbe>
+c0107db4:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0107db7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+c0107dba:	74 08                	je     c0107dc4 <basic_check+0xbe>
+c0107dbc:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0107dbf:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+c0107dc2:	75 19                	jne    c0107ddd <basic_check+0xd7>
+c0107dc4:	68 a8 d5 10 c0       	push   $0xc010d5a8
+c0107dc9:	68 16 d5 10 c0       	push   $0xc010d516
+c0107dce:	68 d4 00 00 00       	push   $0xd4
+c0107dd3:	68 2b d5 10 c0       	push   $0xc010d52b
+c0107dd8:	e8 18 86 ff ff       	call   c01003f5 <__panic>
+    assert(page_ref(p0) == 0 && page_ref(p1) == 0 && page_ref(p2) == 0);
+c0107ddd:	83 ec 0c             	sub    $0xc,%esp
+c0107de0:	ff 75 ec             	pushl  -0x14(%ebp)
+c0107de3:	e8 4c fa ff ff       	call   c0107834 <page_ref>
+c0107de8:	83 c4 10             	add    $0x10,%esp
+c0107deb:	85 c0                	test   %eax,%eax
+c0107ded:	75 24                	jne    c0107e13 <basic_check+0x10d>
+c0107def:	83 ec 0c             	sub    $0xc,%esp
+c0107df2:	ff 75 f0             	pushl  -0x10(%ebp)
+c0107df5:	e8 3a fa ff ff       	call   c0107834 <page_ref>
+c0107dfa:	83 c4 10             	add    $0x10,%esp
+c0107dfd:	85 c0                	test   %eax,%eax
+c0107dff:	75 12                	jne    c0107e13 <basic_check+0x10d>
+c0107e01:	83 ec 0c             	sub    $0xc,%esp
+c0107e04:	ff 75 f4             	pushl  -0xc(%ebp)
+c0107e07:	e8 28 fa ff ff       	call   c0107834 <page_ref>
+c0107e0c:	83 c4 10             	add    $0x10,%esp
+c0107e0f:	85 c0                	test   %eax,%eax
+c0107e11:	74 19                	je     c0107e2c <basic_check+0x126>
+c0107e13:	68 cc d5 10 c0       	push   $0xc010d5cc
+c0107e18:	68 16 d5 10 c0       	push   $0xc010d516
+c0107e1d:	68 d5 00 00 00       	push   $0xd5
+c0107e22:	68 2b d5 10 c0       	push   $0xc010d52b
+c0107e27:	e8 c9 85 ff ff       	call   c01003f5 <__panic>
+
+    assert(page2pa(p0) < npage * PGSIZE);
+c0107e2c:	83 ec 0c             	sub    $0xc,%esp
+c0107e2f:	ff 75 ec             	pushl  -0x14(%ebp)
+c0107e32:	e8 ea f9 ff ff       	call   c0107821 <page2pa>
+c0107e37:	83 c4 10             	add    $0x10,%esp
+c0107e3a:	89 c2                	mov    %eax,%edx
+c0107e3c:	a1 80 0f 1b c0       	mov    0xc01b0f80,%eax
+c0107e41:	c1 e0 0c             	shl    $0xc,%eax
+c0107e44:	39 c2                	cmp    %eax,%edx
+c0107e46:	72 19                	jb     c0107e61 <basic_check+0x15b>
+c0107e48:	68 08 d6 10 c0       	push   $0xc010d608
+c0107e4d:	68 16 d5 10 c0       	push   $0xc010d516
+c0107e52:	68 d7 00 00 00       	push   $0xd7
+c0107e57:	68 2b d5 10 c0       	push   $0xc010d52b
+c0107e5c:	e8 94 85 ff ff       	call   c01003f5 <__panic>
+    assert(page2pa(p1) < npage * PGSIZE);
+c0107e61:	83 ec 0c             	sub    $0xc,%esp
+c0107e64:	ff 75 f0             	pushl  -0x10(%ebp)
+c0107e67:	e8 b5 f9 ff ff       	call   c0107821 <page2pa>
+c0107e6c:	83 c4 10             	add    $0x10,%esp
+c0107e6f:	89 c2                	mov    %eax,%edx
+c0107e71:	a1 80 0f 1b c0       	mov    0xc01b0f80,%eax
+c0107e76:	c1 e0 0c             	shl    $0xc,%eax
+c0107e79:	39 c2                	cmp    %eax,%edx
+c0107e7b:	72 19                	jb     c0107e96 <basic_check+0x190>
+c0107e7d:	68 25 d6 10 c0       	push   $0xc010d625
+c0107e82:	68 16 d5 10 c0       	push   $0xc010d516
+c0107e87:	68 d8 00 00 00       	push   $0xd8
+c0107e8c:	68 2b d5 10 c0       	push   $0xc010d52b
+c0107e91:	e8 5f 85 ff ff       	call   c01003f5 <__panic>
+    assert(page2pa(p2) < npage * PGSIZE);
+c0107e96:	83 ec 0c             	sub    $0xc,%esp
+c0107e99:	ff 75 f4             	pushl  -0xc(%ebp)
+c0107e9c:	e8 80 f9 ff ff       	call   c0107821 <page2pa>
+c0107ea1:	83 c4 10             	add    $0x10,%esp
+c0107ea4:	89 c2                	mov    %eax,%edx
+c0107ea6:	a1 80 0f 1b c0       	mov    0xc01b0f80,%eax
+c0107eab:	c1 e0 0c             	shl    $0xc,%eax
+c0107eae:	39 c2                	cmp    %eax,%edx
+c0107eb0:	72 19                	jb     c0107ecb <basic_check+0x1c5>
+c0107eb2:	68 42 d6 10 c0       	push   $0xc010d642
+c0107eb7:	68 16 d5 10 c0       	push   $0xc010d516
+c0107ebc:	68 d9 00 00 00       	push   $0xd9
+c0107ec1:	68 2b d5 10 c0       	push   $0xc010d52b
+c0107ec6:	e8 2a 85 ff ff       	call   c01003f5 <__panic>
+
+    list_entry_t free_list_store = free_list;
+c0107ecb:	a1 64 31 1b c0       	mov    0xc01b3164,%eax
+c0107ed0:	8b 15 68 31 1b c0    	mov    0xc01b3168,%edx
+c0107ed6:	89 45 d0             	mov    %eax,-0x30(%ebp)
+c0107ed9:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+c0107edc:	c7 45 e4 64 31 1b c0 	movl   $0xc01b3164,-0x1c(%ebp)
+ * list_init - initialize a new entry
+ * @elm:        new entry to be initialized
+ * */
+static inline void
+list_init(list_entry_t *elm) {
+    elm->prev = elm->next = elm;
+c0107ee3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0107ee6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c0107ee9:	89 50 04             	mov    %edx,0x4(%eax)
+c0107eec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0107eef:	8b 50 04             	mov    0x4(%eax),%edx
+c0107ef2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0107ef5:	89 10                	mov    %edx,(%eax)
+c0107ef7:	c7 45 d8 64 31 1b c0 	movl   $0xc01b3164,-0x28(%ebp)
+ * list_empty - tests whether a list is empty
+ * @list:       the list to test.
+ * */
+static inline bool
+list_empty(list_entry_t *list) {
+    return list->next == list;
+c0107efe:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c0107f01:	8b 40 04             	mov    0x4(%eax),%eax
+c0107f04:	39 45 d8             	cmp    %eax,-0x28(%ebp)
+c0107f07:	0f 94 c0             	sete   %al
+c0107f0a:	0f b6 c0             	movzbl %al,%eax
+    list_init(&free_list);
+    assert(list_empty(&free_list));
+c0107f0d:	85 c0                	test   %eax,%eax
+c0107f0f:	75 19                	jne    c0107f2a <basic_check+0x224>
+c0107f11:	68 5f d6 10 c0       	push   $0xc010d65f
+c0107f16:	68 16 d5 10 c0       	push   $0xc010d516
+c0107f1b:	68 dd 00 00 00       	push   $0xdd
+c0107f20:	68 2b d5 10 c0       	push   $0xc010d52b
+c0107f25:	e8 cb 84 ff ff       	call   c01003f5 <__panic>
+
+    unsigned int nr_free_store = nr_free;
+c0107f2a:	a1 6c 31 1b c0       	mov    0xc01b316c,%eax
+c0107f2f:	89 45 e0             	mov    %eax,-0x20(%ebp)
+    nr_free = 0;
+c0107f32:	c7 05 6c 31 1b c0 00 	movl   $0x0,0xc01b316c
+c0107f39:	00 00 00 
+
+    assert(alloc_page() == NULL);
+c0107f3c:	83 ec 0c             	sub    $0xc,%esp
+c0107f3f:	6a 01                	push   $0x1
+c0107f41:	e8 7b b8 ff ff       	call   c01037c1 <alloc_pages>
+c0107f46:	83 c4 10             	add    $0x10,%esp
+c0107f49:	85 c0                	test   %eax,%eax
+c0107f4b:	74 19                	je     c0107f66 <basic_check+0x260>
+c0107f4d:	68 76 d6 10 c0       	push   $0xc010d676
+c0107f52:	68 16 d5 10 c0       	push   $0xc010d516
+c0107f57:	68 e2 00 00 00       	push   $0xe2
+c0107f5c:	68 2b d5 10 c0       	push   $0xc010d52b
+c0107f61:	e8 8f 84 ff ff       	call   c01003f5 <__panic>
+
+    free_page(p0);
+c0107f66:	83 ec 08             	sub    $0x8,%esp
+c0107f69:	6a 01                	push   $0x1
+c0107f6b:	ff 75 ec             	pushl  -0x14(%ebp)
+c0107f6e:	e8 ba b8 ff ff       	call   c010382d <free_pages>
+c0107f73:	83 c4 10             	add    $0x10,%esp
+    free_page(p1);
+c0107f76:	83 ec 08             	sub    $0x8,%esp
+c0107f79:	6a 01                	push   $0x1
+c0107f7b:	ff 75 f0             	pushl  -0x10(%ebp)
+c0107f7e:	e8 aa b8 ff ff       	call   c010382d <free_pages>
+c0107f83:	83 c4 10             	add    $0x10,%esp
+    free_page(p2);
+c0107f86:	83 ec 08             	sub    $0x8,%esp
+c0107f89:	6a 01                	push   $0x1
+c0107f8b:	ff 75 f4             	pushl  -0xc(%ebp)
+c0107f8e:	e8 9a b8 ff ff       	call   c010382d <free_pages>
+c0107f93:	83 c4 10             	add    $0x10,%esp
+    assert(nr_free == 3);
+c0107f96:	a1 6c 31 1b c0       	mov    0xc01b316c,%eax
+c0107f9b:	83 f8 03             	cmp    $0x3,%eax
+c0107f9e:	74 19                	je     c0107fb9 <basic_check+0x2b3>
+c0107fa0:	68 8b d6 10 c0       	push   $0xc010d68b
+c0107fa5:	68 16 d5 10 c0       	push   $0xc010d516
+c0107faa:	68 e7 00 00 00       	push   $0xe7
+c0107faf:	68 2b d5 10 c0       	push   $0xc010d52b
+c0107fb4:	e8 3c 84 ff ff       	call   c01003f5 <__panic>
+
+    assert((p0 = alloc_page()) != NULL);
+c0107fb9:	83 ec 0c             	sub    $0xc,%esp
+c0107fbc:	6a 01                	push   $0x1
+c0107fbe:	e8 fe b7 ff ff       	call   c01037c1 <alloc_pages>
+c0107fc3:	83 c4 10             	add    $0x10,%esp
+c0107fc6:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0107fc9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+c0107fcd:	75 19                	jne    c0107fe8 <basic_check+0x2e2>
+c0107fcf:	68 51 d5 10 c0       	push   $0xc010d551
+c0107fd4:	68 16 d5 10 c0       	push   $0xc010d516
+c0107fd9:	68 e9 00 00 00       	push   $0xe9
+c0107fde:	68 2b d5 10 c0       	push   $0xc010d52b
+c0107fe3:	e8 0d 84 ff ff       	call   c01003f5 <__panic>
+    assert((p1 = alloc_page()) != NULL);
+c0107fe8:	83 ec 0c             	sub    $0xc,%esp
+c0107feb:	6a 01                	push   $0x1
+c0107fed:	e8 cf b7 ff ff       	call   c01037c1 <alloc_pages>
+c0107ff2:	83 c4 10             	add    $0x10,%esp
+c0107ff5:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0107ff8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c0107ffc:	75 19                	jne    c0108017 <basic_check+0x311>
+c0107ffe:	68 6d d5 10 c0       	push   $0xc010d56d
+c0108003:	68 16 d5 10 c0       	push   $0xc010d516
+c0108008:	68 ea 00 00 00       	push   $0xea
+c010800d:	68 2b d5 10 c0       	push   $0xc010d52b
+c0108012:	e8 de 83 ff ff       	call   c01003f5 <__panic>
+    assert((p2 = alloc_page()) != NULL);
+c0108017:	83 ec 0c             	sub    $0xc,%esp
+c010801a:	6a 01                	push   $0x1
+c010801c:	e8 a0 b7 ff ff       	call   c01037c1 <alloc_pages>
+c0108021:	83 c4 10             	add    $0x10,%esp
+c0108024:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0108027:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c010802b:	75 19                	jne    c0108046 <basic_check+0x340>
+c010802d:	68 89 d5 10 c0       	push   $0xc010d589
+c0108032:	68 16 d5 10 c0       	push   $0xc010d516
+c0108037:	68 eb 00 00 00       	push   $0xeb
+c010803c:	68 2b d5 10 c0       	push   $0xc010d52b
+c0108041:	e8 af 83 ff ff       	call   c01003f5 <__panic>
+
+    assert(alloc_page() == NULL);
+c0108046:	83 ec 0c             	sub    $0xc,%esp
+c0108049:	6a 01                	push   $0x1
+c010804b:	e8 71 b7 ff ff       	call   c01037c1 <alloc_pages>
+c0108050:	83 c4 10             	add    $0x10,%esp
+c0108053:	85 c0                	test   %eax,%eax
+c0108055:	74 19                	je     c0108070 <basic_check+0x36a>
+c0108057:	68 76 d6 10 c0       	push   $0xc010d676
+c010805c:	68 16 d5 10 c0       	push   $0xc010d516
+c0108061:	68 ed 00 00 00       	push   $0xed
+c0108066:	68 2b d5 10 c0       	push   $0xc010d52b
+c010806b:	e8 85 83 ff ff       	call   c01003f5 <__panic>
+
+    free_page(p0);
+c0108070:	83 ec 08             	sub    $0x8,%esp
+c0108073:	6a 01                	push   $0x1
+c0108075:	ff 75 ec             	pushl  -0x14(%ebp)
+c0108078:	e8 b0 b7 ff ff       	call   c010382d <free_pages>
+c010807d:	83 c4 10             	add    $0x10,%esp
+c0108080:	c7 45 e8 64 31 1b c0 	movl   $0xc01b3164,-0x18(%ebp)
+c0108087:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010808a:	8b 40 04             	mov    0x4(%eax),%eax
+c010808d:	39 45 e8             	cmp    %eax,-0x18(%ebp)
+c0108090:	0f 94 c0             	sete   %al
+c0108093:	0f b6 c0             	movzbl %al,%eax
+    assert(!list_empty(&free_list));
+c0108096:	85 c0                	test   %eax,%eax
+c0108098:	74 19                	je     c01080b3 <basic_check+0x3ad>
+c010809a:	68 98 d6 10 c0       	push   $0xc010d698
+c010809f:	68 16 d5 10 c0       	push   $0xc010d516
+c01080a4:	68 f0 00 00 00       	push   $0xf0
+c01080a9:	68 2b d5 10 c0       	push   $0xc010d52b
+c01080ae:	e8 42 83 ff ff       	call   c01003f5 <__panic>
+
+    struct Page *p;
+    assert((p = alloc_page()) == p0);
+c01080b3:	83 ec 0c             	sub    $0xc,%esp
+c01080b6:	6a 01                	push   $0x1
+c01080b8:	e8 04 b7 ff ff       	call   c01037c1 <alloc_pages>
+c01080bd:	83 c4 10             	add    $0x10,%esp
+c01080c0:	89 45 dc             	mov    %eax,-0x24(%ebp)
+c01080c3:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c01080c6:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+c01080c9:	74 19                	je     c01080e4 <basic_check+0x3de>
+c01080cb:	68 b0 d6 10 c0       	push   $0xc010d6b0
+c01080d0:	68 16 d5 10 c0       	push   $0xc010d516
+c01080d5:	68 f3 00 00 00       	push   $0xf3
+c01080da:	68 2b d5 10 c0       	push   $0xc010d52b
+c01080df:	e8 11 83 ff ff       	call   c01003f5 <__panic>
+    assert(alloc_page() == NULL);
+c01080e4:	83 ec 0c             	sub    $0xc,%esp
+c01080e7:	6a 01                	push   $0x1
+c01080e9:	e8 d3 b6 ff ff       	call   c01037c1 <alloc_pages>
+c01080ee:	83 c4 10             	add    $0x10,%esp
+c01080f1:	85 c0                	test   %eax,%eax
+c01080f3:	74 19                	je     c010810e <basic_check+0x408>
+c01080f5:	68 76 d6 10 c0       	push   $0xc010d676
+c01080fa:	68 16 d5 10 c0       	push   $0xc010d516
+c01080ff:	68 f4 00 00 00       	push   $0xf4
+c0108104:	68 2b d5 10 c0       	push   $0xc010d52b
+c0108109:	e8 e7 82 ff ff       	call   c01003f5 <__panic>
+
+    assert(nr_free == 0);
+c010810e:	a1 6c 31 1b c0       	mov    0xc01b316c,%eax
+c0108113:	85 c0                	test   %eax,%eax
+c0108115:	74 19                	je     c0108130 <basic_check+0x42a>
+c0108117:	68 c9 d6 10 c0       	push   $0xc010d6c9
+c010811c:	68 16 d5 10 c0       	push   $0xc010d516
+c0108121:	68 f6 00 00 00       	push   $0xf6
+c0108126:	68 2b d5 10 c0       	push   $0xc010d52b
+c010812b:	e8 c5 82 ff ff       	call   c01003f5 <__panic>
+    free_list = free_list_store;
+c0108130:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c0108133:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c0108136:	a3 64 31 1b c0       	mov    %eax,0xc01b3164
+c010813b:	89 15 68 31 1b c0    	mov    %edx,0xc01b3168
+    nr_free = nr_free_store;
+c0108141:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0108144:	a3 6c 31 1b c0       	mov    %eax,0xc01b316c
+
+    free_page(p);
+c0108149:	83 ec 08             	sub    $0x8,%esp
+c010814c:	6a 01                	push   $0x1
+c010814e:	ff 75 dc             	pushl  -0x24(%ebp)
+c0108151:	e8 d7 b6 ff ff       	call   c010382d <free_pages>
+c0108156:	83 c4 10             	add    $0x10,%esp
+    free_page(p1);
+c0108159:	83 ec 08             	sub    $0x8,%esp
+c010815c:	6a 01                	push   $0x1
+c010815e:	ff 75 f0             	pushl  -0x10(%ebp)
+c0108161:	e8 c7 b6 ff ff       	call   c010382d <free_pages>
+c0108166:	83 c4 10             	add    $0x10,%esp
+    free_page(p2);
+c0108169:	83 ec 08             	sub    $0x8,%esp
+c010816c:	6a 01                	push   $0x1
+c010816e:	ff 75 f4             	pushl  -0xc(%ebp)
+c0108171:	e8 b7 b6 ff ff       	call   c010382d <free_pages>
+c0108176:	83 c4 10             	add    $0x10,%esp
+}
+c0108179:	90                   	nop
+c010817a:	c9                   	leave  
+c010817b:	c3                   	ret    
+
+c010817c <default_check>:
+
+// LAB2: below code is used to check the first fit allocation algorithm (your EXERCISE 1) 
+// NOTICE: You SHOULD NOT CHANGE basic_check, default_check functions!
+static void
+default_check(void) {
+c010817c:	55                   	push   %ebp
+c010817d:	89 e5                	mov    %esp,%ebp
+c010817f:	81 ec 88 00 00 00    	sub    $0x88,%esp
+    int count = 0, total = 0;
+c0108185:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c010818c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    list_entry_t *le = &free_list;
+c0108193:	c7 45 ec 64 31 1b c0 	movl   $0xc01b3164,-0x14(%ebp)
+    while ((le = list_next(le)) != &free_list) {
+c010819a:	eb 60                	jmp    c01081fc <default_check+0x80>
+        struct Page *p = le2page(le, page_link);
+c010819c:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010819f:	83 e8 0c             	sub    $0xc,%eax
+c01081a2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+        assert(PageProperty(p));
+c01081a5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01081a8:	83 c0 04             	add    $0x4,%eax
+c01081ab:	c7 45 b0 01 00 00 00 	movl   $0x1,-0x50(%ebp)
+c01081b2:	89 45 ac             	mov    %eax,-0x54(%ebp)
+ * @addr:   the address to count from
+ * */
+static inline bool
+test_bit(int nr, volatile void *addr) {
+    int oldbit;
+    asm volatile ("btl %2, %1; sbbl %0,%0" : "=r" (oldbit) : "m" (*(volatile long *)addr), "Ir" (nr));
+c01081b5:	8b 45 ac             	mov    -0x54(%ebp),%eax
+c01081b8:	8b 55 b0             	mov    -0x50(%ebp),%edx
+c01081bb:	0f a3 10             	bt     %edx,(%eax)
+c01081be:	19 c0                	sbb    %eax,%eax
+c01081c0:	89 45 a8             	mov    %eax,-0x58(%ebp)
+    return oldbit != 0;
+c01081c3:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
+c01081c7:	0f 95 c0             	setne  %al
+c01081ca:	0f b6 c0             	movzbl %al,%eax
+c01081cd:	85 c0                	test   %eax,%eax
+c01081cf:	75 19                	jne    c01081ea <default_check+0x6e>
+c01081d1:	68 d6 d6 10 c0       	push   $0xc010d6d6
+c01081d6:	68 16 d5 10 c0       	push   $0xc010d516
+c01081db:	68 07 01 00 00       	push   $0x107
+c01081e0:	68 2b d5 10 c0       	push   $0xc010d52b
+c01081e5:	e8 0b 82 ff ff       	call   c01003f5 <__panic>
+        count ++, total += p->property;
+c01081ea:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+c01081ee:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01081f1:	8b 50 08             	mov    0x8(%eax),%edx
+c01081f4:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01081f7:	01 d0                	add    %edx,%eax
+c01081f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c01081fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01081ff:	89 45 e0             	mov    %eax,-0x20(%ebp)
+ * list_next - get the next entry
+ * @listelm:    the list head
+ **/
+static inline list_entry_t *
+list_next(list_entry_t *listelm) {
+    return listelm->next;
+c0108202:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0108205:	8b 40 04             	mov    0x4(%eax),%eax
+// NOTICE: You SHOULD NOT CHANGE basic_check, default_check functions!
+static void
+default_check(void) {
+    int count = 0, total = 0;
+    list_entry_t *le = &free_list;
+    while ((le = list_next(le)) != &free_list) {
+c0108208:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c010820b:	81 7d ec 64 31 1b c0 	cmpl   $0xc01b3164,-0x14(%ebp)
+c0108212:	75 88                	jne    c010819c <default_check+0x20>
+        struct Page *p = le2page(le, page_link);
+        assert(PageProperty(p));
+        count ++, total += p->property;
+    }
+    assert(total == nr_free_pages());
+c0108214:	e8 49 b6 ff ff       	call   c0103862 <nr_free_pages>
+c0108219:	89 c2                	mov    %eax,%edx
+c010821b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010821e:	39 c2                	cmp    %eax,%edx
+c0108220:	74 19                	je     c010823b <default_check+0xbf>
+c0108222:	68 e6 d6 10 c0       	push   $0xc010d6e6
+c0108227:	68 16 d5 10 c0       	push   $0xc010d516
+c010822c:	68 0a 01 00 00       	push   $0x10a
+c0108231:	68 2b d5 10 c0       	push   $0xc010d52b
+c0108236:	e8 ba 81 ff ff       	call   c01003f5 <__panic>
+
+    basic_check();
+c010823b:	e8 c6 fa ff ff       	call   c0107d06 <basic_check>
+
+    struct Page *p0 = alloc_pages(5), *p1, *p2;
+c0108240:	83 ec 0c             	sub    $0xc,%esp
+c0108243:	6a 05                	push   $0x5
+c0108245:	e8 77 b5 ff ff       	call   c01037c1 <alloc_pages>
+c010824a:	83 c4 10             	add    $0x10,%esp
+c010824d:	89 45 dc             	mov    %eax,-0x24(%ebp)
+    assert(p0 != NULL);
+c0108250:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+c0108254:	75 19                	jne    c010826f <default_check+0xf3>
+c0108256:	68 ff d6 10 c0       	push   $0xc010d6ff
+c010825b:	68 16 d5 10 c0       	push   $0xc010d516
+c0108260:	68 0f 01 00 00       	push   $0x10f
+c0108265:	68 2b d5 10 c0       	push   $0xc010d52b
+c010826a:	e8 86 81 ff ff       	call   c01003f5 <__panic>
+    assert(!PageProperty(p0));
+c010826f:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0108272:	83 c0 04             	add    $0x4,%eax
+c0108275:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
+c010827c:	89 45 a4             	mov    %eax,-0x5c(%ebp)
+ * @addr:   the address to count from
+ * */
+static inline bool
+test_bit(int nr, volatile void *addr) {
+    int oldbit;
+    asm volatile ("btl %2, %1; sbbl %0,%0" : "=r" (oldbit) : "m" (*(volatile long *)addr), "Ir" (nr));
+c010827f:	8b 45 a4             	mov    -0x5c(%ebp),%eax
+c0108282:	8b 55 e8             	mov    -0x18(%ebp),%edx
+c0108285:	0f a3 10             	bt     %edx,(%eax)
+c0108288:	19 c0                	sbb    %eax,%eax
+c010828a:	89 45 a0             	mov    %eax,-0x60(%ebp)
+    return oldbit != 0;
+c010828d:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
+c0108291:	0f 95 c0             	setne  %al
+c0108294:	0f b6 c0             	movzbl %al,%eax
+c0108297:	85 c0                	test   %eax,%eax
+c0108299:	74 19                	je     c01082b4 <default_check+0x138>
+c010829b:	68 0a d7 10 c0       	push   $0xc010d70a
+c01082a0:	68 16 d5 10 c0       	push   $0xc010d516
+c01082a5:	68 10 01 00 00       	push   $0x110
+c01082aa:	68 2b d5 10 c0       	push   $0xc010d52b
+c01082af:	e8 41 81 ff ff       	call   c01003f5 <__panic>
+
+    list_entry_t free_list_store = free_list;
+c01082b4:	a1 64 31 1b c0       	mov    0xc01b3164,%eax
+c01082b9:	8b 15 68 31 1b c0    	mov    0xc01b3168,%edx
+c01082bf:	89 45 80             	mov    %eax,-0x80(%ebp)
+c01082c2:	89 55 84             	mov    %edx,-0x7c(%ebp)
+c01082c5:	c7 45 d0 64 31 1b c0 	movl   $0xc01b3164,-0x30(%ebp)
+ * list_init - initialize a new entry
+ * @elm:        new entry to be initialized
+ * */
+static inline void
+list_init(list_entry_t *elm) {
+    elm->prev = elm->next = elm;
+c01082cc:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c01082cf:	8b 55 d0             	mov    -0x30(%ebp),%edx
+c01082d2:	89 50 04             	mov    %edx,0x4(%eax)
+c01082d5:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c01082d8:	8b 50 04             	mov    0x4(%eax),%edx
+c01082db:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c01082de:	89 10                	mov    %edx,(%eax)
+c01082e0:	c7 45 d8 64 31 1b c0 	movl   $0xc01b3164,-0x28(%ebp)
+ * list_empty - tests whether a list is empty
+ * @list:       the list to test.
+ * */
+static inline bool
+list_empty(list_entry_t *list) {
+    return list->next == list;
+c01082e7:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c01082ea:	8b 40 04             	mov    0x4(%eax),%eax
+c01082ed:	39 45 d8             	cmp    %eax,-0x28(%ebp)
+c01082f0:	0f 94 c0             	sete   %al
+c01082f3:	0f b6 c0             	movzbl %al,%eax
+    list_init(&free_list);
+    assert(list_empty(&free_list));
+c01082f6:	85 c0                	test   %eax,%eax
+c01082f8:	75 19                	jne    c0108313 <default_check+0x197>
+c01082fa:	68 5f d6 10 c0       	push   $0xc010d65f
+c01082ff:	68 16 d5 10 c0       	push   $0xc010d516
+c0108304:	68 14 01 00 00       	push   $0x114
+c0108309:	68 2b d5 10 c0       	push   $0xc010d52b
+c010830e:	e8 e2 80 ff ff       	call   c01003f5 <__panic>
+    assert(alloc_page() == NULL);
+c0108313:	83 ec 0c             	sub    $0xc,%esp
+c0108316:	6a 01                	push   $0x1
+c0108318:	e8 a4 b4 ff ff       	call   c01037c1 <alloc_pages>
+c010831d:	83 c4 10             	add    $0x10,%esp
+c0108320:	85 c0                	test   %eax,%eax
+c0108322:	74 19                	je     c010833d <default_check+0x1c1>
+c0108324:	68 76 d6 10 c0       	push   $0xc010d676
+c0108329:	68 16 d5 10 c0       	push   $0xc010d516
+c010832e:	68 15 01 00 00       	push   $0x115
+c0108333:	68 2b d5 10 c0       	push   $0xc010d52b
+c0108338:	e8 b8 80 ff ff       	call   c01003f5 <__panic>
+
+    unsigned int nr_free_store = nr_free;
+c010833d:	a1 6c 31 1b c0       	mov    0xc01b316c,%eax
+c0108342:	89 45 cc             	mov    %eax,-0x34(%ebp)
+    nr_free = 0;
+c0108345:	c7 05 6c 31 1b c0 00 	movl   $0x0,0xc01b316c
+c010834c:	00 00 00 
+
+    free_pages(p0 + 2, 3);
+c010834f:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0108352:	83 c0 40             	add    $0x40,%eax
+c0108355:	83 ec 08             	sub    $0x8,%esp
+c0108358:	6a 03                	push   $0x3
+c010835a:	50                   	push   %eax
+c010835b:	e8 cd b4 ff ff       	call   c010382d <free_pages>
+c0108360:	83 c4 10             	add    $0x10,%esp
+    assert(alloc_pages(4) == NULL);
+c0108363:	83 ec 0c             	sub    $0xc,%esp
+c0108366:	6a 04                	push   $0x4
+c0108368:	e8 54 b4 ff ff       	call   c01037c1 <alloc_pages>
+c010836d:	83 c4 10             	add    $0x10,%esp
+c0108370:	85 c0                	test   %eax,%eax
+c0108372:	74 19                	je     c010838d <default_check+0x211>
+c0108374:	68 1c d7 10 c0       	push   $0xc010d71c
+c0108379:	68 16 d5 10 c0       	push   $0xc010d516
+c010837e:	68 1b 01 00 00       	push   $0x11b
+c0108383:	68 2b d5 10 c0       	push   $0xc010d52b
+c0108388:	e8 68 80 ff ff       	call   c01003f5 <__panic>
+    assert(PageProperty(p0 + 2) && p0[2].property == 3);
+c010838d:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0108390:	83 c0 40             	add    $0x40,%eax
+c0108393:	83 c0 04             	add    $0x4,%eax
+c0108396:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
+c010839d:	89 45 9c             	mov    %eax,-0x64(%ebp)
+ * @addr:   the address to count from
+ * */
+static inline bool
+test_bit(int nr, volatile void *addr) {
+    int oldbit;
+    asm volatile ("btl %2, %1; sbbl %0,%0" : "=r" (oldbit) : "m" (*(volatile long *)addr), "Ir" (nr));
+c01083a0:	8b 45 9c             	mov    -0x64(%ebp),%eax
+c01083a3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c01083a6:	0f a3 10             	bt     %edx,(%eax)
+c01083a9:	19 c0                	sbb    %eax,%eax
+c01083ab:	89 45 98             	mov    %eax,-0x68(%ebp)
+    return oldbit != 0;
+c01083ae:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
+c01083b2:	0f 95 c0             	setne  %al
+c01083b5:	0f b6 c0             	movzbl %al,%eax
+c01083b8:	85 c0                	test   %eax,%eax
+c01083ba:	74 0e                	je     c01083ca <default_check+0x24e>
+c01083bc:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c01083bf:	83 c0 40             	add    $0x40,%eax
+c01083c2:	8b 40 08             	mov    0x8(%eax),%eax
+c01083c5:	83 f8 03             	cmp    $0x3,%eax
+c01083c8:	74 19                	je     c01083e3 <default_check+0x267>
+c01083ca:	68 34 d7 10 c0       	push   $0xc010d734
+c01083cf:	68 16 d5 10 c0       	push   $0xc010d516
+c01083d4:	68 1c 01 00 00       	push   $0x11c
+c01083d9:	68 2b d5 10 c0       	push   $0xc010d52b
+c01083de:	e8 12 80 ff ff       	call   c01003f5 <__panic>
+    assert((p1 = alloc_pages(3)) != NULL);
+c01083e3:	83 ec 0c             	sub    $0xc,%esp
+c01083e6:	6a 03                	push   $0x3
+c01083e8:	e8 d4 b3 ff ff       	call   c01037c1 <alloc_pages>
+c01083ed:	83 c4 10             	add    $0x10,%esp
+c01083f0:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+c01083f3:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
+c01083f7:	75 19                	jne    c0108412 <default_check+0x296>
+c01083f9:	68 60 d7 10 c0       	push   $0xc010d760
+c01083fe:	68 16 d5 10 c0       	push   $0xc010d516
+c0108403:	68 1d 01 00 00       	push   $0x11d
+c0108408:	68 2b d5 10 c0       	push   $0xc010d52b
+c010840d:	e8 e3 7f ff ff       	call   c01003f5 <__panic>
+    assert(alloc_page() == NULL);
+c0108412:	83 ec 0c             	sub    $0xc,%esp
+c0108415:	6a 01                	push   $0x1
+c0108417:	e8 a5 b3 ff ff       	call   c01037c1 <alloc_pages>
+c010841c:	83 c4 10             	add    $0x10,%esp
+c010841f:	85 c0                	test   %eax,%eax
+c0108421:	74 19                	je     c010843c <default_check+0x2c0>
+c0108423:	68 76 d6 10 c0       	push   $0xc010d676
+c0108428:	68 16 d5 10 c0       	push   $0xc010d516
+c010842d:	68 1e 01 00 00       	push   $0x11e
+c0108432:	68 2b d5 10 c0       	push   $0xc010d52b
+c0108437:	e8 b9 7f ff ff       	call   c01003f5 <__panic>
+    assert(p0 + 2 == p1);
+c010843c:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c010843f:	83 c0 40             	add    $0x40,%eax
+c0108442:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
+c0108445:	74 19                	je     c0108460 <default_check+0x2e4>
+c0108447:	68 7e d7 10 c0       	push   $0xc010d77e
+c010844c:	68 16 d5 10 c0       	push   $0xc010d516
+c0108451:	68 1f 01 00 00       	push   $0x11f
+c0108456:	68 2b d5 10 c0       	push   $0xc010d52b
+c010845b:	e8 95 7f ff ff       	call   c01003f5 <__panic>
+
+    p2 = p0 + 1;
+c0108460:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0108463:	83 c0 20             	add    $0x20,%eax
+c0108466:	89 45 c0             	mov    %eax,-0x40(%ebp)
+    free_page(p0);
+c0108469:	83 ec 08             	sub    $0x8,%esp
+c010846c:	6a 01                	push   $0x1
+c010846e:	ff 75 dc             	pushl  -0x24(%ebp)
+c0108471:	e8 b7 b3 ff ff       	call   c010382d <free_pages>
+c0108476:	83 c4 10             	add    $0x10,%esp
+    free_pages(p1, 3);
+c0108479:	83 ec 08             	sub    $0x8,%esp
+c010847c:	6a 03                	push   $0x3
+c010847e:	ff 75 c4             	pushl  -0x3c(%ebp)
+c0108481:	e8 a7 b3 ff ff       	call   c010382d <free_pages>
+c0108486:	83 c4 10             	add    $0x10,%esp
+    assert(PageProperty(p0) && p0->property == 1);
+c0108489:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c010848c:	83 c0 04             	add    $0x4,%eax
+c010848f:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
+c0108496:	89 45 94             	mov    %eax,-0x6c(%ebp)
+ * @addr:   the address to count from
+ * */
+static inline bool
+test_bit(int nr, volatile void *addr) {
+    int oldbit;
+    asm volatile ("btl %2, %1; sbbl %0,%0" : "=r" (oldbit) : "m" (*(volatile long *)addr), "Ir" (nr));
+c0108499:	8b 45 94             	mov    -0x6c(%ebp),%eax
+c010849c:	8b 55 c8             	mov    -0x38(%ebp),%edx
+c010849f:	0f a3 10             	bt     %edx,(%eax)
+c01084a2:	19 c0                	sbb    %eax,%eax
+c01084a4:	89 45 90             	mov    %eax,-0x70(%ebp)
+    return oldbit != 0;
+c01084a7:	83 7d 90 00          	cmpl   $0x0,-0x70(%ebp)
+c01084ab:	0f 95 c0             	setne  %al
+c01084ae:	0f b6 c0             	movzbl %al,%eax
+c01084b1:	85 c0                	test   %eax,%eax
+c01084b3:	74 0b                	je     c01084c0 <default_check+0x344>
+c01084b5:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c01084b8:	8b 40 08             	mov    0x8(%eax),%eax
+c01084bb:	83 f8 01             	cmp    $0x1,%eax
+c01084be:	74 19                	je     c01084d9 <default_check+0x35d>
+c01084c0:	68 8c d7 10 c0       	push   $0xc010d78c
+c01084c5:	68 16 d5 10 c0       	push   $0xc010d516
+c01084ca:	68 24 01 00 00       	push   $0x124
+c01084cf:	68 2b d5 10 c0       	push   $0xc010d52b
+c01084d4:	e8 1c 7f ff ff       	call   c01003f5 <__panic>
+    assert(PageProperty(p1) && p1->property == 3);
+c01084d9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+c01084dc:	83 c0 04             	add    $0x4,%eax
+c01084df:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
+c01084e6:	89 45 8c             	mov    %eax,-0x74(%ebp)
+ * @addr:   the address to count from
+ * */
+static inline bool
+test_bit(int nr, volatile void *addr) {
+    int oldbit;
+    asm volatile ("btl %2, %1; sbbl %0,%0" : "=r" (oldbit) : "m" (*(volatile long *)addr), "Ir" (nr));
+c01084e9:	8b 45 8c             	mov    -0x74(%ebp),%eax
+c01084ec:	8b 55 bc             	mov    -0x44(%ebp),%edx
+c01084ef:	0f a3 10             	bt     %edx,(%eax)
+c01084f2:	19 c0                	sbb    %eax,%eax
+c01084f4:	89 45 88             	mov    %eax,-0x78(%ebp)
+    return oldbit != 0;
+c01084f7:	83 7d 88 00          	cmpl   $0x0,-0x78(%ebp)
+c01084fb:	0f 95 c0             	setne  %al
+c01084fe:	0f b6 c0             	movzbl %al,%eax
+c0108501:	85 c0                	test   %eax,%eax
+c0108503:	74 0b                	je     c0108510 <default_check+0x394>
+c0108505:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+c0108508:	8b 40 08             	mov    0x8(%eax),%eax
+c010850b:	83 f8 03             	cmp    $0x3,%eax
+c010850e:	74 19                	je     c0108529 <default_check+0x3ad>
+c0108510:	68 b4 d7 10 c0       	push   $0xc010d7b4
+c0108515:	68 16 d5 10 c0       	push   $0xc010d516
+c010851a:	68 25 01 00 00       	push   $0x125
+c010851f:	68 2b d5 10 c0       	push   $0xc010d52b
+c0108524:	e8 cc 7e ff ff       	call   c01003f5 <__panic>
+
+    assert((p0 = alloc_page()) == p2 - 1);
+c0108529:	83 ec 0c             	sub    $0xc,%esp
+c010852c:	6a 01                	push   $0x1
+c010852e:	e8 8e b2 ff ff       	call   c01037c1 <alloc_pages>
+c0108533:	83 c4 10             	add    $0x10,%esp
+c0108536:	89 45 dc             	mov    %eax,-0x24(%ebp)
+c0108539:	8b 45 c0             	mov    -0x40(%ebp),%eax
+c010853c:	83 e8 20             	sub    $0x20,%eax
+c010853f:	39 45 dc             	cmp    %eax,-0x24(%ebp)
+c0108542:	74 19                	je     c010855d <default_check+0x3e1>
+c0108544:	68 da d7 10 c0       	push   $0xc010d7da
+c0108549:	68 16 d5 10 c0       	push   $0xc010d516
+c010854e:	68 27 01 00 00       	push   $0x127
+c0108553:	68 2b d5 10 c0       	push   $0xc010d52b
+c0108558:	e8 98 7e ff ff       	call   c01003f5 <__panic>
+    free_page(p0);
+c010855d:	83 ec 08             	sub    $0x8,%esp
+c0108560:	6a 01                	push   $0x1
+c0108562:	ff 75 dc             	pushl  -0x24(%ebp)
+c0108565:	e8 c3 b2 ff ff       	call   c010382d <free_pages>
+c010856a:	83 c4 10             	add    $0x10,%esp
+    assert((p0 = alloc_pages(2)) == p2 + 1);
+c010856d:	83 ec 0c             	sub    $0xc,%esp
+c0108570:	6a 02                	push   $0x2
+c0108572:	e8 4a b2 ff ff       	call   c01037c1 <alloc_pages>
+c0108577:	83 c4 10             	add    $0x10,%esp
+c010857a:	89 45 dc             	mov    %eax,-0x24(%ebp)
+c010857d:	8b 45 c0             	mov    -0x40(%ebp),%eax
+c0108580:	83 c0 20             	add    $0x20,%eax
+c0108583:	39 45 dc             	cmp    %eax,-0x24(%ebp)
+c0108586:	74 19                	je     c01085a1 <default_check+0x425>
+c0108588:	68 f8 d7 10 c0       	push   $0xc010d7f8
+c010858d:	68 16 d5 10 c0       	push   $0xc010d516
+c0108592:	68 29 01 00 00       	push   $0x129
+c0108597:	68 2b d5 10 c0       	push   $0xc010d52b
+c010859c:	e8 54 7e ff ff       	call   c01003f5 <__panic>
+
+    free_pages(p0, 2);
+c01085a1:	83 ec 08             	sub    $0x8,%esp
+c01085a4:	6a 02                	push   $0x2
+c01085a6:	ff 75 dc             	pushl  -0x24(%ebp)
+c01085a9:	e8 7f b2 ff ff       	call   c010382d <free_pages>
+c01085ae:	83 c4 10             	add    $0x10,%esp
+    free_page(p2);
+c01085b1:	83 ec 08             	sub    $0x8,%esp
+c01085b4:	6a 01                	push   $0x1
+c01085b6:	ff 75 c0             	pushl  -0x40(%ebp)
+c01085b9:	e8 6f b2 ff ff       	call   c010382d <free_pages>
+c01085be:	83 c4 10             	add    $0x10,%esp
+
+    assert((p0 = alloc_pages(5)) != NULL);
+c01085c1:	83 ec 0c             	sub    $0xc,%esp
+c01085c4:	6a 05                	push   $0x5
+c01085c6:	e8 f6 b1 ff ff       	call   c01037c1 <alloc_pages>
+c01085cb:	83 c4 10             	add    $0x10,%esp
+c01085ce:	89 45 dc             	mov    %eax,-0x24(%ebp)
+c01085d1:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+c01085d5:	75 19                	jne    c01085f0 <default_check+0x474>
+c01085d7:	68 18 d8 10 c0       	push   $0xc010d818
+c01085dc:	68 16 d5 10 c0       	push   $0xc010d516
+c01085e1:	68 2e 01 00 00       	push   $0x12e
+c01085e6:	68 2b d5 10 c0       	push   $0xc010d52b
+c01085eb:	e8 05 7e ff ff       	call   c01003f5 <__panic>
+    assert(alloc_page() == NULL);
+c01085f0:	83 ec 0c             	sub    $0xc,%esp
+c01085f3:	6a 01                	push   $0x1
+c01085f5:	e8 c7 b1 ff ff       	call   c01037c1 <alloc_pages>
+c01085fa:	83 c4 10             	add    $0x10,%esp
+c01085fd:	85 c0                	test   %eax,%eax
+c01085ff:	74 19                	je     c010861a <default_check+0x49e>
+c0108601:	68 76 d6 10 c0       	push   $0xc010d676
+c0108606:	68 16 d5 10 c0       	push   $0xc010d516
+c010860b:	68 2f 01 00 00       	push   $0x12f
+c0108610:	68 2b d5 10 c0       	push   $0xc010d52b
+c0108615:	e8 db 7d ff ff       	call   c01003f5 <__panic>
+
+    assert(nr_free == 0);
+c010861a:	a1 6c 31 1b c0       	mov    0xc01b316c,%eax
+c010861f:	85 c0                	test   %eax,%eax
+c0108621:	74 19                	je     c010863c <default_check+0x4c0>
+c0108623:	68 c9 d6 10 c0       	push   $0xc010d6c9
+c0108628:	68 16 d5 10 c0       	push   $0xc010d516
+c010862d:	68 31 01 00 00       	push   $0x131
+c0108632:	68 2b d5 10 c0       	push   $0xc010d52b
+c0108637:	e8 b9 7d ff ff       	call   c01003f5 <__panic>
+    nr_free = nr_free_store;
+c010863c:	8b 45 cc             	mov    -0x34(%ebp),%eax
+c010863f:	a3 6c 31 1b c0       	mov    %eax,0xc01b316c
+
+    free_list = free_list_store;
+c0108644:	8b 45 80             	mov    -0x80(%ebp),%eax
+c0108647:	8b 55 84             	mov    -0x7c(%ebp),%edx
+c010864a:	a3 64 31 1b c0       	mov    %eax,0xc01b3164
+c010864f:	89 15 68 31 1b c0    	mov    %edx,0xc01b3168
+    free_pages(p0, 5);
+c0108655:	83 ec 08             	sub    $0x8,%esp
+c0108658:	6a 05                	push   $0x5
+c010865a:	ff 75 dc             	pushl  -0x24(%ebp)
+c010865d:	e8 cb b1 ff ff       	call   c010382d <free_pages>
+c0108662:	83 c4 10             	add    $0x10,%esp
+
+    le = &free_list;
+c0108665:	c7 45 ec 64 31 1b c0 	movl   $0xc01b3164,-0x14(%ebp)
+    while ((le = list_next(le)) != &free_list) {
+c010866c:	eb 1d                	jmp    c010868b <default_check+0x50f>
+        struct Page *p = le2page(le, page_link);
+c010866e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0108671:	83 e8 0c             	sub    $0xc,%eax
+c0108674:	89 45 b4             	mov    %eax,-0x4c(%ebp)
+        count --, total -= p->property;
+c0108677:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+c010867b:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c010867e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
+c0108681:	8b 40 08             	mov    0x8(%eax),%eax
+c0108684:	29 c2                	sub    %eax,%edx
+c0108686:	89 d0                	mov    %edx,%eax
+c0108688:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c010868b:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010868e:	89 45 b8             	mov    %eax,-0x48(%ebp)
+ * list_next - get the next entry
+ * @listelm:    the list head
+ **/
+static inline list_entry_t *
+list_next(list_entry_t *listelm) {
+    return listelm->next;
+c0108691:	8b 45 b8             	mov    -0x48(%ebp),%eax
+c0108694:	8b 40 04             	mov    0x4(%eax),%eax
+
+    free_list = free_list_store;
+    free_pages(p0, 5);
+
+    le = &free_list;
+    while ((le = list_next(le)) != &free_list) {
+c0108697:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c010869a:	81 7d ec 64 31 1b c0 	cmpl   $0xc01b3164,-0x14(%ebp)
+c01086a1:	75 cb                	jne    c010866e <default_check+0x4f2>
+        struct Page *p = le2page(le, page_link);
+        count --, total -= p->property;
+    }
+    assert(count == 0);
+c01086a3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c01086a7:	74 19                	je     c01086c2 <default_check+0x546>
+c01086a9:	68 36 d8 10 c0       	push   $0xc010d836
+c01086ae:	68 16 d5 10 c0       	push   $0xc010d516
+c01086b3:	68 3c 01 00 00       	push   $0x13c
+c01086b8:	68 2b d5 10 c0       	push   $0xc010d52b
+c01086bd:	e8 33 7d ff ff       	call   c01003f5 <__panic>
+    assert(total == 0);
+c01086c2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c01086c6:	74 19                	je     c01086e1 <default_check+0x565>
+c01086c8:	68 41 d8 10 c0       	push   $0xc010d841
+c01086cd:	68 16 d5 10 c0       	push   $0xc010d516
+c01086d2:	68 3d 01 00 00       	push   $0x13d
+c01086d7:	68 2b d5 10 c0       	push   $0xc010d52b
+c01086dc:	e8 14 7d ff ff       	call   c01003f5 <__panic>
+}
+c01086e1:	90                   	nop
+c01086e2:	c9                   	leave  
+c01086e3:	c3                   	ret    
+
+c01086e4 <page2ppn>:
+
+extern struct Page *pages;
+extern size_t npage;
+
+static inline ppn_t
+page2ppn(struct Page *page) {
+c01086e4:	55                   	push   %ebp
+c01086e5:	89 e5                	mov    %esp,%ebp
+    return page - pages;
+c01086e7:	8b 45 08             	mov    0x8(%ebp),%eax
+c01086ea:	8b 15 84 30 1b c0    	mov    0xc01b3084,%edx
+c01086f0:	29 d0                	sub    %edx,%eax
+c01086f2:	c1 f8 05             	sar    $0x5,%eax
+}
+c01086f5:	5d                   	pop    %ebp
+c01086f6:	c3                   	ret    
+
+c01086f7 <page2pa>:
+
+static inline uintptr_t
+page2pa(struct Page *page) {
+c01086f7:	55                   	push   %ebp
+c01086f8:	89 e5                	mov    %esp,%ebp
+    return page2ppn(page) << PGSHIFT;
+c01086fa:	ff 75 08             	pushl  0x8(%ebp)
+c01086fd:	e8 e2 ff ff ff       	call   c01086e4 <page2ppn>
+c0108702:	83 c4 04             	add    $0x4,%esp
+c0108705:	c1 e0 0c             	shl    $0xc,%eax
+}
+c0108708:	c9                   	leave  
+c0108709:	c3                   	ret    
+
+c010870a <page2kva>:
+    }
+    return &pages[PPN(pa)];
+}
+
+static inline void *
+page2kva(struct Page *page) {
+c010870a:	55                   	push   %ebp
+c010870b:	89 e5                	mov    %esp,%ebp
+c010870d:	83 ec 18             	sub    $0x18,%esp
+    return KADDR(page2pa(page));
+c0108710:	ff 75 08             	pushl  0x8(%ebp)
+c0108713:	e8 df ff ff ff       	call   c01086f7 <page2pa>
+c0108718:	83 c4 04             	add    $0x4,%esp
+c010871b:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c010871e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108721:	c1 e8 0c             	shr    $0xc,%eax
+c0108724:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0108727:	a1 80 0f 1b c0       	mov    0xc01b0f80,%eax
+c010872c:	39 45 f0             	cmp    %eax,-0x10(%ebp)
+c010872f:	72 14                	jb     c0108745 <page2kva+0x3b>
+c0108731:	ff 75 f4             	pushl  -0xc(%ebp)
+c0108734:	68 7c d8 10 c0       	push   $0xc010d87c
+c0108739:	6a 65                	push   $0x65
+c010873b:	68 9f d8 10 c0       	push   $0xc010d89f
+c0108740:	e8 b0 7c ff ff       	call   c01003f5 <__panic>
+c0108745:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108748:	2d 00 00 00 40       	sub    $0x40000000,%eax
+}
+c010874d:	c9                   	leave  
+c010874e:	c3                   	ret    
+
+c010874f <swapfs_init>:
+#include <ide.h>
+#include <pmm.h>
+#include <assert.h>
+
+void
+swapfs_init(void) {
+c010874f:	55                   	push   %ebp
+c0108750:	89 e5                	mov    %esp,%ebp
+c0108752:	83 ec 08             	sub    $0x8,%esp
+    static_assert((PGSIZE % SECTSIZE) == 0);
+    if (!ide_device_valid(SWAP_DEV_NO)) {
+c0108755:	83 ec 0c             	sub    $0xc,%esp
+c0108758:	6a 01                	push   $0x1
+c010875a:	e8 6b 8a ff ff       	call   c01011ca <ide_device_valid>
+c010875f:	83 c4 10             	add    $0x10,%esp
+c0108762:	85 c0                	test   %eax,%eax
+c0108764:	75 14                	jne    c010877a <swapfs_init+0x2b>
+        panic("swap fs isn't available.\n");
+c0108766:	83 ec 04             	sub    $0x4,%esp
+c0108769:	68 ad d8 10 c0       	push   $0xc010d8ad
+c010876e:	6a 0d                	push   $0xd
+c0108770:	68 c7 d8 10 c0       	push   $0xc010d8c7
+c0108775:	e8 7b 7c ff ff       	call   c01003f5 <__panic>
+    }
+    max_swap_offset = ide_device_size(SWAP_DEV_NO) / (PGSIZE / SECTSIZE);
+c010877a:	83 ec 0c             	sub    $0xc,%esp
+c010877d:	6a 01                	push   $0x1
+c010877f:	e8 86 8a ff ff       	call   c010120a <ide_device_size>
+c0108784:	83 c4 10             	add    $0x10,%esp
+c0108787:	c1 e8 03             	shr    $0x3,%eax
+c010878a:	a3 3c 31 1b c0       	mov    %eax,0xc01b313c
+}
+c010878f:	90                   	nop
+c0108790:	c9                   	leave  
+c0108791:	c3                   	ret    
+
+c0108792 <swapfs_read>:
+
+int
+swapfs_read(swap_entry_t entry, struct Page *page) {
+c0108792:	55                   	push   %ebp
+c0108793:	89 e5                	mov    %esp,%ebp
+c0108795:	83 ec 18             	sub    $0x18,%esp
+    return ide_read_secs(SWAP_DEV_NO, swap_offset(entry) * PAGE_NSECT, page2kva(page), PAGE_NSECT);
+c0108798:	83 ec 0c             	sub    $0xc,%esp
+c010879b:	ff 75 0c             	pushl  0xc(%ebp)
+c010879e:	e8 67 ff ff ff       	call   c010870a <page2kva>
+c01087a3:	83 c4 10             	add    $0x10,%esp
+c01087a6:	89 c2                	mov    %eax,%edx
+c01087a8:	8b 45 08             	mov    0x8(%ebp),%eax
+c01087ab:	c1 e8 08             	shr    $0x8,%eax
+c01087ae:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c01087b1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c01087b5:	74 0a                	je     c01087c1 <swapfs_read+0x2f>
+c01087b7:	a1 3c 31 1b c0       	mov    0xc01b313c,%eax
+c01087bc:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+c01087bf:	72 14                	jb     c01087d5 <swapfs_read+0x43>
+c01087c1:	ff 75 08             	pushl  0x8(%ebp)
+c01087c4:	68 d8 d8 10 c0       	push   $0xc010d8d8
+c01087c9:	6a 14                	push   $0x14
+c01087cb:	68 c7 d8 10 c0       	push   $0xc010d8c7
+c01087d0:	e8 20 7c ff ff       	call   c01003f5 <__panic>
+c01087d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01087d8:	c1 e0 03             	shl    $0x3,%eax
+c01087db:	6a 08                	push   $0x8
+c01087dd:	52                   	push   %edx
+c01087de:	50                   	push   %eax
+c01087df:	6a 01                	push   $0x1
+c01087e1:	e8 64 8a ff ff       	call   c010124a <ide_read_secs>
+c01087e6:	83 c4 10             	add    $0x10,%esp
+}
+c01087e9:	c9                   	leave  
+c01087ea:	c3                   	ret    
+
+c01087eb <swapfs_write>:
+
+int
+swapfs_write(swap_entry_t entry, struct Page *page) {
+c01087eb:	55                   	push   %ebp
+c01087ec:	89 e5                	mov    %esp,%ebp
+c01087ee:	83 ec 18             	sub    $0x18,%esp
+    return ide_write_secs(SWAP_DEV_NO, swap_offset(entry) * PAGE_NSECT, page2kva(page), PAGE_NSECT);
+c01087f1:	83 ec 0c             	sub    $0xc,%esp
+c01087f4:	ff 75 0c             	pushl  0xc(%ebp)
+c01087f7:	e8 0e ff ff ff       	call   c010870a <page2kva>
+c01087fc:	83 c4 10             	add    $0x10,%esp
+c01087ff:	89 c2                	mov    %eax,%edx
+c0108801:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108804:	c1 e8 08             	shr    $0x8,%eax
+c0108807:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c010880a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c010880e:	74 0a                	je     c010881a <swapfs_write+0x2f>
+c0108810:	a1 3c 31 1b c0       	mov    0xc01b313c,%eax
+c0108815:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+c0108818:	72 14                	jb     c010882e <swapfs_write+0x43>
+c010881a:	ff 75 08             	pushl  0x8(%ebp)
+c010881d:	68 d8 d8 10 c0       	push   $0xc010d8d8
+c0108822:	6a 19                	push   $0x19
+c0108824:	68 c7 d8 10 c0       	push   $0xc010d8c7
+c0108829:	e8 c7 7b ff ff       	call   c01003f5 <__panic>
+c010882e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108831:	c1 e0 03             	shl    $0x3,%eax
+c0108834:	6a 08                	push   $0x8
+c0108836:	52                   	push   %edx
+c0108837:	50                   	push   %eax
+c0108838:	6a 01                	push   $0x1
+c010883a:	e8 35 8c ff ff       	call   c0101474 <ide_write_secs>
+c010883f:	83 c4 10             	add    $0x10,%esp
+}
+c0108842:	c9                   	leave  
+c0108843:	c3                   	ret    
+
+c0108844 <kernel_thread_entry>:
+.text
+.globl kernel_thread_entry
+kernel_thread_entry:        # void kernel_thread(void)
+
+    pushl %edx              # push arg
+c0108844:	52                   	push   %edx
+    call *%ebx              # call fn
+c0108845:	ff d3                	call   *%ebx
+
+    pushl %eax              # save the return value of fn(arg)
+c0108847:	50                   	push   %eax
+    call do_exit            # call do_exit to terminate current thread
+c0108848:	e8 72 0c 00 00       	call   c01094bf <do_exit>
+
+c010884d <switch_to>:
+.text
+.globl switch_to
+switch_to:                      # switch_to(from, to)
+
+    # save from's registers
+    movl 4(%esp), %eax          # eax points to from
+c010884d:	8b 44 24 04          	mov    0x4(%esp),%eax
+    popl 0(%eax)                # save eip !popl
+c0108851:	8f 00                	popl   (%eax)
+    movl %esp, 4(%eax)
+c0108853:	89 60 04             	mov    %esp,0x4(%eax)
+    movl %ebx, 8(%eax)
+c0108856:	89 58 08             	mov    %ebx,0x8(%eax)
+    movl %ecx, 12(%eax)
+c0108859:	89 48 0c             	mov    %ecx,0xc(%eax)
+    movl %edx, 16(%eax)
+c010885c:	89 50 10             	mov    %edx,0x10(%eax)
+    movl %esi, 20(%eax)
+c010885f:	89 70 14             	mov    %esi,0x14(%eax)
+    movl %edi, 24(%eax)
+c0108862:	89 78 18             	mov    %edi,0x18(%eax)
+    movl %ebp, 28(%eax)
+c0108865:	89 68 1c             	mov    %ebp,0x1c(%eax)
+
+    # restore to's registers
+    movl 4(%esp), %eax          # not 8(%esp): popped return address already
+c0108868:	8b 44 24 04          	mov    0x4(%esp),%eax
+                                # eax now points to to
+    movl 28(%eax), %ebp
+c010886c:	8b 68 1c             	mov    0x1c(%eax),%ebp
+    movl 24(%eax), %edi
+c010886f:	8b 78 18             	mov    0x18(%eax),%edi
+    movl 20(%eax), %esi
+c0108872:	8b 70 14             	mov    0x14(%eax),%esi
+    movl 16(%eax), %edx
+c0108875:	8b 50 10             	mov    0x10(%eax),%edx
+    movl 12(%eax), %ecx
+c0108878:	8b 48 0c             	mov    0xc(%eax),%ecx
+    movl 8(%eax), %ebx
+c010887b:	8b 58 08             	mov    0x8(%eax),%ebx
+    movl 4(%eax), %esp
+c010887e:	8b 60 04             	mov    0x4(%eax),%esp
+
+    pushl 0(%eax)               # push eip
+c0108881:	ff 30                	pushl  (%eax)
+
+    ret
+c0108883:	c3                   	ret    
+
+c0108884 <test_and_set_bit>:
+ * test_and_set_bit - Atomically set a bit and return its old value
+ * @nr:     the bit to set
+ * @addr:   the address to count from
+ * */
+static inline bool
+test_and_set_bit(int nr, volatile void *addr) {
+c0108884:	55                   	push   %ebp
+c0108885:	89 e5                	mov    %esp,%ebp
+c0108887:	83 ec 10             	sub    $0x10,%esp
+    int oldbit;
+    asm volatile ("btsl %2, %1; sbbl %0, %0" : "=r" (oldbit), "=m" (*(volatile long *)addr) : "Ir" (nr) : "memory");
+c010888a:	8b 55 0c             	mov    0xc(%ebp),%edx
+c010888d:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108890:	0f ab 02             	bts    %eax,(%edx)
+c0108893:	19 c0                	sbb    %eax,%eax
+c0108895:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    return oldbit != 0;
+c0108898:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+c010889c:	0f 95 c0             	setne  %al
+c010889f:	0f b6 c0             	movzbl %al,%eax
+}
+c01088a2:	c9                   	leave  
+c01088a3:	c3                   	ret    
+
+c01088a4 <test_and_clear_bit>:
+ * test_and_clear_bit - Atomically clear a bit and return its old value
+ * @nr:     the bit to clear
+ * @addr:   the address to count from
+ * */
+static inline bool
+test_and_clear_bit(int nr, volatile void *addr) {
+c01088a4:	55                   	push   %ebp
+c01088a5:	89 e5                	mov    %esp,%ebp
+c01088a7:	83 ec 10             	sub    $0x10,%esp
+    int oldbit;
+    asm volatile ("btrl %2, %1; sbbl %0, %0" : "=r" (oldbit), "=m" (*(volatile long *)addr) : "Ir" (nr) : "memory");
+c01088aa:	8b 55 0c             	mov    0xc(%ebp),%edx
+c01088ad:	8b 45 08             	mov    0x8(%ebp),%eax
+c01088b0:	0f b3 02             	btr    %eax,(%edx)
+c01088b3:	19 c0                	sbb    %eax,%eax
+c01088b5:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    return oldbit != 0;
+c01088b8:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+c01088bc:	0f 95 c0             	setne  %al
+c01088bf:	0f b6 c0             	movzbl %al,%eax
+}
+c01088c2:	c9                   	leave  
+c01088c3:	c3                   	ret    
+
+c01088c4 <__intr_save>:
+#include <assert.h>
+#include <atomic.h>
+#include <sched.h>
+
+static inline bool
+__intr_save(void) {
+c01088c4:	55                   	push   %ebp
+c01088c5:	89 e5                	mov    %esp,%ebp
+c01088c7:	83 ec 18             	sub    $0x18,%esp
+}
+
+static inline uint32_t
+read_eflags(void) {
+    uint32_t eflags;
+    asm volatile ("pushfl; popl %0" : "=r" (eflags));
+c01088ca:	9c                   	pushf  
+c01088cb:	58                   	pop    %eax
+c01088cc:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    return eflags;
+c01088cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    if (read_eflags() & FL_IF) {
+c01088d2:	25 00 02 00 00       	and    $0x200,%eax
+c01088d7:	85 c0                	test   %eax,%eax
+c01088d9:	74 0c                	je     c01088e7 <__intr_save+0x23>
+        intr_disable();
+c01088db:	e8 cd 98 ff ff       	call   c01021ad <intr_disable>
+        return 1;
+c01088e0:	b8 01 00 00 00       	mov    $0x1,%eax
+c01088e5:	eb 05                	jmp    c01088ec <__intr_save+0x28>
+    }
+    return 0;
+c01088e7:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c01088ec:	c9                   	leave  
+c01088ed:	c3                   	ret    
+
+c01088ee <__intr_restore>:
+
+static inline void
+__intr_restore(bool flag) {
+c01088ee:	55                   	push   %ebp
+c01088ef:	89 e5                	mov    %esp,%ebp
+c01088f1:	83 ec 08             	sub    $0x8,%esp
+    if (flag) {
+c01088f4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c01088f8:	74 05                	je     c01088ff <__intr_restore+0x11>
+        intr_enable();
+c01088fa:	e8 a7 98 ff ff       	call   c01021a6 <intr_enable>
+    }
+}
+c01088ff:	90                   	nop
+c0108900:	c9                   	leave  
+c0108901:	c3                   	ret    
+
+c0108902 <try_lock>:
+lock_init(lock_t *lock) {
+    *lock = 0;
+}
+
+static inline bool
+try_lock(lock_t *lock) {
+c0108902:	55                   	push   %ebp
+c0108903:	89 e5                	mov    %esp,%ebp
+    return !test_and_set_bit(0, lock);
+c0108905:	ff 75 08             	pushl  0x8(%ebp)
+c0108908:	6a 00                	push   $0x0
+c010890a:	e8 75 ff ff ff       	call   c0108884 <test_and_set_bit>
+c010890f:	83 c4 08             	add    $0x8,%esp
+c0108912:	85 c0                	test   %eax,%eax
+c0108914:	0f 94 c0             	sete   %al
+c0108917:	0f b6 c0             	movzbl %al,%eax
+}
+c010891a:	c9                   	leave  
+c010891b:	c3                   	ret    
+
+c010891c <lock>:
+
+static inline void
+lock(lock_t *lock) {
+c010891c:	55                   	push   %ebp
+c010891d:	89 e5                	mov    %esp,%ebp
+c010891f:	83 ec 08             	sub    $0x8,%esp
+    while (!try_lock(lock)) {
+c0108922:	eb 05                	jmp    c0108929 <lock+0xd>
+        schedule();
+c0108924:	e8 13 1c 00 00       	call   c010a53c <schedule>
+    return !test_and_set_bit(0, lock);
+}
+
+static inline void
+lock(lock_t *lock) {
+    while (!try_lock(lock)) {
+c0108929:	83 ec 0c             	sub    $0xc,%esp
+c010892c:	ff 75 08             	pushl  0x8(%ebp)
+c010892f:	e8 ce ff ff ff       	call   c0108902 <try_lock>
+c0108934:	83 c4 10             	add    $0x10,%esp
+c0108937:	85 c0                	test   %eax,%eax
+c0108939:	74 e9                	je     c0108924 <lock+0x8>
+        schedule();
+    }
+}
+c010893b:	90                   	nop
+c010893c:	c9                   	leave  
+c010893d:	c3                   	ret    
+
+c010893e <unlock>:
+
+static inline void
+unlock(lock_t *lock) {
+c010893e:	55                   	push   %ebp
+c010893f:	89 e5                	mov    %esp,%ebp
+c0108941:	83 ec 08             	sub    $0x8,%esp
+    if (!test_and_clear_bit(0, lock)) {
+c0108944:	ff 75 08             	pushl  0x8(%ebp)
+c0108947:	6a 00                	push   $0x0
+c0108949:	e8 56 ff ff ff       	call   c01088a4 <test_and_clear_bit>
+c010894e:	83 c4 08             	add    $0x8,%esp
+c0108951:	85 c0                	test   %eax,%eax
+c0108953:	75 14                	jne    c0108969 <unlock+0x2b>
+        panic("Unlock failed.\n");
+c0108955:	83 ec 04             	sub    $0x4,%esp
+c0108958:	68 f8 d8 10 c0       	push   $0xc010d8f8
+c010895d:	6a 34                	push   $0x34
+c010895f:	68 08 d9 10 c0       	push   $0xc010d908
+c0108964:	e8 8c 7a ff ff       	call   c01003f5 <__panic>
+    }
+}
+c0108969:	90                   	nop
+c010896a:	c9                   	leave  
+c010896b:	c3                   	ret    
+
+c010896c <page2ppn>:
+
+extern struct Page *pages;
+extern size_t npage;
+
+static inline ppn_t
+page2ppn(struct Page *page) {
+c010896c:	55                   	push   %ebp
+c010896d:	89 e5                	mov    %esp,%ebp
+    return page - pages;
+c010896f:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108972:	8b 15 84 30 1b c0    	mov    0xc01b3084,%edx
+c0108978:	29 d0                	sub    %edx,%eax
+c010897a:	c1 f8 05             	sar    $0x5,%eax
+}
+c010897d:	5d                   	pop    %ebp
+c010897e:	c3                   	ret    
+
+c010897f <page2pa>:
+
+static inline uintptr_t
+page2pa(struct Page *page) {
+c010897f:	55                   	push   %ebp
+c0108980:	89 e5                	mov    %esp,%ebp
+    return page2ppn(page) << PGSHIFT;
+c0108982:	ff 75 08             	pushl  0x8(%ebp)
+c0108985:	e8 e2 ff ff ff       	call   c010896c <page2ppn>
+c010898a:	83 c4 04             	add    $0x4,%esp
+c010898d:	c1 e0 0c             	shl    $0xc,%eax
+}
+c0108990:	c9                   	leave  
+c0108991:	c3                   	ret    
+
+c0108992 <pa2page>:
+
+static inline struct Page *
+pa2page(uintptr_t pa) {
+c0108992:	55                   	push   %ebp
+c0108993:	89 e5                	mov    %esp,%ebp
+c0108995:	83 ec 08             	sub    $0x8,%esp
+    if (PPN(pa) >= npage) {
+c0108998:	8b 45 08             	mov    0x8(%ebp),%eax
+c010899b:	c1 e8 0c             	shr    $0xc,%eax
+c010899e:	89 c2                	mov    %eax,%edx
+c01089a0:	a1 80 0f 1b c0       	mov    0xc01b0f80,%eax
+c01089a5:	39 c2                	cmp    %eax,%edx
+c01089a7:	72 14                	jb     c01089bd <pa2page+0x2b>
+        panic("pa2page called with invalid pa");
+c01089a9:	83 ec 04             	sub    $0x4,%esp
+c01089ac:	68 1c d9 10 c0       	push   $0xc010d91c
+c01089b1:	6a 5e                	push   $0x5e
+c01089b3:	68 3b d9 10 c0       	push   $0xc010d93b
+c01089b8:	e8 38 7a ff ff       	call   c01003f5 <__panic>
+    }
+    return &pages[PPN(pa)];
+c01089bd:	a1 84 30 1b c0       	mov    0xc01b3084,%eax
+c01089c2:	8b 55 08             	mov    0x8(%ebp),%edx
+c01089c5:	c1 ea 0c             	shr    $0xc,%edx
+c01089c8:	c1 e2 05             	shl    $0x5,%edx
+c01089cb:	01 d0                	add    %edx,%eax
+}
+c01089cd:	c9                   	leave  
+c01089ce:	c3                   	ret    
+
+c01089cf <page2kva>:
+
+static inline void *
+page2kva(struct Page *page) {
+c01089cf:	55                   	push   %ebp
+c01089d0:	89 e5                	mov    %esp,%ebp
+c01089d2:	83 ec 18             	sub    $0x18,%esp
+    return KADDR(page2pa(page));
+c01089d5:	ff 75 08             	pushl  0x8(%ebp)
+c01089d8:	e8 a2 ff ff ff       	call   c010897f <page2pa>
+c01089dd:	83 c4 04             	add    $0x4,%esp
+c01089e0:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c01089e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01089e6:	c1 e8 0c             	shr    $0xc,%eax
+c01089e9:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c01089ec:	a1 80 0f 1b c0       	mov    0xc01b0f80,%eax
+c01089f1:	39 45 f0             	cmp    %eax,-0x10(%ebp)
+c01089f4:	72 14                	jb     c0108a0a <page2kva+0x3b>
+c01089f6:	ff 75 f4             	pushl  -0xc(%ebp)
+c01089f9:	68 4c d9 10 c0       	push   $0xc010d94c
+c01089fe:	6a 65                	push   $0x65
+c0108a00:	68 3b d9 10 c0       	push   $0xc010d93b
+c0108a05:	e8 eb 79 ff ff       	call   c01003f5 <__panic>
+c0108a0a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108a0d:	2d 00 00 00 40       	sub    $0x40000000,%eax
+}
+c0108a12:	c9                   	leave  
+c0108a13:	c3                   	ret    
+
+c0108a14 <kva2page>:
+
+static inline struct Page *
+kva2page(void *kva) {
+c0108a14:	55                   	push   %ebp
+c0108a15:	89 e5                	mov    %esp,%ebp
+c0108a17:	83 ec 18             	sub    $0x18,%esp
+    return pa2page(PADDR(kva));
+c0108a1a:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108a1d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0108a20:	81 7d f4 ff ff ff bf 	cmpl   $0xbfffffff,-0xc(%ebp)
+c0108a27:	77 14                	ja     c0108a3d <kva2page+0x29>
+c0108a29:	ff 75 f4             	pushl  -0xc(%ebp)
+c0108a2c:	68 70 d9 10 c0       	push   $0xc010d970
+c0108a31:	6a 6a                	push   $0x6a
+c0108a33:	68 3b d9 10 c0       	push   $0xc010d93b
+c0108a38:	e8 b8 79 ff ff       	call   c01003f5 <__panic>
+c0108a3d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108a40:	05 00 00 00 40       	add    $0x40000000,%eax
+c0108a45:	83 ec 0c             	sub    $0xc,%esp
+c0108a48:	50                   	push   %eax
+c0108a49:	e8 44 ff ff ff       	call   c0108992 <pa2page>
+c0108a4e:	83 c4 10             	add    $0x10,%esp
+}
+c0108a51:	c9                   	leave  
+c0108a52:	c3                   	ret    
+
+c0108a53 <mm_count_inc>:
+
+static inline int
+mm_count_inc(struct mm_struct *mm) {
+c0108a53:	55                   	push   %ebp
+c0108a54:	89 e5                	mov    %esp,%ebp
+    mm->mm_count += 1;
+c0108a56:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108a59:	8b 40 18             	mov    0x18(%eax),%eax
+c0108a5c:	8d 50 01             	lea    0x1(%eax),%edx
+c0108a5f:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108a62:	89 50 18             	mov    %edx,0x18(%eax)
+    return mm->mm_count;
+c0108a65:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108a68:	8b 40 18             	mov    0x18(%eax),%eax
+}
+c0108a6b:	5d                   	pop    %ebp
+c0108a6c:	c3                   	ret    
+
+c0108a6d <mm_count_dec>:
+
+static inline int
+mm_count_dec(struct mm_struct *mm) {
+c0108a6d:	55                   	push   %ebp
+c0108a6e:	89 e5                	mov    %esp,%ebp
+    mm->mm_count -= 1;
+c0108a70:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108a73:	8b 40 18             	mov    0x18(%eax),%eax
+c0108a76:	8d 50 ff             	lea    -0x1(%eax),%edx
+c0108a79:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108a7c:	89 50 18             	mov    %edx,0x18(%eax)
+    return mm->mm_count;
+c0108a7f:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108a82:	8b 40 18             	mov    0x18(%eax),%eax
+}
+c0108a85:	5d                   	pop    %ebp
+c0108a86:	c3                   	ret    
+
+c0108a87 <lock_mm>:
+
+static inline void
+lock_mm(struct mm_struct *mm) {
+c0108a87:	55                   	push   %ebp
+c0108a88:	89 e5                	mov    %esp,%ebp
+c0108a8a:	83 ec 08             	sub    $0x8,%esp
+    if (mm != NULL) {
+c0108a8d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c0108a91:	74 12                	je     c0108aa5 <lock_mm+0x1e>
+        lock(&(mm->mm_lock));
+c0108a93:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108a96:	83 c0 1c             	add    $0x1c,%eax
+c0108a99:	83 ec 0c             	sub    $0xc,%esp
+c0108a9c:	50                   	push   %eax
+c0108a9d:	e8 7a fe ff ff       	call   c010891c <lock>
+c0108aa2:	83 c4 10             	add    $0x10,%esp
+    }
+}
+c0108aa5:	90                   	nop
+c0108aa6:	c9                   	leave  
+c0108aa7:	c3                   	ret    
+
+c0108aa8 <unlock_mm>:
+
+static inline void
+unlock_mm(struct mm_struct *mm) {
+c0108aa8:	55                   	push   %ebp
+c0108aa9:	89 e5                	mov    %esp,%ebp
+c0108aab:	83 ec 08             	sub    $0x8,%esp
+    if (mm != NULL) {
+c0108aae:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c0108ab2:	74 12                	je     c0108ac6 <unlock_mm+0x1e>
+        unlock(&(mm->mm_lock));
+c0108ab4:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108ab7:	83 c0 1c             	add    $0x1c,%eax
+c0108aba:	83 ec 0c             	sub    $0xc,%esp
+c0108abd:	50                   	push   %eax
+c0108abe:	e8 7b fe ff ff       	call   c010893e <unlock>
+c0108ac3:	83 c4 10             	add    $0x10,%esp
+    }
+}
+c0108ac6:	90                   	nop
+c0108ac7:	c9                   	leave  
+c0108ac8:	c3                   	ret    
+
+c0108ac9 <alloc_proc>:
+void forkrets(struct trapframe *tf);
+void switch_to(struct context *from, struct context *to);
+
+// alloc_proc - alloc a proc_struct and init all fields of proc_struct
+static struct proc_struct *
+alloc_proc(void) {
+c0108ac9:	55                   	push   %ebp
+c0108aca:	89 e5                	mov    %esp,%ebp
+c0108acc:	83 ec 18             	sub    $0x18,%esp
+    struct proc_struct *proc = kmalloc(sizeof(struct proc_struct));
+c0108acf:	83 ec 0c             	sub    $0xc,%esp
+c0108ad2:	68 a0 00 00 00       	push   $0xa0
+c0108ad7:	e8 d5 e0 ff ff       	call   c0106bb1 <kmalloc>
+c0108adc:	83 c4 10             	add    $0x10,%esp
+c0108adf:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if (proc != NULL) {
+c0108ae2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0108ae6:	0f 84 1c 01 00 00    	je     c0108c08 <alloc_proc+0x13f>
+     *       struct trapframe *tf;                       // Trap frame for current interrupt
+     *       uintptr_t cr3;                              // CR3 register: the base addr of Page Directroy Table(PDT)
+     *       uint32_t flags;                             // Process flag
+     *       char name[PROC_NAME_LEN + 1];               // Process name
+     */
+        proc->state = PROC_UNINIT;
+c0108aec:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108aef:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+        proc->pid = -1;
+c0108af5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108af8:	c7 40 04 ff ff ff ff 	movl   $0xffffffff,0x4(%eax)
+        proc->cr3 = boot_cr3;
+c0108aff:	8b 15 80 30 1b c0    	mov    0xc01b3080,%edx
+c0108b05:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108b08:	89 50 40             	mov    %edx,0x40(%eax)
+       
+        proc->runs = 0;
+c0108b0b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108b0e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
+        proc->kstack = 0;
+c0108b15:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108b18:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
+        proc->need_resched = 0;
+c0108b1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108b22:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
+        proc->parent = NULL;
+c0108b29:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108b2c:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
+        proc->mm = NULL;
+c0108b33:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108b36:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
+        memset(&proc->context, 0, sizeof(struct context)); 
+c0108b3d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108b40:	83 c0 1c             	add    $0x1c,%eax
+c0108b43:	83 ec 04             	sub    $0x4,%esp
+c0108b46:	6a 20                	push   $0x20
+c0108b48:	6a 00                	push   $0x0
+c0108b4a:	50                   	push   %eax
+c0108b4b:	e8 08 25 00 00       	call   c010b058 <memset>
+c0108b50:	83 c4 10             	add    $0x10,%esp
+        proc->tf = NULL;
+c0108b53:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108b56:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
+        proc->flags = 0;
+c0108b5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108b60:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
+        memset(proc->name, 0, PROC_NAME_LEN);         
+c0108b67:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108b6a:	83 c0 48             	add    $0x48,%eax
+c0108b6d:	83 ec 04             	sub    $0x4,%esp
+c0108b70:	6a 0f                	push   $0xf
+c0108b72:	6a 00                	push   $0x0
+c0108b74:	50                   	push   %eax
+c0108b75:	e8 de 24 00 00       	call   c010b058 <memset>
+c0108b7a:	83 c4 10             	add    $0x10,%esp
+    /*
+     * below fields(add in LAB5) in proc_struct need to be initialized  
+     *       uint32_t wait_state;                        // waiting state
+     *       struct proc_struct *cptr, *yptr, *optr;     // relations between processes
+   */
+        proc->wait_state = 0;
+c0108b7d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108b80:	c7 40 6c 00 00 00 00 	movl   $0x0,0x6c(%eax)
+        proc->cptr = proc->optr = proc->yptr = NULL;
+c0108b87:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108b8a:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
+c0108b91:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108b94:	8b 50 74             	mov    0x74(%eax),%edx
+c0108b97:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108b9a:	89 50 78             	mov    %edx,0x78(%eax)
+c0108b9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108ba0:	8b 50 78             	mov    0x78(%eax),%edx
+c0108ba3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108ba6:	89 50 70             	mov    %edx,0x70(%eax)
+     *     int time_slice;                             // time slice for occupying the CPU
+     *     skew_heap_entry_t lab6_run_pool;            // FOR LAB6 ONLY: the entry in the run pool
+     *     uint32_t lab6_stride;                       // FOR LAB6 ONLY: the current stride of the process
+     *     uint32_t lab6_priority;                     // FOR LAB6 ONLY: the priority of process, set by lab6_set_priority(uint32_t)
+     */
+        proc->rq = NULL;
+c0108ba9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108bac:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
+        memset(&proc->run_link, 0, sizeof(list_entry_t));
+c0108bb3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108bb6:	83 e8 80             	sub    $0xffffff80,%eax
+c0108bb9:	83 ec 04             	sub    $0x4,%esp
+c0108bbc:	6a 08                	push   $0x8
+c0108bbe:	6a 00                	push   $0x0
+c0108bc0:	50                   	push   %eax
+c0108bc1:	e8 92 24 00 00       	call   c010b058 <memset>
+c0108bc6:	83 c4 10             	add    $0x10,%esp
+        proc->time_slice = 0;
+c0108bc9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108bcc:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
+c0108bd3:	00 00 00 
+        memset(&proc->lab6_run_pool,0,sizeof(skew_heap_entry_t));
+c0108bd6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108bd9:	05 8c 00 00 00       	add    $0x8c,%eax
+c0108bde:	83 ec 04             	sub    $0x4,%esp
+c0108be1:	6a 0c                	push   $0xc
+c0108be3:	6a 00                	push   $0x0
+c0108be5:	50                   	push   %eax
+c0108be6:	e8 6d 24 00 00       	call   c010b058 <memset>
+c0108beb:	83 c4 10             	add    $0x10,%esp
+	proc->lab6_stride=0;
+c0108bee:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108bf1:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
+c0108bf8:	00 00 00 
+	proc->lab6_priority=1;
+c0108bfb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108bfe:	c7 80 9c 00 00 00 01 	movl   $0x1,0x9c(%eax)
+c0108c05:	00 00 00 
+    }
+    return proc;
+c0108c08:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+c0108c0b:	c9                   	leave  
+c0108c0c:	c3                   	ret    
+
+c0108c0d <set_proc_name>:
+
+// set_proc_name - set the name of proc
+char *
+set_proc_name(struct proc_struct *proc, const char *name) {
+c0108c0d:	55                   	push   %ebp
+c0108c0e:	89 e5                	mov    %esp,%ebp
+c0108c10:	83 ec 08             	sub    $0x8,%esp
+    memset(proc->name, 0, sizeof(proc->name));
+c0108c13:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108c16:	83 c0 48             	add    $0x48,%eax
+c0108c19:	83 ec 04             	sub    $0x4,%esp
+c0108c1c:	6a 10                	push   $0x10
+c0108c1e:	6a 00                	push   $0x0
+c0108c20:	50                   	push   %eax
+c0108c21:	e8 32 24 00 00       	call   c010b058 <memset>
+c0108c26:	83 c4 10             	add    $0x10,%esp
+    return memcpy(proc->name, name, PROC_NAME_LEN);
+c0108c29:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108c2c:	83 c0 48             	add    $0x48,%eax
+c0108c2f:	83 ec 04             	sub    $0x4,%esp
+c0108c32:	6a 0f                	push   $0xf
+c0108c34:	ff 75 0c             	pushl  0xc(%ebp)
+c0108c37:	50                   	push   %eax
+c0108c38:	e8 fe 24 00 00       	call   c010b13b <memcpy>
+c0108c3d:	83 c4 10             	add    $0x10,%esp
+}
+c0108c40:	c9                   	leave  
+c0108c41:	c3                   	ret    
+
+c0108c42 <get_proc_name>:
+
+// get_proc_name - get the name of proc
+char *
+get_proc_name(struct proc_struct *proc) {
+c0108c42:	55                   	push   %ebp
+c0108c43:	89 e5                	mov    %esp,%ebp
+c0108c45:	83 ec 08             	sub    $0x8,%esp
+    static char name[PROC_NAME_LEN + 1];
+    memset(name, 0, sizeof(name));
+c0108c48:	83 ec 04             	sub    $0x4,%esp
+c0108c4b:	6a 10                	push   $0x10
+c0108c4d:	6a 00                	push   $0x0
+c0108c4f:	68 44 30 1b c0       	push   $0xc01b3044
+c0108c54:	e8 ff 23 00 00       	call   c010b058 <memset>
+c0108c59:	83 c4 10             	add    $0x10,%esp
+    return memcpy(name, proc->name, PROC_NAME_LEN);
+c0108c5c:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108c5f:	83 c0 48             	add    $0x48,%eax
+c0108c62:	83 ec 04             	sub    $0x4,%esp
+c0108c65:	6a 0f                	push   $0xf
+c0108c67:	50                   	push   %eax
+c0108c68:	68 44 30 1b c0       	push   $0xc01b3044
+c0108c6d:	e8 c9 24 00 00       	call   c010b13b <memcpy>
+c0108c72:	83 c4 10             	add    $0x10,%esp
+}
+c0108c75:	c9                   	leave  
+c0108c76:	c3                   	ret    
+
+c0108c77 <set_links>:
+
+// set_links - set the relation links of process
+static void
+set_links(struct proc_struct *proc) {
+c0108c77:	55                   	push   %ebp
+c0108c78:	89 e5                	mov    %esp,%ebp
+c0108c7a:	83 ec 20             	sub    $0x20,%esp
+    list_add(&proc_list, &(proc->list_link));
+c0108c7d:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108c80:	83 c0 58             	add    $0x58,%eax
+c0108c83:	c7 45 fc 70 31 1b c0 	movl   $0xc01b3170,-0x4(%ebp)
+c0108c8a:	89 45 f8             	mov    %eax,-0x8(%ebp)
+c0108c8d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0108c90:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0108c93:	8b 45 f8             	mov    -0x8(%ebp),%eax
+c0108c96:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ * Insert the new element @elm *after* the element @listelm which
+ * is already in the list.
+ * */
+static inline void
+list_add_after(list_entry_t *listelm, list_entry_t *elm) {
+    __list_add(elm, listelm, listelm->next);
+c0108c99:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108c9c:	8b 40 04             	mov    0x4(%eax),%eax
+c0108c9f:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c0108ca2:	89 55 ec             	mov    %edx,-0x14(%ebp)
+c0108ca5:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0108ca8:	89 55 e8             	mov    %edx,-0x18(%ebp)
+c0108cab:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ * */
+static inline void
+__list_add(list_entry_t *elm, list_entry_t *prev, list_entry_t *next) {
+    prev->next = next->prev = elm;
+c0108cae:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0108cb1:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c0108cb4:	89 10                	mov    %edx,(%eax)
+c0108cb6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0108cb9:	8b 10                	mov    (%eax),%edx
+c0108cbb:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0108cbe:	89 50 04             	mov    %edx,0x4(%eax)
+    elm->next = next;
+c0108cc1:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0108cc4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c0108cc7:	89 50 04             	mov    %edx,0x4(%eax)
+    elm->prev = prev;
+c0108cca:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0108ccd:	8b 55 e8             	mov    -0x18(%ebp),%edx
+c0108cd0:	89 10                	mov    %edx,(%eax)
+    proc->yptr = NULL;
+c0108cd2:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108cd5:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
+    if ((proc->optr = proc->parent->cptr) != NULL) {
+c0108cdc:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108cdf:	8b 40 14             	mov    0x14(%eax),%eax
+c0108ce2:	8b 50 70             	mov    0x70(%eax),%edx
+c0108ce5:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108ce8:	89 50 78             	mov    %edx,0x78(%eax)
+c0108ceb:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108cee:	8b 40 78             	mov    0x78(%eax),%eax
+c0108cf1:	85 c0                	test   %eax,%eax
+c0108cf3:	74 0c                	je     c0108d01 <set_links+0x8a>
+        proc->optr->yptr = proc;
+c0108cf5:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108cf8:	8b 40 78             	mov    0x78(%eax),%eax
+c0108cfb:	8b 55 08             	mov    0x8(%ebp),%edx
+c0108cfe:	89 50 74             	mov    %edx,0x74(%eax)
+    }
+    proc->parent->cptr = proc;
+c0108d01:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108d04:	8b 40 14             	mov    0x14(%eax),%eax
+c0108d07:	8b 55 08             	mov    0x8(%ebp),%edx
+c0108d0a:	89 50 70             	mov    %edx,0x70(%eax)
+    nr_process ++;
+c0108d0d:	a1 40 30 1b c0       	mov    0xc01b3040,%eax
+c0108d12:	83 c0 01             	add    $0x1,%eax
+c0108d15:	a3 40 30 1b c0       	mov    %eax,0xc01b3040
+}
+c0108d1a:	90                   	nop
+c0108d1b:	c9                   	leave  
+c0108d1c:	c3                   	ret    
+
+c0108d1d <remove_links>:
+
+// remove_links - clean the relation links of process
+static void
+remove_links(struct proc_struct *proc) {
+c0108d1d:	55                   	push   %ebp
+c0108d1e:	89 e5                	mov    %esp,%ebp
+c0108d20:	83 ec 10             	sub    $0x10,%esp
+    list_del(&(proc->list_link));
+c0108d23:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108d26:	83 c0 58             	add    $0x58,%eax
+c0108d29:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ * Note: list_empty() on @listelm does not return true after this, the entry is
+ * in an undefined state.
+ * */
+static inline void
+list_del(list_entry_t *listelm) {
+    __list_del(listelm->prev, listelm->next);
+c0108d2c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0108d2f:	8b 40 04             	mov    0x4(%eax),%eax
+c0108d32:	8b 55 fc             	mov    -0x4(%ebp),%edx
+c0108d35:	8b 12                	mov    (%edx),%edx
+c0108d37:	89 55 f8             	mov    %edx,-0x8(%ebp)
+c0108d3a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ * */
+static inline void
+__list_del(list_entry_t *prev, list_entry_t *next) {
+    prev->next = next;
+c0108d3d:	8b 45 f8             	mov    -0x8(%ebp),%eax
+c0108d40:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0108d43:	89 50 04             	mov    %edx,0x4(%eax)
+    next->prev = prev;
+c0108d46:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108d49:	8b 55 f8             	mov    -0x8(%ebp),%edx
+c0108d4c:	89 10                	mov    %edx,(%eax)
+    if (proc->optr != NULL) {
+c0108d4e:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108d51:	8b 40 78             	mov    0x78(%eax),%eax
+c0108d54:	85 c0                	test   %eax,%eax
+c0108d56:	74 0f                	je     c0108d67 <remove_links+0x4a>
+        proc->optr->yptr = proc->yptr;
+c0108d58:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108d5b:	8b 40 78             	mov    0x78(%eax),%eax
+c0108d5e:	8b 55 08             	mov    0x8(%ebp),%edx
+c0108d61:	8b 52 74             	mov    0x74(%edx),%edx
+c0108d64:	89 50 74             	mov    %edx,0x74(%eax)
+    }
+    if (proc->yptr != NULL) {
+c0108d67:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108d6a:	8b 40 74             	mov    0x74(%eax),%eax
+c0108d6d:	85 c0                	test   %eax,%eax
+c0108d6f:	74 11                	je     c0108d82 <remove_links+0x65>
+        proc->yptr->optr = proc->optr;
+c0108d71:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108d74:	8b 40 74             	mov    0x74(%eax),%eax
+c0108d77:	8b 55 08             	mov    0x8(%ebp),%edx
+c0108d7a:	8b 52 78             	mov    0x78(%edx),%edx
+c0108d7d:	89 50 78             	mov    %edx,0x78(%eax)
+c0108d80:	eb 0f                	jmp    c0108d91 <remove_links+0x74>
+    }
+    else {
+       proc->parent->cptr = proc->optr;
+c0108d82:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108d85:	8b 40 14             	mov    0x14(%eax),%eax
+c0108d88:	8b 55 08             	mov    0x8(%ebp),%edx
+c0108d8b:	8b 52 78             	mov    0x78(%edx),%edx
+c0108d8e:	89 50 70             	mov    %edx,0x70(%eax)
+    }
+    nr_process --;
+c0108d91:	a1 40 30 1b c0       	mov    0xc01b3040,%eax
+c0108d96:	83 e8 01             	sub    $0x1,%eax
+c0108d99:	a3 40 30 1b c0       	mov    %eax,0xc01b3040
+}
+c0108d9e:	90                   	nop
+c0108d9f:	c9                   	leave  
+c0108da0:	c3                   	ret    
+
+c0108da1 <get_pid>:
+
+// get_pid - alloc a unique pid for process
+static int
+get_pid(void) {
+c0108da1:	55                   	push   %ebp
+c0108da2:	89 e5                	mov    %esp,%ebp
+c0108da4:	83 ec 10             	sub    $0x10,%esp
+    static_assert(MAX_PID > MAX_PROCESS);
+    struct proc_struct *proc;
+    list_entry_t *list = &proc_list, *le;
+c0108da7:	c7 45 f8 70 31 1b c0 	movl   $0xc01b3170,-0x8(%ebp)
+    static int next_safe = MAX_PID, last_pid = MAX_PID;
+    if (++ last_pid >= MAX_PID) {
+c0108dae:	a1 6c ca 12 c0       	mov    0xc012ca6c,%eax
+c0108db3:	83 c0 01             	add    $0x1,%eax
+c0108db6:	a3 6c ca 12 c0       	mov    %eax,0xc012ca6c
+c0108dbb:	a1 6c ca 12 c0       	mov    0xc012ca6c,%eax
+c0108dc0:	3d ff 1f 00 00       	cmp    $0x1fff,%eax
+c0108dc5:	7e 0c                	jle    c0108dd3 <get_pid+0x32>
+        last_pid = 1;
+c0108dc7:	c7 05 6c ca 12 c0 01 	movl   $0x1,0xc012ca6c
+c0108dce:	00 00 00 
+        goto inside;
+c0108dd1:	eb 13                	jmp    c0108de6 <get_pid+0x45>
+    }
+    if (last_pid >= next_safe) {
+c0108dd3:	8b 15 6c ca 12 c0    	mov    0xc012ca6c,%edx
+c0108dd9:	a1 70 ca 12 c0       	mov    0xc012ca70,%eax
+c0108dde:	39 c2                	cmp    %eax,%edx
+c0108de0:	0f 8c ac 00 00 00    	jl     c0108e92 <get_pid+0xf1>
+    inside:
+        next_safe = MAX_PID;
+c0108de6:	c7 05 70 ca 12 c0 00 	movl   $0x2000,0xc012ca70
+c0108ded:	20 00 00 
+    repeat:
+        le = list;
+c0108df0:	8b 45 f8             	mov    -0x8(%ebp),%eax
+c0108df3:	89 45 fc             	mov    %eax,-0x4(%ebp)
+        while ((le = list_next(le)) != list) {
+c0108df6:	eb 7f                	jmp    c0108e77 <get_pid+0xd6>
+            proc = le2proc(le, list_link);
+c0108df8:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0108dfb:	83 e8 58             	sub    $0x58,%eax
+c0108dfe:	89 45 f4             	mov    %eax,-0xc(%ebp)
+            if (proc->pid == last_pid) {
+c0108e01:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108e04:	8b 50 04             	mov    0x4(%eax),%edx
+c0108e07:	a1 6c ca 12 c0       	mov    0xc012ca6c,%eax
+c0108e0c:	39 c2                	cmp    %eax,%edx
+c0108e0e:	75 3e                	jne    c0108e4e <get_pid+0xad>
+                if (++ last_pid >= next_safe) {
+c0108e10:	a1 6c ca 12 c0       	mov    0xc012ca6c,%eax
+c0108e15:	83 c0 01             	add    $0x1,%eax
+c0108e18:	a3 6c ca 12 c0       	mov    %eax,0xc012ca6c
+c0108e1d:	8b 15 6c ca 12 c0    	mov    0xc012ca6c,%edx
+c0108e23:	a1 70 ca 12 c0       	mov    0xc012ca70,%eax
+c0108e28:	39 c2                	cmp    %eax,%edx
+c0108e2a:	7c 4b                	jl     c0108e77 <get_pid+0xd6>
+                    if (last_pid >= MAX_PID) {
+c0108e2c:	a1 6c ca 12 c0       	mov    0xc012ca6c,%eax
+c0108e31:	3d ff 1f 00 00       	cmp    $0x1fff,%eax
+c0108e36:	7e 0a                	jle    c0108e42 <get_pid+0xa1>
+                        last_pid = 1;
+c0108e38:	c7 05 6c ca 12 c0 01 	movl   $0x1,0xc012ca6c
+c0108e3f:	00 00 00 
+                    }
+                    next_safe = MAX_PID;
+c0108e42:	c7 05 70 ca 12 c0 00 	movl   $0x2000,0xc012ca70
+c0108e49:	20 00 00 
+                    goto repeat;
+c0108e4c:	eb a2                	jmp    c0108df0 <get_pid+0x4f>
+                }
+            }
+            else if (proc->pid > last_pid && next_safe > proc->pid) {
+c0108e4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108e51:	8b 50 04             	mov    0x4(%eax),%edx
+c0108e54:	a1 6c ca 12 c0       	mov    0xc012ca6c,%eax
+c0108e59:	39 c2                	cmp    %eax,%edx
+c0108e5b:	7e 1a                	jle    c0108e77 <get_pid+0xd6>
+c0108e5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108e60:	8b 50 04             	mov    0x4(%eax),%edx
+c0108e63:	a1 70 ca 12 c0       	mov    0xc012ca70,%eax
+c0108e68:	39 c2                	cmp    %eax,%edx
+c0108e6a:	7d 0b                	jge    c0108e77 <get_pid+0xd6>
+                next_safe = proc->pid;
+c0108e6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108e6f:	8b 40 04             	mov    0x4(%eax),%eax
+c0108e72:	a3 70 ca 12 c0       	mov    %eax,0xc012ca70
+c0108e77:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0108e7a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ * list_next - get the next entry
+ * @listelm:    the list head
+ **/
+static inline list_entry_t *
+list_next(list_entry_t *listelm) {
+    return listelm->next;
+c0108e7d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0108e80:	8b 40 04             	mov    0x4(%eax),%eax
+    if (last_pid >= next_safe) {
+    inside:
+        next_safe = MAX_PID;
+    repeat:
+        le = list;
+        while ((le = list_next(le)) != list) {
+c0108e83:	89 45 fc             	mov    %eax,-0x4(%ebp)
+c0108e86:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0108e89:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+c0108e8c:	0f 85 66 ff ff ff    	jne    c0108df8 <get_pid+0x57>
+            else if (proc->pid > last_pid && next_safe > proc->pid) {
+                next_safe = proc->pid;
+            }
+        }
+    }
+    return last_pid;
+c0108e92:	a1 6c ca 12 c0       	mov    0xc012ca6c,%eax
+}
+c0108e97:	c9                   	leave  
+c0108e98:	c3                   	ret    
+
+c0108e99 <proc_run>:
+
+// proc_run - make process "proc" running on cpu
+// NOTE: before call switch_to, should load  base addr of "proc"'s new PDT
+void
+proc_run(struct proc_struct *proc) {
+c0108e99:	55                   	push   %ebp
+c0108e9a:	89 e5                	mov    %esp,%ebp
+c0108e9c:	83 ec 18             	sub    $0x18,%esp
+    if (proc != current) {
+c0108e9f:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c0108ea4:	39 45 08             	cmp    %eax,0x8(%ebp)
+c0108ea7:	74 6b                	je     c0108f14 <proc_run+0x7b>
+        bool intr_flag;
+        struct proc_struct *prev = current, *next = proc;
+c0108ea9:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c0108eae:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0108eb1:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108eb4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+        local_intr_save(intr_flag);
+c0108eb7:	e8 08 fa ff ff       	call   c01088c4 <__intr_save>
+c0108ebc:	89 45 ec             	mov    %eax,-0x14(%ebp)
+        {
+            current = proc;
+c0108ebf:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108ec2:	a3 28 10 1b c0       	mov    %eax,0xc01b1028
+            load_esp0(next->kstack + KSTACKSIZE);
+c0108ec7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0108eca:	8b 40 0c             	mov    0xc(%eax),%eax
+c0108ecd:	05 00 20 00 00       	add    $0x2000,%eax
+c0108ed2:	83 ec 0c             	sub    $0xc,%esp
+c0108ed5:	50                   	push   %eax
+c0108ed6:	e8 92 a7 ff ff       	call   c010366d <load_esp0>
+c0108edb:	83 c4 10             	add    $0x10,%esp
+            lcr3(next->cr3);
+c0108ede:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0108ee1:	8b 40 40             	mov    0x40(%eax),%eax
+c0108ee4:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    asm volatile ("mov %0, %%cr0" :: "r" (cr0) : "memory");
+}
+
+static inline void
+lcr3(uintptr_t cr3) {
+    asm volatile ("mov %0, %%cr3" :: "r" (cr3) : "memory");
+c0108ee7:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0108eea:	0f 22 d8             	mov    %eax,%cr3
+            switch_to(&(prev->context), &(next->context));
+c0108eed:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0108ef0:	8d 50 1c             	lea    0x1c(%eax),%edx
+c0108ef3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108ef6:	83 c0 1c             	add    $0x1c,%eax
+c0108ef9:	83 ec 08             	sub    $0x8,%esp
+c0108efc:	52                   	push   %edx
+c0108efd:	50                   	push   %eax
+c0108efe:	e8 4a f9 ff ff       	call   c010884d <switch_to>
+c0108f03:	83 c4 10             	add    $0x10,%esp
+        }
+        local_intr_restore(intr_flag);
+c0108f06:	83 ec 0c             	sub    $0xc,%esp
+c0108f09:	ff 75 ec             	pushl  -0x14(%ebp)
+c0108f0c:	e8 dd f9 ff ff       	call   c01088ee <__intr_restore>
+c0108f11:	83 c4 10             	add    $0x10,%esp
+    }
+}
+c0108f14:	90                   	nop
+c0108f15:	c9                   	leave  
+c0108f16:	c3                   	ret    
+
+c0108f17 <forkret>:
+
+// forkret -- the first kernel entry point of a new thread/process
+// NOTE: the addr of forkret is setted in copy_thread function
+//       after switch_to, the current proc will execute here.
+static void
+forkret(void) {
+c0108f17:	55                   	push   %ebp
+c0108f18:	89 e5                	mov    %esp,%ebp
+c0108f1a:	83 ec 08             	sub    $0x8,%esp
+    forkrets(current->tf);
+c0108f1d:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c0108f22:	8b 40 3c             	mov    0x3c(%eax),%eax
+c0108f25:	83 ec 0c             	sub    $0xc,%esp
+c0108f28:	50                   	push   %eax
+c0108f29:	e8 81 a5 ff ff       	call   c01034af <forkrets>
+c0108f2e:	83 c4 10             	add    $0x10,%esp
+}
+c0108f31:	90                   	nop
+c0108f32:	c9                   	leave  
+c0108f33:	c3                   	ret    
+
+c0108f34 <hash_proc>:
+
+// hash_proc - add proc into proc hash_list
+static void
+hash_proc(struct proc_struct *proc) {
+c0108f34:	55                   	push   %ebp
+c0108f35:	89 e5                	mov    %esp,%ebp
+c0108f37:	53                   	push   %ebx
+c0108f38:	83 ec 24             	sub    $0x24,%esp
+    list_add(hash_list + pid_hashfn(proc->pid), &(proc->hash_link));
+c0108f3b:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108f3e:	8d 58 60             	lea    0x60(%eax),%ebx
+c0108f41:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108f44:	8b 40 04             	mov    0x4(%eax),%eax
+c0108f47:	83 ec 08             	sub    $0x8,%esp
+c0108f4a:	6a 0a                	push   $0xa
+c0108f4c:	50                   	push   %eax
+c0108f4d:	e8 9d 28 00 00       	call   c010b7ef <hash32>
+c0108f52:	83 c4 10             	add    $0x10,%esp
+c0108f55:	c1 e0 03             	shl    $0x3,%eax
+c0108f58:	05 40 10 1b c0       	add    $0xc01b1040,%eax
+c0108f5d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0108f60:	89 5d f0             	mov    %ebx,-0x10(%ebp)
+c0108f63:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108f66:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0108f69:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0108f6c:	89 45 e8             	mov    %eax,-0x18(%ebp)
+ * Insert the new element @elm *after* the element @listelm which
+ * is already in the list.
+ * */
+static inline void
+list_add_after(list_entry_t *listelm, list_entry_t *elm) {
+    __list_add(elm, listelm, listelm->next);
+c0108f6f:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0108f72:	8b 40 04             	mov    0x4(%eax),%eax
+c0108f75:	8b 55 e8             	mov    -0x18(%ebp),%edx
+c0108f78:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+c0108f7b:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c0108f7e:	89 55 e0             	mov    %edx,-0x20(%ebp)
+c0108f81:	89 45 dc             	mov    %eax,-0x24(%ebp)
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ * */
+static inline void
+__list_add(list_entry_t *elm, list_entry_t *prev, list_entry_t *next) {
+    prev->next = next->prev = elm;
+c0108f84:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0108f87:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c0108f8a:	89 10                	mov    %edx,(%eax)
+c0108f8c:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0108f8f:	8b 10                	mov    (%eax),%edx
+c0108f91:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0108f94:	89 50 04             	mov    %edx,0x4(%eax)
+    elm->next = next;
+c0108f97:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0108f9a:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c0108f9d:	89 50 04             	mov    %edx,0x4(%eax)
+    elm->prev = prev;
+c0108fa0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0108fa3:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c0108fa6:	89 10                	mov    %edx,(%eax)
+}
+c0108fa8:	90                   	nop
+c0108fa9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+c0108fac:	c9                   	leave  
+c0108fad:	c3                   	ret    
+
+c0108fae <unhash_proc>:
+
+// unhash_proc - delete proc from proc hash_list
+static void
+unhash_proc(struct proc_struct *proc) {
+c0108fae:	55                   	push   %ebp
+c0108faf:	89 e5                	mov    %esp,%ebp
+c0108fb1:	83 ec 10             	sub    $0x10,%esp
+    list_del(&(proc->hash_link));
+c0108fb4:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108fb7:	83 c0 60             	add    $0x60,%eax
+c0108fba:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ * Note: list_empty() on @listelm does not return true after this, the entry is
+ * in an undefined state.
+ * */
+static inline void
+list_del(list_entry_t *listelm) {
+    __list_del(listelm->prev, listelm->next);
+c0108fbd:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0108fc0:	8b 40 04             	mov    0x4(%eax),%eax
+c0108fc3:	8b 55 fc             	mov    -0x4(%ebp),%edx
+c0108fc6:	8b 12                	mov    (%edx),%edx
+c0108fc8:	89 55 f8             	mov    %edx,-0x8(%ebp)
+c0108fcb:	89 45 f4             	mov    %eax,-0xc(%ebp)
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ * */
+static inline void
+__list_del(list_entry_t *prev, list_entry_t *next) {
+    prev->next = next;
+c0108fce:	8b 45 f8             	mov    -0x8(%ebp),%eax
+c0108fd1:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0108fd4:	89 50 04             	mov    %edx,0x4(%eax)
+    next->prev = prev;
+c0108fd7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108fda:	8b 55 f8             	mov    -0x8(%ebp),%edx
+c0108fdd:	89 10                	mov    %edx,(%eax)
+}
+c0108fdf:	90                   	nop
+c0108fe0:	c9                   	leave  
+c0108fe1:	c3                   	ret    
+
+c0108fe2 <find_proc>:
+
+// find_proc - find proc frome proc hash_list according to pid
+struct proc_struct *
+find_proc(int pid) {
+c0108fe2:	55                   	push   %ebp
+c0108fe3:	89 e5                	mov    %esp,%ebp
+c0108fe5:	83 ec 18             	sub    $0x18,%esp
+    if (0 < pid && pid < MAX_PID) {
+c0108fe8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c0108fec:	7e 5d                	jle    c010904b <find_proc+0x69>
+c0108fee:	81 7d 08 ff 1f 00 00 	cmpl   $0x1fff,0x8(%ebp)
+c0108ff5:	7f 54                	jg     c010904b <find_proc+0x69>
+        list_entry_t *list = hash_list + pid_hashfn(pid), *le = list;
+c0108ff7:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108ffa:	83 ec 08             	sub    $0x8,%esp
+c0108ffd:	6a 0a                	push   $0xa
+c0108fff:	50                   	push   %eax
+c0109000:	e8 ea 27 00 00       	call   c010b7ef <hash32>
+c0109005:	83 c4 10             	add    $0x10,%esp
+c0109008:	c1 e0 03             	shl    $0x3,%eax
+c010900b:	05 40 10 1b c0       	add    $0xc01b1040,%eax
+c0109010:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0109013:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0109016:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        while ((le = list_next(le)) != list) {
+c0109019:	eb 19                	jmp    c0109034 <find_proc+0x52>
+            struct proc_struct *proc = le2proc(le, hash_link);
+c010901b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010901e:	83 e8 60             	sub    $0x60,%eax
+c0109021:	89 45 ec             	mov    %eax,-0x14(%ebp)
+            if (proc->pid == pid) {
+c0109024:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0109027:	8b 40 04             	mov    0x4(%eax),%eax
+c010902a:	3b 45 08             	cmp    0x8(%ebp),%eax
+c010902d:	75 05                	jne    c0109034 <find_proc+0x52>
+                return proc;
+c010902f:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0109032:	eb 1c                	jmp    c0109050 <find_proc+0x6e>
+c0109034:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0109037:	89 45 e8             	mov    %eax,-0x18(%ebp)
+ * list_next - get the next entry
+ * @listelm:    the list head
+ **/
+static inline list_entry_t *
+list_next(list_entry_t *listelm) {
+    return listelm->next;
+c010903a:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010903d:	8b 40 04             	mov    0x4(%eax),%eax
+// find_proc - find proc frome proc hash_list according to pid
+struct proc_struct *
+find_proc(int pid) {
+    if (0 < pid && pid < MAX_PID) {
+        list_entry_t *list = hash_list + pid_hashfn(pid), *le = list;
+        while ((le = list_next(le)) != list) {
+c0109040:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0109043:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0109046:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+c0109049:	75 d0                	jne    c010901b <find_proc+0x39>
+            if (proc->pid == pid) {
+                return proc;
+            }
+        }
+    }
+    return NULL;
+c010904b:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c0109050:	c9                   	leave  
+c0109051:	c3                   	ret    
+
+c0109052 <kernel_thread>:
+
+// kernel_thread - create a kernel thread using "fn" function
+// NOTE: the contents of temp trapframe tf will be copied to 
+//       proc->tf in do_fork-->copy_thread function
+int
+kernel_thread(int (*fn)(void *), void *arg, uint32_t clone_flags) {
+c0109052:	55                   	push   %ebp
+c0109053:	89 e5                	mov    %esp,%ebp
+c0109055:	83 ec 58             	sub    $0x58,%esp
+    struct trapframe tf;
+    memset(&tf, 0, sizeof(struct trapframe));
+c0109058:	83 ec 04             	sub    $0x4,%esp
+c010905b:	6a 4c                	push   $0x4c
+c010905d:	6a 00                	push   $0x0
+c010905f:	8d 45 ac             	lea    -0x54(%ebp),%eax
+c0109062:	50                   	push   %eax
+c0109063:	e8 f0 1f 00 00       	call   c010b058 <memset>
+c0109068:	83 c4 10             	add    $0x10,%esp
+    tf.tf_cs = KERNEL_CS;
+c010906b:	66 c7 45 e8 08 00    	movw   $0x8,-0x18(%ebp)
+    tf.tf_ds = tf.tf_es = tf.tf_ss = KERNEL_DS;
+c0109071:	66 c7 45 f4 10 00    	movw   $0x10,-0xc(%ebp)
+c0109077:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
+c010907b:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
+c010907f:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
+c0109083:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
+    tf.tf_regs.reg_ebx = (uint32_t)fn;
+c0109087:	8b 45 08             	mov    0x8(%ebp),%eax
+c010908a:	89 45 bc             	mov    %eax,-0x44(%ebp)
+    tf.tf_regs.reg_edx = (uint32_t)arg;
+c010908d:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0109090:	89 45 c0             	mov    %eax,-0x40(%ebp)
+    tf.tf_eip = (uint32_t)kernel_thread_entry;
+c0109093:	b8 44 88 10 c0       	mov    $0xc0108844,%eax
+c0109098:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    return do_fork(clone_flags | CLONE_VM, 0, &tf);
+c010909b:	8b 45 10             	mov    0x10(%ebp),%eax
+c010909e:	80 cc 01             	or     $0x1,%ah
+c01090a1:	89 c2                	mov    %eax,%edx
+c01090a3:	83 ec 04             	sub    $0x4,%esp
+c01090a6:	8d 45 ac             	lea    -0x54(%ebp),%eax
+c01090a9:	50                   	push   %eax
+c01090aa:	6a 00                	push   $0x0
+c01090ac:	52                   	push   %edx
+c01090ad:	e8 f2 02 00 00       	call   c01093a4 <do_fork>
+c01090b2:	83 c4 10             	add    $0x10,%esp
+}
+c01090b5:	c9                   	leave  
+c01090b6:	c3                   	ret    
+
+c01090b7 <setup_kstack>:
+
+// setup_kstack - alloc pages with size KSTACKPAGE as process kernel stack
+static int
+setup_kstack(struct proc_struct *proc) {
+c01090b7:	55                   	push   %ebp
+c01090b8:	89 e5                	mov    %esp,%ebp
+c01090ba:	83 ec 18             	sub    $0x18,%esp
+    struct Page *page = alloc_pages(KSTACKPAGE);
+c01090bd:	83 ec 0c             	sub    $0xc,%esp
+c01090c0:	6a 02                	push   $0x2
+c01090c2:	e8 fa a6 ff ff       	call   c01037c1 <alloc_pages>
+c01090c7:	83 c4 10             	add    $0x10,%esp
+c01090ca:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if (page != NULL) {
+c01090cd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c01090d1:	74 1d                	je     c01090f0 <setup_kstack+0x39>
+        proc->kstack = (uintptr_t)page2kva(page);
+c01090d3:	83 ec 0c             	sub    $0xc,%esp
+c01090d6:	ff 75 f4             	pushl  -0xc(%ebp)
+c01090d9:	e8 f1 f8 ff ff       	call   c01089cf <page2kva>
+c01090de:	83 c4 10             	add    $0x10,%esp
+c01090e1:	89 c2                	mov    %eax,%edx
+c01090e3:	8b 45 08             	mov    0x8(%ebp),%eax
+c01090e6:	89 50 0c             	mov    %edx,0xc(%eax)
+        return 0;
+c01090e9:	b8 00 00 00 00       	mov    $0x0,%eax
+c01090ee:	eb 05                	jmp    c01090f5 <setup_kstack+0x3e>
+    }
+    return -E_NO_MEM;
+c01090f0:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
+}
+c01090f5:	c9                   	leave  
+c01090f6:	c3                   	ret    
+
+c01090f7 <put_kstack>:
+
+// put_kstack - free the memory space of process kernel stack
+static void
+put_kstack(struct proc_struct *proc) {
+c01090f7:	55                   	push   %ebp
+c01090f8:	89 e5                	mov    %esp,%ebp
+c01090fa:	83 ec 08             	sub    $0x8,%esp
+    free_pages(kva2page((void *)(proc->kstack)), KSTACKPAGE);
+c01090fd:	8b 45 08             	mov    0x8(%ebp),%eax
+c0109100:	8b 40 0c             	mov    0xc(%eax),%eax
+c0109103:	83 ec 0c             	sub    $0xc,%esp
+c0109106:	50                   	push   %eax
+c0109107:	e8 08 f9 ff ff       	call   c0108a14 <kva2page>
+c010910c:	83 c4 10             	add    $0x10,%esp
+c010910f:	83 ec 08             	sub    $0x8,%esp
+c0109112:	6a 02                	push   $0x2
+c0109114:	50                   	push   %eax
+c0109115:	e8 13 a7 ff ff       	call   c010382d <free_pages>
+c010911a:	83 c4 10             	add    $0x10,%esp
+}
+c010911d:	90                   	nop
+c010911e:	c9                   	leave  
+c010911f:	c3                   	ret    
+
+c0109120 <setup_pgdir>:
+
+// setup_pgdir - alloc one page as PDT
+static int
+setup_pgdir(struct mm_struct *mm) {
+c0109120:	55                   	push   %ebp
+c0109121:	89 e5                	mov    %esp,%ebp
+c0109123:	83 ec 18             	sub    $0x18,%esp
+    struct Page *page;
+    if ((page = alloc_page()) == NULL) {
+c0109126:	83 ec 0c             	sub    $0xc,%esp
+c0109129:	6a 01                	push   $0x1
+c010912b:	e8 91 a6 ff ff       	call   c01037c1 <alloc_pages>
+c0109130:	83 c4 10             	add    $0x10,%esp
+c0109133:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0109136:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c010913a:	75 07                	jne    c0109143 <setup_pgdir+0x23>
+        return -E_NO_MEM;
+c010913c:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
+c0109141:	eb 74                	jmp    c01091b7 <setup_pgdir+0x97>
+    }
+    pde_t *pgdir = page2kva(page);
+c0109143:	83 ec 0c             	sub    $0xc,%esp
+c0109146:	ff 75 f4             	pushl  -0xc(%ebp)
+c0109149:	e8 81 f8 ff ff       	call   c01089cf <page2kva>
+c010914e:	83 c4 10             	add    $0x10,%esp
+c0109151:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    memcpy(pgdir, boot_pgdir, PGSIZE);
+c0109154:	a1 e0 c9 12 c0       	mov    0xc012c9e0,%eax
+c0109159:	83 ec 04             	sub    $0x4,%esp
+c010915c:	68 00 10 00 00       	push   $0x1000
+c0109161:	50                   	push   %eax
+c0109162:	ff 75 f0             	pushl  -0x10(%ebp)
+c0109165:	e8 d1 1f 00 00       	call   c010b13b <memcpy>
+c010916a:	83 c4 10             	add    $0x10,%esp
+    pgdir[PDX(VPT)] = PADDR(pgdir) | PTE_P | PTE_W;
+c010916d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0109170:	8d 90 ac 0f 00 00    	lea    0xfac(%eax),%edx
+c0109176:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0109179:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c010917c:	81 7d ec ff ff ff bf 	cmpl   $0xbfffffff,-0x14(%ebp)
+c0109183:	77 17                	ja     c010919c <setup_pgdir+0x7c>
+c0109185:	ff 75 ec             	pushl  -0x14(%ebp)
+c0109188:	68 70 d9 10 c0       	push   $0xc010d970
+c010918d:	68 3f 01 00 00       	push   $0x13f
+c0109192:	68 94 d9 10 c0       	push   $0xc010d994
+c0109197:	e8 59 72 ff ff       	call   c01003f5 <__panic>
+c010919c:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010919f:	05 00 00 00 40       	add    $0x40000000,%eax
+c01091a4:	83 c8 03             	or     $0x3,%eax
+c01091a7:	89 02                	mov    %eax,(%edx)
+    mm->pgdir = pgdir;
+c01091a9:	8b 45 08             	mov    0x8(%ebp),%eax
+c01091ac:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c01091af:	89 50 0c             	mov    %edx,0xc(%eax)
+    return 0;
+c01091b2:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c01091b7:	c9                   	leave  
+c01091b8:	c3                   	ret    
+
+c01091b9 <put_pgdir>:
+
+// put_pgdir - free the memory space of PDT
+static void
+put_pgdir(struct mm_struct *mm) {
+c01091b9:	55                   	push   %ebp
+c01091ba:	89 e5                	mov    %esp,%ebp
+c01091bc:	83 ec 08             	sub    $0x8,%esp
+    free_page(kva2page(mm->pgdir));
+c01091bf:	8b 45 08             	mov    0x8(%ebp),%eax
+c01091c2:	8b 40 0c             	mov    0xc(%eax),%eax
+c01091c5:	83 ec 0c             	sub    $0xc,%esp
+c01091c8:	50                   	push   %eax
+c01091c9:	e8 46 f8 ff ff       	call   c0108a14 <kva2page>
+c01091ce:	83 c4 10             	add    $0x10,%esp
+c01091d1:	83 ec 08             	sub    $0x8,%esp
+c01091d4:	6a 01                	push   $0x1
+c01091d6:	50                   	push   %eax
+c01091d7:	e8 51 a6 ff ff       	call   c010382d <free_pages>
+c01091dc:	83 c4 10             	add    $0x10,%esp
+}
+c01091df:	90                   	nop
+c01091e0:	c9                   	leave  
+c01091e1:	c3                   	ret    
+
+c01091e2 <copy_mm>:
+
+// copy_mm - process "proc" duplicate OR share process "current"'s mm according clone_flags
+//         - if clone_flags & CLONE_VM, then "share" ; else "duplicate"
+static int
+copy_mm(uint32_t clone_flags, struct proc_struct *proc) {
+c01091e2:	55                   	push   %ebp
+c01091e3:	89 e5                	mov    %esp,%ebp
+c01091e5:	83 ec 18             	sub    $0x18,%esp
+    struct mm_struct *mm, *oldmm = current->mm;
+c01091e8:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c01091ed:	8b 40 18             	mov    0x18(%eax),%eax
+c01091f0:	89 45 ec             	mov    %eax,-0x14(%ebp)
+
+    /* current is a kernel thread */
+    if (oldmm == NULL) {
+c01091f3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+c01091f7:	75 0a                	jne    c0109203 <copy_mm+0x21>
+        return 0;
+c01091f9:	b8 00 00 00 00       	mov    $0x0,%eax
+c01091fe:	e9 03 01 00 00       	jmp    c0109306 <copy_mm+0x124>
+    }
+    if (clone_flags & CLONE_VM) {
+c0109203:	8b 45 08             	mov    0x8(%ebp),%eax
+c0109206:	25 00 01 00 00       	and    $0x100,%eax
+c010920b:	85 c0                	test   %eax,%eax
+c010920d:	74 08                	je     c0109217 <copy_mm+0x35>
+        mm = oldmm;
+c010920f:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0109212:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        goto good_mm;
+c0109215:	eb 65                	jmp    c010927c <copy_mm+0x9a>
+    }
+
+    int ret = -E_NO_MEM;
+c0109217:	c7 45 f0 fc ff ff ff 	movl   $0xfffffffc,-0x10(%ebp)
+    if ((mm = mm_create()) == NULL) {
+c010921e:	e8 41 c3 ff ff       	call   c0105564 <mm_create>
+c0109223:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0109226:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c010922a:	0f 84 d2 00 00 00    	je     c0109302 <copy_mm+0x120>
+        goto bad_mm;
+    }
+    if (setup_pgdir(mm) != 0) {
+c0109230:	83 ec 0c             	sub    $0xc,%esp
+c0109233:	ff 75 f4             	pushl  -0xc(%ebp)
+c0109236:	e8 e5 fe ff ff       	call   c0109120 <setup_pgdir>
+c010923b:	83 c4 10             	add    $0x10,%esp
+c010923e:	85 c0                	test   %eax,%eax
+c0109240:	0f 85 ab 00 00 00    	jne    c01092f1 <copy_mm+0x10f>
+        goto bad_pgdir_cleanup_mm;
+    }
+
+    lock_mm(oldmm);
+c0109246:	83 ec 0c             	sub    $0xc,%esp
+c0109249:	ff 75 ec             	pushl  -0x14(%ebp)
+c010924c:	e8 36 f8 ff ff       	call   c0108a87 <lock_mm>
+c0109251:	83 c4 10             	add    $0x10,%esp
+    {
+        ret = dup_mmap(mm, oldmm);
+c0109254:	83 ec 08             	sub    $0x8,%esp
+c0109257:	ff 75 ec             	pushl  -0x14(%ebp)
+c010925a:	ff 75 f4             	pushl  -0xc(%ebp)
+c010925d:	e8 d3 c7 ff ff       	call   c0105a35 <dup_mmap>
+c0109262:	83 c4 10             	add    $0x10,%esp
+c0109265:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    }
+    unlock_mm(oldmm);
+c0109268:	83 ec 0c             	sub    $0xc,%esp
+c010926b:	ff 75 ec             	pushl  -0x14(%ebp)
+c010926e:	e8 35 f8 ff ff       	call   c0108aa8 <unlock_mm>
+c0109273:	83 c4 10             	add    $0x10,%esp
+
+    if (ret != 0) {
+c0109276:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c010927a:	75 56                	jne    c01092d2 <copy_mm+0xf0>
+        goto bad_dup_cleanup_mmap;
+    }
+
+good_mm:
+    mm_count_inc(mm);
+c010927c:	83 ec 0c             	sub    $0xc,%esp
+c010927f:	ff 75 f4             	pushl  -0xc(%ebp)
+c0109282:	e8 cc f7 ff ff       	call   c0108a53 <mm_count_inc>
+c0109287:	83 c4 10             	add    $0x10,%esp
+    proc->mm = mm;
+c010928a:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010928d:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0109290:	89 50 18             	mov    %edx,0x18(%eax)
+    proc->cr3 = PADDR(mm->pgdir);
+c0109293:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0109296:	8b 40 0c             	mov    0xc(%eax),%eax
+c0109299:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c010929c:	81 7d e8 ff ff ff bf 	cmpl   $0xbfffffff,-0x18(%ebp)
+c01092a3:	77 17                	ja     c01092bc <copy_mm+0xda>
+c01092a5:	ff 75 e8             	pushl  -0x18(%ebp)
+c01092a8:	68 70 d9 10 c0       	push   $0xc010d970
+c01092ad:	68 6e 01 00 00       	push   $0x16e
+c01092b2:	68 94 d9 10 c0       	push   $0xc010d994
+c01092b7:	e8 39 71 ff ff       	call   c01003f5 <__panic>
+c01092bc:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c01092bf:	8d 90 00 00 00 40    	lea    0x40000000(%eax),%edx
+c01092c5:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01092c8:	89 50 40             	mov    %edx,0x40(%eax)
+    return 0;
+c01092cb:	b8 00 00 00 00       	mov    $0x0,%eax
+c01092d0:	eb 34                	jmp    c0109306 <copy_mm+0x124>
+        ret = dup_mmap(mm, oldmm);
+    }
+    unlock_mm(oldmm);
+
+    if (ret != 0) {
+        goto bad_dup_cleanup_mmap;
+c01092d2:	90                   	nop
+    mm_count_inc(mm);
+    proc->mm = mm;
+    proc->cr3 = PADDR(mm->pgdir);
+    return 0;
+bad_dup_cleanup_mmap:
+    exit_mmap(mm);
+c01092d3:	83 ec 0c             	sub    $0xc,%esp
+c01092d6:	ff 75 f4             	pushl  -0xc(%ebp)
+c01092d9:	e8 3e c8 ff ff       	call   c0105b1c <exit_mmap>
+c01092de:	83 c4 10             	add    $0x10,%esp
+    put_pgdir(mm);
+c01092e1:	83 ec 0c             	sub    $0xc,%esp
+c01092e4:	ff 75 f4             	pushl  -0xc(%ebp)
+c01092e7:	e8 cd fe ff ff       	call   c01091b9 <put_pgdir>
+c01092ec:	83 c4 10             	add    $0x10,%esp
+c01092ef:	eb 01                	jmp    c01092f2 <copy_mm+0x110>
+    int ret = -E_NO_MEM;
+    if ((mm = mm_create()) == NULL) {
+        goto bad_mm;
+    }
+    if (setup_pgdir(mm) != 0) {
+        goto bad_pgdir_cleanup_mm;
+c01092f1:	90                   	nop
+    return 0;
+bad_dup_cleanup_mmap:
+    exit_mmap(mm);
+    put_pgdir(mm);
+bad_pgdir_cleanup_mm:
+    mm_destroy(mm);
+c01092f2:	83 ec 0c             	sub    $0xc,%esp
+c01092f5:	ff 75 f4             	pushl  -0xc(%ebp)
+c01092f8:	e8 91 c5 ff ff       	call   c010588e <mm_destroy>
+c01092fd:	83 c4 10             	add    $0x10,%esp
+c0109300:	eb 01                	jmp    c0109303 <copy_mm+0x121>
+        goto good_mm;
+    }
+
+    int ret = -E_NO_MEM;
+    if ((mm = mm_create()) == NULL) {
+        goto bad_mm;
+c0109302:	90                   	nop
+    exit_mmap(mm);
+    put_pgdir(mm);
+bad_pgdir_cleanup_mm:
+    mm_destroy(mm);
+bad_mm:
+    return ret;
+c0109303:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+c0109306:	c9                   	leave  
+c0109307:	c3                   	ret    
+
+c0109308 <copy_thread>:
+
+// copy_thread - setup the trapframe on the  process's kernel stack top and
+//             - setup the kernel entry point and stack of process
+static void
+copy_thread(struct proc_struct *proc, uintptr_t esp, struct trapframe *tf) {
+c0109308:	55                   	push   %ebp
+c0109309:	89 e5                	mov    %esp,%ebp
+c010930b:	57                   	push   %edi
+c010930c:	56                   	push   %esi
+c010930d:	53                   	push   %ebx
+    proc->tf = (struct trapframe *)(proc->kstack + KSTACKSIZE) - 1;
+c010930e:	8b 45 08             	mov    0x8(%ebp),%eax
+c0109311:	8b 40 0c             	mov    0xc(%eax),%eax
+c0109314:	05 b4 1f 00 00       	add    $0x1fb4,%eax
+c0109319:	89 c2                	mov    %eax,%edx
+c010931b:	8b 45 08             	mov    0x8(%ebp),%eax
+c010931e:	89 50 3c             	mov    %edx,0x3c(%eax)
+    *(proc->tf) = *tf;
+c0109321:	8b 45 08             	mov    0x8(%ebp),%eax
+c0109324:	8b 40 3c             	mov    0x3c(%eax),%eax
+c0109327:	8b 55 10             	mov    0x10(%ebp),%edx
+c010932a:	89 d3                	mov    %edx,%ebx
+c010932c:	ba 4c 00 00 00       	mov    $0x4c,%edx
+c0109331:	8b 0b                	mov    (%ebx),%ecx
+c0109333:	89 08                	mov    %ecx,(%eax)
+c0109335:	8b 4c 13 fc          	mov    -0x4(%ebx,%edx,1),%ecx
+c0109339:	89 4c 10 fc          	mov    %ecx,-0x4(%eax,%edx,1)
+c010933d:	8d 78 04             	lea    0x4(%eax),%edi
+c0109340:	83 e7 fc             	and    $0xfffffffc,%edi
+c0109343:	29 f8                	sub    %edi,%eax
+c0109345:	29 c3                	sub    %eax,%ebx
+c0109347:	01 c2                	add    %eax,%edx
+c0109349:	83 e2 fc             	and    $0xfffffffc,%edx
+c010934c:	89 d0                	mov    %edx,%eax
+c010934e:	c1 e8 02             	shr    $0x2,%eax
+c0109351:	89 de                	mov    %ebx,%esi
+c0109353:	89 c1                	mov    %eax,%ecx
+c0109355:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+    proc->tf->tf_regs.reg_eax = 0;
+c0109357:	8b 45 08             	mov    0x8(%ebp),%eax
+c010935a:	8b 40 3c             	mov    0x3c(%eax),%eax
+c010935d:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
+    proc->tf->tf_esp = esp;
+c0109364:	8b 45 08             	mov    0x8(%ebp),%eax
+c0109367:	8b 40 3c             	mov    0x3c(%eax),%eax
+c010936a:	8b 55 0c             	mov    0xc(%ebp),%edx
+c010936d:	89 50 44             	mov    %edx,0x44(%eax)
+    proc->tf->tf_eflags |= FL_IF;
+c0109370:	8b 45 08             	mov    0x8(%ebp),%eax
+c0109373:	8b 40 3c             	mov    0x3c(%eax),%eax
+c0109376:	8b 55 08             	mov    0x8(%ebp),%edx
+c0109379:	8b 52 3c             	mov    0x3c(%edx),%edx
+c010937c:	8b 52 40             	mov    0x40(%edx),%edx
+c010937f:	80 ce 02             	or     $0x2,%dh
+c0109382:	89 50 40             	mov    %edx,0x40(%eax)
+
+    proc->context.eip = (uintptr_t)forkret;
+c0109385:	ba 17 8f 10 c0       	mov    $0xc0108f17,%edx
+c010938a:	8b 45 08             	mov    0x8(%ebp),%eax
+c010938d:	89 50 1c             	mov    %edx,0x1c(%eax)
+    proc->context.esp = (uintptr_t)(proc->tf);
+c0109390:	8b 45 08             	mov    0x8(%ebp),%eax
+c0109393:	8b 40 3c             	mov    0x3c(%eax),%eax
+c0109396:	89 c2                	mov    %eax,%edx
+c0109398:	8b 45 08             	mov    0x8(%ebp),%eax
+c010939b:	89 50 20             	mov    %edx,0x20(%eax)
+}
+c010939e:	90                   	nop
+c010939f:	5b                   	pop    %ebx
+c01093a0:	5e                   	pop    %esi
+c01093a1:	5f                   	pop    %edi
+c01093a2:	5d                   	pop    %ebp
+c01093a3:	c3                   	ret    
+
+c01093a4 <do_fork>:
+ * @clone_flags: used to guide how to clone the child process
+ * @stack:       the parent's user stack pointer. if stack==0, It means to fork a kernel thread.
+ * @tf:          the trapframe info, which will be copied to child process's proc->tf
+ */
+int
+do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) {
+c01093a4:	55                   	push   %ebp
+c01093a5:	89 e5                	mov    %esp,%ebp
+c01093a7:	83 ec 18             	sub    $0x18,%esp
+    int ret = -E_NO_FREE_PROC;
+c01093aa:	c7 45 f4 fb ff ff ff 	movl   $0xfffffffb,-0xc(%ebp)
+    struct proc_struct *proc;
+    if (nr_process >= MAX_PROCESS) {
+c01093b1:	a1 40 30 1b c0       	mov    0xc01b3040,%eax
+c01093b6:	3d ff 0f 00 00       	cmp    $0xfff,%eax
+c01093bb:	0f 8f d1 00 00 00    	jg     c0109492 <do_fork+0xee>
+        goto fork_out;
+    }
+    ret = -E_NO_MEM;
+c01093c1:	c7 45 f4 fc ff ff ff 	movl   $0xfffffffc,-0xc(%ebp)
+    //    3. call copy_mm to dup OR share mm according clone_flag
+    //    4. call copy_thread to setup tf & context in proc_struct
+    //    5. insert proc_struct into hash_list && proc_list
+    //    6. call wakeup_proc to make the new child process RUNNABLE
+    //    7. set ret vaule using child proc's pid
+    proc = alloc_proc();
+c01093c8:	e8 fc f6 ff ff       	call   c0108ac9 <alloc_proc>
+c01093cd:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(proc == NULL)
+c01093d0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c01093d4:	0f 84 bb 00 00 00    	je     c0109495 <do_fork+0xf1>
+        goto fork_out;    
+    //    2. call setup_kstack to allocate a kernel stack for child process
+    proc->parent = current;
+c01093da:	8b 15 28 10 1b c0    	mov    0xc01b1028,%edx
+c01093e0:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01093e3:	89 50 14             	mov    %edx,0x14(%eax)
+    assert(current->wait_state == 0);
+c01093e6:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c01093eb:	8b 40 6c             	mov    0x6c(%eax),%eax
+c01093ee:	85 c0                	test   %eax,%eax
+c01093f0:	74 19                	je     c010940b <do_fork+0x67>
+c01093f2:	68 a8 d9 10 c0       	push   $0xc010d9a8
+c01093f7:	68 c1 d9 10 c0       	push   $0xc010d9c1
+c01093fc:	68 b2 01 00 00       	push   $0x1b2
+c0109401:	68 94 d9 10 c0       	push   $0xc010d994
+c0109406:	e8 ea 6f ff ff       	call   c01003f5 <__panic>
+
+    int status = setup_kstack(proc);
+c010940b:	83 ec 0c             	sub    $0xc,%esp
+c010940e:	ff 75 f0             	pushl  -0x10(%ebp)
+c0109411:	e8 a1 fc ff ff       	call   c01090b7 <setup_kstack>
+c0109416:	83 c4 10             	add    $0x10,%esp
+c0109419:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    if(status != 0)
+c010941c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+c0109420:	75 79                	jne    c010949b <do_fork+0xf7>
+        goto bad_fork_cleanup_kstack;
+    //    3. call copy_mm to dup OR share mm according clone_flag
+    status = copy_mm(clone_flags, proc);
+c0109422:	83 ec 08             	sub    $0x8,%esp
+c0109425:	ff 75 f0             	pushl  -0x10(%ebp)
+c0109428:	ff 75 08             	pushl  0x8(%ebp)
+c010942b:	e8 b2 fd ff ff       	call   c01091e2 <copy_mm>
+c0109430:	83 c4 10             	add    $0x10,%esp
+c0109433:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    if(status != 0)
+c0109436:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+c010943a:	75 70                	jne    c01094ac <do_fork+0x108>
+        goto bad_fork_cleanup_proc;
+    //    4. call copy_thread to setup tf & context in proc_struct
+    copy_thread(proc, stack, tf);
+c010943c:	83 ec 04             	sub    $0x4,%esp
+c010943f:	ff 75 10             	pushl  0x10(%ebp)
+c0109442:	ff 75 0c             	pushl  0xc(%ebp)
+c0109445:	ff 75 f0             	pushl  -0x10(%ebp)
+c0109448:	e8 bb fe ff ff       	call   c0109308 <copy_thread>
+c010944d:	83 c4 10             	add    $0x10,%esp
+    //    5. insert proc_struct into hash_list && proc_list
+    
+    proc->pid = get_pid();
+c0109450:	e8 4c f9 ff ff       	call   c0108da1 <get_pid>
+c0109455:	89 c2                	mov    %eax,%edx
+c0109457:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010945a:	89 50 04             	mov    %edx,0x4(%eax)
+    hash_proc(proc);
+c010945d:	83 ec 0c             	sub    $0xc,%esp
+c0109460:	ff 75 f0             	pushl  -0x10(%ebp)
+c0109463:	e8 cc fa ff ff       	call   c0108f34 <hash_proc>
+c0109468:	83 c4 10             	add    $0x10,%esp
+    set_links(proc);
+c010946b:	83 ec 0c             	sub    $0xc,%esp
+c010946e:	ff 75 f0             	pushl  -0x10(%ebp)
+c0109471:	e8 01 f8 ff ff       	call   c0108c77 <set_links>
+c0109476:	83 c4 10             	add    $0x10,%esp
+    //nr_process ++;
+    //list_add(&proc_list, &proc->list_link);
+    //    6. call wakeup_proc to make the new child process RUNNABLE
+    wakeup_proc(proc);
+c0109479:	83 ec 0c             	sub    $0xc,%esp
+c010947c:	ff 75 f0             	pushl  -0x10(%ebp)
+c010947f:	e8 2b 10 00 00       	call   c010a4af <wakeup_proc>
+c0109484:	83 c4 10             	add    $0x10,%esp
+    //    7. set ret vaule using child proc's pid
+    ret = proc->pid;
+c0109487:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010948a:	8b 40 04             	mov    0x4(%eax),%eax
+c010948d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0109490:	eb 04                	jmp    c0109496 <do_fork+0xf2>
+int
+do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) {
+    int ret = -E_NO_FREE_PROC;
+    struct proc_struct *proc;
+    if (nr_process >= MAX_PROCESS) {
+        goto fork_out;
+c0109492:	90                   	nop
+c0109493:	eb 01                	jmp    c0109496 <do_fork+0xf2>
+    //    5. insert proc_struct into hash_list && proc_list
+    //    6. call wakeup_proc to make the new child process RUNNABLE
+    //    7. set ret vaule using child proc's pid
+    proc = alloc_proc();
+    if(proc == NULL)
+        goto fork_out;    
+c0109495:	90                   	nop
+    wakeup_proc(proc);
+    //    7. set ret vaule using child proc's pid
+    ret = proc->pid;
+	
+fork_out:
+    return ret;
+c0109496:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0109499:	eb 22                	jmp    c01094bd <do_fork+0x119>
+    proc->parent = current;
+    assert(current->wait_state == 0);
+
+    int status = setup_kstack(proc);
+    if(status != 0)
+        goto bad_fork_cleanup_kstack;
+c010949b:	90                   	nop
+	
+fork_out:
+    return ret;
+
+bad_fork_cleanup_kstack:
+    put_kstack(proc);
+c010949c:	83 ec 0c             	sub    $0xc,%esp
+c010949f:	ff 75 f0             	pushl  -0x10(%ebp)
+c01094a2:	e8 50 fc ff ff       	call   c01090f7 <put_kstack>
+c01094a7:	83 c4 10             	add    $0x10,%esp
+c01094aa:	eb 01                	jmp    c01094ad <do_fork+0x109>
+    if(status != 0)
+        goto bad_fork_cleanup_kstack;
+    //    3. call copy_mm to dup OR share mm according clone_flag
+    status = copy_mm(clone_flags, proc);
+    if(status != 0)
+        goto bad_fork_cleanup_proc;
+c01094ac:	90                   	nop
+    return ret;
+
+bad_fork_cleanup_kstack:
+    put_kstack(proc);
+bad_fork_cleanup_proc:
+    kfree(proc);
+c01094ad:	83 ec 0c             	sub    $0xc,%esp
+c01094b0:	ff 75 f0             	pushl  -0x10(%ebp)
+c01094b3:	e8 11 d7 ff ff       	call   c0106bc9 <kfree>
+c01094b8:	83 c4 10             	add    $0x10,%esp
+    goto fork_out;
+c01094bb:	eb d9                	jmp    c0109496 <do_fork+0xf2>
+}
+c01094bd:	c9                   	leave  
+c01094be:	c3                   	ret    
+
+c01094bf <do_exit>:
+// do_exit - called by sys_exit
+//   1. call exit_mmap & put_pgdir & mm_destroy to free the almost all memory space of process
+//   2. set process' state as PROC_ZOMBIE, then call wakeup_proc(parent) to ask parent reclaim itself.
+//   3. call scheduler to switch to other process
+int
+do_exit(int error_code) {
+c01094bf:	55                   	push   %ebp
+c01094c0:	89 e5                	mov    %esp,%ebp
+c01094c2:	83 ec 18             	sub    $0x18,%esp
+    if (current == idleproc) {
+c01094c5:	8b 15 28 10 1b c0    	mov    0xc01b1028,%edx
+c01094cb:	a1 20 10 1b c0       	mov    0xc01b1020,%eax
+c01094d0:	39 c2                	cmp    %eax,%edx
+c01094d2:	75 17                	jne    c01094eb <do_exit+0x2c>
+        panic("idleproc exit.\n");
+c01094d4:	83 ec 04             	sub    $0x4,%esp
+c01094d7:	68 d6 d9 10 c0       	push   $0xc010d9d6
+c01094dc:	68 da 01 00 00       	push   $0x1da
+c01094e1:	68 94 d9 10 c0       	push   $0xc010d994
+c01094e6:	e8 0a 6f ff ff       	call   c01003f5 <__panic>
+    }
+    if (current == initproc) {
+c01094eb:	8b 15 28 10 1b c0    	mov    0xc01b1028,%edx
+c01094f1:	a1 24 10 1b c0       	mov    0xc01b1024,%eax
+c01094f6:	39 c2                	cmp    %eax,%edx
+c01094f8:	75 17                	jne    c0109511 <do_exit+0x52>
+        panic("initproc exit.\n");
+c01094fa:	83 ec 04             	sub    $0x4,%esp
+c01094fd:	68 e6 d9 10 c0       	push   $0xc010d9e6
+c0109502:	68 dd 01 00 00       	push   $0x1dd
+c0109507:	68 94 d9 10 c0       	push   $0xc010d994
+c010950c:	e8 e4 6e ff ff       	call   c01003f5 <__panic>
+    }
+    
+    struct mm_struct *mm = current->mm;
+c0109511:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c0109516:	8b 40 18             	mov    0x18(%eax),%eax
+c0109519:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if (mm != NULL) {
+c010951c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0109520:	74 56                	je     c0109578 <do_exit+0xb9>
+        lcr3(boot_cr3);
+c0109522:	a1 80 30 1b c0       	mov    0xc01b3080,%eax
+c0109527:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c010952a:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010952d:	0f 22 d8             	mov    %eax,%cr3
+        if (mm_count_dec(mm) == 0) {
+c0109530:	83 ec 0c             	sub    $0xc,%esp
+c0109533:	ff 75 f4             	pushl  -0xc(%ebp)
+c0109536:	e8 32 f5 ff ff       	call   c0108a6d <mm_count_dec>
+c010953b:	83 c4 10             	add    $0x10,%esp
+c010953e:	85 c0                	test   %eax,%eax
+c0109540:	75 2a                	jne    c010956c <do_exit+0xad>
+            exit_mmap(mm);
+c0109542:	83 ec 0c             	sub    $0xc,%esp
+c0109545:	ff 75 f4             	pushl  -0xc(%ebp)
+c0109548:	e8 cf c5 ff ff       	call   c0105b1c <exit_mmap>
+c010954d:	83 c4 10             	add    $0x10,%esp
+            put_pgdir(mm);
+c0109550:	83 ec 0c             	sub    $0xc,%esp
+c0109553:	ff 75 f4             	pushl  -0xc(%ebp)
+c0109556:	e8 5e fc ff ff       	call   c01091b9 <put_pgdir>
+c010955b:	83 c4 10             	add    $0x10,%esp
+            mm_destroy(mm);
+c010955e:	83 ec 0c             	sub    $0xc,%esp
+c0109561:	ff 75 f4             	pushl  -0xc(%ebp)
+c0109564:	e8 25 c3 ff ff       	call   c010588e <mm_destroy>
+c0109569:	83 c4 10             	add    $0x10,%esp
+        }
+        current->mm = NULL;
+c010956c:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c0109571:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
+    }
+    current->state = PROC_ZOMBIE;
+c0109578:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c010957d:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
+    current->exit_code = error_code;
+c0109583:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c0109588:	8b 55 08             	mov    0x8(%ebp),%edx
+c010958b:	89 50 68             	mov    %edx,0x68(%eax)
+    
+    bool intr_flag;
+    struct proc_struct *proc;
+    local_intr_save(intr_flag);
+c010958e:	e8 31 f3 ff ff       	call   c01088c4 <__intr_save>
+c0109593:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    {
+        proc = current->parent;
+c0109596:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c010959b:	8b 40 14             	mov    0x14(%eax),%eax
+c010959e:	89 45 ec             	mov    %eax,-0x14(%ebp)
+        if (proc->wait_state == WT_CHILD) {
+c01095a1:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01095a4:	8b 40 6c             	mov    0x6c(%eax),%eax
+c01095a7:	3d 01 00 00 80       	cmp    $0x80000001,%eax
+c01095ac:	0f 85 9d 00 00 00    	jne    c010964f <do_exit+0x190>
+            wakeup_proc(proc);
+c01095b2:	83 ec 0c             	sub    $0xc,%esp
+c01095b5:	ff 75 ec             	pushl  -0x14(%ebp)
+c01095b8:	e8 f2 0e 00 00       	call   c010a4af <wakeup_proc>
+c01095bd:	83 c4 10             	add    $0x10,%esp
+        }
+        while (current->cptr != NULL) {
+c01095c0:	e9 8a 00 00 00       	jmp    c010964f <do_exit+0x190>
+            proc = current->cptr;
+c01095c5:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c01095ca:	8b 40 70             	mov    0x70(%eax),%eax
+c01095cd:	89 45 ec             	mov    %eax,-0x14(%ebp)
+            current->cptr = proc->optr;
+c01095d0:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c01095d5:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c01095d8:	8b 52 78             	mov    0x78(%edx),%edx
+c01095db:	89 50 70             	mov    %edx,0x70(%eax)
+    
+            proc->yptr = NULL;
+c01095de:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01095e1:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
+            if ((proc->optr = initproc->cptr) != NULL) {
+c01095e8:	a1 24 10 1b c0       	mov    0xc01b1024,%eax
+c01095ed:	8b 50 70             	mov    0x70(%eax),%edx
+c01095f0:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01095f3:	89 50 78             	mov    %edx,0x78(%eax)
+c01095f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01095f9:	8b 40 78             	mov    0x78(%eax),%eax
+c01095fc:	85 c0                	test   %eax,%eax
+c01095fe:	74 0e                	je     c010960e <do_exit+0x14f>
+                initproc->cptr->yptr = proc;
+c0109600:	a1 24 10 1b c0       	mov    0xc01b1024,%eax
+c0109605:	8b 40 70             	mov    0x70(%eax),%eax
+c0109608:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c010960b:	89 50 74             	mov    %edx,0x74(%eax)
+            }
+            proc->parent = initproc;
+c010960e:	8b 15 24 10 1b c0    	mov    0xc01b1024,%edx
+c0109614:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0109617:	89 50 14             	mov    %edx,0x14(%eax)
+            initproc->cptr = proc;
+c010961a:	a1 24 10 1b c0       	mov    0xc01b1024,%eax
+c010961f:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c0109622:	89 50 70             	mov    %edx,0x70(%eax)
+            if (proc->state == PROC_ZOMBIE) {
+c0109625:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0109628:	8b 00                	mov    (%eax),%eax
+c010962a:	83 f8 03             	cmp    $0x3,%eax
+c010962d:	75 20                	jne    c010964f <do_exit+0x190>
+                if (initproc->wait_state == WT_CHILD) {
+c010962f:	a1 24 10 1b c0       	mov    0xc01b1024,%eax
+c0109634:	8b 40 6c             	mov    0x6c(%eax),%eax
+c0109637:	3d 01 00 00 80       	cmp    $0x80000001,%eax
+c010963c:	75 11                	jne    c010964f <do_exit+0x190>
+                    wakeup_proc(initproc);
+c010963e:	a1 24 10 1b c0       	mov    0xc01b1024,%eax
+c0109643:	83 ec 0c             	sub    $0xc,%esp
+c0109646:	50                   	push   %eax
+c0109647:	e8 63 0e 00 00       	call   c010a4af <wakeup_proc>
+c010964c:	83 c4 10             	add    $0x10,%esp
+    {
+        proc = current->parent;
+        if (proc->wait_state == WT_CHILD) {
+            wakeup_proc(proc);
+        }
+        while (current->cptr != NULL) {
+c010964f:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c0109654:	8b 40 70             	mov    0x70(%eax),%eax
+c0109657:	85 c0                	test   %eax,%eax
+c0109659:	0f 85 66 ff ff ff    	jne    c01095c5 <do_exit+0x106>
+                    wakeup_proc(initproc);
+                }
+            }
+        }
+    }
+    local_intr_restore(intr_flag);
+c010965f:	83 ec 0c             	sub    $0xc,%esp
+c0109662:	ff 75 f0             	pushl  -0x10(%ebp)
+c0109665:	e8 84 f2 ff ff       	call   c01088ee <__intr_restore>
+c010966a:	83 c4 10             	add    $0x10,%esp
+    
+    schedule();
+c010966d:	e8 ca 0e 00 00       	call   c010a53c <schedule>
+    panic("do_exit will not return!! %d.\n", current->pid);
+c0109672:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c0109677:	8b 40 04             	mov    0x4(%eax),%eax
+c010967a:	50                   	push   %eax
+c010967b:	68 f8 d9 10 c0       	push   $0xc010d9f8
+c0109680:	68 09 02 00 00       	push   $0x209
+c0109685:	68 94 d9 10 c0       	push   $0xc010d994
+c010968a:	e8 66 6d ff ff       	call   c01003f5 <__panic>
+
+c010968f <load_icode>:
+/* load_icode - load the content of binary program(ELF format) as the new content of current process
+ * @binary:  the memory addr of the content of binary program
+ * @size:  the size of the content of binary program
+ */
+static int
+load_icode(unsigned char *binary, size_t size) {
+c010968f:	55                   	push   %ebp
+c0109690:	89 e5                	mov    %esp,%ebp
+c0109692:	83 ec 58             	sub    $0x58,%esp
+    if (current->mm != NULL) {
+c0109695:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c010969a:	8b 40 18             	mov    0x18(%eax),%eax
+c010969d:	85 c0                	test   %eax,%eax
+c010969f:	74 17                	je     c01096b8 <load_icode+0x29>
+        panic("load_icode: current->mm must be empty.\n");
+c01096a1:	83 ec 04             	sub    $0x4,%esp
+c01096a4:	68 18 da 10 c0       	push   $0xc010da18
+c01096a9:	68 13 02 00 00       	push   $0x213
+c01096ae:	68 94 d9 10 c0       	push   $0xc010d994
+c01096b3:	e8 3d 6d ff ff       	call   c01003f5 <__panic>
+    }
+
+    int ret = -E_NO_MEM;
+c01096b8:	c7 45 f4 fc ff ff ff 	movl   $0xfffffffc,-0xc(%ebp)
+    struct mm_struct *mm;
+    //(1) create a new mm for current process
+    if ((mm = mm_create()) == NULL) {
+c01096bf:	e8 a0 be ff ff       	call   c0105564 <mm_create>
+c01096c4:	89 45 d0             	mov    %eax,-0x30(%ebp)
+c01096c7:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
+c01096cb:	0f 84 90 05 00 00    	je     c0109c61 <load_icode+0x5d2>
+        goto bad_mm;
+    }
+    //(2) create a new PDT, and mm->pgdir= kernel virtual addr of PDT
+    if (setup_pgdir(mm) != 0) {
+c01096d1:	83 ec 0c             	sub    $0xc,%esp
+c01096d4:	ff 75 d0             	pushl  -0x30(%ebp)
+c01096d7:	e8 44 fa ff ff       	call   c0109120 <setup_pgdir>
+c01096dc:	83 c4 10             	add    $0x10,%esp
+c01096df:	85 c0                	test   %eax,%eax
+c01096e1:	0f 85 69 05 00 00    	jne    c0109c50 <load_icode+0x5c1>
+        goto bad_pgdir_cleanup_mm;
+    }
+    //(3) copy TEXT/DATA section, build BSS parts in binary to memory space of process
+    struct Page *page;
+    //(3.1) get the file header of the bianry program (ELF format)
+    struct elfhdr *elf = (struct elfhdr *)binary;
+c01096e7:	8b 45 08             	mov    0x8(%ebp),%eax
+c01096ea:	89 45 cc             	mov    %eax,-0x34(%ebp)
+    //(3.2) get the entry of the program section headers of the bianry program (ELF format)
+    struct proghdr *ph = (struct proghdr *)(binary + elf->e_phoff);
+c01096ed:	8b 45 cc             	mov    -0x34(%ebp),%eax
+c01096f0:	8b 50 1c             	mov    0x1c(%eax),%edx
+c01096f3:	8b 45 08             	mov    0x8(%ebp),%eax
+c01096f6:	01 d0                	add    %edx,%eax
+c01096f8:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    //(3.3) This program is valid?
+    if (elf->e_magic != ELF_MAGIC) {
+c01096fb:	8b 45 cc             	mov    -0x34(%ebp),%eax
+c01096fe:	8b 00                	mov    (%eax),%eax
+c0109700:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
+c0109705:	74 0c                	je     c0109713 <load_icode+0x84>
+        ret = -E_INVAL_ELF;
+c0109707:	c7 45 f4 f8 ff ff ff 	movl   $0xfffffff8,-0xc(%ebp)
+        goto bad_elf_cleanup_pgdir;
+c010970e:	e9 2d 05 00 00       	jmp    c0109c40 <load_icode+0x5b1>
+    }
+
+    uint32_t vm_flags, perm;
+    struct proghdr *ph_end = ph + elf->e_phnum;
+c0109713:	8b 45 cc             	mov    -0x34(%ebp),%eax
+c0109716:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
+c010971a:	0f b7 c0             	movzwl %ax,%eax
+c010971d:	c1 e0 05             	shl    $0x5,%eax
+c0109720:	89 c2                	mov    %eax,%edx
+c0109722:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0109725:	01 d0                	add    %edx,%eax
+c0109727:	89 45 c8             	mov    %eax,-0x38(%ebp)
+    for (; ph < ph_end; ph ++) {
+c010972a:	e9 e0 02 00 00       	jmp    c0109a0f <load_icode+0x380>
+    //(3.4) find every program section headers
+        if (ph->p_type != ELF_PT_LOAD) {
+c010972f:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0109732:	8b 00                	mov    (%eax),%eax
+c0109734:	83 f8 01             	cmp    $0x1,%eax
+c0109737:	0f 85 c7 02 00 00    	jne    c0109a04 <load_icode+0x375>
+            continue ;
+        }
+        if (ph->p_filesz > ph->p_memsz) {
+c010973d:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0109740:	8b 50 10             	mov    0x10(%eax),%edx
+c0109743:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0109746:	8b 40 14             	mov    0x14(%eax),%eax
+c0109749:	39 c2                	cmp    %eax,%edx
+c010974b:	76 0c                	jbe    c0109759 <load_icode+0xca>
+            ret = -E_INVAL_ELF;
+c010974d:	c7 45 f4 f8 ff ff ff 	movl   $0xfffffff8,-0xc(%ebp)
+            goto bad_cleanup_mmap;
+c0109754:	e9 d9 04 00 00       	jmp    c0109c32 <load_icode+0x5a3>
+        }
+        if (ph->p_filesz == 0) {
+c0109759:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010975c:	8b 40 10             	mov    0x10(%eax),%eax
+c010975f:	85 c0                	test   %eax,%eax
+c0109761:	0f 84 a0 02 00 00    	je     c0109a07 <load_icode+0x378>
+            continue ;
+        }
+    //(3.5) call mm_map fun to setup the new vma ( ph->p_va, ph->p_memsz)
+        vm_flags = 0, perm = PTE_U;
+c0109767:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+c010976e:	c7 45 e4 04 00 00 00 	movl   $0x4,-0x1c(%ebp)
+        if (ph->p_flags & ELF_PF_X) vm_flags |= VM_EXEC;
+c0109775:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0109778:	8b 40 18             	mov    0x18(%eax),%eax
+c010977b:	83 e0 01             	and    $0x1,%eax
+c010977e:	85 c0                	test   %eax,%eax
+c0109780:	74 04                	je     c0109786 <load_icode+0xf7>
+c0109782:	83 4d e8 04          	orl    $0x4,-0x18(%ebp)
+        if (ph->p_flags & ELF_PF_W) vm_flags |= VM_WRITE;
+c0109786:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0109789:	8b 40 18             	mov    0x18(%eax),%eax
+c010978c:	83 e0 02             	and    $0x2,%eax
+c010978f:	85 c0                	test   %eax,%eax
+c0109791:	74 04                	je     c0109797 <load_icode+0x108>
+c0109793:	83 4d e8 02          	orl    $0x2,-0x18(%ebp)
+        if (ph->p_flags & ELF_PF_R) vm_flags |= VM_READ;
+c0109797:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010979a:	8b 40 18             	mov    0x18(%eax),%eax
+c010979d:	83 e0 04             	and    $0x4,%eax
+c01097a0:	85 c0                	test   %eax,%eax
+c01097a2:	74 04                	je     c01097a8 <load_icode+0x119>
+c01097a4:	83 4d e8 01          	orl    $0x1,-0x18(%ebp)
+        if (vm_flags & VM_WRITE) perm |= PTE_W;
+c01097a8:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c01097ab:	83 e0 02             	and    $0x2,%eax
+c01097ae:	85 c0                	test   %eax,%eax
+c01097b0:	74 04                	je     c01097b6 <load_icode+0x127>
+c01097b2:	83 4d e4 02          	orl    $0x2,-0x1c(%ebp)
+        if ((ret = mm_map(mm, ph->p_va, ph->p_memsz, vm_flags, NULL)) != 0) {
+c01097b6:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01097b9:	8b 50 14             	mov    0x14(%eax),%edx
+c01097bc:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01097bf:	8b 40 08             	mov    0x8(%eax),%eax
+c01097c2:	83 ec 0c             	sub    $0xc,%esp
+c01097c5:	6a 00                	push   $0x0
+c01097c7:	ff 75 e8             	pushl  -0x18(%ebp)
+c01097ca:	52                   	push   %edx
+c01097cb:	50                   	push   %eax
+c01097cc:	ff 75 d0             	pushl  -0x30(%ebp)
+c01097cf:	e8 59 c1 ff ff       	call   c010592d <mm_map>
+c01097d4:	83 c4 20             	add    $0x20,%esp
+c01097d7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c01097da:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c01097de:	0f 85 44 04 00 00    	jne    c0109c28 <load_icode+0x599>
+            goto bad_cleanup_mmap;
+        }
+        unsigned char *from = binary + ph->p_offset;
+c01097e4:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01097e7:	8b 50 04             	mov    0x4(%eax),%edx
+c01097ea:	8b 45 08             	mov    0x8(%ebp),%eax
+c01097ed:	01 d0                	add    %edx,%eax
+c01097ef:	89 45 e0             	mov    %eax,-0x20(%ebp)
+        size_t off, size;
+        uintptr_t start = ph->p_va, end, la = ROUNDDOWN(start, PGSIZE);
+c01097f2:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01097f5:	8b 40 08             	mov    0x8(%eax),%eax
+c01097f8:	89 45 d8             	mov    %eax,-0x28(%ebp)
+c01097fb:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c01097fe:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+c0109801:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+c0109804:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+c0109809:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+
+        ret = -E_NO_MEM;
+c010980c:	c7 45 f4 fc ff ff ff 	movl   $0xfffffffc,-0xc(%ebp)
+
+     //(3.6) alloc memory, and  copy the contents of every program section (from, from+end) to process's memory (la, la+end)
+        end = ph->p_va + ph->p_filesz;
+c0109813:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0109816:	8b 50 08             	mov    0x8(%eax),%edx
+c0109819:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010981c:	8b 40 10             	mov    0x10(%eax),%eax
+c010981f:	01 d0                	add    %edx,%eax
+c0109821:	89 45 c0             	mov    %eax,-0x40(%ebp)
+     //(3.6.1) copy TEXT/DATA section of bianry program
+        while (start < end) {
+c0109824:	e9 84 00 00 00       	jmp    c01098ad <load_icode+0x21e>
+            if ((page = pgdir_alloc_page(mm->pgdir, la, perm)) == NULL) {
+c0109829:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c010982c:	8b 40 0c             	mov    0xc(%eax),%eax
+c010982f:	83 ec 04             	sub    $0x4,%esp
+c0109832:	ff 75 e4             	pushl  -0x1c(%ebp)
+c0109835:	ff 75 d4             	pushl  -0x2c(%ebp)
+c0109838:	50                   	push   %eax
+c0109839:	e8 a9 ac ff ff       	call   c01044e7 <pgdir_alloc_page>
+c010983e:	83 c4 10             	add    $0x10,%esp
+c0109841:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0109844:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c0109848:	0f 84 dd 03 00 00    	je     c0109c2b <load_icode+0x59c>
+                goto bad_cleanup_mmap;
+            }
+            off = start - la, size = PGSIZE - off, la += PGSIZE;
+c010984e:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c0109851:	2b 45 d4             	sub    -0x2c(%ebp),%eax
+c0109854:	89 45 bc             	mov    %eax,-0x44(%ebp)
+c0109857:	b8 00 10 00 00       	mov    $0x1000,%eax
+c010985c:	2b 45 bc             	sub    -0x44(%ebp),%eax
+c010985f:	89 45 dc             	mov    %eax,-0x24(%ebp)
+c0109862:	81 45 d4 00 10 00 00 	addl   $0x1000,-0x2c(%ebp)
+            if (end < la) {
+c0109869:	8b 45 c0             	mov    -0x40(%ebp),%eax
+c010986c:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
+c010986f:	73 09                	jae    c010987a <load_icode+0x1eb>
+                size -= la - end;
+c0109871:	8b 45 c0             	mov    -0x40(%ebp),%eax
+c0109874:	2b 45 d4             	sub    -0x2c(%ebp),%eax
+c0109877:	01 45 dc             	add    %eax,-0x24(%ebp)
+            }
+            memcpy(page2kva(page) + off, from, size);
+c010987a:	83 ec 0c             	sub    $0xc,%esp
+c010987d:	ff 75 f0             	pushl  -0x10(%ebp)
+c0109880:	e8 4a f1 ff ff       	call   c01089cf <page2kva>
+c0109885:	83 c4 10             	add    $0x10,%esp
+c0109888:	89 c2                	mov    %eax,%edx
+c010988a:	8b 45 bc             	mov    -0x44(%ebp),%eax
+c010988d:	01 d0                	add    %edx,%eax
+c010988f:	83 ec 04             	sub    $0x4,%esp
+c0109892:	ff 75 dc             	pushl  -0x24(%ebp)
+c0109895:	ff 75 e0             	pushl  -0x20(%ebp)
+c0109898:	50                   	push   %eax
+c0109899:	e8 9d 18 00 00       	call   c010b13b <memcpy>
+c010989e:	83 c4 10             	add    $0x10,%esp
+            start += size, from += size;
+c01098a1:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c01098a4:	01 45 d8             	add    %eax,-0x28(%ebp)
+c01098a7:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c01098aa:	01 45 e0             	add    %eax,-0x20(%ebp)
+        ret = -E_NO_MEM;
+
+     //(3.6) alloc memory, and  copy the contents of every program section (from, from+end) to process's memory (la, la+end)
+        end = ph->p_va + ph->p_filesz;
+     //(3.6.1) copy TEXT/DATA section of bianry program
+        while (start < end) {
+c01098ad:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c01098b0:	3b 45 c0             	cmp    -0x40(%ebp),%eax
+c01098b3:	0f 82 70 ff ff ff    	jb     c0109829 <load_icode+0x19a>
+            memcpy(page2kva(page) + off, from, size);
+            start += size, from += size;
+        }
+
+      //(3.6.2) build BSS section of binary program
+        end = ph->p_va + ph->p_memsz;
+c01098b9:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01098bc:	8b 50 08             	mov    0x8(%eax),%edx
+c01098bf:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01098c2:	8b 40 14             	mov    0x14(%eax),%eax
+c01098c5:	01 d0                	add    %edx,%eax
+c01098c7:	89 45 c0             	mov    %eax,-0x40(%ebp)
+        if (start < la) {
+c01098ca:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c01098cd:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
+c01098d0:	0f 83 20 01 00 00    	jae    c01099f6 <load_icode+0x367>
+            /* ph->p_memsz == ph->p_filesz */
+            if (start == end) {
+c01098d6:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c01098d9:	3b 45 c0             	cmp    -0x40(%ebp),%eax
+c01098dc:	0f 84 28 01 00 00    	je     c0109a0a <load_icode+0x37b>
+                continue ;
+            }
+            off = start + PGSIZE - la, size = PGSIZE - off;
+c01098e2:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c01098e5:	2b 45 d4             	sub    -0x2c(%ebp),%eax
+c01098e8:	05 00 10 00 00       	add    $0x1000,%eax
+c01098ed:	89 45 bc             	mov    %eax,-0x44(%ebp)
+c01098f0:	b8 00 10 00 00       	mov    $0x1000,%eax
+c01098f5:	2b 45 bc             	sub    -0x44(%ebp),%eax
+c01098f8:	89 45 dc             	mov    %eax,-0x24(%ebp)
+            if (end < la) {
+c01098fb:	8b 45 c0             	mov    -0x40(%ebp),%eax
+c01098fe:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
+c0109901:	73 09                	jae    c010990c <load_icode+0x27d>
+                size -= la - end;
+c0109903:	8b 45 c0             	mov    -0x40(%ebp),%eax
+c0109906:	2b 45 d4             	sub    -0x2c(%ebp),%eax
+c0109909:	01 45 dc             	add    %eax,-0x24(%ebp)
+            }
+            memset(page2kva(page) + off, 0, size);
+c010990c:	83 ec 0c             	sub    $0xc,%esp
+c010990f:	ff 75 f0             	pushl  -0x10(%ebp)
+c0109912:	e8 b8 f0 ff ff       	call   c01089cf <page2kva>
+c0109917:	83 c4 10             	add    $0x10,%esp
+c010991a:	89 c2                	mov    %eax,%edx
+c010991c:	8b 45 bc             	mov    -0x44(%ebp),%eax
+c010991f:	01 d0                	add    %edx,%eax
+c0109921:	83 ec 04             	sub    $0x4,%esp
+c0109924:	ff 75 dc             	pushl  -0x24(%ebp)
+c0109927:	6a 00                	push   $0x0
+c0109929:	50                   	push   %eax
+c010992a:	e8 29 17 00 00       	call   c010b058 <memset>
+c010992f:	83 c4 10             	add    $0x10,%esp
+            start += size;
+c0109932:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0109935:	01 45 d8             	add    %eax,-0x28(%ebp)
+            assert((end < la && start == end) || (end >= la && start == la));
+c0109938:	8b 45 c0             	mov    -0x40(%ebp),%eax
+c010993b:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
+c010993e:	73 0c                	jae    c010994c <load_icode+0x2bd>
+c0109940:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c0109943:	3b 45 c0             	cmp    -0x40(%ebp),%eax
+c0109946:	0f 84 aa 00 00 00    	je     c01099f6 <load_icode+0x367>
+c010994c:	8b 45 c0             	mov    -0x40(%ebp),%eax
+c010994f:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
+c0109952:	72 0c                	jb     c0109960 <load_icode+0x2d1>
+c0109954:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c0109957:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
+c010995a:	0f 84 96 00 00 00    	je     c01099f6 <load_icode+0x367>
+c0109960:	68 40 da 10 c0       	push   $0xc010da40
+c0109965:	68 c1 d9 10 c0       	push   $0xc010d9c1
+c010996a:	68 65 02 00 00       	push   $0x265
+c010996f:	68 94 d9 10 c0       	push   $0xc010d994
+c0109974:	e8 7c 6a ff ff       	call   c01003f5 <__panic>
+        }
+        while (start < end) {
+            if ((page = pgdir_alloc_page(mm->pgdir, la, perm)) == NULL) {
+c0109979:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c010997c:	8b 40 0c             	mov    0xc(%eax),%eax
+c010997f:	83 ec 04             	sub    $0x4,%esp
+c0109982:	ff 75 e4             	pushl  -0x1c(%ebp)
+c0109985:	ff 75 d4             	pushl  -0x2c(%ebp)
+c0109988:	50                   	push   %eax
+c0109989:	e8 59 ab ff ff       	call   c01044e7 <pgdir_alloc_page>
+c010998e:	83 c4 10             	add    $0x10,%esp
+c0109991:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0109994:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c0109998:	0f 84 90 02 00 00    	je     c0109c2e <load_icode+0x59f>
+                goto bad_cleanup_mmap;
+            }
+            off = start - la, size = PGSIZE - off, la += PGSIZE;
+c010999e:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c01099a1:	2b 45 d4             	sub    -0x2c(%ebp),%eax
+c01099a4:	89 45 bc             	mov    %eax,-0x44(%ebp)
+c01099a7:	b8 00 10 00 00       	mov    $0x1000,%eax
+c01099ac:	2b 45 bc             	sub    -0x44(%ebp),%eax
+c01099af:	89 45 dc             	mov    %eax,-0x24(%ebp)
+c01099b2:	81 45 d4 00 10 00 00 	addl   $0x1000,-0x2c(%ebp)
+            if (end < la) {
+c01099b9:	8b 45 c0             	mov    -0x40(%ebp),%eax
+c01099bc:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
+c01099bf:	73 09                	jae    c01099ca <load_icode+0x33b>
+                size -= la - end;
+c01099c1:	8b 45 c0             	mov    -0x40(%ebp),%eax
+c01099c4:	2b 45 d4             	sub    -0x2c(%ebp),%eax
+c01099c7:	01 45 dc             	add    %eax,-0x24(%ebp)
+            }
+            memset(page2kva(page) + off, 0, size);
+c01099ca:	83 ec 0c             	sub    $0xc,%esp
+c01099cd:	ff 75 f0             	pushl  -0x10(%ebp)
+c01099d0:	e8 fa ef ff ff       	call   c01089cf <page2kva>
+c01099d5:	83 c4 10             	add    $0x10,%esp
+c01099d8:	89 c2                	mov    %eax,%edx
+c01099da:	8b 45 bc             	mov    -0x44(%ebp),%eax
+c01099dd:	01 d0                	add    %edx,%eax
+c01099df:	83 ec 04             	sub    $0x4,%esp
+c01099e2:	ff 75 dc             	pushl  -0x24(%ebp)
+c01099e5:	6a 00                	push   $0x0
+c01099e7:	50                   	push   %eax
+c01099e8:	e8 6b 16 00 00       	call   c010b058 <memset>
+c01099ed:	83 c4 10             	add    $0x10,%esp
+            start += size;
+c01099f0:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c01099f3:	01 45 d8             	add    %eax,-0x28(%ebp)
+            }
+            memset(page2kva(page) + off, 0, size);
+            start += size;
+            assert((end < la && start == end) || (end >= la && start == la));
+        }
+        while (start < end) {
+c01099f6:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c01099f9:	3b 45 c0             	cmp    -0x40(%ebp),%eax
+c01099fc:	0f 82 77 ff ff ff    	jb     c0109979 <load_icode+0x2ea>
+c0109a02:	eb 07                	jmp    c0109a0b <load_icode+0x37c>
+    uint32_t vm_flags, perm;
+    struct proghdr *ph_end = ph + elf->e_phnum;
+    for (; ph < ph_end; ph ++) {
+    //(3.4) find every program section headers
+        if (ph->p_type != ELF_PT_LOAD) {
+            continue ;
+c0109a04:	90                   	nop
+c0109a05:	eb 04                	jmp    c0109a0b <load_icode+0x37c>
+        if (ph->p_filesz > ph->p_memsz) {
+            ret = -E_INVAL_ELF;
+            goto bad_cleanup_mmap;
+        }
+        if (ph->p_filesz == 0) {
+            continue ;
+c0109a07:	90                   	nop
+c0109a08:	eb 01                	jmp    c0109a0b <load_icode+0x37c>
+      //(3.6.2) build BSS section of binary program
+        end = ph->p_va + ph->p_memsz;
+        if (start < la) {
+            /* ph->p_memsz == ph->p_filesz */
+            if (start == end) {
+                continue ;
+c0109a0a:	90                   	nop
+        goto bad_elf_cleanup_pgdir;
+    }
+
+    uint32_t vm_flags, perm;
+    struct proghdr *ph_end = ph + elf->e_phnum;
+    for (; ph < ph_end; ph ++) {
+c0109a0b:	83 45 ec 20          	addl   $0x20,-0x14(%ebp)
+c0109a0f:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0109a12:	3b 45 c8             	cmp    -0x38(%ebp),%eax
+c0109a15:	0f 82 14 fd ff ff    	jb     c010972f <load_icode+0xa0>
+            memset(page2kva(page) + off, 0, size);
+            start += size;
+        }
+    }
+    //(4) build user stack memory
+    vm_flags = VM_READ | VM_WRITE | VM_STACK;
+c0109a1b:	c7 45 e8 0b 00 00 00 	movl   $0xb,-0x18(%ebp)
+    if ((ret = mm_map(mm, USTACKTOP - USTACKSIZE, USTACKSIZE, vm_flags, NULL)) != 0) {
+c0109a22:	83 ec 0c             	sub    $0xc,%esp
+c0109a25:	6a 00                	push   $0x0
+c0109a27:	ff 75 e8             	pushl  -0x18(%ebp)
+c0109a2a:	68 00 00 10 00       	push   $0x100000
+c0109a2f:	68 00 00 f0 af       	push   $0xaff00000
+c0109a34:	ff 75 d0             	pushl  -0x30(%ebp)
+c0109a37:	e8 f1 be ff ff       	call   c010592d <mm_map>
+c0109a3c:	83 c4 20             	add    $0x20,%esp
+c0109a3f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0109a42:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0109a46:	0f 85 e5 01 00 00    	jne    c0109c31 <load_icode+0x5a2>
+        goto bad_cleanup_mmap;
+    }
+    assert(pgdir_alloc_page(mm->pgdir, USTACKTOP-PGSIZE , PTE_USER) != NULL);
+c0109a4c:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c0109a4f:	8b 40 0c             	mov    0xc(%eax),%eax
+c0109a52:	83 ec 04             	sub    $0x4,%esp
+c0109a55:	6a 07                	push   $0x7
+c0109a57:	68 00 f0 ff af       	push   $0xaffff000
+c0109a5c:	50                   	push   %eax
+c0109a5d:	e8 85 aa ff ff       	call   c01044e7 <pgdir_alloc_page>
+c0109a62:	83 c4 10             	add    $0x10,%esp
+c0109a65:	85 c0                	test   %eax,%eax
+c0109a67:	75 19                	jne    c0109a82 <load_icode+0x3f3>
+c0109a69:	68 7c da 10 c0       	push   $0xc010da7c
+c0109a6e:	68 c1 d9 10 c0       	push   $0xc010d9c1
+c0109a73:	68 78 02 00 00       	push   $0x278
+c0109a78:	68 94 d9 10 c0       	push   $0xc010d994
+c0109a7d:	e8 73 69 ff ff       	call   c01003f5 <__panic>
+    assert(pgdir_alloc_page(mm->pgdir, USTACKTOP-2*PGSIZE , PTE_USER) != NULL);
+c0109a82:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c0109a85:	8b 40 0c             	mov    0xc(%eax),%eax
+c0109a88:	83 ec 04             	sub    $0x4,%esp
+c0109a8b:	6a 07                	push   $0x7
+c0109a8d:	68 00 e0 ff af       	push   $0xafffe000
+c0109a92:	50                   	push   %eax
+c0109a93:	e8 4f aa ff ff       	call   c01044e7 <pgdir_alloc_page>
+c0109a98:	83 c4 10             	add    $0x10,%esp
+c0109a9b:	85 c0                	test   %eax,%eax
+c0109a9d:	75 19                	jne    c0109ab8 <load_icode+0x429>
+c0109a9f:	68 c0 da 10 c0       	push   $0xc010dac0
+c0109aa4:	68 c1 d9 10 c0       	push   $0xc010d9c1
+c0109aa9:	68 79 02 00 00       	push   $0x279
+c0109aae:	68 94 d9 10 c0       	push   $0xc010d994
+c0109ab3:	e8 3d 69 ff ff       	call   c01003f5 <__panic>
+    assert(pgdir_alloc_page(mm->pgdir, USTACKTOP-3*PGSIZE , PTE_USER) != NULL);
+c0109ab8:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c0109abb:	8b 40 0c             	mov    0xc(%eax),%eax
+c0109abe:	83 ec 04             	sub    $0x4,%esp
+c0109ac1:	6a 07                	push   $0x7
+c0109ac3:	68 00 d0 ff af       	push   $0xafffd000
+c0109ac8:	50                   	push   %eax
+c0109ac9:	e8 19 aa ff ff       	call   c01044e7 <pgdir_alloc_page>
+c0109ace:	83 c4 10             	add    $0x10,%esp
+c0109ad1:	85 c0                	test   %eax,%eax
+c0109ad3:	75 19                	jne    c0109aee <load_icode+0x45f>
+c0109ad5:	68 04 db 10 c0       	push   $0xc010db04
+c0109ada:	68 c1 d9 10 c0       	push   $0xc010d9c1
+c0109adf:	68 7a 02 00 00       	push   $0x27a
+c0109ae4:	68 94 d9 10 c0       	push   $0xc010d994
+c0109ae9:	e8 07 69 ff ff       	call   c01003f5 <__panic>
+    assert(pgdir_alloc_page(mm->pgdir, USTACKTOP-4*PGSIZE , PTE_USER) != NULL);
+c0109aee:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c0109af1:	8b 40 0c             	mov    0xc(%eax),%eax
+c0109af4:	83 ec 04             	sub    $0x4,%esp
+c0109af7:	6a 07                	push   $0x7
+c0109af9:	68 00 c0 ff af       	push   $0xafffc000
+c0109afe:	50                   	push   %eax
+c0109aff:	e8 e3 a9 ff ff       	call   c01044e7 <pgdir_alloc_page>
+c0109b04:	83 c4 10             	add    $0x10,%esp
+c0109b07:	85 c0                	test   %eax,%eax
+c0109b09:	75 19                	jne    c0109b24 <load_icode+0x495>
+c0109b0b:	68 48 db 10 c0       	push   $0xc010db48
+c0109b10:	68 c1 d9 10 c0       	push   $0xc010d9c1
+c0109b15:	68 7b 02 00 00       	push   $0x27b
+c0109b1a:	68 94 d9 10 c0       	push   $0xc010d994
+c0109b1f:	e8 d1 68 ff ff       	call   c01003f5 <__panic>
+    
+    //(5) set current process's mm, sr3, and set CR3 reg = physical addr of Page Directory
+    mm_count_inc(mm);
+c0109b24:	83 ec 0c             	sub    $0xc,%esp
+c0109b27:	ff 75 d0             	pushl  -0x30(%ebp)
+c0109b2a:	e8 24 ef ff ff       	call   c0108a53 <mm_count_inc>
+c0109b2f:	83 c4 10             	add    $0x10,%esp
+    current->mm = mm;
+c0109b32:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c0109b37:	8b 55 d0             	mov    -0x30(%ebp),%edx
+c0109b3a:	89 50 18             	mov    %edx,0x18(%eax)
+    current->cr3 = PADDR(mm->pgdir);
+c0109b3d:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c0109b42:	8b 55 d0             	mov    -0x30(%ebp),%edx
+c0109b45:	8b 52 0c             	mov    0xc(%edx),%edx
+c0109b48:	89 55 b8             	mov    %edx,-0x48(%ebp)
+c0109b4b:	81 7d b8 ff ff ff bf 	cmpl   $0xbfffffff,-0x48(%ebp)
+c0109b52:	77 17                	ja     c0109b6b <load_icode+0x4dc>
+c0109b54:	ff 75 b8             	pushl  -0x48(%ebp)
+c0109b57:	68 70 d9 10 c0       	push   $0xc010d970
+c0109b5c:	68 80 02 00 00       	push   $0x280
+c0109b61:	68 94 d9 10 c0       	push   $0xc010d994
+c0109b66:	e8 8a 68 ff ff       	call   c01003f5 <__panic>
+c0109b6b:	8b 55 b8             	mov    -0x48(%ebp),%edx
+c0109b6e:	81 c2 00 00 00 40    	add    $0x40000000,%edx
+c0109b74:	89 50 40             	mov    %edx,0x40(%eax)
+    lcr3(PADDR(mm->pgdir));
+c0109b77:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c0109b7a:	8b 40 0c             	mov    0xc(%eax),%eax
+c0109b7d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
+c0109b80:	81 7d b4 ff ff ff bf 	cmpl   $0xbfffffff,-0x4c(%ebp)
+c0109b87:	77 17                	ja     c0109ba0 <load_icode+0x511>
+c0109b89:	ff 75 b4             	pushl  -0x4c(%ebp)
+c0109b8c:	68 70 d9 10 c0       	push   $0xc010d970
+c0109b91:	68 81 02 00 00       	push   $0x281
+c0109b96:	68 94 d9 10 c0       	push   $0xc010d994
+c0109b9b:	e8 55 68 ff ff       	call   c01003f5 <__panic>
+c0109ba0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
+c0109ba3:	05 00 00 00 40       	add    $0x40000000,%eax
+c0109ba8:	89 45 ac             	mov    %eax,-0x54(%ebp)
+c0109bab:	8b 45 ac             	mov    -0x54(%ebp),%eax
+c0109bae:	0f 22 d8             	mov    %eax,%cr3
+
+    //(6) setup trapframe for user environment
+    struct trapframe *tf = current->tf;
+c0109bb1:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c0109bb6:	8b 40 3c             	mov    0x3c(%eax),%eax
+c0109bb9:	89 45 b0             	mov    %eax,-0x50(%ebp)
+    memset(tf, 0, sizeof(struct trapframe));
+c0109bbc:	83 ec 04             	sub    $0x4,%esp
+c0109bbf:	6a 4c                	push   $0x4c
+c0109bc1:	6a 00                	push   $0x0
+c0109bc3:	ff 75 b0             	pushl  -0x50(%ebp)
+c0109bc6:	e8 8d 14 00 00       	call   c010b058 <memset>
+c0109bcb:	83 c4 10             	add    $0x10,%esp
+     *          tf_ds=tf_es=tf_ss should be USER_DS segment
+     *          tf_esp should be the top addr of user stack (USTACKTOP)
+     *          tf_eip should be the entry point of this binary program (elf->e_entry)
+     *          tf_eflags should be set to enable computer to produce Interrupt
+     */
+    tf->tf_cs = USER_CS;
+c0109bce:	8b 45 b0             	mov    -0x50(%ebp),%eax
+c0109bd1:	66 c7 40 3c 1b 00    	movw   $0x1b,0x3c(%eax)
+    tf->tf_ds = tf->tf_es = tf->tf_ss = USER_DS;
+c0109bd7:	8b 45 b0             	mov    -0x50(%ebp),%eax
+c0109bda:	66 c7 40 48 23 00    	movw   $0x23,0x48(%eax)
+c0109be0:	8b 45 b0             	mov    -0x50(%ebp),%eax
+c0109be3:	0f b7 50 48          	movzwl 0x48(%eax),%edx
+c0109be7:	8b 45 b0             	mov    -0x50(%ebp),%eax
+c0109bea:	66 89 50 28          	mov    %dx,0x28(%eax)
+c0109bee:	8b 45 b0             	mov    -0x50(%ebp),%eax
+c0109bf1:	0f b7 50 28          	movzwl 0x28(%eax),%edx
+c0109bf5:	8b 45 b0             	mov    -0x50(%ebp),%eax
+c0109bf8:	66 89 50 2c          	mov    %dx,0x2c(%eax)
+    tf->tf_esp = USTACKTOP;
+c0109bfc:	8b 45 b0             	mov    -0x50(%ebp),%eax
+c0109bff:	c7 40 44 00 00 00 b0 	movl   $0xb0000000,0x44(%eax)
+    tf->tf_eip = elf->e_entry;
+c0109c06:	8b 45 cc             	mov    -0x34(%ebp),%eax
+c0109c09:	8b 50 18             	mov    0x18(%eax),%edx
+c0109c0c:	8b 45 b0             	mov    -0x50(%ebp),%eax
+c0109c0f:	89 50 38             	mov    %edx,0x38(%eax)
+    tf->tf_eflags = 0x00000002 | FL_IF; // to enable interrupt
+c0109c12:	8b 45 b0             	mov    -0x50(%ebp),%eax
+c0109c15:	c7 40 40 02 02 00 00 	movl   $0x202,0x40(%eax)
+    //tf->tf_eflags = FL_IF; // to enable interrupt
+    ret = 0;
+c0109c1c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+out:
+    return ret;
+c0109c23:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0109c26:	eb 3c                	jmp    c0109c64 <load_icode+0x5d5>
+        if (ph->p_flags & ELF_PF_X) vm_flags |= VM_EXEC;
+        if (ph->p_flags & ELF_PF_W) vm_flags |= VM_WRITE;
+        if (ph->p_flags & ELF_PF_R) vm_flags |= VM_READ;
+        if (vm_flags & VM_WRITE) perm |= PTE_W;
+        if ((ret = mm_map(mm, ph->p_va, ph->p_memsz, vm_flags, NULL)) != 0) {
+            goto bad_cleanup_mmap;
+c0109c28:	90                   	nop
+c0109c29:	eb 07                	jmp    c0109c32 <load_icode+0x5a3>
+     //(3.6) alloc memory, and  copy the contents of every program section (from, from+end) to process's memory (la, la+end)
+        end = ph->p_va + ph->p_filesz;
+     //(3.6.1) copy TEXT/DATA section of bianry program
+        while (start < end) {
+            if ((page = pgdir_alloc_page(mm->pgdir, la, perm)) == NULL) {
+                goto bad_cleanup_mmap;
+c0109c2b:	90                   	nop
+c0109c2c:	eb 04                	jmp    c0109c32 <load_icode+0x5a3>
+            start += size;
+            assert((end < la && start == end) || (end >= la && start == la));
+        }
+        while (start < end) {
+            if ((page = pgdir_alloc_page(mm->pgdir, la, perm)) == NULL) {
+                goto bad_cleanup_mmap;
+c0109c2e:	90                   	nop
+c0109c2f:	eb 01                	jmp    c0109c32 <load_icode+0x5a3>
+        }
+    }
+    //(4) build user stack memory
+    vm_flags = VM_READ | VM_WRITE | VM_STACK;
+    if ((ret = mm_map(mm, USTACKTOP - USTACKSIZE, USTACKSIZE, vm_flags, NULL)) != 0) {
+        goto bad_cleanup_mmap;
+c0109c31:	90                   	nop
+    //tf->tf_eflags = FL_IF; // to enable interrupt
+    ret = 0;
+out:
+    return ret;
+bad_cleanup_mmap:
+    exit_mmap(mm);
+c0109c32:	83 ec 0c             	sub    $0xc,%esp
+c0109c35:	ff 75 d0             	pushl  -0x30(%ebp)
+c0109c38:	e8 df be ff ff       	call   c0105b1c <exit_mmap>
+c0109c3d:	83 c4 10             	add    $0x10,%esp
+bad_elf_cleanup_pgdir:
+    put_pgdir(mm);
+c0109c40:	83 ec 0c             	sub    $0xc,%esp
+c0109c43:	ff 75 d0             	pushl  -0x30(%ebp)
+c0109c46:	e8 6e f5 ff ff       	call   c01091b9 <put_pgdir>
+c0109c4b:	83 c4 10             	add    $0x10,%esp
+c0109c4e:	eb 01                	jmp    c0109c51 <load_icode+0x5c2>
+    if ((mm = mm_create()) == NULL) {
+        goto bad_mm;
+    }
+    //(2) create a new PDT, and mm->pgdir= kernel virtual addr of PDT
+    if (setup_pgdir(mm) != 0) {
+        goto bad_pgdir_cleanup_mm;
+c0109c50:	90                   	nop
+bad_cleanup_mmap:
+    exit_mmap(mm);
+bad_elf_cleanup_pgdir:
+    put_pgdir(mm);
+bad_pgdir_cleanup_mm:
+    mm_destroy(mm);
+c0109c51:	83 ec 0c             	sub    $0xc,%esp
+c0109c54:	ff 75 d0             	pushl  -0x30(%ebp)
+c0109c57:	e8 32 bc ff ff       	call   c010588e <mm_destroy>
+c0109c5c:	83 c4 10             	add    $0x10,%esp
+bad_mm:
+    goto out;
+c0109c5f:	eb c2                	jmp    c0109c23 <load_icode+0x594>
+
+    int ret = -E_NO_MEM;
+    struct mm_struct *mm;
+    //(1) create a new mm for current process
+    if ((mm = mm_create()) == NULL) {
+        goto bad_mm;
+c0109c61:	90                   	nop
+bad_elf_cleanup_pgdir:
+    put_pgdir(mm);
+bad_pgdir_cleanup_mm:
+    mm_destroy(mm);
+bad_mm:
+    goto out;
+c0109c62:	eb bf                	jmp    c0109c23 <load_icode+0x594>
+}
+c0109c64:	c9                   	leave  
+c0109c65:	c3                   	ret    
+
+c0109c66 <do_execve>:
+
+// do_execve - call exit_mmap(mm)&put_pgdir(mm) to reclaim memory space of current process
+//           - call load_icode to setup new memory space accroding binary prog.
+int
+do_execve(const char *name, size_t len, unsigned char *binary, size_t size) {
+c0109c66:	55                   	push   %ebp
+c0109c67:	89 e5                	mov    %esp,%ebp
+c0109c69:	83 ec 28             	sub    $0x28,%esp
+    struct mm_struct *mm = current->mm;
+c0109c6c:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c0109c71:	8b 40 18             	mov    0x18(%eax),%eax
+c0109c74:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if (!user_mem_check(mm, (uintptr_t)name, len, 0)) {
+c0109c77:	8b 45 08             	mov    0x8(%ebp),%eax
+c0109c7a:	6a 00                	push   $0x0
+c0109c7c:	ff 75 0c             	pushl  0xc(%ebp)
+c0109c7f:	50                   	push   %eax
+c0109c80:	ff 75 f4             	pushl  -0xc(%ebp)
+c0109c83:	e8 20 c8 ff ff       	call   c01064a8 <user_mem_check>
+c0109c88:	83 c4 10             	add    $0x10,%esp
+c0109c8b:	85 c0                	test   %eax,%eax
+c0109c8d:	75 0a                	jne    c0109c99 <do_execve+0x33>
+        return -E_INVAL;
+c0109c8f:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+c0109c94:	e9 ed 00 00 00       	jmp    c0109d86 <do_execve+0x120>
+    }
+    if (len > PROC_NAME_LEN) {
+c0109c99:	83 7d 0c 0f          	cmpl   $0xf,0xc(%ebp)
+c0109c9d:	76 07                	jbe    c0109ca6 <do_execve+0x40>
+        len = PROC_NAME_LEN;
+c0109c9f:	c7 45 0c 0f 00 00 00 	movl   $0xf,0xc(%ebp)
+    }
+
+    char local_name[PROC_NAME_LEN + 1];
+    memset(local_name, 0, sizeof(local_name));
+c0109ca6:	83 ec 04             	sub    $0x4,%esp
+c0109ca9:	6a 10                	push   $0x10
+c0109cab:	6a 00                	push   $0x0
+c0109cad:	8d 45 dc             	lea    -0x24(%ebp),%eax
+c0109cb0:	50                   	push   %eax
+c0109cb1:	e8 a2 13 00 00       	call   c010b058 <memset>
+c0109cb6:	83 c4 10             	add    $0x10,%esp
+    memcpy(local_name, name, len);
+c0109cb9:	83 ec 04             	sub    $0x4,%esp
+c0109cbc:	ff 75 0c             	pushl  0xc(%ebp)
+c0109cbf:	ff 75 08             	pushl  0x8(%ebp)
+c0109cc2:	8d 45 dc             	lea    -0x24(%ebp),%eax
+c0109cc5:	50                   	push   %eax
+c0109cc6:	e8 70 14 00 00       	call   c010b13b <memcpy>
+c0109ccb:	83 c4 10             	add    $0x10,%esp
+
+    if (mm != NULL) {
+c0109cce:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0109cd2:	74 56                	je     c0109d2a <do_execve+0xc4>
+        lcr3(boot_cr3);
+c0109cd4:	a1 80 30 1b c0       	mov    0xc01b3080,%eax
+c0109cd9:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0109cdc:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0109cdf:	0f 22 d8             	mov    %eax,%cr3
+        if (mm_count_dec(mm) == 0) {
+c0109ce2:	83 ec 0c             	sub    $0xc,%esp
+c0109ce5:	ff 75 f4             	pushl  -0xc(%ebp)
+c0109ce8:	e8 80 ed ff ff       	call   c0108a6d <mm_count_dec>
+c0109ced:	83 c4 10             	add    $0x10,%esp
+c0109cf0:	85 c0                	test   %eax,%eax
+c0109cf2:	75 2a                	jne    c0109d1e <do_execve+0xb8>
+            exit_mmap(mm);
+c0109cf4:	83 ec 0c             	sub    $0xc,%esp
+c0109cf7:	ff 75 f4             	pushl  -0xc(%ebp)
+c0109cfa:	e8 1d be ff ff       	call   c0105b1c <exit_mmap>
+c0109cff:	83 c4 10             	add    $0x10,%esp
+            put_pgdir(mm);
+c0109d02:	83 ec 0c             	sub    $0xc,%esp
+c0109d05:	ff 75 f4             	pushl  -0xc(%ebp)
+c0109d08:	e8 ac f4 ff ff       	call   c01091b9 <put_pgdir>
+c0109d0d:	83 c4 10             	add    $0x10,%esp
+            mm_destroy(mm);
+c0109d10:	83 ec 0c             	sub    $0xc,%esp
+c0109d13:	ff 75 f4             	pushl  -0xc(%ebp)
+c0109d16:	e8 73 bb ff ff       	call   c010588e <mm_destroy>
+c0109d1b:	83 c4 10             	add    $0x10,%esp
+        }
+        current->mm = NULL;
+c0109d1e:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c0109d23:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
+    }
+    int ret;
+    if ((ret = load_icode(binary, size)) != 0) {
+c0109d2a:	83 ec 08             	sub    $0x8,%esp
+c0109d2d:	ff 75 14             	pushl  0x14(%ebp)
+c0109d30:	ff 75 10             	pushl  0x10(%ebp)
+c0109d33:	e8 57 f9 ff ff       	call   c010968f <load_icode>
+c0109d38:	83 c4 10             	add    $0x10,%esp
+c0109d3b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0109d3e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c0109d42:	75 1c                	jne    c0109d60 <do_execve+0xfa>
+        goto execve_exit;
+    }
+    set_proc_name(current, local_name);
+c0109d44:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c0109d49:	83 ec 08             	sub    $0x8,%esp
+c0109d4c:	8d 55 dc             	lea    -0x24(%ebp),%edx
+c0109d4f:	52                   	push   %edx
+c0109d50:	50                   	push   %eax
+c0109d51:	e8 b7 ee ff ff       	call   c0108c0d <set_proc_name>
+c0109d56:	83 c4 10             	add    $0x10,%esp
+    return 0;
+c0109d59:	b8 00 00 00 00       	mov    $0x0,%eax
+c0109d5e:	eb 26                	jmp    c0109d86 <do_execve+0x120>
+        }
+        current->mm = NULL;
+    }
+    int ret;
+    if ((ret = load_icode(binary, size)) != 0) {
+        goto execve_exit;
+c0109d60:	90                   	nop
+    }
+    set_proc_name(current, local_name);
+    return 0;
+
+execve_exit:
+    do_exit(ret);
+c0109d61:	83 ec 0c             	sub    $0xc,%esp
+c0109d64:	ff 75 f0             	pushl  -0x10(%ebp)
+c0109d67:	e8 53 f7 ff ff       	call   c01094bf <do_exit>
+c0109d6c:	83 c4 10             	add    $0x10,%esp
+    panic("already exit: %e.\n", ret);
+c0109d6f:	ff 75 f0             	pushl  -0x10(%ebp)
+c0109d72:	68 8b db 10 c0       	push   $0xc010db8b
+c0109d77:	68 c4 02 00 00       	push   $0x2c4
+c0109d7c:	68 94 d9 10 c0       	push   $0xc010d994
+c0109d81:	e8 6f 66 ff ff       	call   c01003f5 <__panic>
+}
+c0109d86:	c9                   	leave  
+c0109d87:	c3                   	ret    
+
+c0109d88 <do_yield>:
+
+// do_yield - ask the scheduler to reschedule
+int
+do_yield(void) {
+c0109d88:	55                   	push   %ebp
+c0109d89:	89 e5                	mov    %esp,%ebp
+    current->need_resched = 1;
+c0109d8b:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c0109d90:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
+    return 0;
+c0109d97:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c0109d9c:	5d                   	pop    %ebp
+c0109d9d:	c3                   	ret    
+
+c0109d9e <do_wait>:
+
+// do_wait - wait one OR any children with PROC_ZOMBIE state, and free memory space of kernel stack
+//         - proc struct of this child.
+// NOTE: only after do_wait function, all resources of the child proces are free.
+int
+do_wait(int pid, int *code_store) {
+c0109d9e:	55                   	push   %ebp
+c0109d9f:	89 e5                	mov    %esp,%ebp
+c0109da1:	83 ec 18             	sub    $0x18,%esp
+    struct mm_struct *mm = current->mm;
+c0109da4:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c0109da9:	8b 40 18             	mov    0x18(%eax),%eax
+c0109dac:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    if (code_store != NULL) {
+c0109daf:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+c0109db3:	74 21                	je     c0109dd6 <do_wait+0x38>
+        if (!user_mem_check(mm, (uintptr_t)code_store, sizeof(int), 1)) {
+c0109db5:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0109db8:	6a 01                	push   $0x1
+c0109dba:	6a 04                	push   $0x4
+c0109dbc:	50                   	push   %eax
+c0109dbd:	ff 75 ec             	pushl  -0x14(%ebp)
+c0109dc0:	e8 e3 c6 ff ff       	call   c01064a8 <user_mem_check>
+c0109dc5:	83 c4 10             	add    $0x10,%esp
+c0109dc8:	85 c0                	test   %eax,%eax
+c0109dca:	75 0a                	jne    c0109dd6 <do_wait+0x38>
+            return -E_INVAL;
+c0109dcc:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+c0109dd1:	e9 54 01 00 00       	jmp    c0109f2a <do_wait+0x18c>
+    }
+
+    struct proc_struct *proc;
+    bool intr_flag, haskid;
+repeat:
+    haskid = 0;
+c0109dd6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    if (pid != 0) {
+c0109ddd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c0109de1:	74 39                	je     c0109e1c <do_wait+0x7e>
+        proc = find_proc(pid);
+c0109de3:	83 ec 0c             	sub    $0xc,%esp
+c0109de6:	ff 75 08             	pushl  0x8(%ebp)
+c0109de9:	e8 f4 f1 ff ff       	call   c0108fe2 <find_proc>
+c0109dee:	83 c4 10             	add    $0x10,%esp
+c0109df1:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        if (proc != NULL && proc->parent == current) {
+c0109df4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0109df8:	74 4f                	je     c0109e49 <do_wait+0xab>
+c0109dfa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0109dfd:	8b 50 14             	mov    0x14(%eax),%edx
+c0109e00:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c0109e05:	39 c2                	cmp    %eax,%edx
+c0109e07:	75 40                	jne    c0109e49 <do_wait+0xab>
+            haskid = 1;
+c0109e09:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+            if (proc->state == PROC_ZOMBIE) {
+c0109e10:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0109e13:	8b 00                	mov    (%eax),%eax
+c0109e15:	83 f8 03             	cmp    $0x3,%eax
+c0109e18:	75 2f                	jne    c0109e49 <do_wait+0xab>
+                goto found;
+c0109e1a:	eb 7f                	jmp    c0109e9b <do_wait+0xfd>
+            }
+        }
+    }
+    else {
+        proc = current->cptr;
+c0109e1c:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c0109e21:	8b 40 70             	mov    0x70(%eax),%eax
+c0109e24:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        for (; proc != NULL; proc = proc->optr) {
+c0109e27:	eb 1a                	jmp    c0109e43 <do_wait+0xa5>
+            haskid = 1;
+c0109e29:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+            if (proc->state == PROC_ZOMBIE) {
+c0109e30:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0109e33:	8b 00                	mov    (%eax),%eax
+c0109e35:	83 f8 03             	cmp    $0x3,%eax
+c0109e38:	74 60                	je     c0109e9a <do_wait+0xfc>
+            }
+        }
+    }
+    else {
+        proc = current->cptr;
+        for (; proc != NULL; proc = proc->optr) {
+c0109e3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0109e3d:	8b 40 78             	mov    0x78(%eax),%eax
+c0109e40:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0109e43:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0109e47:	75 e0                	jne    c0109e29 <do_wait+0x8b>
+            if (proc->state == PROC_ZOMBIE) {
+                goto found;
+            }
+        }
+    }
+    if (haskid) {
+c0109e49:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c0109e4d:	74 41                	je     c0109e90 <do_wait+0xf2>
+        current->state = PROC_SLEEPING;
+c0109e4f:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c0109e54:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
+        current->wait_state = WT_CHILD;
+c0109e5a:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c0109e5f:	c7 40 6c 01 00 00 80 	movl   $0x80000001,0x6c(%eax)
+        schedule();
+c0109e66:	e8 d1 06 00 00       	call   c010a53c <schedule>
+        if (current->flags & PF_EXITING) {
+c0109e6b:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c0109e70:	8b 40 44             	mov    0x44(%eax),%eax
+c0109e73:	83 e0 01             	and    $0x1,%eax
+c0109e76:	85 c0                	test   %eax,%eax
+c0109e78:	0f 84 58 ff ff ff    	je     c0109dd6 <do_wait+0x38>
+            do_exit(-E_KILLED);
+c0109e7e:	83 ec 0c             	sub    $0xc,%esp
+c0109e81:	6a f7                	push   $0xfffffff7
+c0109e83:	e8 37 f6 ff ff       	call   c01094bf <do_exit>
+c0109e88:	83 c4 10             	add    $0x10,%esp
+        }
+        goto repeat;
+c0109e8b:	e9 46 ff ff ff       	jmp    c0109dd6 <do_wait+0x38>
+    }
+    return -E_BAD_PROC;
+c0109e90:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
+c0109e95:	e9 90 00 00 00       	jmp    c0109f2a <do_wait+0x18c>
+    else {
+        proc = current->cptr;
+        for (; proc != NULL; proc = proc->optr) {
+            haskid = 1;
+            if (proc->state == PROC_ZOMBIE) {
+                goto found;
+c0109e9a:	90                   	nop
+        goto repeat;
+    }
+    return -E_BAD_PROC;
+
+found:
+    if (proc == idleproc || proc == initproc) {
+c0109e9b:	a1 20 10 1b c0       	mov    0xc01b1020,%eax
+c0109ea0:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+c0109ea3:	74 0a                	je     c0109eaf <do_wait+0x111>
+c0109ea5:	a1 24 10 1b c0       	mov    0xc01b1024,%eax
+c0109eaa:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+c0109ead:	75 17                	jne    c0109ec6 <do_wait+0x128>
+        panic("wait idleproc or initproc.\n");
+c0109eaf:	83 ec 04             	sub    $0x4,%esp
+c0109eb2:	68 9e db 10 c0       	push   $0xc010db9e
+c0109eb7:	68 fd 02 00 00       	push   $0x2fd
+c0109ebc:	68 94 d9 10 c0       	push   $0xc010d994
+c0109ec1:	e8 2f 65 ff ff       	call   c01003f5 <__panic>
+    }
+    if (code_store != NULL) {
+c0109ec6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+c0109eca:	74 0b                	je     c0109ed7 <do_wait+0x139>
+        *code_store = proc->exit_code;
+c0109ecc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0109ecf:	8b 50 68             	mov    0x68(%eax),%edx
+c0109ed2:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0109ed5:	89 10                	mov    %edx,(%eax)
+    }
+    local_intr_save(intr_flag);
+c0109ed7:	e8 e8 e9 ff ff       	call   c01088c4 <__intr_save>
+c0109edc:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    {
+        unhash_proc(proc);
+c0109edf:	83 ec 0c             	sub    $0xc,%esp
+c0109ee2:	ff 75 f4             	pushl  -0xc(%ebp)
+c0109ee5:	e8 c4 f0 ff ff       	call   c0108fae <unhash_proc>
+c0109eea:	83 c4 10             	add    $0x10,%esp
+        remove_links(proc);
+c0109eed:	83 ec 0c             	sub    $0xc,%esp
+c0109ef0:	ff 75 f4             	pushl  -0xc(%ebp)
+c0109ef3:	e8 25 ee ff ff       	call   c0108d1d <remove_links>
+c0109ef8:	83 c4 10             	add    $0x10,%esp
+    }
+    local_intr_restore(intr_flag);
+c0109efb:	83 ec 0c             	sub    $0xc,%esp
+c0109efe:	ff 75 e8             	pushl  -0x18(%ebp)
+c0109f01:	e8 e8 e9 ff ff       	call   c01088ee <__intr_restore>
+c0109f06:	83 c4 10             	add    $0x10,%esp
+    put_kstack(proc);
+c0109f09:	83 ec 0c             	sub    $0xc,%esp
+c0109f0c:	ff 75 f4             	pushl  -0xc(%ebp)
+c0109f0f:	e8 e3 f1 ff ff       	call   c01090f7 <put_kstack>
+c0109f14:	83 c4 10             	add    $0x10,%esp
+    kfree(proc);
+c0109f17:	83 ec 0c             	sub    $0xc,%esp
+c0109f1a:	ff 75 f4             	pushl  -0xc(%ebp)
+c0109f1d:	e8 a7 cc ff ff       	call   c0106bc9 <kfree>
+c0109f22:	83 c4 10             	add    $0x10,%esp
+    return 0;
+c0109f25:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c0109f2a:	c9                   	leave  
+c0109f2b:	c3                   	ret    
+
+c0109f2c <do_kill>:
+
+// do_kill - kill process with pid by set this process's flags with PF_EXITING
+int
+do_kill(int pid) {
+c0109f2c:	55                   	push   %ebp
+c0109f2d:	89 e5                	mov    %esp,%ebp
+c0109f2f:	83 ec 18             	sub    $0x18,%esp
+    struct proc_struct *proc;
+    if ((proc = find_proc(pid)) != NULL) {
+c0109f32:	83 ec 0c             	sub    $0xc,%esp
+c0109f35:	ff 75 08             	pushl  0x8(%ebp)
+c0109f38:	e8 a5 f0 ff ff       	call   c0108fe2 <find_proc>
+c0109f3d:	83 c4 10             	add    $0x10,%esp
+c0109f40:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0109f43:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0109f47:	74 44                	je     c0109f8d <do_kill+0x61>
+        if (!(proc->flags & PF_EXITING)) {
+c0109f49:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0109f4c:	8b 40 44             	mov    0x44(%eax),%eax
+c0109f4f:	83 e0 01             	and    $0x1,%eax
+c0109f52:	85 c0                	test   %eax,%eax
+c0109f54:	75 30                	jne    c0109f86 <do_kill+0x5a>
+            proc->flags |= PF_EXITING;
+c0109f56:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0109f59:	8b 40 44             	mov    0x44(%eax),%eax
+c0109f5c:	83 c8 01             	or     $0x1,%eax
+c0109f5f:	89 c2                	mov    %eax,%edx
+c0109f61:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0109f64:	89 50 44             	mov    %edx,0x44(%eax)
+            if (proc->wait_state & WT_INTERRUPTED) {
+c0109f67:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0109f6a:	8b 40 6c             	mov    0x6c(%eax),%eax
+c0109f6d:	85 c0                	test   %eax,%eax
+c0109f6f:	79 0e                	jns    c0109f7f <do_kill+0x53>
+                wakeup_proc(proc);
+c0109f71:	83 ec 0c             	sub    $0xc,%esp
+c0109f74:	ff 75 f4             	pushl  -0xc(%ebp)
+c0109f77:	e8 33 05 00 00       	call   c010a4af <wakeup_proc>
+c0109f7c:	83 c4 10             	add    $0x10,%esp
+            }
+            return 0;
+c0109f7f:	b8 00 00 00 00       	mov    $0x0,%eax
+c0109f84:	eb 0c                	jmp    c0109f92 <do_kill+0x66>
+        }
+        return -E_KILLED;
+c0109f86:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
+c0109f8b:	eb 05                	jmp    c0109f92 <do_kill+0x66>
+    }
+    return -E_INVAL;
+c0109f8d:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+}
+c0109f92:	c9                   	leave  
+c0109f93:	c3                   	ret    
+
+c0109f94 <kernel_execve>:
+
+// kernel_execve - do SYS_exec syscall to exec a user program called by user_main kernel_thread
+static int
+kernel_execve(const char *name, unsigned char *binary, size_t size) {
+c0109f94:	55                   	push   %ebp
+c0109f95:	89 e5                	mov    %esp,%ebp
+c0109f97:	57                   	push   %edi
+c0109f98:	56                   	push   %esi
+c0109f99:	53                   	push   %ebx
+c0109f9a:	83 ec 1c             	sub    $0x1c,%esp
+    int ret, len = strlen(name);
+c0109f9d:	83 ec 0c             	sub    $0xc,%esp
+c0109fa0:	ff 75 08             	pushl  0x8(%ebp)
+c0109fa3:	e8 7f 0d 00 00       	call   c010ad27 <strlen>
+c0109fa8:	83 c4 10             	add    $0x10,%esp
+c0109fab:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    asm volatile (
+c0109fae:	b8 04 00 00 00       	mov    $0x4,%eax
+c0109fb3:	8b 55 08             	mov    0x8(%ebp),%edx
+c0109fb6:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
+c0109fb9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+c0109fbc:	8b 75 10             	mov    0x10(%ebp),%esi
+c0109fbf:	89 f7                	mov    %esi,%edi
+c0109fc1:	cd 80                	int    $0x80
+c0109fc3:	89 45 e0             	mov    %eax,-0x20(%ebp)
+        "int %1;"
+        : "=a" (ret)
+        : "i" (T_SYSCALL), "0" (SYS_exec), "d" (name), "c" (len), "b" (binary), "D" (size)
+        : "memory");
+    return ret;
+c0109fc6:	8b 45 e0             	mov    -0x20(%ebp),%eax
+}
+c0109fc9:	8d 65 f4             	lea    -0xc(%ebp),%esp
+c0109fcc:	5b                   	pop    %ebx
+c0109fcd:	5e                   	pop    %esi
+c0109fce:	5f                   	pop    %edi
+c0109fcf:	5d                   	pop    %ebp
+c0109fd0:	c3                   	ret    
+
+c0109fd1 <user_main>:
+
+#define KERNEL_EXECVE2(x, xstart, xsize)        __KERNEL_EXECVE2(x, xstart, xsize)
+
+// user_main - kernel thread used to exec a user program
+static int
+user_main(void *arg) {
+c0109fd1:	55                   	push   %ebp
+c0109fd2:	89 e5                	mov    %esp,%ebp
+c0109fd4:	83 ec 08             	sub    $0x8,%esp
+#ifdef TEST
+    KERNEL_EXECVE2(TEST, TESTSTART, TESTSIZE);
+c0109fd7:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c0109fdc:	8b 40 04             	mov    0x4(%eax),%eax
+c0109fdf:	83 ec 04             	sub    $0x4,%esp
+c0109fe2:	68 ba db 10 c0       	push   $0xc010dbba
+c0109fe7:	50                   	push   %eax
+c0109fe8:	68 c4 db 10 c0       	push   $0xc010dbc4
+c0109fed:	e8 9d 62 ff ff       	call   c010028f <cprintf>
+c0109ff2:	83 c4 10             	add    $0x10,%esp
+c0109ff5:	b8 60 79 00 00       	mov    $0x7960,%eax
+c0109ffa:	83 ec 04             	sub    $0x4,%esp
+c0109ffd:	50                   	push   %eax
+c0109ffe:	68 24 2b 15 c0       	push   $0xc0152b24
+c010a003:	68 ba db 10 c0       	push   $0xc010dbba
+c010a008:	e8 87 ff ff ff       	call   c0109f94 <kernel_execve>
+c010a00d:	83 c4 10             	add    $0x10,%esp
+#else
+    KERNEL_EXECVE(exit);
+#endif
+    panic("user_main execve failed.\n");
+c010a010:	83 ec 04             	sub    $0x4,%esp
+c010a013:	68 eb db 10 c0       	push   $0xc010dbeb
+c010a018:	68 46 03 00 00       	push   $0x346
+c010a01d:	68 94 d9 10 c0       	push   $0xc010d994
+c010a022:	e8 ce 63 ff ff       	call   c01003f5 <__panic>
+
+c010a027 <init_main>:
+}
+
+// init_main - the second kernel thread used to create user_main kernel threads
+static int
+init_main(void *arg) {
+c010a027:	55                   	push   %ebp
+c010a028:	89 e5                	mov    %esp,%ebp
+c010a02a:	83 ec 28             	sub    $0x28,%esp
+    size_t nr_free_pages_store = nr_free_pages();
+c010a02d:	e8 30 98 ff ff       	call   c0103862 <nr_free_pages>
+c010a032:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    size_t kernel_allocated_store = kallocated();
+c010a035:	e8 5a ca ff ff       	call   c0106a94 <kallocated>
+c010a03a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+
+    int pid = kernel_thread(user_main, NULL, 0);
+c010a03d:	83 ec 04             	sub    $0x4,%esp
+c010a040:	6a 00                	push   $0x0
+c010a042:	6a 00                	push   $0x0
+c010a044:	68 d1 9f 10 c0       	push   $0xc0109fd1
+c010a049:	e8 04 f0 ff ff       	call   c0109052 <kernel_thread>
+c010a04e:	83 c4 10             	add    $0x10,%esp
+c010a051:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    if (pid <= 0) {
+c010a054:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+c010a058:	7f 1c                	jg     c010a076 <init_main+0x4f>
+        panic("create user_main failed.\n");
+c010a05a:	83 ec 04             	sub    $0x4,%esp
+c010a05d:	68 05 dc 10 c0       	push   $0xc010dc05
+c010a062:	68 51 03 00 00       	push   $0x351
+c010a067:	68 94 d9 10 c0       	push   $0xc010d994
+c010a06c:	e8 84 63 ff ff       	call   c01003f5 <__panic>
+    }
+
+    while (do_wait(0, NULL) == 0) {
+        schedule();
+c010a071:	e8 c6 04 00 00       	call   c010a53c <schedule>
+    int pid = kernel_thread(user_main, NULL, 0);
+    if (pid <= 0) {
+        panic("create user_main failed.\n");
+    }
+
+    while (do_wait(0, NULL) == 0) {
+c010a076:	83 ec 08             	sub    $0x8,%esp
+c010a079:	6a 00                	push   $0x0
+c010a07b:	6a 00                	push   $0x0
+c010a07d:	e8 1c fd ff ff       	call   c0109d9e <do_wait>
+c010a082:	83 c4 10             	add    $0x10,%esp
+c010a085:	85 c0                	test   %eax,%eax
+c010a087:	74 e8                	je     c010a071 <init_main+0x4a>
+        schedule();
+    }
+
+    cprintf("all user-mode processes have quit.\n");
+c010a089:	83 ec 0c             	sub    $0xc,%esp
+c010a08c:	68 20 dc 10 c0       	push   $0xc010dc20
+c010a091:	e8 f9 61 ff ff       	call   c010028f <cprintf>
+c010a096:	83 c4 10             	add    $0x10,%esp
+    assert(initproc->cptr == NULL && initproc->yptr == NULL && initproc->optr == NULL);
+c010a099:	a1 24 10 1b c0       	mov    0xc01b1024,%eax
+c010a09e:	8b 40 70             	mov    0x70(%eax),%eax
+c010a0a1:	85 c0                	test   %eax,%eax
+c010a0a3:	75 18                	jne    c010a0bd <init_main+0x96>
+c010a0a5:	a1 24 10 1b c0       	mov    0xc01b1024,%eax
+c010a0aa:	8b 40 74             	mov    0x74(%eax),%eax
+c010a0ad:	85 c0                	test   %eax,%eax
+c010a0af:	75 0c                	jne    c010a0bd <init_main+0x96>
+c010a0b1:	a1 24 10 1b c0       	mov    0xc01b1024,%eax
+c010a0b6:	8b 40 78             	mov    0x78(%eax),%eax
+c010a0b9:	85 c0                	test   %eax,%eax
+c010a0bb:	74 19                	je     c010a0d6 <init_main+0xaf>
+c010a0bd:	68 44 dc 10 c0       	push   $0xc010dc44
+c010a0c2:	68 c1 d9 10 c0       	push   $0xc010d9c1
+c010a0c7:	68 59 03 00 00       	push   $0x359
+c010a0cc:	68 94 d9 10 c0       	push   $0xc010d994
+c010a0d1:	e8 1f 63 ff ff       	call   c01003f5 <__panic>
+    assert(nr_process == 2);
+c010a0d6:	a1 40 30 1b c0       	mov    0xc01b3040,%eax
+c010a0db:	83 f8 02             	cmp    $0x2,%eax
+c010a0de:	74 19                	je     c010a0f9 <init_main+0xd2>
+c010a0e0:	68 8f dc 10 c0       	push   $0xc010dc8f
+c010a0e5:	68 c1 d9 10 c0       	push   $0xc010d9c1
+c010a0ea:	68 5a 03 00 00       	push   $0x35a
+c010a0ef:	68 94 d9 10 c0       	push   $0xc010d994
+c010a0f4:	e8 fc 62 ff ff       	call   c01003f5 <__panic>
+c010a0f9:	c7 45 e4 70 31 1b c0 	movl   $0xc01b3170,-0x1c(%ebp)
+c010a100:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c010a103:	8b 40 04             	mov    0x4(%eax),%eax
+    assert(list_next(&proc_list) == &(initproc->list_link));
+c010a106:	8b 15 24 10 1b c0    	mov    0xc01b1024,%edx
+c010a10c:	83 c2 58             	add    $0x58,%edx
+c010a10f:	39 d0                	cmp    %edx,%eax
+c010a111:	74 19                	je     c010a12c <init_main+0x105>
+c010a113:	68 a0 dc 10 c0       	push   $0xc010dca0
+c010a118:	68 c1 d9 10 c0       	push   $0xc010d9c1
+c010a11d:	68 5b 03 00 00       	push   $0x35b
+c010a122:	68 94 d9 10 c0       	push   $0xc010d994
+c010a127:	e8 c9 62 ff ff       	call   c01003f5 <__panic>
+c010a12c:	c7 45 e8 70 31 1b c0 	movl   $0xc01b3170,-0x18(%ebp)
+ * list_prev - get the previous entry
+ * @listelm:    the list head
+ **/
+static inline list_entry_t *
+list_prev(list_entry_t *listelm) {
+    return listelm->prev;
+c010a133:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010a136:	8b 00                	mov    (%eax),%eax
+    assert(list_prev(&proc_list) == &(initproc->list_link));
+c010a138:	8b 15 24 10 1b c0    	mov    0xc01b1024,%edx
+c010a13e:	83 c2 58             	add    $0x58,%edx
+c010a141:	39 d0                	cmp    %edx,%eax
+c010a143:	74 19                	je     c010a15e <init_main+0x137>
+c010a145:	68 d0 dc 10 c0       	push   $0xc010dcd0
+c010a14a:	68 c1 d9 10 c0       	push   $0xc010d9c1
+c010a14f:	68 5c 03 00 00       	push   $0x35c
+c010a154:	68 94 d9 10 c0       	push   $0xc010d994
+c010a159:	e8 97 62 ff ff       	call   c01003f5 <__panic>
+
+    cprintf("init check memory pass.\n");
+c010a15e:	83 ec 0c             	sub    $0xc,%esp
+c010a161:	68 00 dd 10 c0       	push   $0xc010dd00
+c010a166:	e8 24 61 ff ff       	call   c010028f <cprintf>
+c010a16b:	83 c4 10             	add    $0x10,%esp
+    return 0;
+c010a16e:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c010a173:	c9                   	leave  
+c010a174:	c3                   	ret    
+
+c010a175 <proc_init>:
+
+// proc_init - set up the first kernel thread idleproc "idle" by itself and 
+//           - create the second kernel thread init_main
+void
+proc_init(void) {
+c010a175:	55                   	push   %ebp
+c010a176:	89 e5                	mov    %esp,%ebp
+c010a178:	83 ec 18             	sub    $0x18,%esp
+c010a17b:	c7 45 e8 70 31 1b c0 	movl   $0xc01b3170,-0x18(%ebp)
+ * list_init - initialize a new entry
+ * @elm:        new entry to be initialized
+ * */
+static inline void
+list_init(list_entry_t *elm) {
+    elm->prev = elm->next = elm;
+c010a182:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010a185:	8b 55 e8             	mov    -0x18(%ebp),%edx
+c010a188:	89 50 04             	mov    %edx,0x4(%eax)
+c010a18b:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010a18e:	8b 50 04             	mov    0x4(%eax),%edx
+c010a191:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010a194:	89 10                	mov    %edx,(%eax)
+    int i;
+
+    list_init(&proc_list);
+    for (i = 0; i < HASH_LIST_SIZE; i ++) {
+c010a196:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c010a19d:	eb 26                	jmp    c010a1c5 <proc_init+0x50>
+        list_init(hash_list + i);
+c010a19f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010a1a2:	c1 e0 03             	shl    $0x3,%eax
+c010a1a5:	05 40 10 1b c0       	add    $0xc01b1040,%eax
+c010a1aa:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c010a1ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010a1b0:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c010a1b3:	89 50 04             	mov    %edx,0x4(%eax)
+c010a1b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010a1b9:	8b 50 04             	mov    0x4(%eax),%edx
+c010a1bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010a1bf:	89 10                	mov    %edx,(%eax)
+void
+proc_init(void) {
+    int i;
+
+    list_init(&proc_list);
+    for (i = 0; i < HASH_LIST_SIZE; i ++) {
+c010a1c1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+c010a1c5:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
+c010a1cc:	7e d1                	jle    c010a19f <proc_init+0x2a>
+        list_init(hash_list + i);
+    }
+
+    if ((idleproc = alloc_proc()) == NULL) {
+c010a1ce:	e8 f6 e8 ff ff       	call   c0108ac9 <alloc_proc>
+c010a1d3:	a3 20 10 1b c0       	mov    %eax,0xc01b1020
+c010a1d8:	a1 20 10 1b c0       	mov    0xc01b1020,%eax
+c010a1dd:	85 c0                	test   %eax,%eax
+c010a1df:	75 17                	jne    c010a1f8 <proc_init+0x83>
+        panic("cannot alloc idleproc.\n");
+c010a1e1:	83 ec 04             	sub    $0x4,%esp
+c010a1e4:	68 19 dd 10 c0       	push   $0xc010dd19
+c010a1e9:	68 6e 03 00 00       	push   $0x36e
+c010a1ee:	68 94 d9 10 c0       	push   $0xc010d994
+c010a1f3:	e8 fd 61 ff ff       	call   c01003f5 <__panic>
+    }
+
+    idleproc->pid = 0;
+c010a1f8:	a1 20 10 1b c0       	mov    0xc01b1020,%eax
+c010a1fd:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
+    idleproc->state = PROC_RUNNABLE;
+c010a204:	a1 20 10 1b c0       	mov    0xc01b1020,%eax
+c010a209:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
+    idleproc->kstack = (uintptr_t)bootstack;
+c010a20f:	a1 20 10 1b c0       	mov    0xc01b1020,%eax
+c010a214:	ba 00 a0 12 c0       	mov    $0xc012a000,%edx
+c010a219:	89 50 0c             	mov    %edx,0xc(%eax)
+    idleproc->need_resched = 1;
+c010a21c:	a1 20 10 1b c0       	mov    0xc01b1020,%eax
+c010a221:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
+    set_proc_name(idleproc, "idle");
+c010a228:	a1 20 10 1b c0       	mov    0xc01b1020,%eax
+c010a22d:	83 ec 08             	sub    $0x8,%esp
+c010a230:	68 31 dd 10 c0       	push   $0xc010dd31
+c010a235:	50                   	push   %eax
+c010a236:	e8 d2 e9 ff ff       	call   c0108c0d <set_proc_name>
+c010a23b:	83 c4 10             	add    $0x10,%esp
+    nr_process ++;
+c010a23e:	a1 40 30 1b c0       	mov    0xc01b3040,%eax
+c010a243:	83 c0 01             	add    $0x1,%eax
+c010a246:	a3 40 30 1b c0       	mov    %eax,0xc01b3040
+
+    current = idleproc;
+c010a24b:	a1 20 10 1b c0       	mov    0xc01b1020,%eax
+c010a250:	a3 28 10 1b c0       	mov    %eax,0xc01b1028
+
+    int pid = kernel_thread(init_main, NULL, 0);
+c010a255:	83 ec 04             	sub    $0x4,%esp
+c010a258:	6a 00                	push   $0x0
+c010a25a:	6a 00                	push   $0x0
+c010a25c:	68 27 a0 10 c0       	push   $0xc010a027
+c010a261:	e8 ec ed ff ff       	call   c0109052 <kernel_thread>
+c010a266:	83 c4 10             	add    $0x10,%esp
+c010a269:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    if (pid <= 0) {
+c010a26c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+c010a270:	7f 17                	jg     c010a289 <proc_init+0x114>
+        panic("create init_main failed.\n");
+c010a272:	83 ec 04             	sub    $0x4,%esp
+c010a275:	68 36 dd 10 c0       	push   $0xc010dd36
+c010a27a:	68 7c 03 00 00       	push   $0x37c
+c010a27f:	68 94 d9 10 c0       	push   $0xc010d994
+c010a284:	e8 6c 61 ff ff       	call   c01003f5 <__panic>
+    }
+
+    initproc = find_proc(pid);
+c010a289:	83 ec 0c             	sub    $0xc,%esp
+c010a28c:	ff 75 ec             	pushl  -0x14(%ebp)
+c010a28f:	e8 4e ed ff ff       	call   c0108fe2 <find_proc>
+c010a294:	83 c4 10             	add    $0x10,%esp
+c010a297:	a3 24 10 1b c0       	mov    %eax,0xc01b1024
+    set_proc_name(initproc, "init");
+c010a29c:	a1 24 10 1b c0       	mov    0xc01b1024,%eax
+c010a2a1:	83 ec 08             	sub    $0x8,%esp
+c010a2a4:	68 50 dd 10 c0       	push   $0xc010dd50
+c010a2a9:	50                   	push   %eax
+c010a2aa:	e8 5e e9 ff ff       	call   c0108c0d <set_proc_name>
+c010a2af:	83 c4 10             	add    $0x10,%esp
+
+    assert(idleproc != NULL && idleproc->pid == 0);
+c010a2b2:	a1 20 10 1b c0       	mov    0xc01b1020,%eax
+c010a2b7:	85 c0                	test   %eax,%eax
+c010a2b9:	74 0c                	je     c010a2c7 <proc_init+0x152>
+c010a2bb:	a1 20 10 1b c0       	mov    0xc01b1020,%eax
+c010a2c0:	8b 40 04             	mov    0x4(%eax),%eax
+c010a2c3:	85 c0                	test   %eax,%eax
+c010a2c5:	74 19                	je     c010a2e0 <proc_init+0x16b>
+c010a2c7:	68 58 dd 10 c0       	push   $0xc010dd58
+c010a2cc:	68 c1 d9 10 c0       	push   $0xc010d9c1
+c010a2d1:	68 82 03 00 00       	push   $0x382
+c010a2d6:	68 94 d9 10 c0       	push   $0xc010d994
+c010a2db:	e8 15 61 ff ff       	call   c01003f5 <__panic>
+    assert(initproc != NULL && initproc->pid == 1);
+c010a2e0:	a1 24 10 1b c0       	mov    0xc01b1024,%eax
+c010a2e5:	85 c0                	test   %eax,%eax
+c010a2e7:	74 0d                	je     c010a2f6 <proc_init+0x181>
+c010a2e9:	a1 24 10 1b c0       	mov    0xc01b1024,%eax
+c010a2ee:	8b 40 04             	mov    0x4(%eax),%eax
+c010a2f1:	83 f8 01             	cmp    $0x1,%eax
+c010a2f4:	74 19                	je     c010a30f <proc_init+0x19a>
+c010a2f6:	68 80 dd 10 c0       	push   $0xc010dd80
+c010a2fb:	68 c1 d9 10 c0       	push   $0xc010d9c1
+c010a300:	68 83 03 00 00       	push   $0x383
+c010a305:	68 94 d9 10 c0       	push   $0xc010d994
+c010a30a:	e8 e6 60 ff ff       	call   c01003f5 <__panic>
+}
+c010a30f:	90                   	nop
+c010a310:	c9                   	leave  
+c010a311:	c3                   	ret    
+
+c010a312 <cpu_idle>:
+
+// cpu_idle - at the end of kern_init, the first kernel thread idleproc will do below works
+void
+cpu_idle(void) {
+c010a312:	55                   	push   %ebp
+c010a313:	89 e5                	mov    %esp,%ebp
+c010a315:	83 ec 08             	sub    $0x8,%esp
+    while (1) {
+        if (current->need_resched) {
+c010a318:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c010a31d:	8b 40 10             	mov    0x10(%eax),%eax
+c010a320:	85 c0                	test   %eax,%eax
+c010a322:	74 f4                	je     c010a318 <cpu_idle+0x6>
+            schedule();
+c010a324:	e8 13 02 00 00       	call   c010a53c <schedule>
+        }
+    }
+c010a329:	eb ed                	jmp    c010a318 <cpu_idle+0x6>
+
+c010a32b <lab6_set_priority>:
+}
+
+//FOR LAB6, set the process's priority (bigger value will get more CPU time) 
+void
+lab6_set_priority(uint32_t priority)
+{
+c010a32b:	55                   	push   %ebp
+c010a32c:	89 e5                	mov    %esp,%ebp
+    if (priority == 0)
+c010a32e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c010a332:	75 11                	jne    c010a345 <lab6_set_priority+0x1a>
+        current->lab6_priority = 1;
+c010a334:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c010a339:	c7 80 9c 00 00 00 01 	movl   $0x1,0x9c(%eax)
+c010a340:	00 00 00 
+    else current->lab6_priority = priority;
+}
+c010a343:	eb 0e                	jmp    c010a353 <lab6_set_priority+0x28>
+void
+lab6_set_priority(uint32_t priority)
+{
+    if (priority == 0)
+        current->lab6_priority = 1;
+    else current->lab6_priority = priority;
+c010a345:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c010a34a:	8b 55 08             	mov    0x8(%ebp),%edx
+c010a34d:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
+}
+c010a353:	90                   	nop
+c010a354:	5d                   	pop    %ebp
+c010a355:	c3                   	ret    
+
+c010a356 <__intr_save>:
+#include <assert.h>
+#include <atomic.h>
+#include <sched.h>
+
+static inline bool
+__intr_save(void) {
+c010a356:	55                   	push   %ebp
+c010a357:	89 e5                	mov    %esp,%ebp
+c010a359:	83 ec 18             	sub    $0x18,%esp
+}
+
+static inline uint32_t
+read_eflags(void) {
+    uint32_t eflags;
+    asm volatile ("pushfl; popl %0" : "=r" (eflags));
+c010a35c:	9c                   	pushf  
+c010a35d:	58                   	pop    %eax
+c010a35e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    return eflags;
+c010a361:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    if (read_eflags() & FL_IF) {
+c010a364:	25 00 02 00 00       	and    $0x200,%eax
+c010a369:	85 c0                	test   %eax,%eax
+c010a36b:	74 0c                	je     c010a379 <__intr_save+0x23>
+        intr_disable();
+c010a36d:	e8 3b 7e ff ff       	call   c01021ad <intr_disable>
+        return 1;
+c010a372:	b8 01 00 00 00       	mov    $0x1,%eax
+c010a377:	eb 05                	jmp    c010a37e <__intr_save+0x28>
+    }
+    return 0;
+c010a379:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c010a37e:	c9                   	leave  
+c010a37f:	c3                   	ret    
+
+c010a380 <__intr_restore>:
+
+static inline void
+__intr_restore(bool flag) {
+c010a380:	55                   	push   %ebp
+c010a381:	89 e5                	mov    %esp,%ebp
+c010a383:	83 ec 08             	sub    $0x8,%esp
+    if (flag) {
+c010a386:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c010a38a:	74 05                	je     c010a391 <__intr_restore+0x11>
+        intr_enable();
+c010a38c:	e8 15 7e ff ff       	call   c01021a6 <intr_enable>
+    }
+}
+c010a391:	90                   	nop
+c010a392:	c9                   	leave  
+c010a393:	c3                   	ret    
+
+c010a394 <sched_class_enqueue>:
+static struct sched_class *sched_class;
+
+static struct run_queue *rq;
+
+static inline void
+sched_class_enqueue(struct proc_struct *proc) {
+c010a394:	55                   	push   %ebp
+c010a395:	89 e5                	mov    %esp,%ebp
+c010a397:	83 ec 08             	sub    $0x8,%esp
+    if (proc != idleproc) {
+c010a39a:	a1 20 10 1b c0       	mov    0xc01b1020,%eax
+c010a39f:	39 45 08             	cmp    %eax,0x8(%ebp)
+c010a3a2:	74 1a                	je     c010a3be <sched_class_enqueue+0x2a>
+        sched_class->enqueue(rq, proc);
+c010a3a4:	a1 5c 30 1b c0       	mov    0xc01b305c,%eax
+c010a3a9:	8b 40 08             	mov    0x8(%eax),%eax
+c010a3ac:	8b 15 60 30 1b c0    	mov    0xc01b3060,%edx
+c010a3b2:	83 ec 08             	sub    $0x8,%esp
+c010a3b5:	ff 75 08             	pushl  0x8(%ebp)
+c010a3b8:	52                   	push   %edx
+c010a3b9:	ff d0                	call   *%eax
+c010a3bb:	83 c4 10             	add    $0x10,%esp
+    }
+}
+c010a3be:	90                   	nop
+c010a3bf:	c9                   	leave  
+c010a3c0:	c3                   	ret    
+
+c010a3c1 <sched_class_dequeue>:
+
+static inline void
+sched_class_dequeue(struct proc_struct *proc) {
+c010a3c1:	55                   	push   %ebp
+c010a3c2:	89 e5                	mov    %esp,%ebp
+c010a3c4:	83 ec 08             	sub    $0x8,%esp
+    sched_class->dequeue(rq, proc);
+c010a3c7:	a1 5c 30 1b c0       	mov    0xc01b305c,%eax
+c010a3cc:	8b 40 0c             	mov    0xc(%eax),%eax
+c010a3cf:	8b 15 60 30 1b c0    	mov    0xc01b3060,%edx
+c010a3d5:	83 ec 08             	sub    $0x8,%esp
+c010a3d8:	ff 75 08             	pushl  0x8(%ebp)
+c010a3db:	52                   	push   %edx
+c010a3dc:	ff d0                	call   *%eax
+c010a3de:	83 c4 10             	add    $0x10,%esp
+}
+c010a3e1:	90                   	nop
+c010a3e2:	c9                   	leave  
+c010a3e3:	c3                   	ret    
+
+c010a3e4 <sched_class_pick_next>:
+
+static inline struct proc_struct *
+sched_class_pick_next(void) {
+c010a3e4:	55                   	push   %ebp
+c010a3e5:	89 e5                	mov    %esp,%ebp
+c010a3e7:	83 ec 08             	sub    $0x8,%esp
+    return sched_class->pick_next(rq);
+c010a3ea:	a1 5c 30 1b c0       	mov    0xc01b305c,%eax
+c010a3ef:	8b 40 10             	mov    0x10(%eax),%eax
+c010a3f2:	8b 15 60 30 1b c0    	mov    0xc01b3060,%edx
+c010a3f8:	83 ec 0c             	sub    $0xc,%esp
+c010a3fb:	52                   	push   %edx
+c010a3fc:	ff d0                	call   *%eax
+c010a3fe:	83 c4 10             	add    $0x10,%esp
+}
+c010a401:	c9                   	leave  
+c010a402:	c3                   	ret    
+
+c010a403 <sched_class_proc_tick>:
+
+void
+sched_class_proc_tick(struct proc_struct *proc) {
+c010a403:	55                   	push   %ebp
+c010a404:	89 e5                	mov    %esp,%ebp
+c010a406:	83 ec 08             	sub    $0x8,%esp
+    if (proc != idleproc) {
+c010a409:	a1 20 10 1b c0       	mov    0xc01b1020,%eax
+c010a40e:	39 45 08             	cmp    %eax,0x8(%ebp)
+c010a411:	74 1c                	je     c010a42f <sched_class_proc_tick+0x2c>
+        sched_class->proc_tick(rq, proc);
+c010a413:	a1 5c 30 1b c0       	mov    0xc01b305c,%eax
+c010a418:	8b 40 14             	mov    0x14(%eax),%eax
+c010a41b:	8b 15 60 30 1b c0    	mov    0xc01b3060,%edx
+c010a421:	83 ec 08             	sub    $0x8,%esp
+c010a424:	ff 75 08             	pushl  0x8(%ebp)
+c010a427:	52                   	push   %edx
+c010a428:	ff d0                	call   *%eax
+c010a42a:	83 c4 10             	add    $0x10,%esp
+    }
+    else {
+        proc->need_resched = 1;
+    }
+}
+c010a42d:	eb 0a                	jmp    c010a439 <sched_class_proc_tick+0x36>
+sched_class_proc_tick(struct proc_struct *proc) {
+    if (proc != idleproc) {
+        sched_class->proc_tick(rq, proc);
+    }
+    else {
+        proc->need_resched = 1;
+c010a42f:	8b 45 08             	mov    0x8(%ebp),%eax
+c010a432:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
+    }
+}
+c010a439:	90                   	nop
+c010a43a:	c9                   	leave  
+c010a43b:	c3                   	ret    
+
+c010a43c <sched_init>:
+
+static struct run_queue __rq;
+
+void
+sched_init(void) {
+c010a43c:	55                   	push   %ebp
+c010a43d:	89 e5                	mov    %esp,%ebp
+c010a43f:	83 ec 18             	sub    $0x18,%esp
+c010a442:	c7 45 f4 54 30 1b c0 	movl   $0xc01b3054,-0xc(%ebp)
+c010a449:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010a44c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c010a44f:	89 50 04             	mov    %edx,0x4(%eax)
+c010a452:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010a455:	8b 50 04             	mov    0x4(%eax),%edx
+c010a458:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010a45b:	89 10                	mov    %edx,(%eax)
+    list_init(&timer_list);
+
+    sched_class = &default_sched_class;
+c010a45d:	c7 05 5c 30 1b c0 74 	movl   $0xc012ca74,0xc01b305c
+c010a464:	ca 12 c0 
+
+    rq = &__rq;
+c010a467:	c7 05 60 30 1b c0 64 	movl   $0xc01b3064,0xc01b3060
+c010a46e:	30 1b c0 
+    rq->max_time_slice = MAX_TIME_SLICE;
+c010a471:	a1 60 30 1b c0       	mov    0xc01b3060,%eax
+c010a476:	c7 40 0c 05 00 00 00 	movl   $0x5,0xc(%eax)
+    sched_class->init(rq);
+c010a47d:	a1 5c 30 1b c0       	mov    0xc01b305c,%eax
+c010a482:	8b 40 04             	mov    0x4(%eax),%eax
+c010a485:	8b 15 60 30 1b c0    	mov    0xc01b3060,%edx
+c010a48b:	83 ec 0c             	sub    $0xc,%esp
+c010a48e:	52                   	push   %edx
+c010a48f:	ff d0                	call   *%eax
+c010a491:	83 c4 10             	add    $0x10,%esp
+
+    cprintf("sched class: %s\n", sched_class->name);
+c010a494:	a1 5c 30 1b c0       	mov    0xc01b305c,%eax
+c010a499:	8b 00                	mov    (%eax),%eax
+c010a49b:	83 ec 08             	sub    $0x8,%esp
+c010a49e:	50                   	push   %eax
+c010a49f:	68 a7 dd 10 c0       	push   $0xc010dda7
+c010a4a4:	e8 e6 5d ff ff       	call   c010028f <cprintf>
+c010a4a9:	83 c4 10             	add    $0x10,%esp
+}
+c010a4ac:	90                   	nop
+c010a4ad:	c9                   	leave  
+c010a4ae:	c3                   	ret    
+
+c010a4af <wakeup_proc>:
+
+void
+wakeup_proc(struct proc_struct *proc) {
+c010a4af:	55                   	push   %ebp
+c010a4b0:	89 e5                	mov    %esp,%ebp
+c010a4b2:	83 ec 18             	sub    $0x18,%esp
+    assert(proc->state != PROC_ZOMBIE);
+c010a4b5:	8b 45 08             	mov    0x8(%ebp),%eax
+c010a4b8:	8b 00                	mov    (%eax),%eax
+c010a4ba:	83 f8 03             	cmp    $0x3,%eax
+c010a4bd:	75 16                	jne    c010a4d5 <wakeup_proc+0x26>
+c010a4bf:	68 b8 dd 10 c0       	push   $0xc010ddb8
+c010a4c4:	68 d3 dd 10 c0       	push   $0xc010ddd3
+c010a4c9:	6a 3c                	push   $0x3c
+c010a4cb:	68 e8 dd 10 c0       	push   $0xc010dde8
+c010a4d0:	e8 20 5f ff ff       	call   c01003f5 <__panic>
+    bool intr_flag;
+    local_intr_save(intr_flag);
+c010a4d5:	e8 7c fe ff ff       	call   c010a356 <__intr_save>
+c010a4da:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    {
+        if (proc->state != PROC_RUNNABLE) {
+c010a4dd:	8b 45 08             	mov    0x8(%ebp),%eax
+c010a4e0:	8b 00                	mov    (%eax),%eax
+c010a4e2:	83 f8 02             	cmp    $0x2,%eax
+c010a4e5:	74 2d                	je     c010a514 <wakeup_proc+0x65>
+            proc->state = PROC_RUNNABLE;
+c010a4e7:	8b 45 08             	mov    0x8(%ebp),%eax
+c010a4ea:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
+            proc->wait_state = 0;
+c010a4f0:	8b 45 08             	mov    0x8(%ebp),%eax
+c010a4f3:	c7 40 6c 00 00 00 00 	movl   $0x0,0x6c(%eax)
+            if (proc != current) {
+c010a4fa:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c010a4ff:	39 45 08             	cmp    %eax,0x8(%ebp)
+c010a502:	74 27                	je     c010a52b <wakeup_proc+0x7c>
+                sched_class_enqueue(proc);
+c010a504:	83 ec 0c             	sub    $0xc,%esp
+c010a507:	ff 75 08             	pushl  0x8(%ebp)
+c010a50a:	e8 85 fe ff ff       	call   c010a394 <sched_class_enqueue>
+c010a50f:	83 c4 10             	add    $0x10,%esp
+c010a512:	eb 17                	jmp    c010a52b <wakeup_proc+0x7c>
+            }
+        }
+        else {
+            warn("wakeup runnable process.\n");
+c010a514:	83 ec 04             	sub    $0x4,%esp
+c010a517:	68 fe dd 10 c0       	push   $0xc010ddfe
+c010a51c:	6a 48                	push   $0x48
+c010a51e:	68 e8 dd 10 c0       	push   $0xc010dde8
+c010a523:	e8 50 5f ff ff       	call   c0100478 <__warn>
+c010a528:	83 c4 10             	add    $0x10,%esp
+        }
+    }
+    local_intr_restore(intr_flag);
+c010a52b:	83 ec 0c             	sub    $0xc,%esp
+c010a52e:	ff 75 f4             	pushl  -0xc(%ebp)
+c010a531:	e8 4a fe ff ff       	call   c010a380 <__intr_restore>
+c010a536:	83 c4 10             	add    $0x10,%esp
+}
+c010a539:	90                   	nop
+c010a53a:	c9                   	leave  
+c010a53b:	c3                   	ret    
+
+c010a53c <schedule>:
+
+void
+schedule(void) {
+c010a53c:	55                   	push   %ebp
+c010a53d:	89 e5                	mov    %esp,%ebp
+c010a53f:	83 ec 18             	sub    $0x18,%esp
+    bool intr_flag;
+    struct proc_struct *next;
+    local_intr_save(intr_flag);
+c010a542:	e8 0f fe ff ff       	call   c010a356 <__intr_save>
+c010a547:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    {
+        current->need_resched = 0;
+c010a54a:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c010a54f:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
+        if (current->state == PROC_RUNNABLE) {
+c010a556:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c010a55b:	8b 00                	mov    (%eax),%eax
+c010a55d:	83 f8 02             	cmp    $0x2,%eax
+c010a560:	75 11                	jne    c010a573 <schedule+0x37>
+            sched_class_enqueue(current);
+c010a562:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c010a567:	83 ec 0c             	sub    $0xc,%esp
+c010a56a:	50                   	push   %eax
+c010a56b:	e8 24 fe ff ff       	call   c010a394 <sched_class_enqueue>
+c010a570:	83 c4 10             	add    $0x10,%esp
+        }
+        if ((next = sched_class_pick_next()) != NULL) {
+c010a573:	e8 6c fe ff ff       	call   c010a3e4 <sched_class_pick_next>
+c010a578:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c010a57b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c010a57f:	74 0e                	je     c010a58f <schedule+0x53>
+            sched_class_dequeue(next);
+c010a581:	83 ec 0c             	sub    $0xc,%esp
+c010a584:	ff 75 f4             	pushl  -0xc(%ebp)
+c010a587:	e8 35 fe ff ff       	call   c010a3c1 <sched_class_dequeue>
+c010a58c:	83 c4 10             	add    $0x10,%esp
+        }
+        if (next == NULL) {
+c010a58f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c010a593:	75 08                	jne    c010a59d <schedule+0x61>
+            next = idleproc;
+c010a595:	a1 20 10 1b c0       	mov    0xc01b1020,%eax
+c010a59a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        }
+        next->runs ++;
+c010a59d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010a5a0:	8b 40 08             	mov    0x8(%eax),%eax
+c010a5a3:	8d 50 01             	lea    0x1(%eax),%edx
+c010a5a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010a5a9:	89 50 08             	mov    %edx,0x8(%eax)
+        if (next != current) {
+c010a5ac:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c010a5b1:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+c010a5b4:	74 0e                	je     c010a5c4 <schedule+0x88>
+            proc_run(next);
+c010a5b6:	83 ec 0c             	sub    $0xc,%esp
+c010a5b9:	ff 75 f4             	pushl  -0xc(%ebp)
+c010a5bc:	e8 d8 e8 ff ff       	call   c0108e99 <proc_run>
+c010a5c1:	83 c4 10             	add    $0x10,%esp
+        }
+    }
+    local_intr_restore(intr_flag);
+c010a5c4:	83 ec 0c             	sub    $0xc,%esp
+c010a5c7:	ff 75 f0             	pushl  -0x10(%ebp)
+c010a5ca:	e8 b1 fd ff ff       	call   c010a380 <__intr_restore>
+c010a5cf:	83 c4 10             	add    $0x10,%esp
+}
+c010a5d2:	90                   	nop
+c010a5d3:	c9                   	leave  
+c010a5d4:	c3                   	ret    
+
+c010a5d5 <skew_heap_merge>:
+}
+
+static inline skew_heap_entry_t *
+skew_heap_merge(skew_heap_entry_t *a, skew_heap_entry_t *b,
+                compare_f comp)
+{
+c010a5d5:	55                   	push   %ebp
+c010a5d6:	89 e5                	mov    %esp,%ebp
+c010a5d8:	83 ec 18             	sub    $0x18,%esp
+     if (a == NULL) return b;
+c010a5db:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c010a5df:	75 08                	jne    c010a5e9 <skew_heap_merge+0x14>
+c010a5e1:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010a5e4:	e9 b4 00 00 00       	jmp    c010a69d <skew_heap_merge+0xc8>
+     else if (b == NULL) return a;
+c010a5e9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+c010a5ed:	75 08                	jne    c010a5f7 <skew_heap_merge+0x22>
+c010a5ef:	8b 45 08             	mov    0x8(%ebp),%eax
+c010a5f2:	e9 a6 00 00 00       	jmp    c010a69d <skew_heap_merge+0xc8>
+     
+     skew_heap_entry_t *l, *r;
+     if (comp(a, b) == -1)
+c010a5f7:	83 ec 08             	sub    $0x8,%esp
+c010a5fa:	ff 75 0c             	pushl  0xc(%ebp)
+c010a5fd:	ff 75 08             	pushl  0x8(%ebp)
+c010a600:	8b 45 10             	mov    0x10(%ebp),%eax
+c010a603:	ff d0                	call   *%eax
+c010a605:	83 c4 10             	add    $0x10,%esp
+c010a608:	83 f8 ff             	cmp    $0xffffffff,%eax
+c010a60b:	75 49                	jne    c010a656 <skew_heap_merge+0x81>
+     {
+          r = a->left;
+c010a60d:	8b 45 08             	mov    0x8(%ebp),%eax
+c010a610:	8b 40 04             	mov    0x4(%eax),%eax
+c010a613:	89 45 f4             	mov    %eax,-0xc(%ebp)
+          l = skew_heap_merge(a->right, b, comp);
+c010a616:	8b 45 08             	mov    0x8(%ebp),%eax
+c010a619:	8b 40 08             	mov    0x8(%eax),%eax
+c010a61c:	83 ec 04             	sub    $0x4,%esp
+c010a61f:	ff 75 10             	pushl  0x10(%ebp)
+c010a622:	ff 75 0c             	pushl  0xc(%ebp)
+c010a625:	50                   	push   %eax
+c010a626:	e8 aa ff ff ff       	call   c010a5d5 <skew_heap_merge>
+c010a62b:	83 c4 10             	add    $0x10,%esp
+c010a62e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+          
+          a->left = l;
+c010a631:	8b 45 08             	mov    0x8(%ebp),%eax
+c010a634:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c010a637:	89 50 04             	mov    %edx,0x4(%eax)
+          a->right = r;
+c010a63a:	8b 45 08             	mov    0x8(%ebp),%eax
+c010a63d:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c010a640:	89 50 08             	mov    %edx,0x8(%eax)
+          if (l) l->parent = a;
+c010a643:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c010a647:	74 08                	je     c010a651 <skew_heap_merge+0x7c>
+c010a649:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010a64c:	8b 55 08             	mov    0x8(%ebp),%edx
+c010a64f:	89 10                	mov    %edx,(%eax)
+
+          return a;
+c010a651:	8b 45 08             	mov    0x8(%ebp),%eax
+c010a654:	eb 47                	jmp    c010a69d <skew_heap_merge+0xc8>
+     }
+     else
+     {
+          r = b->left;
+c010a656:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010a659:	8b 40 04             	mov    0x4(%eax),%eax
+c010a65c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+          l = skew_heap_merge(a, b->right, comp);
+c010a65f:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010a662:	8b 40 08             	mov    0x8(%eax),%eax
+c010a665:	83 ec 04             	sub    $0x4,%esp
+c010a668:	ff 75 10             	pushl  0x10(%ebp)
+c010a66b:	50                   	push   %eax
+c010a66c:	ff 75 08             	pushl  0x8(%ebp)
+c010a66f:	e8 61 ff ff ff       	call   c010a5d5 <skew_heap_merge>
+c010a674:	83 c4 10             	add    $0x10,%esp
+c010a677:	89 45 f0             	mov    %eax,-0x10(%ebp)
+          
+          b->left = l;
+c010a67a:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010a67d:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c010a680:	89 50 04             	mov    %edx,0x4(%eax)
+          b->right = r;
+c010a683:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010a686:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c010a689:	89 50 08             	mov    %edx,0x8(%eax)
+          if (l) l->parent = b;
+c010a68c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c010a690:	74 08                	je     c010a69a <skew_heap_merge+0xc5>
+c010a692:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010a695:	8b 55 0c             	mov    0xc(%ebp),%edx
+c010a698:	89 10                	mov    %edx,(%eax)
+
+          return b;
+c010a69a:	8b 45 0c             	mov    0xc(%ebp),%eax
+     }
+}
+c010a69d:	c9                   	leave  
+c010a69e:	c3                   	ret    
+
+c010a69f <proc_stride_comp_f>:
+
+/* The compare function for two skew_heap_node_t's and the
+ * corresponding procs*/
+static int
+proc_stride_comp_f(void *a, void *b)
+{
+c010a69f:	55                   	push   %ebp
+c010a6a0:	89 e5                	mov    %esp,%ebp
+c010a6a2:	83 ec 10             	sub    $0x10,%esp
+     struct proc_struct *p = le2proc(a, lab6_run_pool);
+c010a6a5:	8b 45 08             	mov    0x8(%ebp),%eax
+c010a6a8:	2d 8c 00 00 00       	sub    $0x8c,%eax
+c010a6ad:	89 45 fc             	mov    %eax,-0x4(%ebp)
+     struct proc_struct *q = le2proc(b, lab6_run_pool);
+c010a6b0:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010a6b3:	2d 8c 00 00 00       	sub    $0x8c,%eax
+c010a6b8:	89 45 f8             	mov    %eax,-0x8(%ebp)
+     int32_t c = p->lab6_stride - q->lab6_stride;
+c010a6bb:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c010a6be:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
+c010a6c4:	8b 45 f8             	mov    -0x8(%ebp),%eax
+c010a6c7:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
+c010a6cd:	29 c2                	sub    %eax,%edx
+c010a6cf:	89 d0                	mov    %edx,%eax
+c010a6d1:	89 45 f4             	mov    %eax,-0xc(%ebp)
+     if (c > 0) return 1;
+c010a6d4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c010a6d8:	7e 07                	jle    c010a6e1 <proc_stride_comp_f+0x42>
+c010a6da:	b8 01 00 00 00       	mov    $0x1,%eax
+c010a6df:	eb 12                	jmp    c010a6f3 <proc_stride_comp_f+0x54>
+     else if (c == 0) return 0;
+c010a6e1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c010a6e5:	75 07                	jne    c010a6ee <proc_stride_comp_f+0x4f>
+c010a6e7:	b8 00 00 00 00       	mov    $0x0,%eax
+c010a6ec:	eb 05                	jmp    c010a6f3 <proc_stride_comp_f+0x54>
+     else return -1;
+c010a6ee:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+c010a6f3:	c9                   	leave  
+c010a6f4:	c3                   	ret    
+
+c010a6f5 <stride_init>:
+ *   - max_time_slice: no need here, the variable would be assigned by the caller.
+ *
+ * hint: see libs/list.h for routines of the list structures.
+ */
+static void
+stride_init(struct run_queue *rq) {
+c010a6f5:	55                   	push   %ebp
+c010a6f6:	89 e5                	mov    %esp,%ebp
+c010a6f8:	83 ec 10             	sub    $0x10,%esp
+     /* LAB6: YOUR CODE 
+      * (1) init the ready process list: rq->run_list
+      * (2) init the run pool: rq->lab6_run_pool
+      * (3) set number of process: rq->proc_num to 0       
+      */
+      list_init(&rq->run_list); 
+c010a6fb:	8b 45 08             	mov    0x8(%ebp),%eax
+c010a6fe:	89 45 fc             	mov    %eax,-0x4(%ebp)
+c010a701:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c010a704:	8b 55 fc             	mov    -0x4(%ebp),%edx
+c010a707:	89 50 04             	mov    %edx,0x4(%eax)
+c010a70a:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c010a70d:	8b 50 04             	mov    0x4(%eax),%edx
+c010a710:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c010a713:	89 10                	mov    %edx,(%eax)
+      rq->lab6_run_pool = NULL;
+c010a715:	8b 45 08             	mov    0x8(%ebp),%eax
+c010a718:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
+      rq->proc_num = 0;
+c010a71f:	8b 45 08             	mov    0x8(%ebp),%eax
+c010a722:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
+}
+c010a729:	90                   	nop
+c010a72a:	c9                   	leave  
+c010a72b:	c3                   	ret    
+
+c010a72c <stride_enqueue>:
+ * 
+ * hint: see libs/skew_heap.h for routines of the priority
+ * queue structures.
+ */
+static void
+stride_enqueue(struct run_queue *rq, struct proc_struct *proc) {
+c010a72c:	55                   	push   %ebp
+c010a72d:	89 e5                	mov    %esp,%ebp
+c010a72f:	83 ec 18             	sub    $0x18,%esp
+      *         list_add_before: insert  a entry into the last of list   
+      * (2) recalculate proc->time_slice
+      * (3) set proc->rq pointer to rq
+      * (4) increase rq->proc_num
+      */
+      rq->lab6_run_pool = skew_heap_insert(rq->lab6_run_pool, &proc->lab6_run_pool, proc_stride_comp_f);
+c010a732:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010a735:	8d 90 8c 00 00 00    	lea    0x8c(%eax),%edx
+c010a73b:	8b 45 08             	mov    0x8(%ebp),%eax
+c010a73e:	8b 40 10             	mov    0x10(%eax),%eax
+c010a741:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c010a744:	89 55 f0             	mov    %edx,-0x10(%ebp)
+c010a747:	c7 45 ec 9f a6 10 c0 	movl   $0xc010a69f,-0x14(%ebp)
+c010a74e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010a751:	89 45 e8             	mov    %eax,-0x18(%ebp)
+     compare_f comp) __attribute__((always_inline));
+
+static inline void
+skew_heap_init(skew_heap_entry_t *a)
+{
+     a->left = a->right = a->parent = NULL;
+c010a754:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010a757:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+c010a75d:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010a760:	8b 10                	mov    (%eax),%edx
+c010a762:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010a765:	89 50 08             	mov    %edx,0x8(%eax)
+c010a768:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010a76b:	8b 50 08             	mov    0x8(%eax),%edx
+c010a76e:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010a771:	89 50 04             	mov    %edx,0x4(%eax)
+static inline skew_heap_entry_t *
+skew_heap_insert(skew_heap_entry_t *a, skew_heap_entry_t *b,
+                 compare_f comp)
+{
+     skew_heap_init(b);
+     return skew_heap_merge(a, b, comp);
+c010a774:	83 ec 04             	sub    $0x4,%esp
+c010a777:	ff 75 ec             	pushl  -0x14(%ebp)
+c010a77a:	ff 75 f0             	pushl  -0x10(%ebp)
+c010a77d:	ff 75 f4             	pushl  -0xc(%ebp)
+c010a780:	e8 50 fe ff ff       	call   c010a5d5 <skew_heap_merge>
+c010a785:	83 c4 10             	add    $0x10,%esp
+c010a788:	89 c2                	mov    %eax,%edx
+c010a78a:	8b 45 08             	mov    0x8(%ebp),%eax
+c010a78d:	89 50 10             	mov    %edx,0x10(%eax)
+      if(proc->time_slice == 0 || proc->time_slice > rq->max_time_slice) {
+c010a790:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010a793:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
+c010a799:	85 c0                	test   %eax,%eax
+c010a79b:	74 13                	je     c010a7b0 <stride_enqueue+0x84>
+c010a79d:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010a7a0:	8b 90 88 00 00 00    	mov    0x88(%eax),%edx
+c010a7a6:	8b 45 08             	mov    0x8(%ebp),%eax
+c010a7a9:	8b 40 0c             	mov    0xc(%eax),%eax
+c010a7ac:	39 c2                	cmp    %eax,%edx
+c010a7ae:	7e 0f                	jle    c010a7bf <stride_enqueue+0x93>
+          proc->time_slice = rq->max_time_slice;
+c010a7b0:	8b 45 08             	mov    0x8(%ebp),%eax
+c010a7b3:	8b 50 0c             	mov    0xc(%eax),%edx
+c010a7b6:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010a7b9:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
+      }
+      proc->rq = rq;
+c010a7bf:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010a7c2:	8b 55 08             	mov    0x8(%ebp),%edx
+c010a7c5:	89 50 7c             	mov    %edx,0x7c(%eax)
+      rq->proc_num ++;
+c010a7c8:	8b 45 08             	mov    0x8(%ebp),%eax
+c010a7cb:	8b 40 08             	mov    0x8(%eax),%eax
+c010a7ce:	8d 50 01             	lea    0x1(%eax),%edx
+c010a7d1:	8b 45 08             	mov    0x8(%ebp),%eax
+c010a7d4:	89 50 08             	mov    %edx,0x8(%eax)
+}
+c010a7d7:	90                   	nop
+c010a7d8:	c9                   	leave  
+c010a7d9:	c3                   	ret    
+
+c010a7da <stride_dequeue>:
+ *
+ * hint: see libs/skew_heap.h for routines of the priority
+ * queue structures.
+ */
+static void
+stride_dequeue(struct run_queue *rq, struct proc_struct *proc) {
+c010a7da:	55                   	push   %ebp
+c010a7db:	89 e5                	mov    %esp,%ebp
+c010a7dd:	83 ec 28             	sub    $0x28,%esp
+      * (1) remove the proc from rq correctly
+      * NOTICE: you can use skew_heap or list. Important functions
+      *         skew_heap_remove: remove a entry from skew_heap
+      *         list_del_init: remove a entry from the  list
+      */
+      rq->lab6_run_pool = skew_heap_remove(rq->lab6_run_pool, &proc->lab6_run_pool, proc_stride_comp_f);
+c010a7e0:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010a7e3:	8d 90 8c 00 00 00    	lea    0x8c(%eax),%edx
+c010a7e9:	8b 45 08             	mov    0x8(%ebp),%eax
+c010a7ec:	8b 40 10             	mov    0x10(%eax),%eax
+c010a7ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c010a7f2:	89 55 f0             	mov    %edx,-0x10(%ebp)
+c010a7f5:	c7 45 ec 9f a6 10 c0 	movl   $0xc010a69f,-0x14(%ebp)
+
+static inline skew_heap_entry_t *
+skew_heap_remove(skew_heap_entry_t *a, skew_heap_entry_t *b,
+                 compare_f comp)
+{
+     skew_heap_entry_t *p   = b->parent;
+c010a7fc:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010a7ff:	8b 00                	mov    (%eax),%eax
+c010a801:	89 45 e8             	mov    %eax,-0x18(%ebp)
+     skew_heap_entry_t *rep = skew_heap_merge(b->left, b->right, comp);
+c010a804:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010a807:	8b 50 08             	mov    0x8(%eax),%edx
+c010a80a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010a80d:	8b 40 04             	mov    0x4(%eax),%eax
+c010a810:	83 ec 04             	sub    $0x4,%esp
+c010a813:	ff 75 ec             	pushl  -0x14(%ebp)
+c010a816:	52                   	push   %edx
+c010a817:	50                   	push   %eax
+c010a818:	e8 b8 fd ff ff       	call   c010a5d5 <skew_heap_merge>
+c010a81d:	83 c4 10             	add    $0x10,%esp
+c010a820:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+     if (rep) rep->parent = p;
+c010a823:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+c010a827:	74 08                	je     c010a831 <stride_dequeue+0x57>
+c010a829:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c010a82c:	8b 55 e8             	mov    -0x18(%ebp),%edx
+c010a82f:	89 10                	mov    %edx,(%eax)
+     
+     if (p)
+c010a831:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+c010a835:	74 24                	je     c010a85b <stride_dequeue+0x81>
+     {
+          if (p->left == b)
+c010a837:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010a83a:	8b 40 04             	mov    0x4(%eax),%eax
+c010a83d:	39 45 f0             	cmp    %eax,-0x10(%ebp)
+c010a840:	75 0b                	jne    c010a84d <stride_dequeue+0x73>
+               p->left = rep;
+c010a842:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010a845:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c010a848:	89 50 04             	mov    %edx,0x4(%eax)
+c010a84b:	eb 09                	jmp    c010a856 <stride_dequeue+0x7c>
+          else p->right = rep;
+c010a84d:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010a850:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c010a853:	89 50 08             	mov    %edx,0x8(%eax)
+          return a;
+c010a856:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010a859:	eb 03                	jmp    c010a85e <stride_dequeue+0x84>
+     }
+     else return rep;
+c010a85b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c010a85e:	8b 55 08             	mov    0x8(%ebp),%edx
+c010a861:	89 42 10             	mov    %eax,0x10(%edx)
+      rq->proc_num --;
+c010a864:	8b 45 08             	mov    0x8(%ebp),%eax
+c010a867:	8b 40 08             	mov    0x8(%eax),%eax
+c010a86a:	8d 50 ff             	lea    -0x1(%eax),%edx
+c010a86d:	8b 45 08             	mov    0x8(%ebp),%eax
+c010a870:	89 50 08             	mov    %edx,0x8(%eax)
+}
+c010a873:	90                   	nop
+c010a874:	c9                   	leave  
+c010a875:	c3                   	ret    
+
+c010a876 <stride_pick_next>:
+ *
+ * hint: see libs/skew_heap.h for routines of the priority
+ * queue structures.
+ */
+static struct proc_struct *
+stride_pick_next(struct run_queue *rq) {
+c010a876:	55                   	push   %ebp
+c010a877:	89 e5                	mov    %esp,%ebp
+c010a879:	53                   	push   %ebx
+c010a87a:	83 ec 10             	sub    $0x10,%esp
+             (1.1) If using skew_heap, we can use le2proc get the p from rq->lab6_run_poll
+             (1.2) If using list, we have to search list to find the p with minimum stride value
+      * (2) update p;s stride value: p->lab6_stride
+      * (3) return p
+      */ 
+      if (rq->lab6_run_pool == NULL) 
+c010a87d:	8b 45 08             	mov    0x8(%ebp),%eax
+c010a880:	8b 40 10             	mov    0x10(%eax),%eax
+c010a883:	85 c0                	test   %eax,%eax
+c010a885:	75 07                	jne    c010a88e <stride_pick_next+0x18>
+          return NULL; 
+c010a887:	b8 00 00 00 00       	mov    $0x0,%eax
+c010a88c:	eb 3b                	jmp    c010a8c9 <stride_pick_next+0x53>
+      struct proc_struct *p = le2proc(rq->lab6_run_pool, lab6_run_pool);
+c010a88e:	8b 45 08             	mov    0x8(%ebp),%eax
+c010a891:	8b 40 10             	mov    0x10(%eax),%eax
+c010a894:	2d 8c 00 00 00       	sub    $0x8c,%eax
+c010a899:	89 45 f8             	mov    %eax,-0x8(%ebp)
+      p->lab6_stride += BIG_STRIDE/p->lab6_priority;
+c010a89c:	8b 45 f8             	mov    -0x8(%ebp),%eax
+c010a89f:	8b 88 98 00 00 00    	mov    0x98(%eax),%ecx
+c010a8a5:	8b 45 f8             	mov    -0x8(%ebp),%eax
+c010a8a8:	8b 98 9c 00 00 00    	mov    0x9c(%eax),%ebx
+c010a8ae:	b8 fd ff ff 7f       	mov    $0x7ffffffd,%eax
+c010a8b3:	ba 00 00 00 00       	mov    $0x0,%edx
+c010a8b8:	f7 f3                	div    %ebx
+c010a8ba:	8d 14 01             	lea    (%ecx,%eax,1),%edx
+c010a8bd:	8b 45 f8             	mov    -0x8(%ebp),%eax
+c010a8c0:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
+      return p;
+c010a8c6:	8b 45 f8             	mov    -0x8(%ebp),%eax
+
+}
+c010a8c9:	83 c4 10             	add    $0x10,%esp
+c010a8cc:	5b                   	pop    %ebx
+c010a8cd:	5d                   	pop    %ebp
+c010a8ce:	c3                   	ret    
+
+c010a8cf <stride_proc_tick>:
+ * denotes the time slices left for current
+ * process. proc->need_resched is the flag variable for process
+ * switching.
+ */
+static void
+stride_proc_tick(struct run_queue *rq, struct proc_struct *proc) {
+c010a8cf:	55                   	push   %ebp
+c010a8d0:	89 e5                	mov    %esp,%ebp
+     /* LAB6: YOUR CODE */
+	if (proc->time_slice > 0) {
+c010a8d2:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010a8d5:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
+c010a8db:	85 c0                	test   %eax,%eax
+c010a8dd:	7e 15                	jle    c010a8f4 <stride_proc_tick+0x25>
+		proc->time_slice --;
+c010a8df:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010a8e2:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
+c010a8e8:	8d 50 ff             	lea    -0x1(%eax),%edx
+c010a8eb:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010a8ee:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
+	}
+	if (proc->time_slice == 0) {
+c010a8f4:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010a8f7:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
+c010a8fd:	85 c0                	test   %eax,%eax
+c010a8ff:	75 0a                	jne    c010a90b <stride_proc_tick+0x3c>
+		proc->need_resched = 1;
+c010a901:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010a904:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
+	}
+}
+c010a90b:	90                   	nop
+c010a90c:	5d                   	pop    %ebp
+c010a90d:	c3                   	ret    
+
+c010a90e <RR_init>:
+#include <proc.h>
+#include <assert.h>
+#include <default_sched.h>
+
+static void
+RR_init(struct run_queue *rq) {
+c010a90e:	55                   	push   %ebp
+c010a90f:	89 e5                	mov    %esp,%ebp
+c010a911:	83 ec 10             	sub    $0x10,%esp
+    list_init(&(rq->run_list));
+c010a914:	8b 45 08             	mov    0x8(%ebp),%eax
+c010a917:	89 45 fc             	mov    %eax,-0x4(%ebp)
+c010a91a:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c010a91d:	8b 55 fc             	mov    -0x4(%ebp),%edx
+c010a920:	89 50 04             	mov    %edx,0x4(%eax)
+c010a923:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c010a926:	8b 50 04             	mov    0x4(%eax),%edx
+c010a929:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c010a92c:	89 10                	mov    %edx,(%eax)
+    rq->proc_num = 0;
+c010a92e:	8b 45 08             	mov    0x8(%ebp),%eax
+c010a931:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
+}
+c010a938:	90                   	nop
+c010a939:	c9                   	leave  
+c010a93a:	c3                   	ret    
+
+c010a93b <RR_enqueue>:
+
+static void
+RR_enqueue(struct run_queue *rq, struct proc_struct *proc) {
+c010a93b:	55                   	push   %ebp
+c010a93c:	89 e5                	mov    %esp,%ebp
+c010a93e:	83 ec 28             	sub    $0x28,%esp
+    assert(list_empty(&(proc->run_link)));
+c010a941:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010a944:	83 e8 80             	sub    $0xffffff80,%eax
+c010a947:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ * list_empty - tests whether a list is empty
+ * @list:       the list to test.
+ * */
+static inline bool
+list_empty(list_entry_t *list) {
+    return list->next == list;
+c010a94a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010a94d:	8b 40 04             	mov    0x4(%eax),%eax
+c010a950:	39 45 f0             	cmp    %eax,-0x10(%ebp)
+c010a953:	0f 94 c0             	sete   %al
+c010a956:	0f b6 c0             	movzbl %al,%eax
+c010a959:	85 c0                	test   %eax,%eax
+c010a95b:	75 16                	jne    c010a973 <RR_enqueue+0x38>
+c010a95d:	68 2c de 10 c0       	push   $0xc010de2c
+c010a962:	68 4a de 10 c0       	push   $0xc010de4a
+c010a967:	6a 0f                	push   $0xf
+c010a969:	68 5f de 10 c0       	push   $0xc010de5f
+c010a96e:	e8 82 5a ff ff       	call   c01003f5 <__panic>
+    list_add_before(&(rq->run_list), &(proc->run_link));
+c010a973:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010a976:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
+c010a97c:	8b 45 08             	mov    0x8(%ebp),%eax
+c010a97f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c010a982:	89 55 ec             	mov    %edx,-0x14(%ebp)
+ * Insert the new element @elm *before* the element @listelm which
+ * is already in the list.
+ * */
+static inline void
+list_add_before(list_entry_t *listelm, list_entry_t *elm) {
+    __list_add(elm, listelm->prev, listelm);
+c010a985:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010a988:	8b 00                	mov    (%eax),%eax
+c010a98a:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c010a98d:	89 55 e8             	mov    %edx,-0x18(%ebp)
+c010a990:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c010a993:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010a996:	89 45 e0             	mov    %eax,-0x20(%ebp)
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ * */
+static inline void
+__list_add(list_entry_t *elm, list_entry_t *prev, list_entry_t *next) {
+    prev->next = next->prev = elm;
+c010a999:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c010a99c:	8b 55 e8             	mov    -0x18(%ebp),%edx
+c010a99f:	89 10                	mov    %edx,(%eax)
+c010a9a1:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c010a9a4:	8b 10                	mov    (%eax),%edx
+c010a9a6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c010a9a9:	89 50 04             	mov    %edx,0x4(%eax)
+    elm->next = next;
+c010a9ac:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010a9af:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c010a9b2:	89 50 04             	mov    %edx,0x4(%eax)
+    elm->prev = prev;
+c010a9b5:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010a9b8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c010a9bb:	89 10                	mov    %edx,(%eax)
+    if (proc->time_slice == 0 || proc->time_slice > rq->max_time_slice) {
+c010a9bd:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010a9c0:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
+c010a9c6:	85 c0                	test   %eax,%eax
+c010a9c8:	74 13                	je     c010a9dd <RR_enqueue+0xa2>
+c010a9ca:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010a9cd:	8b 90 88 00 00 00    	mov    0x88(%eax),%edx
+c010a9d3:	8b 45 08             	mov    0x8(%ebp),%eax
+c010a9d6:	8b 40 0c             	mov    0xc(%eax),%eax
+c010a9d9:	39 c2                	cmp    %eax,%edx
+c010a9db:	7e 0f                	jle    c010a9ec <RR_enqueue+0xb1>
+        proc->time_slice = rq->max_time_slice;
+c010a9dd:	8b 45 08             	mov    0x8(%ebp),%eax
+c010a9e0:	8b 50 0c             	mov    0xc(%eax),%edx
+c010a9e3:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010a9e6:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
+    }
+    proc->rq = rq;
+c010a9ec:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010a9ef:	8b 55 08             	mov    0x8(%ebp),%edx
+c010a9f2:	89 50 7c             	mov    %edx,0x7c(%eax)
+    rq->proc_num ++;
+c010a9f5:	8b 45 08             	mov    0x8(%ebp),%eax
+c010a9f8:	8b 40 08             	mov    0x8(%eax),%eax
+c010a9fb:	8d 50 01             	lea    0x1(%eax),%edx
+c010a9fe:	8b 45 08             	mov    0x8(%ebp),%eax
+c010aa01:	89 50 08             	mov    %edx,0x8(%eax)
+}
+c010aa04:	90                   	nop
+c010aa05:	c9                   	leave  
+c010aa06:	c3                   	ret    
+
+c010aa07 <RR_dequeue>:
+
+static void
+RR_dequeue(struct run_queue *rq, struct proc_struct *proc) {
+c010aa07:	55                   	push   %ebp
+c010aa08:	89 e5                	mov    %esp,%ebp
+c010aa0a:	83 ec 28             	sub    $0x28,%esp
+    assert(!list_empty(&(proc->run_link)) && proc->rq == rq);
+c010aa0d:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010aa10:	83 e8 80             	sub    $0xffffff80,%eax
+c010aa13:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ * list_empty - tests whether a list is empty
+ * @list:       the list to test.
+ * */
+static inline bool
+list_empty(list_entry_t *list) {
+    return list->next == list;
+c010aa16:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010aa19:	8b 40 04             	mov    0x4(%eax),%eax
+c010aa1c:	39 45 f0             	cmp    %eax,-0x10(%ebp)
+c010aa1f:	0f 94 c0             	sete   %al
+c010aa22:	0f b6 c0             	movzbl %al,%eax
+c010aa25:	85 c0                	test   %eax,%eax
+c010aa27:	75 0b                	jne    c010aa34 <RR_dequeue+0x2d>
+c010aa29:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010aa2c:	8b 40 7c             	mov    0x7c(%eax),%eax
+c010aa2f:	3b 45 08             	cmp    0x8(%ebp),%eax
+c010aa32:	74 16                	je     c010aa4a <RR_dequeue+0x43>
+c010aa34:	68 80 de 10 c0       	push   $0xc010de80
+c010aa39:	68 4a de 10 c0       	push   $0xc010de4a
+c010aa3e:	6a 1a                	push   $0x1a
+c010aa40:	68 5f de 10 c0       	push   $0xc010de5f
+c010aa45:	e8 ab 59 ff ff       	call   c01003f5 <__panic>
+    list_del_init(&(proc->run_link));
+c010aa4a:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010aa4d:	83 e8 80             	sub    $0xffffff80,%eax
+c010aa50:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c010aa53:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010aa56:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ * Note: list_empty() on @listelm does not return true after this, the entry is
+ * in an undefined state.
+ * */
+static inline void
+list_del(list_entry_t *listelm) {
+    __list_del(listelm->prev, listelm->next);
+c010aa59:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010aa5c:	8b 40 04             	mov    0x4(%eax),%eax
+c010aa5f:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c010aa62:	8b 12                	mov    (%edx),%edx
+c010aa64:	89 55 e8             	mov    %edx,-0x18(%ebp)
+c010aa67:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ * */
+static inline void
+__list_del(list_entry_t *prev, list_entry_t *next) {
+    prev->next = next;
+c010aa6a:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010aa6d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c010aa70:	89 50 04             	mov    %edx,0x4(%eax)
+    next->prev = prev;
+c010aa73:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c010aa76:	8b 55 e8             	mov    -0x18(%ebp),%edx
+c010aa79:	89 10                	mov    %edx,(%eax)
+c010aa7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010aa7e:	89 45 e0             	mov    %eax,-0x20(%ebp)
+ * list_init - initialize a new entry
+ * @elm:        new entry to be initialized
+ * */
+static inline void
+list_init(list_entry_t *elm) {
+    elm->prev = elm->next = elm;
+c010aa81:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c010aa84:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c010aa87:	89 50 04             	mov    %edx,0x4(%eax)
+c010aa8a:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c010aa8d:	8b 50 04             	mov    0x4(%eax),%edx
+c010aa90:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c010aa93:	89 10                	mov    %edx,(%eax)
+    rq->proc_num --;
+c010aa95:	8b 45 08             	mov    0x8(%ebp),%eax
+c010aa98:	8b 40 08             	mov    0x8(%eax),%eax
+c010aa9b:	8d 50 ff             	lea    -0x1(%eax),%edx
+c010aa9e:	8b 45 08             	mov    0x8(%ebp),%eax
+c010aaa1:	89 50 08             	mov    %edx,0x8(%eax)
+}
+c010aaa4:	90                   	nop
+c010aaa5:	c9                   	leave  
+c010aaa6:	c3                   	ret    
+
+c010aaa7 <RR_pick_next>:
+
+static struct proc_struct *
+RR_pick_next(struct run_queue *rq) {
+c010aaa7:	55                   	push   %ebp
+c010aaa8:	89 e5                	mov    %esp,%ebp
+c010aaaa:	83 ec 10             	sub    $0x10,%esp
+    list_entry_t *le = list_next(&(rq->run_list));
+c010aaad:	8b 45 08             	mov    0x8(%ebp),%eax
+c010aab0:	89 45 f8             	mov    %eax,-0x8(%ebp)
+ * list_next - get the next entry
+ * @listelm:    the list head
+ **/
+static inline list_entry_t *
+list_next(list_entry_t *listelm) {
+    return listelm->next;
+c010aab3:	8b 45 f8             	mov    -0x8(%ebp),%eax
+c010aab6:	8b 40 04             	mov    0x4(%eax),%eax
+c010aab9:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    if (le != &(rq->run_list)) {
+c010aabc:	8b 45 08             	mov    0x8(%ebp),%eax
+c010aabf:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+c010aac2:	74 08                	je     c010aacc <RR_pick_next+0x25>
+        return le2proc(le, run_link);
+c010aac4:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c010aac7:	83 c0 80             	add    $0xffffff80,%eax
+c010aaca:	eb 05                	jmp    c010aad1 <RR_pick_next+0x2a>
+    }
+    return NULL;
+c010aacc:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c010aad1:	c9                   	leave  
+c010aad2:	c3                   	ret    
+
+c010aad3 <RR_proc_tick>:
+
+static void
+RR_proc_tick(struct run_queue *rq, struct proc_struct *proc) {
+c010aad3:	55                   	push   %ebp
+c010aad4:	89 e5                	mov    %esp,%ebp
+    if (proc->time_slice > 0) {
+c010aad6:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010aad9:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
+c010aadf:	85 c0                	test   %eax,%eax
+c010aae1:	7e 15                	jle    c010aaf8 <RR_proc_tick+0x25>
+        proc->time_slice --;
+c010aae3:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010aae6:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
+c010aaec:	8d 50 ff             	lea    -0x1(%eax),%edx
+c010aaef:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010aaf2:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
+    }
+    if (proc->time_slice == 0) {
+c010aaf8:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010aafb:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
+c010ab01:	85 c0                	test   %eax,%eax
+c010ab03:	75 0a                	jne    c010ab0f <RR_proc_tick+0x3c>
+        proc->need_resched = 1;
+c010ab05:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010ab08:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
+    }
+}
+c010ab0f:	90                   	nop
+c010ab10:	5d                   	pop    %ebp
+c010ab11:	c3                   	ret    
+
+c010ab12 <sys_exit>:
+#include <pmm.h>
+#include <assert.h>
+#include <clock.h>
+
+static int
+sys_exit(uint32_t arg[]) {
+c010ab12:	55                   	push   %ebp
+c010ab13:	89 e5                	mov    %esp,%ebp
+c010ab15:	83 ec 18             	sub    $0x18,%esp
+    int error_code = (int)arg[0];
+c010ab18:	8b 45 08             	mov    0x8(%ebp),%eax
+c010ab1b:	8b 00                	mov    (%eax),%eax
+c010ab1d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    return do_exit(error_code);
+c010ab20:	83 ec 0c             	sub    $0xc,%esp
+c010ab23:	ff 75 f4             	pushl  -0xc(%ebp)
+c010ab26:	e8 94 e9 ff ff       	call   c01094bf <do_exit>
+c010ab2b:	83 c4 10             	add    $0x10,%esp
+}
+c010ab2e:	c9                   	leave  
+c010ab2f:	c3                   	ret    
+
+c010ab30 <sys_fork>:
+
+static int
+sys_fork(uint32_t arg[]) {
+c010ab30:	55                   	push   %ebp
+c010ab31:	89 e5                	mov    %esp,%ebp
+c010ab33:	83 ec 18             	sub    $0x18,%esp
+    struct trapframe *tf = current->tf;
+c010ab36:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c010ab3b:	8b 40 3c             	mov    0x3c(%eax),%eax
+c010ab3e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    uintptr_t stack = tf->tf_esp;
+c010ab41:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010ab44:	8b 40 44             	mov    0x44(%eax),%eax
+c010ab47:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    return do_fork(0, stack, tf);
+c010ab4a:	83 ec 04             	sub    $0x4,%esp
+c010ab4d:	ff 75 f4             	pushl  -0xc(%ebp)
+c010ab50:	ff 75 f0             	pushl  -0x10(%ebp)
+c010ab53:	6a 00                	push   $0x0
+c010ab55:	e8 4a e8 ff ff       	call   c01093a4 <do_fork>
+c010ab5a:	83 c4 10             	add    $0x10,%esp
+}
+c010ab5d:	c9                   	leave  
+c010ab5e:	c3                   	ret    
+
+c010ab5f <sys_wait>:
+
+static int
+sys_wait(uint32_t arg[]) {
+c010ab5f:	55                   	push   %ebp
+c010ab60:	89 e5                	mov    %esp,%ebp
+c010ab62:	83 ec 18             	sub    $0x18,%esp
+    int pid = (int)arg[0];
+c010ab65:	8b 45 08             	mov    0x8(%ebp),%eax
+c010ab68:	8b 00                	mov    (%eax),%eax
+c010ab6a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    int *store = (int *)arg[1];
+c010ab6d:	8b 45 08             	mov    0x8(%ebp),%eax
+c010ab70:	83 c0 04             	add    $0x4,%eax
+c010ab73:	8b 00                	mov    (%eax),%eax
+c010ab75:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    return do_wait(pid, store);
+c010ab78:	83 ec 08             	sub    $0x8,%esp
+c010ab7b:	ff 75 f0             	pushl  -0x10(%ebp)
+c010ab7e:	ff 75 f4             	pushl  -0xc(%ebp)
+c010ab81:	e8 18 f2 ff ff       	call   c0109d9e <do_wait>
+c010ab86:	83 c4 10             	add    $0x10,%esp
+}
+c010ab89:	c9                   	leave  
+c010ab8a:	c3                   	ret    
+
+c010ab8b <sys_exec>:
+
+static int
+sys_exec(uint32_t arg[]) {
+c010ab8b:	55                   	push   %ebp
+c010ab8c:	89 e5                	mov    %esp,%ebp
+c010ab8e:	83 ec 18             	sub    $0x18,%esp
+    const char *name = (const char *)arg[0];
+c010ab91:	8b 45 08             	mov    0x8(%ebp),%eax
+c010ab94:	8b 00                	mov    (%eax),%eax
+c010ab96:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    size_t len = (size_t)arg[1];
+c010ab99:	8b 45 08             	mov    0x8(%ebp),%eax
+c010ab9c:	83 c0 04             	add    $0x4,%eax
+c010ab9f:	8b 00                	mov    (%eax),%eax
+c010aba1:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    unsigned char *binary = (unsigned char *)arg[2];
+c010aba4:	8b 45 08             	mov    0x8(%ebp),%eax
+c010aba7:	83 c0 08             	add    $0x8,%eax
+c010abaa:	8b 00                	mov    (%eax),%eax
+c010abac:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    size_t size = (size_t)arg[3];
+c010abaf:	8b 45 08             	mov    0x8(%ebp),%eax
+c010abb2:	83 c0 0c             	add    $0xc,%eax
+c010abb5:	8b 00                	mov    (%eax),%eax
+c010abb7:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    return do_execve(name, len, binary, size);
+c010abba:	ff 75 e8             	pushl  -0x18(%ebp)
+c010abbd:	ff 75 ec             	pushl  -0x14(%ebp)
+c010abc0:	ff 75 f0             	pushl  -0x10(%ebp)
+c010abc3:	ff 75 f4             	pushl  -0xc(%ebp)
+c010abc6:	e8 9b f0 ff ff       	call   c0109c66 <do_execve>
+c010abcb:	83 c4 10             	add    $0x10,%esp
+}
+c010abce:	c9                   	leave  
+c010abcf:	c3                   	ret    
+
+c010abd0 <sys_yield>:
+
+static int
+sys_yield(uint32_t arg[]) {
+c010abd0:	55                   	push   %ebp
+c010abd1:	89 e5                	mov    %esp,%ebp
+c010abd3:	83 ec 08             	sub    $0x8,%esp
+    return do_yield();
+c010abd6:	e8 ad f1 ff ff       	call   c0109d88 <do_yield>
+}
+c010abdb:	c9                   	leave  
+c010abdc:	c3                   	ret    
+
+c010abdd <sys_kill>:
+
+static int
+sys_kill(uint32_t arg[]) {
+c010abdd:	55                   	push   %ebp
+c010abde:	89 e5                	mov    %esp,%ebp
+c010abe0:	83 ec 18             	sub    $0x18,%esp
+    int pid = (int)arg[0];
+c010abe3:	8b 45 08             	mov    0x8(%ebp),%eax
+c010abe6:	8b 00                	mov    (%eax),%eax
+c010abe8:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    return do_kill(pid);
+c010abeb:	83 ec 0c             	sub    $0xc,%esp
+c010abee:	ff 75 f4             	pushl  -0xc(%ebp)
+c010abf1:	e8 36 f3 ff ff       	call   c0109f2c <do_kill>
+c010abf6:	83 c4 10             	add    $0x10,%esp
+}
+c010abf9:	c9                   	leave  
+c010abfa:	c3                   	ret    
+
+c010abfb <sys_getpid>:
+
+static int
+sys_getpid(uint32_t arg[]) {
+c010abfb:	55                   	push   %ebp
+c010abfc:	89 e5                	mov    %esp,%ebp
+    return current->pid;
+c010abfe:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c010ac03:	8b 40 04             	mov    0x4(%eax),%eax
+}
+c010ac06:	5d                   	pop    %ebp
+c010ac07:	c3                   	ret    
+
+c010ac08 <sys_putc>:
+
+static int
+sys_putc(uint32_t arg[]) {
+c010ac08:	55                   	push   %ebp
+c010ac09:	89 e5                	mov    %esp,%ebp
+c010ac0b:	83 ec 18             	sub    $0x18,%esp
+    int c = (int)arg[0];
+c010ac0e:	8b 45 08             	mov    0x8(%ebp),%eax
+c010ac11:	8b 00                	mov    (%eax),%eax
+c010ac13:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cputchar(c);
+c010ac16:	83 ec 0c             	sub    $0xc,%esp
+c010ac19:	ff 75 f4             	pushl  -0xc(%ebp)
+c010ac1c:	e8 94 56 ff ff       	call   c01002b5 <cputchar>
+c010ac21:	83 c4 10             	add    $0x10,%esp
+    return 0;
+c010ac24:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c010ac29:	c9                   	leave  
+c010ac2a:	c3                   	ret    
+
+c010ac2b <sys_pgdir>:
+
+static int
+sys_pgdir(uint32_t arg[]) {
+c010ac2b:	55                   	push   %ebp
+c010ac2c:	89 e5                	mov    %esp,%ebp
+c010ac2e:	83 ec 08             	sub    $0x8,%esp
+    print_pgdir();
+c010ac31:	e8 e6 a2 ff ff       	call   c0104f1c <print_pgdir>
+    return 0;
+c010ac36:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c010ac3b:	c9                   	leave  
+c010ac3c:	c3                   	ret    
+
+c010ac3d <sys_gettime>:
+
+static int
+sys_gettime(uint32_t arg[]) {
+c010ac3d:	55                   	push   %ebp
+c010ac3e:	89 e5                	mov    %esp,%ebp
+    return (int)ticks;
+c010ac40:	a1 78 30 1b c0       	mov    0xc01b3078,%eax
+}
+c010ac45:	5d                   	pop    %ebp
+c010ac46:	c3                   	ret    
+
+c010ac47 <sys_lab6_set_priority>:
+static int
+sys_lab6_set_priority(uint32_t arg[])
+{
+c010ac47:	55                   	push   %ebp
+c010ac48:	89 e5                	mov    %esp,%ebp
+c010ac4a:	83 ec 18             	sub    $0x18,%esp
+    uint32_t priority = (uint32_t)arg[0];
+c010ac4d:	8b 45 08             	mov    0x8(%ebp),%eax
+c010ac50:	8b 00                	mov    (%eax),%eax
+c010ac52:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    lab6_set_priority(priority);
+c010ac55:	83 ec 0c             	sub    $0xc,%esp
+c010ac58:	ff 75 f4             	pushl  -0xc(%ebp)
+c010ac5b:	e8 cb f6 ff ff       	call   c010a32b <lab6_set_priority>
+c010ac60:	83 c4 10             	add    $0x10,%esp
+    return 0;
+c010ac63:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c010ac68:	c9                   	leave  
+c010ac69:	c3                   	ret    
+
+c010ac6a <syscall>:
+};
+
+#define NUM_SYSCALLS        ((sizeof(syscalls)) / (sizeof(syscalls[0])))
+
+void
+syscall(void) {
+c010ac6a:	55                   	push   %ebp
+c010ac6b:	89 e5                	mov    %esp,%ebp
+c010ac6d:	83 ec 28             	sub    $0x28,%esp
+    struct trapframe *tf = current->tf;
+c010ac70:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c010ac75:	8b 40 3c             	mov    0x3c(%eax),%eax
+c010ac78:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    uint32_t arg[5];
+    int num = tf->tf_regs.reg_eax;
+c010ac7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010ac7e:	8b 40 1c             	mov    0x1c(%eax),%eax
+c010ac81:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if (num >= 0 && num < NUM_SYSCALLS) {
+c010ac84:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c010ac88:	78 64                	js     c010acee <syscall+0x84>
+c010ac8a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010ac8d:	3d ff 00 00 00       	cmp    $0xff,%eax
+c010ac92:	77 5a                	ja     c010acee <syscall+0x84>
+        if (syscalls[num] != NULL) {
+c010ac94:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010ac97:	8b 04 85 a0 ca 12 c0 	mov    -0x3fed3560(,%eax,4),%eax
+c010ac9e:	85 c0                	test   %eax,%eax
+c010aca0:	74 4c                	je     c010acee <syscall+0x84>
+            arg[0] = tf->tf_regs.reg_edx;
+c010aca2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010aca5:	8b 40 14             	mov    0x14(%eax),%eax
+c010aca8:	89 45 dc             	mov    %eax,-0x24(%ebp)
+            arg[1] = tf->tf_regs.reg_ecx;
+c010acab:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010acae:	8b 40 18             	mov    0x18(%eax),%eax
+c010acb1:	89 45 e0             	mov    %eax,-0x20(%ebp)
+            arg[2] = tf->tf_regs.reg_ebx;
+c010acb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010acb7:	8b 40 10             	mov    0x10(%eax),%eax
+c010acba:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+            arg[3] = tf->tf_regs.reg_edi;
+c010acbd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010acc0:	8b 00                	mov    (%eax),%eax
+c010acc2:	89 45 e8             	mov    %eax,-0x18(%ebp)
+            arg[4] = tf->tf_regs.reg_esi;
+c010acc5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010acc8:	8b 40 04             	mov    0x4(%eax),%eax
+c010accb:	89 45 ec             	mov    %eax,-0x14(%ebp)
+            tf->tf_regs.reg_eax = syscalls[num](arg);
+c010acce:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010acd1:	8b 04 85 a0 ca 12 c0 	mov    -0x3fed3560(,%eax,4),%eax
+c010acd8:	83 ec 0c             	sub    $0xc,%esp
+c010acdb:	8d 55 dc             	lea    -0x24(%ebp),%edx
+c010acde:	52                   	push   %edx
+c010acdf:	ff d0                	call   *%eax
+c010ace1:	83 c4 10             	add    $0x10,%esp
+c010ace4:	89 c2                	mov    %eax,%edx
+c010ace6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010ace9:	89 50 1c             	mov    %edx,0x1c(%eax)
+            return ;
+c010acec:	eb 37                	jmp    c010ad25 <syscall+0xbb>
+        }
+    }
+    print_trapframe(tf);
+c010acee:	83 ec 0c             	sub    $0xc,%esp
+c010acf1:	ff 75 f4             	pushl  -0xc(%ebp)
+c010acf4:	e8 ad 76 ff ff       	call   c01023a6 <print_trapframe>
+c010acf9:	83 c4 10             	add    $0x10,%esp
+    panic("undefined syscall %d, pid = %d, name = %s.\n",
+c010acfc:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c010ad01:	8d 50 48             	lea    0x48(%eax),%edx
+c010ad04:	a1 28 10 1b c0       	mov    0xc01b1028,%eax
+c010ad09:	8b 40 04             	mov    0x4(%eax),%eax
+c010ad0c:	83 ec 08             	sub    $0x8,%esp
+c010ad0f:	52                   	push   %edx
+c010ad10:	50                   	push   %eax
+c010ad11:	ff 75 f0             	pushl  -0x10(%ebp)
+c010ad14:	68 b4 de 10 c0       	push   $0xc010deb4
+c010ad19:	6a 72                	push   $0x72
+c010ad1b:	68 e0 de 10 c0       	push   $0xc010dee0
+c010ad20:	e8 d0 56 ff ff       	call   c01003f5 <__panic>
+            num, current->pid, current->name);
+}
+c010ad25:	c9                   	leave  
+c010ad26:	c3                   	ret    
+
+c010ad27 <strlen>:
+ * @s:      the input string
+ *
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+c010ad27:	55                   	push   %ebp
+c010ad28:	89 e5                	mov    %esp,%ebp
+c010ad2a:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+c010ad2d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (*s ++ != '\0') {
+c010ad34:	eb 04                	jmp    c010ad3a <strlen+0x13>
+        cnt ++;
+c010ad36:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+    size_t cnt = 0;
+    while (*s ++ != '\0') {
+c010ad3a:	8b 45 08             	mov    0x8(%ebp),%eax
+c010ad3d:	8d 50 01             	lea    0x1(%eax),%edx
+c010ad40:	89 55 08             	mov    %edx,0x8(%ebp)
+c010ad43:	0f b6 00             	movzbl (%eax),%eax
+c010ad46:	84 c0                	test   %al,%al
+c010ad48:	75 ec                	jne    c010ad36 <strlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+c010ad4a:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+c010ad4d:	c9                   	leave  
+c010ad4e:	c3                   	ret    
+
+c010ad4f <strnlen>:
+ * The return value is strlen(s), if that is less than @len, or
+ * @len if there is no '\0' character among the first @len characters
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+c010ad4f:	55                   	push   %ebp
+c010ad50:	89 e5                	mov    %esp,%ebp
+c010ad52:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+c010ad55:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (cnt < len && *s ++ != '\0') {
+c010ad5c:	eb 04                	jmp    c010ad62 <strnlen+0x13>
+        cnt ++;
+c010ad5e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+    size_t cnt = 0;
+    while (cnt < len && *s ++ != '\0') {
+c010ad62:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c010ad65:	3b 45 0c             	cmp    0xc(%ebp),%eax
+c010ad68:	73 10                	jae    c010ad7a <strnlen+0x2b>
+c010ad6a:	8b 45 08             	mov    0x8(%ebp),%eax
+c010ad6d:	8d 50 01             	lea    0x1(%eax),%edx
+c010ad70:	89 55 08             	mov    %edx,0x8(%ebp)
+c010ad73:	0f b6 00             	movzbl (%eax),%eax
+c010ad76:	84 c0                	test   %al,%al
+c010ad78:	75 e4                	jne    c010ad5e <strnlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+c010ad7a:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+c010ad7d:	c9                   	leave  
+c010ad7e:	c3                   	ret    
+
+c010ad7f <strcpy>:
+ * To avoid overflows, the size of array pointed by @dst should be long enough to
+ * contain the same string as @src (including the terminating null character), and
+ * should not overlap in memory with @src.
+ * */
+char *
+strcpy(char *dst, const char *src) {
+c010ad7f:	55                   	push   %ebp
+c010ad80:	89 e5                	mov    %esp,%ebp
+c010ad82:	57                   	push   %edi
+c010ad83:	56                   	push   %esi
+c010ad84:	83 ec 20             	sub    $0x20,%esp
+c010ad87:	8b 45 08             	mov    0x8(%ebp),%eax
+c010ad8a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c010ad8d:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010ad90:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCPY
+#define __HAVE_ARCH_STRCPY
+static inline char *
+__strcpy(char *dst, const char *src) {
+    int d0, d1, d2;
+    asm volatile (
+c010ad93:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c010ad96:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010ad99:	89 d1                	mov    %edx,%ecx
+c010ad9b:	89 c2                	mov    %eax,%edx
+c010ad9d:	89 ce                	mov    %ecx,%esi
+c010ad9f:	89 d7                	mov    %edx,%edi
+c010ada1:	ac                   	lods   %ds:(%esi),%al
+c010ada2:	aa                   	stos   %al,%es:(%edi)
+c010ada3:	84 c0                	test   %al,%al
+c010ada5:	75 fa                	jne    c010ada1 <strcpy+0x22>
+c010ada7:	89 fa                	mov    %edi,%edx
+c010ada9:	89 f1                	mov    %esi,%ecx
+c010adab:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+c010adae:	89 55 e8             	mov    %edx,-0x18(%ebp)
+c010adb1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+        "stosb;"
+        "testb %%al, %%al;"
+        "jne 1b;"
+        : "=&S" (d0), "=&D" (d1), "=&a" (d2)
+        : "0" (src), "1" (dst) : "memory");
+    return dst;
+c010adb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCPY
+    return __strcpy(dst, src);
+c010adb7:	90                   	nop
+    char *p = dst;
+    while ((*p ++ = *src ++) != '\0')
+        /* nothing */;
+    return dst;
+#endif /* __HAVE_ARCH_STRCPY */
+}
+c010adb8:	83 c4 20             	add    $0x20,%esp
+c010adbb:	5e                   	pop    %esi
+c010adbc:	5f                   	pop    %edi
+c010adbd:	5d                   	pop    %ebp
+c010adbe:	c3                   	ret    
+
+c010adbf <strncpy>:
+ * @len:    maximum number of characters to be copied from @src
+ *
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+c010adbf:	55                   	push   %ebp
+c010adc0:	89 e5                	mov    %esp,%ebp
+c010adc2:	83 ec 10             	sub    $0x10,%esp
+    char *p = dst;
+c010adc5:	8b 45 08             	mov    0x8(%ebp),%eax
+c010adc8:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    while (len > 0) {
+c010adcb:	eb 21                	jmp    c010adee <strncpy+0x2f>
+        if ((*p = *src) != '\0') {
+c010adcd:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010add0:	0f b6 10             	movzbl (%eax),%edx
+c010add3:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c010add6:	88 10                	mov    %dl,(%eax)
+c010add8:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c010addb:	0f b6 00             	movzbl (%eax),%eax
+c010adde:	84 c0                	test   %al,%al
+c010ade0:	74 04                	je     c010ade6 <strncpy+0x27>
+            src ++;
+c010ade2:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+        }
+        p ++, len --;
+c010ade6:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+c010adea:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+    char *p = dst;
+    while (len > 0) {
+c010adee:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+c010adf2:	75 d9                	jne    c010adcd <strncpy+0xe>
+        if ((*p = *src) != '\0') {
+            src ++;
+        }
+        p ++, len --;
+    }
+    return dst;
+c010adf4:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+c010adf7:	c9                   	leave  
+c010adf8:	c3                   	ret    
+
+c010adf9 <strcmp>:
+ * - A value greater than zero indicates that the first character that does
+ *   not match has a greater value in @s1 than in @s2;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+strcmp(const char *s1, const char *s2) {
+c010adf9:	55                   	push   %ebp
+c010adfa:	89 e5                	mov    %esp,%ebp
+c010adfc:	57                   	push   %edi
+c010adfd:	56                   	push   %esi
+c010adfe:	83 ec 20             	sub    $0x20,%esp
+c010ae01:	8b 45 08             	mov    0x8(%ebp),%eax
+c010ae04:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c010ae07:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010ae0a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCMP
+#define __HAVE_ARCH_STRCMP
+static inline int
+__strcmp(const char *s1, const char *s2) {
+    int d0, d1, ret;
+    asm volatile (
+c010ae0d:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c010ae10:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010ae13:	89 d1                	mov    %edx,%ecx
+c010ae15:	89 c2                	mov    %eax,%edx
+c010ae17:	89 ce                	mov    %ecx,%esi
+c010ae19:	89 d7                	mov    %edx,%edi
+c010ae1b:	ac                   	lods   %ds:(%esi),%al
+c010ae1c:	ae                   	scas   %es:(%edi),%al
+c010ae1d:	75 08                	jne    c010ae27 <strcmp+0x2e>
+c010ae1f:	84 c0                	test   %al,%al
+c010ae21:	75 f8                	jne    c010ae1b <strcmp+0x22>
+c010ae23:	31 c0                	xor    %eax,%eax
+c010ae25:	eb 04                	jmp    c010ae2b <strcmp+0x32>
+c010ae27:	19 c0                	sbb    %eax,%eax
+c010ae29:	0c 01                	or     $0x1,%al
+c010ae2b:	89 fa                	mov    %edi,%edx
+c010ae2d:	89 f1                	mov    %esi,%ecx
+c010ae2f:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c010ae32:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+c010ae35:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+        "orb $1, %%al;"
+        "3:"
+        : "=a" (ret), "=&S" (d0), "=&D" (d1)
+        : "1" (s1), "2" (s2)
+        : "memory");
+    return ret;
+c010ae38:	8b 45 ec             	mov    -0x14(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCMP
+    return __strcmp(s1, s2);
+c010ae3b:	90                   	nop
+    while (*s1 != '\0' && *s1 == *s2) {
+        s1 ++, s2 ++;
+    }
+    return (int)((unsigned char)*s1 - (unsigned char)*s2);
+#endif /* __HAVE_ARCH_STRCMP */
+}
+c010ae3c:	83 c4 20             	add    $0x20,%esp
+c010ae3f:	5e                   	pop    %esi
+c010ae40:	5f                   	pop    %edi
+c010ae41:	5d                   	pop    %ebp
+c010ae42:	c3                   	ret    
+
+c010ae43 <strncmp>:
+ * they are equal to each other, it continues with the following pairs until
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+c010ae43:	55                   	push   %ebp
+c010ae44:	89 e5                	mov    %esp,%ebp
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+c010ae46:	eb 0c                	jmp    c010ae54 <strncmp+0x11>
+        n --, s1 ++, s2 ++;
+c010ae48:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+c010ae4c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+c010ae50:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+c010ae54:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+c010ae58:	74 1a                	je     c010ae74 <strncmp+0x31>
+c010ae5a:	8b 45 08             	mov    0x8(%ebp),%eax
+c010ae5d:	0f b6 00             	movzbl (%eax),%eax
+c010ae60:	84 c0                	test   %al,%al
+c010ae62:	74 10                	je     c010ae74 <strncmp+0x31>
+c010ae64:	8b 45 08             	mov    0x8(%ebp),%eax
+c010ae67:	0f b6 10             	movzbl (%eax),%edx
+c010ae6a:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010ae6d:	0f b6 00             	movzbl (%eax),%eax
+c010ae70:	38 c2                	cmp    %al,%dl
+c010ae72:	74 d4                	je     c010ae48 <strncmp+0x5>
+        n --, s1 ++, s2 ++;
+    }
+    return (n == 0) ? 0 : (int)((unsigned char)*s1 - (unsigned char)*s2);
+c010ae74:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+c010ae78:	74 18                	je     c010ae92 <strncmp+0x4f>
+c010ae7a:	8b 45 08             	mov    0x8(%ebp),%eax
+c010ae7d:	0f b6 00             	movzbl (%eax),%eax
+c010ae80:	0f b6 d0             	movzbl %al,%edx
+c010ae83:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010ae86:	0f b6 00             	movzbl (%eax),%eax
+c010ae89:	0f b6 c0             	movzbl %al,%eax
+c010ae8c:	29 c2                	sub    %eax,%edx
+c010ae8e:	89 d0                	mov    %edx,%eax
+c010ae90:	eb 05                	jmp    c010ae97 <strncmp+0x54>
+c010ae92:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c010ae97:	5d                   	pop    %ebp
+c010ae98:	c3                   	ret    
+
+c010ae99 <strchr>:
+ *
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+c010ae99:	55                   	push   %ebp
+c010ae9a:	89 e5                	mov    %esp,%ebp
+c010ae9c:	83 ec 04             	sub    $0x4,%esp
+c010ae9f:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010aea2:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+c010aea5:	eb 14                	jmp    c010aebb <strchr+0x22>
+        if (*s == c) {
+c010aea7:	8b 45 08             	mov    0x8(%ebp),%eax
+c010aeaa:	0f b6 00             	movzbl (%eax),%eax
+c010aead:	3a 45 fc             	cmp    -0x4(%ebp),%al
+c010aeb0:	75 05                	jne    c010aeb7 <strchr+0x1e>
+            return (char *)s;
+c010aeb2:	8b 45 08             	mov    0x8(%ebp),%eax
+c010aeb5:	eb 13                	jmp    c010aeca <strchr+0x31>
+        }
+        s ++;
+c010aeb7:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+    while (*s != '\0') {
+c010aebb:	8b 45 08             	mov    0x8(%ebp),%eax
+c010aebe:	0f b6 00             	movzbl (%eax),%eax
+c010aec1:	84 c0                	test   %al,%al
+c010aec3:	75 e2                	jne    c010aea7 <strchr+0xe>
+        if (*s == c) {
+            return (char *)s;
+        }
+        s ++;
+    }
+    return NULL;
+c010aec5:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c010aeca:	c9                   	leave  
+c010aecb:	c3                   	ret    
+
+c010aecc <strfind>:
+ * The strfind() function is like strchr() except that if @c is
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+c010aecc:	55                   	push   %ebp
+c010aecd:	89 e5                	mov    %esp,%ebp
+c010aecf:	83 ec 04             	sub    $0x4,%esp
+c010aed2:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010aed5:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+c010aed8:	eb 0f                	jmp    c010aee9 <strfind+0x1d>
+        if (*s == c) {
+c010aeda:	8b 45 08             	mov    0x8(%ebp),%eax
+c010aedd:	0f b6 00             	movzbl (%eax),%eax
+c010aee0:	3a 45 fc             	cmp    -0x4(%ebp),%al
+c010aee3:	74 10                	je     c010aef5 <strfind+0x29>
+            break;
+        }
+        s ++;
+c010aee5:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+    while (*s != '\0') {
+c010aee9:	8b 45 08             	mov    0x8(%ebp),%eax
+c010aeec:	0f b6 00             	movzbl (%eax),%eax
+c010aeef:	84 c0                	test   %al,%al
+c010aef1:	75 e7                	jne    c010aeda <strfind+0xe>
+c010aef3:	eb 01                	jmp    c010aef6 <strfind+0x2a>
+        if (*s == c) {
+            break;
+c010aef5:	90                   	nop
+        }
+        s ++;
+    }
+    return (char *)s;
+c010aef6:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+c010aef9:	c9                   	leave  
+c010aefa:	c3                   	ret    
+
+c010aefb <strtol>:
+ * an optional "0x" or "0X" prefix.
+ *
+ * The strtol() function returns the converted integral number as a long int value.
+ * */
+long
+strtol(const char *s, char **endptr, int base) {
+c010aefb:	55                   	push   %ebp
+c010aefc:	89 e5                	mov    %esp,%ebp
+c010aefe:	83 ec 10             	sub    $0x10,%esp
+    int neg = 0;
+c010af01:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    long val = 0;
+c010af08:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+c010af0f:	eb 04                	jmp    c010af15 <strtol+0x1a>
+        s ++;
+c010af11:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+strtol(const char *s, char **endptr, int base) {
+    int neg = 0;
+    long val = 0;
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+c010af15:	8b 45 08             	mov    0x8(%ebp),%eax
+c010af18:	0f b6 00             	movzbl (%eax),%eax
+c010af1b:	3c 20                	cmp    $0x20,%al
+c010af1d:	74 f2                	je     c010af11 <strtol+0x16>
+c010af1f:	8b 45 08             	mov    0x8(%ebp),%eax
+c010af22:	0f b6 00             	movzbl (%eax),%eax
+c010af25:	3c 09                	cmp    $0x9,%al
+c010af27:	74 e8                	je     c010af11 <strtol+0x16>
+        s ++;
+    }
+
+    // plus/minus sign
+    if (*s == '+') {
+c010af29:	8b 45 08             	mov    0x8(%ebp),%eax
+c010af2c:	0f b6 00             	movzbl (%eax),%eax
+c010af2f:	3c 2b                	cmp    $0x2b,%al
+c010af31:	75 06                	jne    c010af39 <strtol+0x3e>
+        s ++;
+c010af33:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+c010af37:	eb 15                	jmp    c010af4e <strtol+0x53>
+    }
+    else if (*s == '-') {
+c010af39:	8b 45 08             	mov    0x8(%ebp),%eax
+c010af3c:	0f b6 00             	movzbl (%eax),%eax
+c010af3f:	3c 2d                	cmp    $0x2d,%al
+c010af41:	75 0b                	jne    c010af4e <strtol+0x53>
+        s ++, neg = 1;
+c010af43:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+c010af47:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+    }
+
+    // hex or octal base prefix
+    if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x')) {
+c010af4e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+c010af52:	74 06                	je     c010af5a <strtol+0x5f>
+c010af54:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+c010af58:	75 24                	jne    c010af7e <strtol+0x83>
+c010af5a:	8b 45 08             	mov    0x8(%ebp),%eax
+c010af5d:	0f b6 00             	movzbl (%eax),%eax
+c010af60:	3c 30                	cmp    $0x30,%al
+c010af62:	75 1a                	jne    c010af7e <strtol+0x83>
+c010af64:	8b 45 08             	mov    0x8(%ebp),%eax
+c010af67:	83 c0 01             	add    $0x1,%eax
+c010af6a:	0f b6 00             	movzbl (%eax),%eax
+c010af6d:	3c 78                	cmp    $0x78,%al
+c010af6f:	75 0d                	jne    c010af7e <strtol+0x83>
+        s += 2, base = 16;
+c010af71:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+c010af75:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+c010af7c:	eb 2a                	jmp    c010afa8 <strtol+0xad>
+    }
+    else if (base == 0 && s[0] == '0') {
+c010af7e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+c010af82:	75 17                	jne    c010af9b <strtol+0xa0>
+c010af84:	8b 45 08             	mov    0x8(%ebp),%eax
+c010af87:	0f b6 00             	movzbl (%eax),%eax
+c010af8a:	3c 30                	cmp    $0x30,%al
+c010af8c:	75 0d                	jne    c010af9b <strtol+0xa0>
+        s ++, base = 8;
+c010af8e:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+c010af92:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+c010af99:	eb 0d                	jmp    c010afa8 <strtol+0xad>
+    }
+    else if (base == 0) {
+c010af9b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+c010af9f:	75 07                	jne    c010afa8 <strtol+0xad>
+        base = 10;
+c010afa1:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+    // digits
+    while (1) {
+        int dig;
+
+        if (*s >= '0' && *s <= '9') {
+c010afa8:	8b 45 08             	mov    0x8(%ebp),%eax
+c010afab:	0f b6 00             	movzbl (%eax),%eax
+c010afae:	3c 2f                	cmp    $0x2f,%al
+c010afb0:	7e 1b                	jle    c010afcd <strtol+0xd2>
+c010afb2:	8b 45 08             	mov    0x8(%ebp),%eax
+c010afb5:	0f b6 00             	movzbl (%eax),%eax
+c010afb8:	3c 39                	cmp    $0x39,%al
+c010afba:	7f 11                	jg     c010afcd <strtol+0xd2>
+            dig = *s - '0';
+c010afbc:	8b 45 08             	mov    0x8(%ebp),%eax
+c010afbf:	0f b6 00             	movzbl (%eax),%eax
+c010afc2:	0f be c0             	movsbl %al,%eax
+c010afc5:	83 e8 30             	sub    $0x30,%eax
+c010afc8:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c010afcb:	eb 48                	jmp    c010b015 <strtol+0x11a>
+        }
+        else if (*s >= 'a' && *s <= 'z') {
+c010afcd:	8b 45 08             	mov    0x8(%ebp),%eax
+c010afd0:	0f b6 00             	movzbl (%eax),%eax
+c010afd3:	3c 60                	cmp    $0x60,%al
+c010afd5:	7e 1b                	jle    c010aff2 <strtol+0xf7>
+c010afd7:	8b 45 08             	mov    0x8(%ebp),%eax
+c010afda:	0f b6 00             	movzbl (%eax),%eax
+c010afdd:	3c 7a                	cmp    $0x7a,%al
+c010afdf:	7f 11                	jg     c010aff2 <strtol+0xf7>
+            dig = *s - 'a' + 10;
+c010afe1:	8b 45 08             	mov    0x8(%ebp),%eax
+c010afe4:	0f b6 00             	movzbl (%eax),%eax
+c010afe7:	0f be c0             	movsbl %al,%eax
+c010afea:	83 e8 57             	sub    $0x57,%eax
+c010afed:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c010aff0:	eb 23                	jmp    c010b015 <strtol+0x11a>
+        }
+        else if (*s >= 'A' && *s <= 'Z') {
+c010aff2:	8b 45 08             	mov    0x8(%ebp),%eax
+c010aff5:	0f b6 00             	movzbl (%eax),%eax
+c010aff8:	3c 40                	cmp    $0x40,%al
+c010affa:	7e 3c                	jle    c010b038 <strtol+0x13d>
+c010affc:	8b 45 08             	mov    0x8(%ebp),%eax
+c010afff:	0f b6 00             	movzbl (%eax),%eax
+c010b002:	3c 5a                	cmp    $0x5a,%al
+c010b004:	7f 32                	jg     c010b038 <strtol+0x13d>
+            dig = *s - 'A' + 10;
+c010b006:	8b 45 08             	mov    0x8(%ebp),%eax
+c010b009:	0f b6 00             	movzbl (%eax),%eax
+c010b00c:	0f be c0             	movsbl %al,%eax
+c010b00f:	83 e8 37             	sub    $0x37,%eax
+c010b012:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+c010b015:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010b018:	3b 45 10             	cmp    0x10(%ebp),%eax
+c010b01b:	7d 1a                	jge    c010b037 <strtol+0x13c>
+            break;
+        }
+        s ++, val = (val * base) + dig;
+c010b01d:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+c010b021:	8b 45 f8             	mov    -0x8(%ebp),%eax
+c010b024:	0f af 45 10          	imul   0x10(%ebp),%eax
+c010b028:	89 c2                	mov    %eax,%edx
+c010b02a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010b02d:	01 d0                	add    %edx,%eax
+c010b02f:	89 45 f8             	mov    %eax,-0x8(%ebp)
+        // we don't properly detect overflow!
+    }
+c010b032:	e9 71 ff ff ff       	jmp    c010afa8 <strtol+0xad>
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+            break;
+c010b037:	90                   	nop
+        }
+        s ++, val = (val * base) + dig;
+        // we don't properly detect overflow!
+    }
+
+    if (endptr) {
+c010b038:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+c010b03c:	74 08                	je     c010b046 <strtol+0x14b>
+        *endptr = (char *) s;
+c010b03e:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010b041:	8b 55 08             	mov    0x8(%ebp),%edx
+c010b044:	89 10                	mov    %edx,(%eax)
+    }
+    return (neg ? -val : val);
+c010b046:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+c010b04a:	74 07                	je     c010b053 <strtol+0x158>
+c010b04c:	8b 45 f8             	mov    -0x8(%ebp),%eax
+c010b04f:	f7 d8                	neg    %eax
+c010b051:	eb 03                	jmp    c010b056 <strtol+0x15b>
+c010b053:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+c010b056:	c9                   	leave  
+c010b057:	c3                   	ret    
+
+c010b058 <memset>:
+ * @n:      number of bytes to be set to the value
+ *
+ * The memset() function returns @s.
+ * */
+void *
+memset(void *s, char c, size_t n) {
+c010b058:	55                   	push   %ebp
+c010b059:	89 e5                	mov    %esp,%ebp
+c010b05b:	57                   	push   %edi
+c010b05c:	83 ec 24             	sub    $0x24,%esp
+c010b05f:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010b062:	88 45 d8             	mov    %al,-0x28(%ebp)
+#ifdef __HAVE_ARCH_MEMSET
+    return __memset(s, c, n);
+c010b065:	0f be 45 d8          	movsbl -0x28(%ebp),%eax
+c010b069:	8b 55 08             	mov    0x8(%ebp),%edx
+c010b06c:	89 55 f8             	mov    %edx,-0x8(%ebp)
+c010b06f:	88 45 f7             	mov    %al,-0x9(%ebp)
+c010b072:	8b 45 10             	mov    0x10(%ebp),%eax
+c010b075:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_MEMSET
+#define __HAVE_ARCH_MEMSET
+static inline void *
+__memset(void *s, char c, size_t n) {
+    int d0, d1;
+    asm volatile (
+c010b078:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+c010b07b:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
+c010b07f:	8b 55 f8             	mov    -0x8(%ebp),%edx
+c010b082:	89 d7                	mov    %edx,%edi
+c010b084:	f3 aa                	rep stos %al,%es:(%edi)
+c010b086:	89 fa                	mov    %edi,%edx
+c010b088:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+c010b08b:	89 55 e8             	mov    %edx,-0x18(%ebp)
+        "rep; stosb;"
+        : "=&c" (d0), "=&D" (d1)
+        : "0" (n), "a" (c), "1" (s)
+        : "memory");
+    return s;
+c010b08e:	8b 45 f8             	mov    -0x8(%ebp),%eax
+c010b091:	90                   	nop
+    while (n -- > 0) {
+        *p ++ = c;
+    }
+    return s;
+#endif /* __HAVE_ARCH_MEMSET */
+}
+c010b092:	83 c4 24             	add    $0x24,%esp
+c010b095:	5f                   	pop    %edi
+c010b096:	5d                   	pop    %ebp
+c010b097:	c3                   	ret    
+
+c010b098 <memmove>:
+ * @n:      number of bytes to copy
+ *
+ * The memmove() function returns @dst.
+ * */
+void *
+memmove(void *dst, const void *src, size_t n) {
+c010b098:	55                   	push   %ebp
+c010b099:	89 e5                	mov    %esp,%ebp
+c010b09b:	57                   	push   %edi
+c010b09c:	56                   	push   %esi
+c010b09d:	53                   	push   %ebx
+c010b09e:	83 ec 30             	sub    $0x30,%esp
+c010b0a1:	8b 45 08             	mov    0x8(%ebp),%eax
+c010b0a4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c010b0a7:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010b0aa:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c010b0ad:	8b 45 10             	mov    0x10(%ebp),%eax
+c010b0b0:	89 45 e8             	mov    %eax,-0x18(%ebp)
+
+#ifndef __HAVE_ARCH_MEMMOVE
+#define __HAVE_ARCH_MEMMOVE
+static inline void *
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+c010b0b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010b0b6:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+c010b0b9:	73 42                	jae    c010b0fd <memmove+0x65>
+c010b0bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010b0be:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c010b0c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010b0c4:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c010b0c7:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010b0ca:	89 45 dc             	mov    %eax,-0x24(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+c010b0cd:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c010b0d0:	c1 e8 02             	shr    $0x2,%eax
+c010b0d3:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+c010b0d5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c010b0d8:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c010b0db:	89 d7                	mov    %edx,%edi
+c010b0dd:	89 c6                	mov    %eax,%esi
+c010b0df:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+c010b0e1:	8b 4d dc             	mov    -0x24(%ebp),%ecx
+c010b0e4:	83 e1 03             	and    $0x3,%ecx
+c010b0e7:	74 02                	je     c010b0eb <memmove+0x53>
+c010b0e9:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+c010b0eb:	89 f0                	mov    %esi,%eax
+c010b0ed:	89 fa                	mov    %edi,%edx
+c010b0ef:	89 4d d8             	mov    %ecx,-0x28(%ebp)
+c010b0f2:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+c010b0f5:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+c010b0f8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMMOVE
+    return __memmove(dst, src, n);
+c010b0fb:	eb 36                	jmp    c010b133 <memmove+0x9b>
+    asm volatile (
+        "std;"
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+c010b0fd:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010b100:	8d 50 ff             	lea    -0x1(%eax),%edx
+c010b103:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010b106:	01 c2                	add    %eax,%edx
+c010b108:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010b10b:	8d 48 ff             	lea    -0x1(%eax),%ecx
+c010b10e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010b111:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+        return __memcpy(dst, src, n);
+    }
+    int d0, d1, d2;
+    asm volatile (
+c010b114:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010b117:	89 c1                	mov    %eax,%ecx
+c010b119:	89 d8                	mov    %ebx,%eax
+c010b11b:	89 d6                	mov    %edx,%esi
+c010b11d:	89 c7                	mov    %eax,%edi
+c010b11f:	fd                   	std    
+c010b120:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+c010b122:	fc                   	cld    
+c010b123:	89 f8                	mov    %edi,%eax
+c010b125:	89 f2                	mov    %esi,%edx
+c010b127:	89 4d cc             	mov    %ecx,-0x34(%ebp)
+c010b12a:	89 55 c8             	mov    %edx,-0x38(%ebp)
+c010b12d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+        : "memory");
+    return dst;
+c010b130:	8b 45 f0             	mov    -0x10(%ebp),%eax
+            *d ++ = *s ++;
+        }
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMMOVE */
+}
+c010b133:	83 c4 30             	add    $0x30,%esp
+c010b136:	5b                   	pop    %ebx
+c010b137:	5e                   	pop    %esi
+c010b138:	5f                   	pop    %edi
+c010b139:	5d                   	pop    %ebp
+c010b13a:	c3                   	ret    
+
+c010b13b <memcpy>:
+ * it always copies exactly @n bytes. To avoid overflows, the size of arrays pointed
+ * by both @src and @dst, should be at least @n bytes, and should not overlap
+ * (for overlapping memory area, memmove is a safer approach).
+ * */
+void *
+memcpy(void *dst, const void *src, size_t n) {
+c010b13b:	55                   	push   %ebp
+c010b13c:	89 e5                	mov    %esp,%ebp
+c010b13e:	57                   	push   %edi
+c010b13f:	56                   	push   %esi
+c010b140:	83 ec 20             	sub    $0x20,%esp
+c010b143:	8b 45 08             	mov    0x8(%ebp),%eax
+c010b146:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c010b149:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010b14c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c010b14f:	8b 45 10             	mov    0x10(%ebp),%eax
+c010b152:	89 45 ec             	mov    %eax,-0x14(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+c010b155:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010b158:	c1 e8 02             	shr    $0x2,%eax
+c010b15b:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+c010b15d:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c010b160:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010b163:	89 d7                	mov    %edx,%edi
+c010b165:	89 c6                	mov    %eax,%esi
+c010b167:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+c010b169:	8b 4d ec             	mov    -0x14(%ebp),%ecx
+c010b16c:	83 e1 03             	and    $0x3,%ecx
+c010b16f:	74 02                	je     c010b173 <memcpy+0x38>
+c010b171:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+c010b173:	89 f0                	mov    %esi,%eax
+c010b175:	89 fa                	mov    %edi,%edx
+c010b177:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+c010b17a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+c010b17d:	89 45 e0             	mov    %eax,-0x20(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+c010b180:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMCPY
+    return __memcpy(dst, src, n);
+c010b183:	90                   	nop
+    while (n -- > 0) {
+        *d ++ = *s ++;
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMCPY */
+}
+c010b184:	83 c4 20             	add    $0x20,%esp
+c010b187:	5e                   	pop    %esi
+c010b188:	5f                   	pop    %edi
+c010b189:	5d                   	pop    %ebp
+c010b18a:	c3                   	ret    
+
+c010b18b <memcmp>:
+ *   match in both memory blocks has a greater value in @v1 than in @v2
+ *   as if evaluated as unsigned char values;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+c010b18b:	55                   	push   %ebp
+c010b18c:	89 e5                	mov    %esp,%ebp
+c010b18e:	83 ec 10             	sub    $0x10,%esp
+    const char *s1 = (const char *)v1;
+c010b191:	8b 45 08             	mov    0x8(%ebp),%eax
+c010b194:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    const char *s2 = (const char *)v2;
+c010b197:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010b19a:	89 45 f8             	mov    %eax,-0x8(%ebp)
+    while (n -- > 0) {
+c010b19d:	eb 30                	jmp    c010b1cf <memcmp+0x44>
+        if (*s1 != *s2) {
+c010b19f:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c010b1a2:	0f b6 10             	movzbl (%eax),%edx
+c010b1a5:	8b 45 f8             	mov    -0x8(%ebp),%eax
+c010b1a8:	0f b6 00             	movzbl (%eax),%eax
+c010b1ab:	38 c2                	cmp    %al,%dl
+c010b1ad:	74 18                	je     c010b1c7 <memcmp+0x3c>
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+c010b1af:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c010b1b2:	0f b6 00             	movzbl (%eax),%eax
+c010b1b5:	0f b6 d0             	movzbl %al,%edx
+c010b1b8:	8b 45 f8             	mov    -0x8(%ebp),%eax
+c010b1bb:	0f b6 00             	movzbl (%eax),%eax
+c010b1be:	0f b6 c0             	movzbl %al,%eax
+c010b1c1:	29 c2                	sub    %eax,%edx
+c010b1c3:	89 d0                	mov    %edx,%eax
+c010b1c5:	eb 1a                	jmp    c010b1e1 <memcmp+0x56>
+        }
+        s1 ++, s2 ++;
+c010b1c7:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+c010b1cb:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+    const char *s1 = (const char *)v1;
+    const char *s2 = (const char *)v2;
+    while (n -- > 0) {
+c010b1cf:	8b 45 10             	mov    0x10(%ebp),%eax
+c010b1d2:	8d 50 ff             	lea    -0x1(%eax),%edx
+c010b1d5:	89 55 10             	mov    %edx,0x10(%ebp)
+c010b1d8:	85 c0                	test   %eax,%eax
+c010b1da:	75 c3                	jne    c010b19f <memcmp+0x14>
+        if (*s1 != *s2) {
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+        }
+        s1 ++, s2 ++;
+    }
+    return 0;
+c010b1dc:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c010b1e1:	c9                   	leave  
+c010b1e2:	c3                   	ret    
+
+c010b1e3 <printnum>:
+ * @width:      maximum number of digits, if the actual width is less than @width, use @padc instead
+ * @padc:       character that padded on the left if the actual width is less than @width
+ * */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+        unsigned long long num, unsigned base, int width, int padc) {
+c010b1e3:	55                   	push   %ebp
+c010b1e4:	89 e5                	mov    %esp,%ebp
+c010b1e6:	83 ec 38             	sub    $0x38,%esp
+c010b1e9:	8b 45 10             	mov    0x10(%ebp),%eax
+c010b1ec:	89 45 d0             	mov    %eax,-0x30(%ebp)
+c010b1ef:	8b 45 14             	mov    0x14(%ebp),%eax
+c010b1f2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+    unsigned long long result = num;
+c010b1f5:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c010b1f8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c010b1fb:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c010b1fe:	89 55 ec             	mov    %edx,-0x14(%ebp)
+    unsigned mod = do_div(result, base);
+c010b201:	8b 45 18             	mov    0x18(%ebp),%eax
+c010b204:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c010b207:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010b20a:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c010b20d:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c010b210:	89 55 f0             	mov    %edx,-0x10(%ebp)
+c010b213:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010b216:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c010b219:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c010b21d:	74 1c                	je     c010b23b <printnum+0x58>
+c010b21f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010b222:	ba 00 00 00 00       	mov    $0x0,%edx
+c010b227:	f7 75 e4             	divl   -0x1c(%ebp)
+c010b22a:	89 55 f4             	mov    %edx,-0xc(%ebp)
+c010b22d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010b230:	ba 00 00 00 00       	mov    $0x0,%edx
+c010b235:	f7 75 e4             	divl   -0x1c(%ebp)
+c010b238:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c010b23b:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c010b23e:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c010b241:	f7 75 e4             	divl   -0x1c(%ebp)
+c010b244:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c010b247:	89 55 dc             	mov    %edx,-0x24(%ebp)
+c010b24a:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c010b24d:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c010b250:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c010b253:	89 55 ec             	mov    %edx,-0x14(%ebp)
+c010b256:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c010b259:	89 45 d8             	mov    %eax,-0x28(%ebp)
+
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+c010b25c:	8b 45 18             	mov    0x18(%ebp),%eax
+c010b25f:	ba 00 00 00 00       	mov    $0x0,%edx
+c010b264:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+c010b267:	77 41                	ja     c010b2aa <printnum+0xc7>
+c010b269:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+c010b26c:	72 05                	jb     c010b273 <printnum+0x90>
+c010b26e:	3b 45 d0             	cmp    -0x30(%ebp),%eax
+c010b271:	77 37                	ja     c010b2aa <printnum+0xc7>
+        printnum(putch, putdat, result, base, width - 1, padc);
+c010b273:	8b 45 1c             	mov    0x1c(%ebp),%eax
+c010b276:	83 e8 01             	sub    $0x1,%eax
+c010b279:	83 ec 04             	sub    $0x4,%esp
+c010b27c:	ff 75 20             	pushl  0x20(%ebp)
+c010b27f:	50                   	push   %eax
+c010b280:	ff 75 18             	pushl  0x18(%ebp)
+c010b283:	ff 75 ec             	pushl  -0x14(%ebp)
+c010b286:	ff 75 e8             	pushl  -0x18(%ebp)
+c010b289:	ff 75 0c             	pushl  0xc(%ebp)
+c010b28c:	ff 75 08             	pushl  0x8(%ebp)
+c010b28f:	e8 4f ff ff ff       	call   c010b1e3 <printnum>
+c010b294:	83 c4 20             	add    $0x20,%esp
+c010b297:	eb 1b                	jmp    c010b2b4 <printnum+0xd1>
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+            putch(padc, putdat);
+c010b299:	83 ec 08             	sub    $0x8,%esp
+c010b29c:	ff 75 0c             	pushl  0xc(%ebp)
+c010b29f:	ff 75 20             	pushl  0x20(%ebp)
+c010b2a2:	8b 45 08             	mov    0x8(%ebp),%eax
+c010b2a5:	ff d0                	call   *%eax
+c010b2a7:	83 c4 10             	add    $0x10,%esp
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+        printnum(putch, putdat, result, base, width - 1, padc);
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+c010b2aa:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+c010b2ae:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+c010b2b2:	7f e5                	jg     c010b299 <printnum+0xb6>
+            putch(padc, putdat);
+    }
+    // then print this (the least significant) digit
+    putch("0123456789abcdef"[mod], putdat);
+c010b2b4:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c010b2b7:	05 04 e0 10 c0       	add    $0xc010e004,%eax
+c010b2bc:	0f b6 00             	movzbl (%eax),%eax
+c010b2bf:	0f be c0             	movsbl %al,%eax
+c010b2c2:	83 ec 08             	sub    $0x8,%esp
+c010b2c5:	ff 75 0c             	pushl  0xc(%ebp)
+c010b2c8:	50                   	push   %eax
+c010b2c9:	8b 45 08             	mov    0x8(%ebp),%eax
+c010b2cc:	ff d0                	call   *%eax
+c010b2ce:	83 c4 10             	add    $0x10,%esp
+}
+c010b2d1:	90                   	nop
+c010b2d2:	c9                   	leave  
+c010b2d3:	c3                   	ret    
+
+c010b2d4 <getuint>:
+ * getuint - get an unsigned int of various possible sizes from a varargs list
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static unsigned long long
+getuint(va_list *ap, int lflag) {
+c010b2d4:	55                   	push   %ebp
+c010b2d5:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+c010b2d7:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+c010b2db:	7e 14                	jle    c010b2f1 <getuint+0x1d>
+        return va_arg(*ap, unsigned long long);
+c010b2dd:	8b 45 08             	mov    0x8(%ebp),%eax
+c010b2e0:	8b 00                	mov    (%eax),%eax
+c010b2e2:	8d 48 08             	lea    0x8(%eax),%ecx
+c010b2e5:	8b 55 08             	mov    0x8(%ebp),%edx
+c010b2e8:	89 0a                	mov    %ecx,(%edx)
+c010b2ea:	8b 50 04             	mov    0x4(%eax),%edx
+c010b2ed:	8b 00                	mov    (%eax),%eax
+c010b2ef:	eb 30                	jmp    c010b321 <getuint+0x4d>
+    }
+    else if (lflag) {
+c010b2f1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+c010b2f5:	74 16                	je     c010b30d <getuint+0x39>
+        return va_arg(*ap, unsigned long);
+c010b2f7:	8b 45 08             	mov    0x8(%ebp),%eax
+c010b2fa:	8b 00                	mov    (%eax),%eax
+c010b2fc:	8d 48 04             	lea    0x4(%eax),%ecx
+c010b2ff:	8b 55 08             	mov    0x8(%ebp),%edx
+c010b302:	89 0a                	mov    %ecx,(%edx)
+c010b304:	8b 00                	mov    (%eax),%eax
+c010b306:	ba 00 00 00 00       	mov    $0x0,%edx
+c010b30b:	eb 14                	jmp    c010b321 <getuint+0x4d>
+    }
+    else {
+        return va_arg(*ap, unsigned int);
+c010b30d:	8b 45 08             	mov    0x8(%ebp),%eax
+c010b310:	8b 00                	mov    (%eax),%eax
+c010b312:	8d 48 04             	lea    0x4(%eax),%ecx
+c010b315:	8b 55 08             	mov    0x8(%ebp),%edx
+c010b318:	89 0a                	mov    %ecx,(%edx)
+c010b31a:	8b 00                	mov    (%eax),%eax
+c010b31c:	ba 00 00 00 00       	mov    $0x0,%edx
+    }
+}
+c010b321:	5d                   	pop    %ebp
+c010b322:	c3                   	ret    
+
+c010b323 <getint>:
+ * getint - same as getuint but signed, we can't use getuint because of sign extension
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static long long
+getint(va_list *ap, int lflag) {
+c010b323:	55                   	push   %ebp
+c010b324:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+c010b326:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+c010b32a:	7e 14                	jle    c010b340 <getint+0x1d>
+        return va_arg(*ap, long long);
+c010b32c:	8b 45 08             	mov    0x8(%ebp),%eax
+c010b32f:	8b 00                	mov    (%eax),%eax
+c010b331:	8d 48 08             	lea    0x8(%eax),%ecx
+c010b334:	8b 55 08             	mov    0x8(%ebp),%edx
+c010b337:	89 0a                	mov    %ecx,(%edx)
+c010b339:	8b 50 04             	mov    0x4(%eax),%edx
+c010b33c:	8b 00                	mov    (%eax),%eax
+c010b33e:	eb 28                	jmp    c010b368 <getint+0x45>
+    }
+    else if (lflag) {
+c010b340:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+c010b344:	74 12                	je     c010b358 <getint+0x35>
+        return va_arg(*ap, long);
+c010b346:	8b 45 08             	mov    0x8(%ebp),%eax
+c010b349:	8b 00                	mov    (%eax),%eax
+c010b34b:	8d 48 04             	lea    0x4(%eax),%ecx
+c010b34e:	8b 55 08             	mov    0x8(%ebp),%edx
+c010b351:	89 0a                	mov    %ecx,(%edx)
+c010b353:	8b 00                	mov    (%eax),%eax
+c010b355:	99                   	cltd   
+c010b356:	eb 10                	jmp    c010b368 <getint+0x45>
+    }
+    else {
+        return va_arg(*ap, int);
+c010b358:	8b 45 08             	mov    0x8(%ebp),%eax
+c010b35b:	8b 00                	mov    (%eax),%eax
+c010b35d:	8d 48 04             	lea    0x4(%eax),%ecx
+c010b360:	8b 55 08             	mov    0x8(%ebp),%edx
+c010b363:	89 0a                	mov    %ecx,(%edx)
+c010b365:	8b 00                	mov    (%eax),%eax
+c010b367:	99                   	cltd   
+    }
+}
+c010b368:	5d                   	pop    %ebp
+c010b369:	c3                   	ret    
+
+c010b36a <printfmt>:
+ * @putch:      specified putch function, print a single character
+ * @putdat:     used by @putch function
+ * @fmt:        the format string to use
+ * */
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...) {
+c010b36a:	55                   	push   %ebp
+c010b36b:	89 e5                	mov    %esp,%ebp
+c010b36d:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+c010b370:	8d 45 14             	lea    0x14(%ebp),%eax
+c010b373:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    vprintfmt(putch, putdat, fmt, ap);
+c010b376:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010b379:	50                   	push   %eax
+c010b37a:	ff 75 10             	pushl  0x10(%ebp)
+c010b37d:	ff 75 0c             	pushl  0xc(%ebp)
+c010b380:	ff 75 08             	pushl  0x8(%ebp)
+c010b383:	e8 06 00 00 00       	call   c010b38e <vprintfmt>
+c010b388:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+c010b38b:	90                   	nop
+c010b38c:	c9                   	leave  
+c010b38d:	c3                   	ret    
+
+c010b38e <vprintfmt>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want printfmt() instead.
+ * */
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap) {
+c010b38e:	55                   	push   %ebp
+c010b38f:	89 e5                	mov    %esp,%ebp
+c010b391:	56                   	push   %esi
+c010b392:	53                   	push   %ebx
+c010b393:	83 ec 20             	sub    $0x20,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+c010b396:	eb 17                	jmp    c010b3af <vprintfmt+0x21>
+            if (ch == '\0') {
+c010b398:	85 db                	test   %ebx,%ebx
+c010b39a:	0f 84 8e 03 00 00    	je     c010b72e <vprintfmt+0x3a0>
+                return;
+            }
+            putch(ch, putdat);
+c010b3a0:	83 ec 08             	sub    $0x8,%esp
+c010b3a3:	ff 75 0c             	pushl  0xc(%ebp)
+c010b3a6:	53                   	push   %ebx
+c010b3a7:	8b 45 08             	mov    0x8(%ebp),%eax
+c010b3aa:	ff d0                	call   *%eax
+c010b3ac:	83 c4 10             	add    $0x10,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+c010b3af:	8b 45 10             	mov    0x10(%ebp),%eax
+c010b3b2:	8d 50 01             	lea    0x1(%eax),%edx
+c010b3b5:	89 55 10             	mov    %edx,0x10(%ebp)
+c010b3b8:	0f b6 00             	movzbl (%eax),%eax
+c010b3bb:	0f b6 d8             	movzbl %al,%ebx
+c010b3be:	83 fb 25             	cmp    $0x25,%ebx
+c010b3c1:	75 d5                	jne    c010b398 <vprintfmt+0xa>
+            }
+            putch(ch, putdat);
+        }
+
+        // Process a %-escape sequence
+        char padc = ' ';
+c010b3c3:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+        width = precision = -1;
+c010b3c7:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+c010b3ce:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c010b3d1:	89 45 e8             	mov    %eax,-0x18(%ebp)
+        lflag = altflag = 0;
+c010b3d4:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+c010b3db:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c010b3de:	89 45 e0             	mov    %eax,-0x20(%ebp)
+
+    reswitch:
+        switch (ch = *(unsigned char *)fmt ++) {
+c010b3e1:	8b 45 10             	mov    0x10(%ebp),%eax
+c010b3e4:	8d 50 01             	lea    0x1(%eax),%edx
+c010b3e7:	89 55 10             	mov    %edx,0x10(%ebp)
+c010b3ea:	0f b6 00             	movzbl (%eax),%eax
+c010b3ed:	0f b6 d8             	movzbl %al,%ebx
+c010b3f0:	8d 43 dd             	lea    -0x23(%ebx),%eax
+c010b3f3:	83 f8 55             	cmp    $0x55,%eax
+c010b3f6:	0f 87 05 03 00 00    	ja     c010b701 <vprintfmt+0x373>
+c010b3fc:	8b 04 85 28 e0 10 c0 	mov    -0x3fef1fd8(,%eax,4),%eax
+c010b403:	ff e0                	jmp    *%eax
+
+        // flag to pad on the right
+        case '-':
+            padc = '-';
+c010b405:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+            goto reswitch;
+c010b409:	eb d6                	jmp    c010b3e1 <vprintfmt+0x53>
+
+        // flag to pad with 0's instead of spaces
+        case '0':
+            padc = '0';
+c010b40b:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+            goto reswitch;
+c010b40f:	eb d0                	jmp    c010b3e1 <vprintfmt+0x53>
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+c010b411:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+                precision = precision * 10 + ch - '0';
+c010b418:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c010b41b:	89 d0                	mov    %edx,%eax
+c010b41d:	c1 e0 02             	shl    $0x2,%eax
+c010b420:	01 d0                	add    %edx,%eax
+c010b422:	01 c0                	add    %eax,%eax
+c010b424:	01 d8                	add    %ebx,%eax
+c010b426:	83 e8 30             	sub    $0x30,%eax
+c010b429:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+                ch = *fmt;
+c010b42c:	8b 45 10             	mov    0x10(%ebp),%eax
+c010b42f:	0f b6 00             	movzbl (%eax),%eax
+c010b432:	0f be d8             	movsbl %al,%ebx
+                if (ch < '0' || ch > '9') {
+c010b435:	83 fb 2f             	cmp    $0x2f,%ebx
+c010b438:	7e 39                	jle    c010b473 <vprintfmt+0xe5>
+c010b43a:	83 fb 39             	cmp    $0x39,%ebx
+c010b43d:	7f 34                	jg     c010b473 <vprintfmt+0xe5>
+            padc = '0';
+            goto reswitch;
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+c010b43f:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+                precision = precision * 10 + ch - '0';
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+c010b443:	eb d3                	jmp    c010b418 <vprintfmt+0x8a>
+            goto process_precision;
+
+        case '*':
+            precision = va_arg(ap, int);
+c010b445:	8b 45 14             	mov    0x14(%ebp),%eax
+c010b448:	8d 50 04             	lea    0x4(%eax),%edx
+c010b44b:	89 55 14             	mov    %edx,0x14(%ebp)
+c010b44e:	8b 00                	mov    (%eax),%eax
+c010b450:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+            goto process_precision;
+c010b453:	eb 1f                	jmp    c010b474 <vprintfmt+0xe6>
+
+        case '.':
+            if (width < 0)
+c010b455:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+c010b459:	79 86                	jns    c010b3e1 <vprintfmt+0x53>
+                width = 0;
+c010b45b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+            goto reswitch;
+c010b462:	e9 7a ff ff ff       	jmp    c010b3e1 <vprintfmt+0x53>
+
+        case '#':
+            altflag = 1;
+c010b467:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+            goto reswitch;
+c010b46e:	e9 6e ff ff ff       	jmp    c010b3e1 <vprintfmt+0x53>
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+            goto process_precision;
+c010b473:	90                   	nop
+        case '#':
+            altflag = 1;
+            goto reswitch;
+
+        process_precision:
+            if (width < 0)
+c010b474:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+c010b478:	0f 89 63 ff ff ff    	jns    c010b3e1 <vprintfmt+0x53>
+                width = precision, precision = -1;
+c010b47e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c010b481:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c010b484:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+            goto reswitch;
+c010b48b:	e9 51 ff ff ff       	jmp    c010b3e1 <vprintfmt+0x53>
+
+        // long flag (doubled for long long)
+        case 'l':
+            lflag ++;
+c010b490:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
+            goto reswitch;
+c010b494:	e9 48 ff ff ff       	jmp    c010b3e1 <vprintfmt+0x53>
+
+        // character
+        case 'c':
+            putch(va_arg(ap, int), putdat);
+c010b499:	8b 45 14             	mov    0x14(%ebp),%eax
+c010b49c:	8d 50 04             	lea    0x4(%eax),%edx
+c010b49f:	89 55 14             	mov    %edx,0x14(%ebp)
+c010b4a2:	8b 00                	mov    (%eax),%eax
+c010b4a4:	83 ec 08             	sub    $0x8,%esp
+c010b4a7:	ff 75 0c             	pushl  0xc(%ebp)
+c010b4aa:	50                   	push   %eax
+c010b4ab:	8b 45 08             	mov    0x8(%ebp),%eax
+c010b4ae:	ff d0                	call   *%eax
+c010b4b0:	83 c4 10             	add    $0x10,%esp
+            break;
+c010b4b3:	e9 71 02 00 00       	jmp    c010b729 <vprintfmt+0x39b>
+
+        // error message
+        case 'e':
+            err = va_arg(ap, int);
+c010b4b8:	8b 45 14             	mov    0x14(%ebp),%eax
+c010b4bb:	8d 50 04             	lea    0x4(%eax),%edx
+c010b4be:	89 55 14             	mov    %edx,0x14(%ebp)
+c010b4c1:	8b 18                	mov    (%eax),%ebx
+            if (err < 0) {
+c010b4c3:	85 db                	test   %ebx,%ebx
+c010b4c5:	79 02                	jns    c010b4c9 <vprintfmt+0x13b>
+                err = -err;
+c010b4c7:	f7 db                	neg    %ebx
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+c010b4c9:	83 fb 18             	cmp    $0x18,%ebx
+c010b4cc:	7f 0b                	jg     c010b4d9 <vprintfmt+0x14b>
+c010b4ce:	8b 34 9d a0 df 10 c0 	mov    -0x3fef2060(,%ebx,4),%esi
+c010b4d5:	85 f6                	test   %esi,%esi
+c010b4d7:	75 19                	jne    c010b4f2 <vprintfmt+0x164>
+                printfmt(putch, putdat, "error %d", err);
+c010b4d9:	53                   	push   %ebx
+c010b4da:	68 15 e0 10 c0       	push   $0xc010e015
+c010b4df:	ff 75 0c             	pushl  0xc(%ebp)
+c010b4e2:	ff 75 08             	pushl  0x8(%ebp)
+c010b4e5:	e8 80 fe ff ff       	call   c010b36a <printfmt>
+c010b4ea:	83 c4 10             	add    $0x10,%esp
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+            }
+            break;
+c010b4ed:	e9 37 02 00 00       	jmp    c010b729 <vprintfmt+0x39b>
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+                printfmt(putch, putdat, "error %d", err);
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+c010b4f2:	56                   	push   %esi
+c010b4f3:	68 1e e0 10 c0       	push   $0xc010e01e
+c010b4f8:	ff 75 0c             	pushl  0xc(%ebp)
+c010b4fb:	ff 75 08             	pushl  0x8(%ebp)
+c010b4fe:	e8 67 fe ff ff       	call   c010b36a <printfmt>
+c010b503:	83 c4 10             	add    $0x10,%esp
+            }
+            break;
+c010b506:	e9 1e 02 00 00       	jmp    c010b729 <vprintfmt+0x39b>
+
+        // string
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+c010b50b:	8b 45 14             	mov    0x14(%ebp),%eax
+c010b50e:	8d 50 04             	lea    0x4(%eax),%edx
+c010b511:	89 55 14             	mov    %edx,0x14(%ebp)
+c010b514:	8b 30                	mov    (%eax),%esi
+c010b516:	85 f6                	test   %esi,%esi
+c010b518:	75 05                	jne    c010b51f <vprintfmt+0x191>
+                p = "(null)";
+c010b51a:	be 21 e0 10 c0       	mov    $0xc010e021,%esi
+            }
+            if (width > 0 && padc != '-') {
+c010b51f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+c010b523:	7e 76                	jle    c010b59b <vprintfmt+0x20d>
+c010b525:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+c010b529:	74 70                	je     c010b59b <vprintfmt+0x20d>
+                for (width -= strnlen(p, precision); width > 0; width --) {
+c010b52b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c010b52e:	83 ec 08             	sub    $0x8,%esp
+c010b531:	50                   	push   %eax
+c010b532:	56                   	push   %esi
+c010b533:	e8 17 f8 ff ff       	call   c010ad4f <strnlen>
+c010b538:	83 c4 10             	add    $0x10,%esp
+c010b53b:	89 c2                	mov    %eax,%edx
+c010b53d:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010b540:	29 d0                	sub    %edx,%eax
+c010b542:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c010b545:	eb 17                	jmp    c010b55e <vprintfmt+0x1d0>
+                    putch(padc, putdat);
+c010b547:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+c010b54b:	83 ec 08             	sub    $0x8,%esp
+c010b54e:	ff 75 0c             	pushl  0xc(%ebp)
+c010b551:	50                   	push   %eax
+c010b552:	8b 45 08             	mov    0x8(%ebp),%eax
+c010b555:	ff d0                	call   *%eax
+c010b557:	83 c4 10             	add    $0x10,%esp
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+                p = "(null)";
+            }
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+c010b55a:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+c010b55e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+c010b562:	7f e3                	jg     c010b547 <vprintfmt+0x1b9>
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+c010b564:	eb 35                	jmp    c010b59b <vprintfmt+0x20d>
+                if (altflag && (ch < ' ' || ch > '~')) {
+c010b566:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+c010b56a:	74 1c                	je     c010b588 <vprintfmt+0x1fa>
+c010b56c:	83 fb 1f             	cmp    $0x1f,%ebx
+c010b56f:	7e 05                	jle    c010b576 <vprintfmt+0x1e8>
+c010b571:	83 fb 7e             	cmp    $0x7e,%ebx
+c010b574:	7e 12                	jle    c010b588 <vprintfmt+0x1fa>
+                    putch('?', putdat);
+c010b576:	83 ec 08             	sub    $0x8,%esp
+c010b579:	ff 75 0c             	pushl  0xc(%ebp)
+c010b57c:	6a 3f                	push   $0x3f
+c010b57e:	8b 45 08             	mov    0x8(%ebp),%eax
+c010b581:	ff d0                	call   *%eax
+c010b583:	83 c4 10             	add    $0x10,%esp
+c010b586:	eb 0f                	jmp    c010b597 <vprintfmt+0x209>
+                }
+                else {
+                    putch(ch, putdat);
+c010b588:	83 ec 08             	sub    $0x8,%esp
+c010b58b:	ff 75 0c             	pushl  0xc(%ebp)
+c010b58e:	53                   	push   %ebx
+c010b58f:	8b 45 08             	mov    0x8(%ebp),%eax
+c010b592:	ff d0                	call   *%eax
+c010b594:	83 c4 10             	add    $0x10,%esp
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+c010b597:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+c010b59b:	89 f0                	mov    %esi,%eax
+c010b59d:	8d 70 01             	lea    0x1(%eax),%esi
+c010b5a0:	0f b6 00             	movzbl (%eax),%eax
+c010b5a3:	0f be d8             	movsbl %al,%ebx
+c010b5a6:	85 db                	test   %ebx,%ebx
+c010b5a8:	74 26                	je     c010b5d0 <vprintfmt+0x242>
+c010b5aa:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+c010b5ae:	78 b6                	js     c010b566 <vprintfmt+0x1d8>
+c010b5b0:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+c010b5b4:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+c010b5b8:	79 ac                	jns    c010b566 <vprintfmt+0x1d8>
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+c010b5ba:	eb 14                	jmp    c010b5d0 <vprintfmt+0x242>
+                putch(' ', putdat);
+c010b5bc:	83 ec 08             	sub    $0x8,%esp
+c010b5bf:	ff 75 0c             	pushl  0xc(%ebp)
+c010b5c2:	6a 20                	push   $0x20
+c010b5c4:	8b 45 08             	mov    0x8(%ebp),%eax
+c010b5c7:	ff d0                	call   *%eax
+c010b5c9:	83 c4 10             	add    $0x10,%esp
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+c010b5cc:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+c010b5d0:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+c010b5d4:	7f e6                	jg     c010b5bc <vprintfmt+0x22e>
+                putch(' ', putdat);
+            }
+            break;
+c010b5d6:	e9 4e 01 00 00       	jmp    c010b729 <vprintfmt+0x39b>
+
+        // (signed) decimal
+        case 'd':
+            num = getint(&ap, lflag);
+c010b5db:	83 ec 08             	sub    $0x8,%esp
+c010b5de:	ff 75 e0             	pushl  -0x20(%ebp)
+c010b5e1:	8d 45 14             	lea    0x14(%ebp),%eax
+c010b5e4:	50                   	push   %eax
+c010b5e5:	e8 39 fd ff ff       	call   c010b323 <getint>
+c010b5ea:	83 c4 10             	add    $0x10,%esp
+c010b5ed:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c010b5f0:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            if ((long long)num < 0) {
+c010b5f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010b5f6:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c010b5f9:	85 d2                	test   %edx,%edx
+c010b5fb:	79 23                	jns    c010b620 <vprintfmt+0x292>
+                putch('-', putdat);
+c010b5fd:	83 ec 08             	sub    $0x8,%esp
+c010b600:	ff 75 0c             	pushl  0xc(%ebp)
+c010b603:	6a 2d                	push   $0x2d
+c010b605:	8b 45 08             	mov    0x8(%ebp),%eax
+c010b608:	ff d0                	call   *%eax
+c010b60a:	83 c4 10             	add    $0x10,%esp
+                num = -(long long)num;
+c010b60d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010b610:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c010b613:	f7 d8                	neg    %eax
+c010b615:	83 d2 00             	adc    $0x0,%edx
+c010b618:	f7 da                	neg    %edx
+c010b61a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c010b61d:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            }
+            base = 10;
+c010b620:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+c010b627:	e9 9f 00 00 00       	jmp    c010b6cb <vprintfmt+0x33d>
+
+        // unsigned decimal
+        case 'u':
+            num = getuint(&ap, lflag);
+c010b62c:	83 ec 08             	sub    $0x8,%esp
+c010b62f:	ff 75 e0             	pushl  -0x20(%ebp)
+c010b632:	8d 45 14             	lea    0x14(%ebp),%eax
+c010b635:	50                   	push   %eax
+c010b636:	e8 99 fc ff ff       	call   c010b2d4 <getuint>
+c010b63b:	83 c4 10             	add    $0x10,%esp
+c010b63e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c010b641:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 10;
+c010b644:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+c010b64b:	eb 7e                	jmp    c010b6cb <vprintfmt+0x33d>
+
+        // (unsigned) octal
+        case 'o':
+            num = getuint(&ap, lflag);
+c010b64d:	83 ec 08             	sub    $0x8,%esp
+c010b650:	ff 75 e0             	pushl  -0x20(%ebp)
+c010b653:	8d 45 14             	lea    0x14(%ebp),%eax
+c010b656:	50                   	push   %eax
+c010b657:	e8 78 fc ff ff       	call   c010b2d4 <getuint>
+c010b65c:	83 c4 10             	add    $0x10,%esp
+c010b65f:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c010b662:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 8;
+c010b665:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+            goto number;
+c010b66c:	eb 5d                	jmp    c010b6cb <vprintfmt+0x33d>
+
+        // pointer
+        case 'p':
+            putch('0', putdat);
+c010b66e:	83 ec 08             	sub    $0x8,%esp
+c010b671:	ff 75 0c             	pushl  0xc(%ebp)
+c010b674:	6a 30                	push   $0x30
+c010b676:	8b 45 08             	mov    0x8(%ebp),%eax
+c010b679:	ff d0                	call   *%eax
+c010b67b:	83 c4 10             	add    $0x10,%esp
+            putch('x', putdat);
+c010b67e:	83 ec 08             	sub    $0x8,%esp
+c010b681:	ff 75 0c             	pushl  0xc(%ebp)
+c010b684:	6a 78                	push   $0x78
+c010b686:	8b 45 08             	mov    0x8(%ebp),%eax
+c010b689:	ff d0                	call   *%eax
+c010b68b:	83 c4 10             	add    $0x10,%esp
+            num = (unsigned long long)(uintptr_t)va_arg(ap, void *);
+c010b68e:	8b 45 14             	mov    0x14(%ebp),%eax
+c010b691:	8d 50 04             	lea    0x4(%eax),%edx
+c010b694:	89 55 14             	mov    %edx,0x14(%ebp)
+c010b697:	8b 00                	mov    (%eax),%eax
+c010b699:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c010b69c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+            base = 16;
+c010b6a3:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+            goto number;
+c010b6aa:	eb 1f                	jmp    c010b6cb <vprintfmt+0x33d>
+
+        // (unsigned) hexadecimal
+        case 'x':
+            num = getuint(&ap, lflag);
+c010b6ac:	83 ec 08             	sub    $0x8,%esp
+c010b6af:	ff 75 e0             	pushl  -0x20(%ebp)
+c010b6b2:	8d 45 14             	lea    0x14(%ebp),%eax
+c010b6b5:	50                   	push   %eax
+c010b6b6:	e8 19 fc ff ff       	call   c010b2d4 <getuint>
+c010b6bb:	83 c4 10             	add    $0x10,%esp
+c010b6be:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c010b6c1:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 16;
+c010b6c4:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+        number:
+            printnum(putch, putdat, num, base, width, padc);
+c010b6cb:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+c010b6cf:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010b6d2:	83 ec 04             	sub    $0x4,%esp
+c010b6d5:	52                   	push   %edx
+c010b6d6:	ff 75 e8             	pushl  -0x18(%ebp)
+c010b6d9:	50                   	push   %eax
+c010b6da:	ff 75 f4             	pushl  -0xc(%ebp)
+c010b6dd:	ff 75 f0             	pushl  -0x10(%ebp)
+c010b6e0:	ff 75 0c             	pushl  0xc(%ebp)
+c010b6e3:	ff 75 08             	pushl  0x8(%ebp)
+c010b6e6:	e8 f8 fa ff ff       	call   c010b1e3 <printnum>
+c010b6eb:	83 c4 20             	add    $0x20,%esp
+            break;
+c010b6ee:	eb 39                	jmp    c010b729 <vprintfmt+0x39b>
+
+        // escaped '%' character
+        case '%':
+            putch(ch, putdat);
+c010b6f0:	83 ec 08             	sub    $0x8,%esp
+c010b6f3:	ff 75 0c             	pushl  0xc(%ebp)
+c010b6f6:	53                   	push   %ebx
+c010b6f7:	8b 45 08             	mov    0x8(%ebp),%eax
+c010b6fa:	ff d0                	call   *%eax
+c010b6fc:	83 c4 10             	add    $0x10,%esp
+            break;
+c010b6ff:	eb 28                	jmp    c010b729 <vprintfmt+0x39b>
+
+        // unrecognized escape sequence - just print it literally
+        default:
+            putch('%', putdat);
+c010b701:	83 ec 08             	sub    $0x8,%esp
+c010b704:	ff 75 0c             	pushl  0xc(%ebp)
+c010b707:	6a 25                	push   $0x25
+c010b709:	8b 45 08             	mov    0x8(%ebp),%eax
+c010b70c:	ff d0                	call   *%eax
+c010b70e:	83 c4 10             	add    $0x10,%esp
+            for (fmt --; fmt[-1] != '%'; fmt --)
+c010b711:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+c010b715:	eb 04                	jmp    c010b71b <vprintfmt+0x38d>
+c010b717:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+c010b71b:	8b 45 10             	mov    0x10(%ebp),%eax
+c010b71e:	83 e8 01             	sub    $0x1,%eax
+c010b721:	0f b6 00             	movzbl (%eax),%eax
+c010b724:	3c 25                	cmp    $0x25,%al
+c010b726:	75 ef                	jne    c010b717 <vprintfmt+0x389>
+                /* do nothing */;
+            break;
+c010b728:	90                   	nop
+        }
+    }
+c010b729:	e9 68 fc ff ff       	jmp    c010b396 <vprintfmt+0x8>
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+            if (ch == '\0') {
+                return;
+c010b72e:	90                   	nop
+            for (fmt --; fmt[-1] != '%'; fmt --)
+                /* do nothing */;
+            break;
+        }
+    }
+}
+c010b72f:	8d 65 f8             	lea    -0x8(%ebp),%esp
+c010b732:	5b                   	pop    %ebx
+c010b733:	5e                   	pop    %esi
+c010b734:	5d                   	pop    %ebp
+c010b735:	c3                   	ret    
+
+c010b736 <sprintputch>:
+ * sprintputch - 'print' a single character in a buffer
+ * @ch:         the character will be printed
+ * @b:          the buffer to place the character @ch
+ * */
+static void
+sprintputch(int ch, struct sprintbuf *b) {
+c010b736:	55                   	push   %ebp
+c010b737:	89 e5                	mov    %esp,%ebp
+    b->cnt ++;
+c010b739:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010b73c:	8b 40 08             	mov    0x8(%eax),%eax
+c010b73f:	8d 50 01             	lea    0x1(%eax),%edx
+c010b742:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010b745:	89 50 08             	mov    %edx,0x8(%eax)
+    if (b->buf < b->ebuf) {
+c010b748:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010b74b:	8b 10                	mov    (%eax),%edx
+c010b74d:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010b750:	8b 40 04             	mov    0x4(%eax),%eax
+c010b753:	39 c2                	cmp    %eax,%edx
+c010b755:	73 12                	jae    c010b769 <sprintputch+0x33>
+        *b->buf ++ = ch;
+c010b757:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010b75a:	8b 00                	mov    (%eax),%eax
+c010b75c:	8d 48 01             	lea    0x1(%eax),%ecx
+c010b75f:	8b 55 0c             	mov    0xc(%ebp),%edx
+c010b762:	89 0a                	mov    %ecx,(%edx)
+c010b764:	8b 55 08             	mov    0x8(%ebp),%edx
+c010b767:	88 10                	mov    %dl,(%eax)
+    }
+}
+c010b769:	90                   	nop
+c010b76a:	5d                   	pop    %ebp
+c010b76b:	c3                   	ret    
+
+c010b76c <snprintf>:
+ * @str:        the buffer to place the result into
+ * @size:       the size of buffer, including the trailing null space
+ * @fmt:        the format string to use
+ * */
+int
+snprintf(char *str, size_t size, const char *fmt, ...) {
+c010b76c:	55                   	push   %ebp
+c010b76d:	89 e5                	mov    %esp,%ebp
+c010b76f:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    int cnt;
+    va_start(ap, fmt);
+c010b772:	8d 45 14             	lea    0x14(%ebp),%eax
+c010b775:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    cnt = vsnprintf(str, size, fmt, ap);
+c010b778:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010b77b:	50                   	push   %eax
+c010b77c:	ff 75 10             	pushl  0x10(%ebp)
+c010b77f:	ff 75 0c             	pushl  0xc(%ebp)
+c010b782:	ff 75 08             	pushl  0x8(%ebp)
+c010b785:	e8 0b 00 00 00       	call   c010b795 <vsnprintf>
+c010b78a:	83 c4 10             	add    $0x10,%esp
+c010b78d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+    return cnt;
+c010b790:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+c010b793:	c9                   	leave  
+c010b794:	c3                   	ret    
+
+c010b795 <vsnprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want snprintf() instead.
+ * */
+int
+vsnprintf(char *str, size_t size, const char *fmt, va_list ap) {
+c010b795:	55                   	push   %ebp
+c010b796:	89 e5                	mov    %esp,%ebp
+c010b798:	83 ec 18             	sub    $0x18,%esp
+    struct sprintbuf b = {str, str + size - 1, 0};
+c010b79b:	8b 45 08             	mov    0x8(%ebp),%eax
+c010b79e:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c010b7a1:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010b7a4:	8d 50 ff             	lea    -0x1(%eax),%edx
+c010b7a7:	8b 45 08             	mov    0x8(%ebp),%eax
+c010b7aa:	01 d0                	add    %edx,%eax
+c010b7ac:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c010b7af:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    if (str == NULL || b.buf > b.ebuf) {
+c010b7b6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c010b7ba:	74 0a                	je     c010b7c6 <vsnprintf+0x31>
+c010b7bc:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c010b7bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010b7c2:	39 c2                	cmp    %eax,%edx
+c010b7c4:	76 07                	jbe    c010b7cd <vsnprintf+0x38>
+        return -E_INVAL;
+c010b7c6:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+c010b7cb:	eb 20                	jmp    c010b7ed <vsnprintf+0x58>
+    }
+    // print the string to the buffer
+    vprintfmt((void*)sprintputch, &b, fmt, ap);
+c010b7cd:	ff 75 14             	pushl  0x14(%ebp)
+c010b7d0:	ff 75 10             	pushl  0x10(%ebp)
+c010b7d3:	8d 45 ec             	lea    -0x14(%ebp),%eax
+c010b7d6:	50                   	push   %eax
+c010b7d7:	68 36 b7 10 c0       	push   $0xc010b736
+c010b7dc:	e8 ad fb ff ff       	call   c010b38e <vprintfmt>
+c010b7e1:	83 c4 10             	add    $0x10,%esp
+    // null terminate the buffer
+    *b.buf = '\0';
+c010b7e4:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010b7e7:	c6 00 00             	movb   $0x0,(%eax)
+    return b.cnt;
+c010b7ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+c010b7ed:	c9                   	leave  
+c010b7ee:	c3                   	ret    
+
+c010b7ef <hash32>:
+ * @bits:   the number of bits in a return value
+ *
+ * High bits are more random, so we use them.
+ * */
+uint32_t
+hash32(uint32_t val, unsigned int bits) {
+c010b7ef:	55                   	push   %ebp
+c010b7f0:	89 e5                	mov    %esp,%ebp
+c010b7f2:	83 ec 10             	sub    $0x10,%esp
+    uint32_t hash = val * GOLDEN_RATIO_PRIME_32;
+c010b7f5:	8b 45 08             	mov    0x8(%ebp),%eax
+c010b7f8:	69 c0 01 00 37 9e    	imul   $0x9e370001,%eax,%eax
+c010b7fe:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    return (hash >> (32 - bits));
+c010b801:	b8 20 00 00 00       	mov    $0x20,%eax
+c010b806:	2b 45 0c             	sub    0xc(%ebp),%eax
+c010b809:	8b 55 fc             	mov    -0x4(%ebp),%edx
+c010b80c:	89 c1                	mov    %eax,%ecx
+c010b80e:	d3 ea                	shr    %cl,%edx
+c010b810:	89 d0                	mov    %edx,%eax
+}
+c010b812:	c9                   	leave  
+c010b813:	c3                   	ret    
+
+c010b814 <rand>:
+ * rand - returns a pseudo-random integer
+ *
+ * The rand() function return a value in the range [0, RAND_MAX].
+ * */
+int
+rand(void) {
+c010b814:	55                   	push   %ebp
+c010b815:	89 e5                	mov    %esp,%ebp
+c010b817:	57                   	push   %edi
+c010b818:	56                   	push   %esi
+c010b819:	53                   	push   %ebx
+c010b81a:	83 ec 24             	sub    $0x24,%esp
+    next = (next * 0x5DEECE66DLL + 0xBLL) & ((1LL << 48) - 1);
+c010b81d:	a1 a0 ce 12 c0       	mov    0xc012cea0,%eax
+c010b822:	8b 15 a4 ce 12 c0    	mov    0xc012cea4,%edx
+c010b828:	69 fa 6d e6 ec de    	imul   $0xdeece66d,%edx,%edi
+c010b82e:	6b f0 05             	imul   $0x5,%eax,%esi
+c010b831:	01 fe                	add    %edi,%esi
+c010b833:	bf 6d e6 ec de       	mov    $0xdeece66d,%edi
+c010b838:	f7 e7                	mul    %edi
+c010b83a:	01 d6                	add    %edx,%esi
+c010b83c:	89 f2                	mov    %esi,%edx
+c010b83e:	83 c0 0b             	add    $0xb,%eax
+c010b841:	83 d2 00             	adc    $0x0,%edx
+c010b844:	89 c7                	mov    %eax,%edi
+c010b846:	83 e7 ff             	and    $0xffffffff,%edi
+c010b849:	89 f9                	mov    %edi,%ecx
+c010b84b:	0f b7 da             	movzwl %dx,%ebx
+c010b84e:	89 0d a0 ce 12 c0    	mov    %ecx,0xc012cea0
+c010b854:	89 1d a4 ce 12 c0    	mov    %ebx,0xc012cea4
+    unsigned long long result = (next >> 12);
+c010b85a:	a1 a0 ce 12 c0       	mov    0xc012cea0,%eax
+c010b85f:	8b 15 a4 ce 12 c0    	mov    0xc012cea4,%edx
+c010b865:	0f ac d0 0c          	shrd   $0xc,%edx,%eax
+c010b869:	c1 ea 0c             	shr    $0xc,%edx
+c010b86c:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c010b86f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+    return (int)do_div(result, RAND_MAX + 1);
+c010b872:	c7 45 dc 00 00 00 80 	movl   $0x80000000,-0x24(%ebp)
+c010b879:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c010b87c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c010b87f:	89 45 d8             	mov    %eax,-0x28(%ebp)
+c010b882:	89 55 e8             	mov    %edx,-0x18(%ebp)
+c010b885:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010b888:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c010b88b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+c010b88f:	74 1c                	je     c010b8ad <rand+0x99>
+c010b891:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010b894:	ba 00 00 00 00       	mov    $0x0,%edx
+c010b899:	f7 75 dc             	divl   -0x24(%ebp)
+c010b89c:	89 55 ec             	mov    %edx,-0x14(%ebp)
+c010b89f:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010b8a2:	ba 00 00 00 00       	mov    $0x0,%edx
+c010b8a7:	f7 75 dc             	divl   -0x24(%ebp)
+c010b8aa:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c010b8ad:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c010b8b0:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c010b8b3:	f7 75 dc             	divl   -0x24(%ebp)
+c010b8b6:	89 45 d8             	mov    %eax,-0x28(%ebp)
+c010b8b9:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+c010b8bc:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c010b8bf:	8b 55 e8             	mov    -0x18(%ebp),%edx
+c010b8c2:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c010b8c5:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+c010b8c8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+}
+c010b8cb:	83 c4 24             	add    $0x24,%esp
+c010b8ce:	5b                   	pop    %ebx
+c010b8cf:	5e                   	pop    %esi
+c010b8d0:	5f                   	pop    %edi
+c010b8d1:	5d                   	pop    %ebp
+c010b8d2:	c3                   	ret    
+
+c010b8d3 <srand>:
+/* *
+ * srand - seed the random number generator with the given number
+ * @seed:   the required seed number
+ * */
+void
+srand(unsigned int seed) {
+c010b8d3:	55                   	push   %ebp
+c010b8d4:	89 e5                	mov    %esp,%ebp
+    next = seed;
+c010b8d6:	8b 45 08             	mov    0x8(%ebp),%eax
+c010b8d9:	ba 00 00 00 00       	mov    $0x0,%edx
+c010b8de:	a3 a0 ce 12 c0       	mov    %eax,0xc012cea0
+c010b8e3:	89 15 a4 ce 12 c0    	mov    %edx,0xc012cea4
+}
+c010b8e9:	90                   	nop
+c010b8ea:	5d                   	pop    %ebp
+c010b8eb:	c3                   	ret    
diff -r -u -P lab6_origin/obj/kernel.sym lab6/obj/kernel.sym
--- lab6_origin/obj/kernel.sym	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/kernel.sym	2019-05-13 17:41:10.940246800 +0800
@@ -0,0 +1,733 @@
+c0100000 .text
+c010b900 .rodata
+c010e180 .stab
+c0123955 .stabstr
+c012a000 .data
+c01ae000 .data.pgdir
+c01b0000 .bss
+00000000 .comment
+00000000 obj/kern/init/entry.o
+c010001e next
+c0100034 spin
+c01af000 __boot_pt1
+00000400 i
+00000000 init.c
+c0100137 lab1_print_cur_status
+c01b0000 round.2080
+c01001f4 lab1_switch_to_user
+c01001fa lab1_switch_to_kernel
+c0100200 lab1_switch_test
+00000000 stdio.c
+c0100242 cputch
+00000000 readline.c
+c01b0020 buf
+00000000 panic.c
+c01b0420 is_panic
+00000000 kdebug.c
+c01004c9 stab_binsearch
+c0100b3e read_eip
+00000000 kmonitor.c
+c012c000 commands
+c0100c14 parse
+c0100cd0 runcmd
+00000000 ide.c
+c010bc14 channels
+c01b0440 ide_devices
+c0100e6c ide_wait_ready
+00000000 clock.c
+00000000 console.c
+c0101707 __intr_save
+c0101731 __intr_restore
+c0101745 delay
+c01b0520 crt_buf
+c01b0524 crt_pos
+c01b0526 addr_6845
+c010178e cga_init
+c01b0528 serial_exists
+c0101875 serial_init
+c010195a lpt_putc_sub
+c01019d4 lpt_putc
+c0101a0b cga_putc
+c0101be0 serial_putc_sub
+c0101c3a serial_putc
+c01b0540 cons
+c0101c71 cons_intr
+c0101cbd serial_proc_data
+c012c040 shiftcode
+c012c140 togglecode
+c012c240 normalmap
+c012c340 shiftmap
+c012c440 ctlmap
+c012c540 charcode
+c0101d36 kbd_proc_data
+c01b0748 shift.1719
+c0101ec3 kbd_intr
+c0101edc kbd_init
+00000000 picirq.c
+c012c550 irq_mask
+c01b074c did_init
+c0101fe3 pic_setmask
+00000000 intr.c
+00000000 trap.c
+c01021b4 print_ticks
+c01b0760 idt
+c012c560 idt_pd
+c010235f trapname
+c010c220 excnames.1960
+c012c580 IA32flags
+c0102643 print_pgfault
+c01026b8 pgfault_handler
+c01b0f60 in_swap_tick_event
+c0102778 trap_dispatch
+00000000 pmm.c
+c01034b5 page2ppn
+c01034c8 page2pa
+c01034db pa2page
+c0103518 page2kva
+c010355d pte2page
+c0103597 pde2page
+c01035b3 page_ref
+c01035bd set_page_ref
+c01035cb page_ref_inc
+c01035e2 page_ref_dec
+c01035f9 __intr_save
+c0103623 __intr_restore
+c01b0fa0 ts
+c012ca00 gdt
+c012ca30 gdt_pd
+c0103637 lgdt
+c010367b gdt_init
+c010376d init_pmm_manager
+c01037a2 init_memmap
+c0103890 page_init
+c0103c3c boot_map_segment
+c0103d25 boot_alloc_page
+c0104598 check_alloc_page
+c01045bb check_pgdir
+c0104b21 check_boot_pgdir
+c0103fa0 page_remove_pte
+c0104e1a perm2str
+c01b1008 str.2109
+c0104e68 get_pgtable_items
+00000000 swap_fifo.c
+c0105070 _fifo_init_mm
+c01050a2 _fifo_map_swappable
+c0105127 _fifo_swap_out_victim
+c01051f5 _fifo_check_swap
+c01054c4 _fifo_init
+c01054ce _fifo_set_unswappable
+c01054d8 _fifo_tick_event
+00000000 vmm.c
+c01054e2 lock_init
+c01054f1 mm_count
+c01054fc set_mm_count
+c010550b pa2page
+c0105548 pde2page
+c01056ef check_vma_overlap
+c0105c73 check_vmm
+c0105c9e check_vma_struct
+c010609b check_pgfault
+00000000 kmalloc.c
+c01065c8 __intr_save
+c01065f2 __intr_restore
+c0106606 page2ppn
+c0106619 page2pa
+c010662c pa2page
+c0106669 page2kva
+c01066ae kva2page
+c012ca60 arena
+c012ca68 slobfree
+c01b1010 bigblocks
+c01066ed __slob_get_free_pages
+c010672d __slob_free_pages
+c0106766 slob_alloc
+c0106935 slob_free
+c0106a9e find_order
+c0106ac2 __kmalloc
+00000000 swap.c
+c0106d17 pa2page
+c0106d54 pte2page
+c0106d8e pde2page
+c01b101c sm
+c010721f check_swap
+c01070a6 check_content_set
+c0107207 check_content_access
+00000000 default_pmm.c
+c010780e page2ppn
+c0107821 page2pa
+c0107834 page_ref
+c010783e set_page_ref
+c010784c default_init
+c010787a default_init_memmap
+c01079a4 default_alloc_pages
+c0107b1c default_free_pages
+c0107cfc default_nr_free_pages
+c0107d06 basic_check
+c010817c default_check
+00000000 swapfs.c
+c01086e4 page2ppn
+c01086f7 page2pa
+c010870a page2kva
+00000000 proc.c
+c0108884 test_and_set_bit
+c01088a4 test_and_clear_bit
+c01088c4 __intr_save
+c01088ee __intr_restore
+c0108902 try_lock
+c010891c lock
+c010893e unlock
+c010896c page2ppn
+c010897f page2pa
+c0108992 pa2page
+c01089cf page2kva
+c0108a14 kva2page
+c0108a53 mm_count_inc
+c0108a6d mm_count_dec
+c0108a87 lock_mm
+c0108aa8 unlock_mm
+c01b1040 hash_list
+c01b3040 nr_process
+c0108ac9 alloc_proc
+c01b3044 name.1986
+c0108c77 set_links
+c0108d1d remove_links
+c0108da1 get_pid
+c012ca6c last_pid.2002
+c012ca70 next_safe.2001
+c0108f17 forkret
+c0108f34 hash_proc
+c0108fae unhash_proc
+c01090b7 setup_kstack
+c01090f7 put_kstack
+c0109120 setup_pgdir
+c01091b9 put_pgdir
+c01091e2 copy_mm
+c0109308 copy_thread
+c010968f load_icode
+c0109f94 kernel_execve
+c0109fd1 user_main
+c010a027 init_main
+00000000 sched.c
+c010a356 __intr_save
+c010a380 __intr_restore
+c01b3054 timer_list
+c01b305c sched_class
+c01b3060 rq
+c010a394 sched_class_enqueue
+c010a3c1 sched_class_dequeue
+c010a3e4 sched_class_pick_next
+c01b3064 __rq
+00000000 default_sched_stride.c
+c010a5d5 skew_heap_merge
+c010a69f proc_stride_comp_f
+c010a6f5 stride_init
+c010a72c stride_enqueue
+c010a7da stride_dequeue
+c010a876 stride_pick_next
+c010a8cf stride_proc_tick
+00000000 default_sched.c
+c010a90e RR_init
+c010a93b RR_enqueue
+c010aa07 RR_dequeue
+c010aaa7 RR_pick_next
+c010aad3 RR_proc_tick
+00000000 syscall.c
+c010ab12 sys_exit
+c010ab30 sys_fork
+c010ab5f sys_wait
+c010ab8b sys_exec
+c010abd0 sys_yield
+c010abdd sys_kill
+c010abfb sys_getpid
+c010ac08 sys_putc
+c010ac2b sys_pgdir
+c010ac3d sys_gettime
+c010ac47 sys_lab6_set_priority
+c012caa0 syscalls
+00000000 string.c
+00000000 printfmt.c
+c010dfa0 error_string
+c010b1e3 printnum
+c010b2d4 getuint
+c010b323 getint
+c010b736 sprintputch
+00000000 hash.c
+00000000 rand.c
+c012cea0 next
+c01033e5 vector242
+c0102e3c vector119
+c0100a05 print_kerninfo
+c0102d1c vector87
+c0102d13 vector86
+c0103451 vector251
+c010ad7f strcpy
+c01011ca ide_device_valid
+c0102d40 vector91
+c0102b36 vector33
+c0103025 vector162
+c0103289 vector213
+c0102dd9 vector108
+c0102b90 vector43
+000078c4 _binary_obj___user_yield_out_size
+c0106a8a slob_allocated
+c0100000 kern_entry
+c0100e5a mon_backtrace
+c0103049 vector165
+c0180120 _binary_obj___user_badsegment_out_start
+c0103139 vector185
+c0102e18 vector115
+c0102e57 vector122
+000078c4 _binary_obj___user_hello_out_size
+c0105be4 copy_from_user
+c019e4b4 _binary_obj___user_forktest_out_end
+c01043de page_insert
+c0102fdd vector156
+c0103409 vector245
+c0103169 vector189
+c0102a5a vector7
+c0102c32 vector61
+c0102ae5 vector24
+c0102df4 vector111
+c01031ed vector200
+0000791c _binary_obj___user_testbss_out_size
+c0102c68 vector67
+c010a4af wakeup_proc
+c0106a94 kallocated
+c01044e7 pgdir_alloc_page
+c0102f05 vector138
+c0102ca7 vector74
+c010b098 memmove
+c0102c0e vector57
+c0152b24 _binary_obj___user_exit_out_end
+c0105564 mm_create
+c010b76c snprintf
+c010ac6a syscall
+c01023a6 print_trapframe
+c0103295 vector214
+c010b38e vprintfmt
+c0102d88 vector99
+c0103f4a get_page
+c010348d __alltraps
+c0101f71 cons_getc
+c0102f29 vector141
+c01004bf is_kernel_panic
+c010309d vector172
+c0100b4f print_stackframe
+c01033d9 vector241
+c01b3088 pra_list_head
+c0103469 vector253
+c0102a36 vector3
+c01034af forkrets
+c0102a2d vector2
+c01093a4 do_fork
+c0103331 vector227
+c0109052 kernel_thread
+c0103265 vector210
+c01b1020 idleproc
+c010330d vector224
+c0102b7e vector41
+c012ca40 swap_manager_fifo
+c010028f cprintf
+c018f304 _binary_obj___user_testbss_out_end
+c01b3170 proc_list
+c0102aca vector21
+c01030d9 vector177
+c0102e33 vector118
+c0102c83 vector70
+c010592d mm_map
+c0102c7a vector69
+c01033a9 vector237
+c0102c4d vector64
+c0102b00 vector27
+c0105a35 dup_mmap
+c0105c65 vmm_init
+c0102ebd vector132
+c012cea8 _binary_obj___user_badarg_out_start
+c0105b1c exit_mmap
+c0103145 vector186
+000078c4 _binary_obj___user_badarg_out_size
+c01032b9 vector217
+c010588e mm_destroy
+c0108844 kernel_thread_entry
+c0109d9e do_wait
+c010b13b memcpy
+c0102a24 vector1
+c01030e5 vector178
+c0102b63 vector38
+c0106bc9 kfree
+c01a5d78 _binary_obj___user_pgdir_out_end
+c01033b5 vector238
+c017885c _binary_obj___user_yield_out_start
+c0100333 readline
+c015a484 _binary_obj___user_hello_out_start
+c0102ec9 vector133
+c0102c9e vector73
+c0102f4d vector144
+c010c2ec vpd
+c0100036 kern_init
+c014b248 _binary_obj___user_exit_out_start
+c0103475 vector254
+c0102d9a vector101
+c0103271 vector211
+c01030b5 vector174
+c01033f1 vector243
+c01041cc copy_range
+c0102e8d vector128
+c01ad6e4 _binary_obj___user_matrix_out_end
+c0102ce6 vector81
+c010a32b lab6_set_priority
+c010382d free_pages
+c0102a88 vector13
+c010b795 vsnprintf
+c0102bd8 vector51
+c0102a9f vector16
+c01b0000 edata
+c0101ef7 cons_init
+c0106ff3 swap_in
+c0101474 ide_write_secs
+c01b307c pmm_manager
+c01033cd vector240
+c0102bf3 vector54
+c0102ab8 vector19
+c0123954 __STAB_END__
+c0102d49 vector92
+c01033fd vector244
+c01b1014 swap_init_ok
+c010366d load_esp0
+c0102f1d vector140
+c0102ba2 vector45
+c0102cd4 vector79
+c0103349 vector229
+c0106daa swap_init
+c0102ff5 vector158
+c010203c pic_enable
+c010874f swapfs_init
+c01b30a0 check_rp
+000078c8 _binary_obj___user_softint_out_size
+c01040d8 exit_range
+c0102b6c vector39
+c010306d vector168
+c01696d0 _binary_obj___user_waitkill_out_end
+c0102b48 vector35
+c0102e06 vector113
+c0123955 __STABSTR_BEGIN__
+c0109f2c do_kill
+c0102e72 vector125
+c01003f5 __panic
+c0161d48 _binary_obj___user_hello_out_end
+c01b1024 initproc
+c01032ad vector216
+c0102c44 vector63
+c0102af7 vector26
+c0101d14 serial_intr
+c0103199 vector193
+c01031bd vector196
+c01000fc grade_backtrace0
+c0103259 vector209
+c0102a3f vector4
+c0103085 vector170
+c010a53c schedule
+c0102eed vector136
+c0102a73 vector10
+c0170f98 _binary_obj___user_softint_out_end
+c0103235 vector206
+c0103481 vector255
+c0103109 vector181
+c0102c20 vector59
+c0100116 grade_backtrace
+c0102d0a vector85
+c0102d01 vector84
+c010884d switch_to
+c0103121 vector183
+c0103001 vector159
+c010327d vector212
+c0102bb4 vector47
+c010aefb strtol
+c010333d vector228
+c0102b87 vector42
+c0102e0f vector114
+c010ad4f strnlen
+c01696d0 _binary_obj___user_softint_out_start
+c013c068 _binary_obj___user_faultread_out_start
+c01030c1 vector175
+c0102f41 vector143
+c0102ea5 vector130
+c010d860 default_pmm_manager
+c0103415 vector246
+c0102a6a vector9
+c0102f35 vector142
+c0102d91 vector100
+000078fc _binary_obj___user_forktree_out_size
+c010a403 sched_class_proc_tick
+c01031f9 vector201
+c01021f0 idt_init
+c0100aa2 print_debuginfo
+c010563e find_vma
+c01b30c0 swap_in_seq_no
+c013476c _binary_obj___user_forktree_out_start
+c0102c29 vector60
+c0102adc vector23
+c010339d vector236
+c01b0f80 npage
+c01062a0 do_pgfault
+c0103361 vector231
+00007918 _binary_obj___user_divzero_out_size
+c0108c0d set_proc_name
+c0102c5f vector66
+c0102b12 vector29
+c0104f1c print_pgdir
+c0102ee1 vector135
+c0100d80 kmonitor
+000078c8 _binary_obj___user_badsegment_out_size
+c0102cc2 vector77
+c01030fd vector180
+c010169e clock_init
+c010324d vector208
+c0102d7f vector98
+c0102d76 vector97
+c0103862 nr_free_pages
+c0106c8f ksize
+000078c4 _binary_obj___user_pgdir_out_size
+c01030cd vector176
+c01879e8 _binary_obj___user_testbss_out_start
+c01031a5 vector194
+c0102b2d vector32
+c01b3080 boot_cr3
+c01b3178 end
+c01031e1 vector199
+c01094bf do_exit
+c0102eb1 vector131
+c010345d vector252
+c0102a1b vector0
+c018f304 _binary_obj___user_faultreadkernel_out_start
+c01879e8 _binary_obj___user_badsegment_out_end
+c010aecc strfind
+00007988 _binary_obj___user_waitkill_out_size
+c0101f28 cons_putc
+c01b3100 swap_out_seq_no
+c010b8ec etext
+c0102f59 vector145
+c0102dd0 vector107
+c012c9e0 boot_pgdir
+c0102b75 vector40
+c01021a6 intr_enable
+c0102da3 vector102
+c017885c _binary_obj___user_spin_out_end
+c0102c05 vector56
+c0102c71 vector68
+c0102a51 vector6
+c010b814 rand
+c0102e99 vector129
+c01031c9 vector197
+c0102fad vector152
+c012c5e0 __vectors
+c0103355 vector230
+c010ae43 strncmp
+c0106a53 slob_init
+c0103e2d get_pte
+c010120a ide_device_size
+c0102b5a vector37
+c01b3128 check_swap_addr
+c0103229 vector205
+c0103019 vector161
+c01b1028 current
+c010adbf strncpy
+c0105c25 copy_to_user
+c0102c8c vector71
+c010300d vector160
+c0196bd4 _binary_obj___user_forktest_out_start
+c0106a6c kmalloc_init
+c01032a1 vector215
+000078c4 _binary_obj___user_spin_out_size
+c0102fe9 vector157
+c01021ad intr_disable
+c0102583 print_regs
+c0102dfd vector112
+c01000bd grade_backtrace2
+c0103115 vector182
+c0102a81 vector12
+c010b18b memcmp
+c0102de2 vector109
+c0102ac1 vector20
+c0102bea vector53
+c0102aaf vector18
+c010a312 cpu_idle
+c0102d64 vector95
+c0109c66 do_execve
+c0103325 vector226
+c0102bc6 vector49
+c0102b99 vector44
+c0102ccb vector78
+c01030a9 vector173
+c0108792 swapfs_read
+c0102e2a vector117
+c0102390 trap_in_kernel
+c0106e84 swap_set_unswappable
+c0102cef vector82
+c01032f5 vector222
+c0102a63 vector8
+c0102f89 vector149
+c01002b5 cputchar
+c010b058 memset
+c010336d vector232
+c010124a ide_read_secs
+c0102dc7 vector106
+c01032dd vector220
+c0102d37 vector90
+c0103031 vector163
+c010b8d3 srand
+c0103385 vector234
+c0106e63 swap_map_swappable
+c0102c3b vector62
+c0102aee vector25
+c01031d5 vector198
+c0102e45 vector120
+c013476c _binary_obj___user_badarg_out_end
+c010031a getchar
+c01043a5 page_remove
+c010b7ef hash32
+c0102bcf vector50
+c0102a96 vector15
+c01b1018 swap_out_num
+c010b36a printfmt
+c0196bd4 _binary_obj___user_faultreadkernel_out_end
+c0109d88 do_yield
+c0102fa1 vector151
+c0102cf8 vector83
+c0102d2e vector89
+c0102d25 vector88
+c0102986 trap
+c01030f1 vector179
+c0102b3f vector34
+c0129b33 __STABSTR_END__
+c0102bab vector46
+c010adf9 strcmp
+c0102ed5 vector134
+c0103301 vector223
+c01032c5 vector218
+c0100620 debuginfo_eip
+c01b313c max_swap_offset
+000078d0 _binary_obj___user_faultreadkernel_out_size
+c010576a insert_vma_struct
+c0102069 pic_init
+c0103319 vector225
+c0103151 vector187
+c0103d68 pmm_init
+c0102b1b vector30
+c0102e84 vector127
+c01b3078 ticks
+c010318d vector192
+c0103055 vector166
+c0102cb9 vector76
+c0102cb0 vector75
+c01031b1 vector195
+c0102f95 vector150
+c0102c17 vector58
+c010342d vector248
+c013c068 _binary_obj___user_forktree_out_end
+c0102e60 vector123
+c0102d6d vector96
+000078dc _binary_obj___user_exit_out_size
+c0102b24 vector31
+c0103211 vector203
+c01037c1 alloc_pages
+c0161d48 _binary_obj___user_waitkill_out_start
+c0102f11 vector139
+c0102fb9 vector153
+c010303d vector164
+c015a484 _binary_obj___user_priority_out_end
+c0102e4e vector121
+c0102a48 vector5
+c0170f98 _binary_obj___user_spin_out_start
+c0103061 vector167
+c0102fd1 vector155
+c0103439 vector249
+c010c2e8 vpt
+c0103445 vector250
+c0102e69 vector124
+c0102deb vector110
+c010321d vector204
+c0143930 _binary_obj___user_faultread_out_end
+c01b3140 swap_page
+c019e4b4 _binary_obj___user_pgdir_out_start
+c01034a4 __trapret
+c01a5d78 _binary_obj___user_matrix_out_start
+c0100266 vcprintf
+c0102ef9 vector137
+000078c8 _binary_obj___user_faultread_out_size
+c0100478 __warn
+c0103421 vector247
+c0102ad3 vector22
+c0103205 vector202
+c0102c95 vector72
+c0102bfc vector55
+c01002cc cputs
+c012c000 bootstacktop
+c0108fe2 find_proc
+c0102e7b vector126
+c0102c56 vector65
+c0102b09 vector28
+c0103079 vector169
+c0106e48 swap_tick_event
+c0103379 vector233
+0000796c _binary_obj___user_matrix_out_size
+c0106ea2 swap_out
+c0106bb1 kmalloc
+c014b248 _binary_obj___user_divzero_out_end
+c0105602 vma_create
+c0102f71 vector147
+c0108e99 proc_run
+c012a000 bootstack
+c01ae000 __boot_pgdir
+c0102db5 vector104
+c01b3164 free_area
+c0102e21 vector116
+c0143930 _binary_obj___user_divzero_out_start
+00007960 _binary_obj___user_priority_out_size
+c01087eb swapfs_write
+c010e180 __STAB_BEGIN__
+c01064a8 user_mem_check
+c010a43c sched_init
+c01b3154 check_ptep
+c0102be1 vector52
+c0102aa8 vector17
+c010312d vector184
+c010ad27 strlen
+c012ca74 default_sched_class
+c0108c42 get_proc_name
+c0152b24 _binary_obj___user_priority_out_start
+c01b100c pgfault_num
+c0103241 vector207
+c0180120 _binary_obj___user_yield_out_end
+c0103175 vector190
+c0100ec6 ide_init
+c01033c1 vector239
+c0102d5b vector94
+c0102d52 vector93
+c010315d vector188
+c010ae99 strchr
+c0102bbd vector48
+c01b3090 check_mm_struct
+c0106e2d swap_init_mm
+c01000d7 grade_backtrace1
+c01032d1 vector219
+c0102f7d vector148
+c01032e9 vector221
+c0102cdd vector80
+c0103091 vector171
+c0102fc5 vector154
+c0102b51 vector36
+c0103391 vector235
+c0102dbe vector105
+c0100e48 mon_kerninfo
+c01b3084 pages
+c0102f65 vector146
+c0104005 unmap_range
+c0103181 vector191
+c010a175 proc_init
+c0102dac vector103
+c0100dee mon_help
+c0102a7a vector11
+000078e0 _binary_obj___user_forktest_out_size
+c0104497 tlb_invalidate
+c0102a8f vector14
diff -r -u -P lab6_origin/obj/libs/hash.d lab6/obj/libs/hash.d
--- lab6_origin/obj/libs/hash.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/libs/hash.d	2019-05-13 17:39:38.546949200 +0800
@@ -0,0 +1 @@
+obj/libs/hash.o obj/libs/hash.d: libs/hash.c libs/stdlib.h libs/defs.h
Binary files lab6_origin/obj/libs/hash.o and lab6/obj/libs/hash.o differ
diff -r -u -P lab6_origin/obj/libs/printfmt.d lab6/obj/libs/printfmt.d
--- lab6_origin/obj/libs/printfmt.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/libs/printfmt.d	2019-05-13 17:39:38.484985100 +0800
@@ -0,0 +1,2 @@
+obj/libs/printfmt.o obj/libs/printfmt.d: libs/printfmt.c libs/defs.h \
+ libs/x86.h libs/error.h libs/stdio.h libs/stdarg.h libs/string.h
Binary files lab6_origin/obj/libs/printfmt.o and lab6/obj/libs/printfmt.o differ
diff -r -u -P lab6_origin/obj/libs/rand.d lab6/obj/libs/rand.d
--- lab6_origin/obj/libs/rand.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/libs/rand.d	2019-05-13 17:39:38.509970400 +0800
@@ -0,0 +1,2 @@
+obj/libs/rand.o obj/libs/rand.d: libs/rand.c libs/x86.h libs/defs.h \
+ libs/stdlib.h
Binary files lab6_origin/obj/libs/rand.o and lab6/obj/libs/rand.o differ
diff -r -u -P lab6_origin/obj/libs/string.d lab6/obj/libs/string.d
--- lab6_origin/obj/libs/string.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/libs/string.d	2019-05-13 17:39:38.510970000 +0800
@@ -0,0 +1,2 @@
+obj/libs/string.o obj/libs/string.d: libs/string.c libs/string.h \
+ libs/defs.h libs/x86.h
Binary files lab6_origin/obj/libs/string.o and lab6/obj/libs/string.o differ
diff -r -u -P lab6_origin/obj/sign/tools/sign.d lab6/obj/sign/tools/sign.d
--- lab6_origin/obj/sign/tools/sign.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/sign/tools/sign.d	2019-05-13 17:39:39.517399100 +0800
@@ -0,0 +1 @@
+obj/sign/tools/sign.o obj/sign/tools/sign.d: tools/sign.c
Binary files lab6_origin/obj/sign/tools/sign.o and lab6/obj/sign/tools/sign.o differ
diff -r -u -P lab6_origin/obj/user/badarg.asm lab6/obj/user/badarg.asm
--- lab6_origin/obj/user/badarg.asm	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/badarg.asm	2019-05-13 17:39:43.381174200 +0800
@@ -0,0 +1,2666 @@
+
+obj/__user_badarg.out:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00800020 <__panic>:
+#include <stdio.h>
+#include <ulib.h>
+#include <error.h>
+
+void
+__panic(const char *file, int line, const char *fmt, ...) {
+  800020:	55                   	push   %ebp
+  800021:	89 e5                	mov    %esp,%ebp
+  800023:	83 ec 18             	sub    $0x18,%esp
+    // print the 'message'
+    va_list ap;
+    va_start(ap, fmt);
+  800026:	8d 45 14             	lea    0x14(%ebp),%eax
+  800029:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("user panic at %s:%d:\n    ", file, line);
+  80002c:	83 ec 04             	sub    $0x4,%esp
+  80002f:	ff 75 0c             	pushl  0xc(%ebp)
+  800032:	ff 75 08             	pushl  0x8(%ebp)
+  800035:	68 60 10 80 00       	push   $0x801060
+  80003a:	e8 9a 02 00 00       	call   8002d9 <cprintf>
+  80003f:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+  800042:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800045:	83 ec 08             	sub    $0x8,%esp
+  800048:	50                   	push   %eax
+  800049:	ff 75 10             	pushl  0x10(%ebp)
+  80004c:	e8 5f 02 00 00       	call   8002b0 <vcprintf>
+  800051:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+  800054:	83 ec 0c             	sub    $0xc,%esp
+  800057:	68 7a 10 80 00       	push   $0x80107a
+  80005c:	e8 78 02 00 00       	call   8002d9 <cprintf>
+  800061:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+    exit(-E_PANIC);
+  800064:	83 ec 0c             	sub    $0xc,%esp
+  800067:	6a f6                	push   $0xfffffff6
+  800069:	e8 49 01 00 00       	call   8001b7 <exit>
+
+0080006e <__warn>:
+}
+
+void
+__warn(const char *file, int line, const char *fmt, ...) {
+  80006e:	55                   	push   %ebp
+  80006f:	89 e5                	mov    %esp,%ebp
+  800071:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    va_start(ap, fmt);
+  800074:	8d 45 14             	lea    0x14(%ebp),%eax
+  800077:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("user warning at %s:%d:\n    ", file, line);
+  80007a:	83 ec 04             	sub    $0x4,%esp
+  80007d:	ff 75 0c             	pushl  0xc(%ebp)
+  800080:	ff 75 08             	pushl  0x8(%ebp)
+  800083:	68 7c 10 80 00       	push   $0x80107c
+  800088:	e8 4c 02 00 00       	call   8002d9 <cprintf>
+  80008d:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+  800090:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800093:	83 ec 08             	sub    $0x8,%esp
+  800096:	50                   	push   %eax
+  800097:	ff 75 10             	pushl  0x10(%ebp)
+  80009a:	e8 11 02 00 00       	call   8002b0 <vcprintf>
+  80009f:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+  8000a2:	83 ec 0c             	sub    $0xc,%esp
+  8000a5:	68 7a 10 80 00       	push   $0x80107a
+  8000aa:	e8 2a 02 00 00       	call   8002d9 <cprintf>
+  8000af:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+  8000b2:	90                   	nop
+  8000b3:	c9                   	leave  
+  8000b4:	c3                   	ret    
+
+008000b5 <syscall>:
+#include <syscall.h>
+
+#define MAX_ARGS            5
+
+static inline int
+syscall(int num, ...) {
+  8000b5:	55                   	push   %ebp
+  8000b6:	89 e5                	mov    %esp,%ebp
+  8000b8:	57                   	push   %edi
+  8000b9:	56                   	push   %esi
+  8000ba:	53                   	push   %ebx
+  8000bb:	83 ec 20             	sub    $0x20,%esp
+    va_list ap;
+    va_start(ap, num);
+  8000be:	8d 45 0c             	lea    0xc(%ebp),%eax
+  8000c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    uint32_t a[MAX_ARGS];
+    int i, ret;
+    for (i = 0; i < MAX_ARGS; i ++) {
+  8000c4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  8000cb:	eb 16                	jmp    8000e3 <syscall+0x2e>
+        a[i] = va_arg(ap, uint32_t);
+  8000cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8000d0:	8d 50 04             	lea    0x4(%eax),%edx
+  8000d3:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  8000d6:	8b 10                	mov    (%eax),%edx
+  8000d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8000db:	89 54 85 d4          	mov    %edx,-0x2c(%ebp,%eax,4)
+syscall(int num, ...) {
+    va_list ap;
+    va_start(ap, num);
+    uint32_t a[MAX_ARGS];
+    int i, ret;
+    for (i = 0; i < MAX_ARGS; i ++) {
+  8000df:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+  8000e3:	83 7d f0 04          	cmpl   $0x4,-0x10(%ebp)
+  8000e7:	7e e4                	jle    8000cd <syscall+0x18>
+    asm volatile (
+        "int %1;"
+        : "=a" (ret)
+        : "i" (T_SYSCALL),
+          "a" (num),
+          "d" (a[0]),
+  8000e9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+          "c" (a[1]),
+  8000ec:	8b 4d d8             	mov    -0x28(%ebp),%ecx
+          "b" (a[2]),
+  8000ef:	8b 5d dc             	mov    -0x24(%ebp),%ebx
+          "D" (a[3]),
+  8000f2:	8b 7d e0             	mov    -0x20(%ebp),%edi
+          "S" (a[4])
+  8000f5:	8b 75 e4             	mov    -0x1c(%ebp),%esi
+    for (i = 0; i < MAX_ARGS; i ++) {
+        a[i] = va_arg(ap, uint32_t);
+    }
+    va_end(ap);
+
+    asm volatile (
+  8000f8:	8b 45 08             	mov    0x8(%ebp),%eax
+  8000fb:	cd 80                	int    $0x80
+  8000fd:	89 45 ec             	mov    %eax,-0x14(%ebp)
+          "c" (a[1]),
+          "b" (a[2]),
+          "D" (a[3]),
+          "S" (a[4])
+        : "cc", "memory");
+    return ret;
+  800100:	8b 45 ec             	mov    -0x14(%ebp),%eax
+}
+  800103:	83 c4 20             	add    $0x20,%esp
+  800106:	5b                   	pop    %ebx
+  800107:	5e                   	pop    %esi
+  800108:	5f                   	pop    %edi
+  800109:	5d                   	pop    %ebp
+  80010a:	c3                   	ret    
+
+0080010b <sys_exit>:
+
+int
+sys_exit(int error_code) {
+  80010b:	55                   	push   %ebp
+  80010c:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_exit, error_code);
+  80010e:	ff 75 08             	pushl  0x8(%ebp)
+  800111:	6a 01                	push   $0x1
+  800113:	e8 9d ff ff ff       	call   8000b5 <syscall>
+  800118:	83 c4 08             	add    $0x8,%esp
+}
+  80011b:	c9                   	leave  
+  80011c:	c3                   	ret    
+
+0080011d <sys_fork>:
+
+int
+sys_fork(void) {
+  80011d:	55                   	push   %ebp
+  80011e:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_fork);
+  800120:	6a 02                	push   $0x2
+  800122:	e8 8e ff ff ff       	call   8000b5 <syscall>
+  800127:	83 c4 04             	add    $0x4,%esp
+}
+  80012a:	c9                   	leave  
+  80012b:	c3                   	ret    
+
+0080012c <sys_wait>:
+
+int
+sys_wait(int pid, int *store) {
+  80012c:	55                   	push   %ebp
+  80012d:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_wait, pid, store);
+  80012f:	ff 75 0c             	pushl  0xc(%ebp)
+  800132:	ff 75 08             	pushl  0x8(%ebp)
+  800135:	6a 03                	push   $0x3
+  800137:	e8 79 ff ff ff       	call   8000b5 <syscall>
+  80013c:	83 c4 0c             	add    $0xc,%esp
+}
+  80013f:	c9                   	leave  
+  800140:	c3                   	ret    
+
+00800141 <sys_yield>:
+
+int
+sys_yield(void) {
+  800141:	55                   	push   %ebp
+  800142:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_yield);
+  800144:	6a 0a                	push   $0xa
+  800146:	e8 6a ff ff ff       	call   8000b5 <syscall>
+  80014b:	83 c4 04             	add    $0x4,%esp
+}
+  80014e:	c9                   	leave  
+  80014f:	c3                   	ret    
+
+00800150 <sys_kill>:
+
+int
+sys_kill(int pid) {
+  800150:	55                   	push   %ebp
+  800151:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_kill, pid);
+  800153:	ff 75 08             	pushl  0x8(%ebp)
+  800156:	6a 0c                	push   $0xc
+  800158:	e8 58 ff ff ff       	call   8000b5 <syscall>
+  80015d:	83 c4 08             	add    $0x8,%esp
+}
+  800160:	c9                   	leave  
+  800161:	c3                   	ret    
+
+00800162 <sys_getpid>:
+
+int
+sys_getpid(void) {
+  800162:	55                   	push   %ebp
+  800163:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_getpid);
+  800165:	6a 12                	push   $0x12
+  800167:	e8 49 ff ff ff       	call   8000b5 <syscall>
+  80016c:	83 c4 04             	add    $0x4,%esp
+}
+  80016f:	c9                   	leave  
+  800170:	c3                   	ret    
+
+00800171 <sys_putc>:
+
+int
+sys_putc(int c) {
+  800171:	55                   	push   %ebp
+  800172:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_putc, c);
+  800174:	ff 75 08             	pushl  0x8(%ebp)
+  800177:	6a 1e                	push   $0x1e
+  800179:	e8 37 ff ff ff       	call   8000b5 <syscall>
+  80017e:	83 c4 08             	add    $0x8,%esp
+}
+  800181:	c9                   	leave  
+  800182:	c3                   	ret    
+
+00800183 <sys_pgdir>:
+
+int
+sys_pgdir(void) {
+  800183:	55                   	push   %ebp
+  800184:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_pgdir);
+  800186:	6a 1f                	push   $0x1f
+  800188:	e8 28 ff ff ff       	call   8000b5 <syscall>
+  80018d:	83 c4 04             	add    $0x4,%esp
+}
+  800190:	c9                   	leave  
+  800191:	c3                   	ret    
+
+00800192 <sys_gettime>:
+
+int
+sys_gettime(void) {
+  800192:	55                   	push   %ebp
+  800193:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_gettime);
+  800195:	6a 11                	push   $0x11
+  800197:	e8 19 ff ff ff       	call   8000b5 <syscall>
+  80019c:	83 c4 04             	add    $0x4,%esp
+}
+  80019f:	c9                   	leave  
+  8001a0:	c3                   	ret    
+
+008001a1 <sys_lab6_set_priority>:
+
+void
+sys_lab6_set_priority(uint32_t priority)
+{
+  8001a1:	55                   	push   %ebp
+  8001a2:	89 e5                	mov    %esp,%ebp
+    syscall(SYS_lab6_set_priority, priority);
+  8001a4:	ff 75 08             	pushl  0x8(%ebp)
+  8001a7:	68 ff 00 00 00       	push   $0xff
+  8001ac:	e8 04 ff ff ff       	call   8000b5 <syscall>
+  8001b1:	83 c4 08             	add    $0x8,%esp
+}
+  8001b4:	90                   	nop
+  8001b5:	c9                   	leave  
+  8001b6:	c3                   	ret    
+
+008001b7 <exit>:
+#include <syscall.h>
+#include <stdio.h>
+#include <ulib.h>
+
+void
+exit(int error_code) {
+  8001b7:	55                   	push   %ebp
+  8001b8:	89 e5                	mov    %esp,%ebp
+  8001ba:	83 ec 08             	sub    $0x8,%esp
+    sys_exit(error_code);
+  8001bd:	83 ec 0c             	sub    $0xc,%esp
+  8001c0:	ff 75 08             	pushl  0x8(%ebp)
+  8001c3:	e8 43 ff ff ff       	call   80010b <sys_exit>
+  8001c8:	83 c4 10             	add    $0x10,%esp
+    cprintf("BUG: exit failed.\n");
+  8001cb:	83 ec 0c             	sub    $0xc,%esp
+  8001ce:	68 98 10 80 00       	push   $0x801098
+  8001d3:	e8 01 01 00 00       	call   8002d9 <cprintf>
+  8001d8:	83 c4 10             	add    $0x10,%esp
+    while (1);
+  8001db:	eb fe                	jmp    8001db <exit+0x24>
+
+008001dd <fork>:
+}
+
+int
+fork(void) {
+  8001dd:	55                   	push   %ebp
+  8001de:	89 e5                	mov    %esp,%ebp
+  8001e0:	83 ec 08             	sub    $0x8,%esp
+    return sys_fork();
+  8001e3:	e8 35 ff ff ff       	call   80011d <sys_fork>
+}
+  8001e8:	c9                   	leave  
+  8001e9:	c3                   	ret    
+
+008001ea <wait>:
+
+int
+wait(void) {
+  8001ea:	55                   	push   %ebp
+  8001eb:	89 e5                	mov    %esp,%ebp
+  8001ed:	83 ec 08             	sub    $0x8,%esp
+    return sys_wait(0, NULL);
+  8001f0:	83 ec 08             	sub    $0x8,%esp
+  8001f3:	6a 00                	push   $0x0
+  8001f5:	6a 00                	push   $0x0
+  8001f7:	e8 30 ff ff ff       	call   80012c <sys_wait>
+  8001fc:	83 c4 10             	add    $0x10,%esp
+}
+  8001ff:	c9                   	leave  
+  800200:	c3                   	ret    
+
+00800201 <waitpid>:
+
+int
+waitpid(int pid, int *store) {
+  800201:	55                   	push   %ebp
+  800202:	89 e5                	mov    %esp,%ebp
+  800204:	83 ec 08             	sub    $0x8,%esp
+    return sys_wait(pid, store);
+  800207:	83 ec 08             	sub    $0x8,%esp
+  80020a:	ff 75 0c             	pushl  0xc(%ebp)
+  80020d:	ff 75 08             	pushl  0x8(%ebp)
+  800210:	e8 17 ff ff ff       	call   80012c <sys_wait>
+  800215:	83 c4 10             	add    $0x10,%esp
+}
+  800218:	c9                   	leave  
+  800219:	c3                   	ret    
+
+0080021a <yield>:
+
+void
+yield(void) {
+  80021a:	55                   	push   %ebp
+  80021b:	89 e5                	mov    %esp,%ebp
+  80021d:	83 ec 08             	sub    $0x8,%esp
+    sys_yield();
+  800220:	e8 1c ff ff ff       	call   800141 <sys_yield>
+}
+  800225:	90                   	nop
+  800226:	c9                   	leave  
+  800227:	c3                   	ret    
+
+00800228 <kill>:
+
+int
+kill(int pid) {
+  800228:	55                   	push   %ebp
+  800229:	89 e5                	mov    %esp,%ebp
+  80022b:	83 ec 08             	sub    $0x8,%esp
+    return sys_kill(pid);
+  80022e:	83 ec 0c             	sub    $0xc,%esp
+  800231:	ff 75 08             	pushl  0x8(%ebp)
+  800234:	e8 17 ff ff ff       	call   800150 <sys_kill>
+  800239:	83 c4 10             	add    $0x10,%esp
+}
+  80023c:	c9                   	leave  
+  80023d:	c3                   	ret    
+
+0080023e <getpid>:
+
+int
+getpid(void) {
+  80023e:	55                   	push   %ebp
+  80023f:	89 e5                	mov    %esp,%ebp
+  800241:	83 ec 08             	sub    $0x8,%esp
+    return sys_getpid();
+  800244:	e8 19 ff ff ff       	call   800162 <sys_getpid>
+}
+  800249:	c9                   	leave  
+  80024a:	c3                   	ret    
+
+0080024b <print_pgdir>:
+
+//print_pgdir - print the PDT&PT
+void
+print_pgdir(void) {
+  80024b:	55                   	push   %ebp
+  80024c:	89 e5                	mov    %esp,%ebp
+  80024e:	83 ec 08             	sub    $0x8,%esp
+    sys_pgdir();
+  800251:	e8 2d ff ff ff       	call   800183 <sys_pgdir>
+}
+  800256:	90                   	nop
+  800257:	c9                   	leave  
+  800258:	c3                   	ret    
+
+00800259 <gettime_msec>:
+
+unsigned int
+gettime_msec(void) {
+  800259:	55                   	push   %ebp
+  80025a:	89 e5                	mov    %esp,%ebp
+  80025c:	83 ec 08             	sub    $0x8,%esp
+    return (unsigned int)sys_gettime();
+  80025f:	e8 2e ff ff ff       	call   800192 <sys_gettime>
+}
+  800264:	c9                   	leave  
+  800265:	c3                   	ret    
+
+00800266 <lab6_set_priority>:
+
+void
+lab6_set_priority(uint32_t priority)
+{
+  800266:	55                   	push   %ebp
+  800267:	89 e5                	mov    %esp,%ebp
+  800269:	83 ec 08             	sub    $0x8,%esp
+    sys_lab6_set_priority(priority);
+  80026c:	83 ec 0c             	sub    $0xc,%esp
+  80026f:	ff 75 08             	pushl  0x8(%ebp)
+  800272:	e8 2a ff ff ff       	call   8001a1 <sys_lab6_set_priority>
+  800277:	83 c4 10             	add    $0x10,%esp
+}
+  80027a:	90                   	nop
+  80027b:	c9                   	leave  
+  80027c:	c3                   	ret    
+
+0080027d <_start>:
+.text
+.globl _start
+_start:
+    # set ebp for backtrace
+    movl $0x0, %ebp
+  80027d:	bd 00 00 00 00       	mov    $0x0,%ebp
+
+    # move down the esp register
+    # since it may cause page fault in backtrace
+    subl $0x20, %esp
+  800282:	83 ec 20             	sub    $0x20,%esp
+
+    # call user-program function
+    call umain
+  800285:	e8 c3 00 00 00       	call   80034d <umain>
+1:  jmp 1b
+  80028a:	eb fe                	jmp    80028a <_start+0xd>
+
+0080028c <cputch>:
+/* *
+ * cputch - writes a single character @c to stdout, and it will
+ * increace the value of counter pointed by @cnt.
+ * */
+static void
+cputch(int c, int *cnt) {
+  80028c:	55                   	push   %ebp
+  80028d:	89 e5                	mov    %esp,%ebp
+  80028f:	83 ec 08             	sub    $0x8,%esp
+    sys_putc(c);
+  800292:	83 ec 0c             	sub    $0xc,%esp
+  800295:	ff 75 08             	pushl  0x8(%ebp)
+  800298:	e8 d4 fe ff ff       	call   800171 <sys_putc>
+  80029d:	83 c4 10             	add    $0x10,%esp
+    (*cnt) ++;
+  8002a0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002a3:	8b 00                	mov    (%eax),%eax
+  8002a5:	8d 50 01             	lea    0x1(%eax),%edx
+  8002a8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002ab:	89 10                	mov    %edx,(%eax)
+}
+  8002ad:	90                   	nop
+  8002ae:	c9                   	leave  
+  8002af:	c3                   	ret    
+
+008002b0 <vcprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want cprintf() instead.
+ * */
+int
+vcprintf(const char *fmt, va_list ap) {
+  8002b0:	55                   	push   %ebp
+  8002b1:	89 e5                	mov    %esp,%ebp
+  8002b3:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+  8002b6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    vprintfmt((void*)cputch, &cnt, fmt, ap);
+  8002bd:	ff 75 0c             	pushl  0xc(%ebp)
+  8002c0:	ff 75 08             	pushl  0x8(%ebp)
+  8002c3:	8d 45 f4             	lea    -0xc(%ebp),%eax
+  8002c6:	50                   	push   %eax
+  8002c7:	68 8c 02 80 00       	push   $0x80028c
+  8002cc:	e8 fc 06 00 00       	call   8009cd <vprintfmt>
+  8002d1:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+  8002d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8002d7:	c9                   	leave  
+  8002d8:	c3                   	ret    
+
+008002d9 <cprintf>:
+ *
+ * The return value is the number of characters which would be
+ * written to stdout.
+ * */
+int
+cprintf(const char *fmt, ...) {
+  8002d9:	55                   	push   %ebp
+  8002da:	89 e5                	mov    %esp,%ebp
+  8002dc:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  8002df:	8d 45 0c             	lea    0xc(%ebp),%eax
+  8002e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    int cnt = vcprintf(fmt, ap);
+  8002e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8002e8:	83 ec 08             	sub    $0x8,%esp
+  8002eb:	50                   	push   %eax
+  8002ec:	ff 75 08             	pushl  0x8(%ebp)
+  8002ef:	e8 bc ff ff ff       	call   8002b0 <vcprintf>
+  8002f4:	83 c4 10             	add    $0x10,%esp
+  8002f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+
+    return cnt;
+  8002fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8002fd:	c9                   	leave  
+  8002fe:	c3                   	ret    
+
+008002ff <cputs>:
+/* *
+ * cputs- writes the string pointed by @str to stdout and
+ * appends a newline character.
+ * */
+int
+cputs(const char *str) {
+  8002ff:	55                   	push   %ebp
+  800300:	89 e5                	mov    %esp,%ebp
+  800302:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+  800305:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    char c;
+    while ((c = *str ++) != '\0') {
+  80030c:	eb 14                	jmp    800322 <cputs+0x23>
+        cputch(c, &cnt);
+  80030e:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
+  800312:	83 ec 08             	sub    $0x8,%esp
+  800315:	8d 55 f0             	lea    -0x10(%ebp),%edx
+  800318:	52                   	push   %edx
+  800319:	50                   	push   %eax
+  80031a:	e8 6d ff ff ff       	call   80028c <cputch>
+  80031f:	83 c4 10             	add    $0x10,%esp
+ * */
+int
+cputs(const char *str) {
+    int cnt = 0;
+    char c;
+    while ((c = *str ++) != '\0') {
+  800322:	8b 45 08             	mov    0x8(%ebp),%eax
+  800325:	8d 50 01             	lea    0x1(%eax),%edx
+  800328:	89 55 08             	mov    %edx,0x8(%ebp)
+  80032b:	0f b6 00             	movzbl (%eax),%eax
+  80032e:	88 45 f7             	mov    %al,-0x9(%ebp)
+  800331:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
+  800335:	75 d7                	jne    80030e <cputs+0xf>
+        cputch(c, &cnt);
+    }
+    cputch('\n', &cnt);
+  800337:	83 ec 08             	sub    $0x8,%esp
+  80033a:	8d 45 f0             	lea    -0x10(%ebp),%eax
+  80033d:	50                   	push   %eax
+  80033e:	6a 0a                	push   $0xa
+  800340:	e8 47 ff ff ff       	call   80028c <cputch>
+  800345:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+  800348:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+  80034b:	c9                   	leave  
+  80034c:	c3                   	ret    
+
+0080034d <umain>:
+#include <ulib.h>
+
+int main(void);
+
+void
+umain(void) {
+  80034d:	55                   	push   %ebp
+  80034e:	89 e5                	mov    %esp,%ebp
+  800350:	83 ec 18             	sub    $0x18,%esp
+    int ret = main();
+  800353:	e8 d3 0b 00 00       	call   800f2b <main>
+  800358:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    exit(ret);
+  80035b:	83 ec 0c             	sub    $0xc,%esp
+  80035e:	ff 75 f4             	pushl  -0xc(%ebp)
+  800361:	e8 51 fe ff ff       	call   8001b7 <exit>
+
+00800366 <strlen>:
+ * @s:      the input string
+ *
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+  800366:	55                   	push   %ebp
+  800367:	89 e5                	mov    %esp,%ebp
+  800369:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  80036c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (*s ++ != '\0') {
+  800373:	eb 04                	jmp    800379 <strlen+0x13>
+        cnt ++;
+  800375:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+    size_t cnt = 0;
+    while (*s ++ != '\0') {
+  800379:	8b 45 08             	mov    0x8(%ebp),%eax
+  80037c:	8d 50 01             	lea    0x1(%eax),%edx
+  80037f:	89 55 08             	mov    %edx,0x8(%ebp)
+  800382:	0f b6 00             	movzbl (%eax),%eax
+  800385:	84 c0                	test   %al,%al
+  800387:	75 ec                	jne    800375 <strlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  800389:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  80038c:	c9                   	leave  
+  80038d:	c3                   	ret    
+
+0080038e <strnlen>:
+ * The return value is strlen(s), if that is less than @len, or
+ * @len if there is no '\0' character among the first @len characters
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+  80038e:	55                   	push   %ebp
+  80038f:	89 e5                	mov    %esp,%ebp
+  800391:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  800394:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (cnt < len && *s ++ != '\0') {
+  80039b:	eb 04                	jmp    8003a1 <strnlen+0x13>
+        cnt ++;
+  80039d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+    size_t cnt = 0;
+    while (cnt < len && *s ++ != '\0') {
+  8003a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8003a4:	3b 45 0c             	cmp    0xc(%ebp),%eax
+  8003a7:	73 10                	jae    8003b9 <strnlen+0x2b>
+  8003a9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003ac:	8d 50 01             	lea    0x1(%eax),%edx
+  8003af:	89 55 08             	mov    %edx,0x8(%ebp)
+  8003b2:	0f b6 00             	movzbl (%eax),%eax
+  8003b5:	84 c0                	test   %al,%al
+  8003b7:	75 e4                	jne    80039d <strnlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  8003b9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  8003bc:	c9                   	leave  
+  8003bd:	c3                   	ret    
+
+008003be <strcpy>:
+ * To avoid overflows, the size of array pointed by @dst should be long enough to
+ * contain the same string as @src (including the terminating null character), and
+ * should not overlap in memory with @src.
+ * */
+char *
+strcpy(char *dst, const char *src) {
+  8003be:	55                   	push   %ebp
+  8003bf:	89 e5                	mov    %esp,%ebp
+  8003c1:	57                   	push   %edi
+  8003c2:	56                   	push   %esi
+  8003c3:	83 ec 20             	sub    $0x20,%esp
+  8003c6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  8003cc:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8003cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCPY
+#define __HAVE_ARCH_STRCPY
+static inline char *
+__strcpy(char *dst, const char *src) {
+    int d0, d1, d2;
+    asm volatile (
+  8003d2:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  8003d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8003d8:	89 d1                	mov    %edx,%ecx
+  8003da:	89 c2                	mov    %eax,%edx
+  8003dc:	89 ce                	mov    %ecx,%esi
+  8003de:	89 d7                	mov    %edx,%edi
+  8003e0:	ac                   	lods   %ds:(%esi),%al
+  8003e1:	aa                   	stos   %al,%es:(%edi)
+  8003e2:	84 c0                	test   %al,%al
+  8003e4:	75 fa                	jne    8003e0 <strcpy+0x22>
+  8003e6:	89 fa                	mov    %edi,%edx
+  8003e8:	89 f1                	mov    %esi,%ecx
+  8003ea:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  8003ed:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  8003f0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+        "stosb;"
+        "testb %%al, %%al;"
+        "jne 1b;"
+        : "=&S" (d0), "=&D" (d1), "=&a" (d2)
+        : "0" (src), "1" (dst) : "memory");
+    return dst;
+  8003f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCPY
+    return __strcpy(dst, src);
+  8003f6:	90                   	nop
+    char *p = dst;
+    while ((*p ++ = *src ++) != '\0')
+        /* nothing */;
+    return dst;
+#endif /* __HAVE_ARCH_STRCPY */
+}
+  8003f7:	83 c4 20             	add    $0x20,%esp
+  8003fa:	5e                   	pop    %esi
+  8003fb:	5f                   	pop    %edi
+  8003fc:	5d                   	pop    %ebp
+  8003fd:	c3                   	ret    
+
+008003fe <strncpy>:
+ * @len:    maximum number of characters to be copied from @src
+ *
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+  8003fe:	55                   	push   %ebp
+  8003ff:	89 e5                	mov    %esp,%ebp
+  800401:	83 ec 10             	sub    $0x10,%esp
+    char *p = dst;
+  800404:	8b 45 08             	mov    0x8(%ebp),%eax
+  800407:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    while (len > 0) {
+  80040a:	eb 21                	jmp    80042d <strncpy+0x2f>
+        if ((*p = *src) != '\0') {
+  80040c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80040f:	0f b6 10             	movzbl (%eax),%edx
+  800412:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800415:	88 10                	mov    %dl,(%eax)
+  800417:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  80041a:	0f b6 00             	movzbl (%eax),%eax
+  80041d:	84 c0                	test   %al,%al
+  80041f:	74 04                	je     800425 <strncpy+0x27>
+            src ++;
+  800421:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+        }
+        p ++, len --;
+  800425:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800429:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+    char *p = dst;
+    while (len > 0) {
+  80042d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800431:	75 d9                	jne    80040c <strncpy+0xe>
+        if ((*p = *src) != '\0') {
+            src ++;
+        }
+        p ++, len --;
+    }
+    return dst;
+  800433:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800436:	c9                   	leave  
+  800437:	c3                   	ret    
+
+00800438 <strcmp>:
+ * - A value greater than zero indicates that the first character that does
+ *   not match has a greater value in @s1 than in @s2;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+strcmp(const char *s1, const char *s2) {
+  800438:	55                   	push   %ebp
+  800439:	89 e5                	mov    %esp,%ebp
+  80043b:	57                   	push   %edi
+  80043c:	56                   	push   %esi
+  80043d:	83 ec 20             	sub    $0x20,%esp
+  800440:	8b 45 08             	mov    0x8(%ebp),%eax
+  800443:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800446:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800449:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCMP
+#define __HAVE_ARCH_STRCMP
+static inline int
+__strcmp(const char *s1, const char *s2) {
+    int d0, d1, ret;
+    asm volatile (
+  80044c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80044f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800452:	89 d1                	mov    %edx,%ecx
+  800454:	89 c2                	mov    %eax,%edx
+  800456:	89 ce                	mov    %ecx,%esi
+  800458:	89 d7                	mov    %edx,%edi
+  80045a:	ac                   	lods   %ds:(%esi),%al
+  80045b:	ae                   	scas   %es:(%edi),%al
+  80045c:	75 08                	jne    800466 <strcmp+0x2e>
+  80045e:	84 c0                	test   %al,%al
+  800460:	75 f8                	jne    80045a <strcmp+0x22>
+  800462:	31 c0                	xor    %eax,%eax
+  800464:	eb 04                	jmp    80046a <strcmp+0x32>
+  800466:	19 c0                	sbb    %eax,%eax
+  800468:	0c 01                	or     $0x1,%al
+  80046a:	89 fa                	mov    %edi,%edx
+  80046c:	89 f1                	mov    %esi,%ecx
+  80046e:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800471:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  800474:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+        "orb $1, %%al;"
+        "3:"
+        : "=a" (ret), "=&S" (d0), "=&D" (d1)
+        : "1" (s1), "2" (s2)
+        : "memory");
+    return ret;
+  800477:	8b 45 ec             	mov    -0x14(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCMP
+    return __strcmp(s1, s2);
+  80047a:	90                   	nop
+    while (*s1 != '\0' && *s1 == *s2) {
+        s1 ++, s2 ++;
+    }
+    return (int)((unsigned char)*s1 - (unsigned char)*s2);
+#endif /* __HAVE_ARCH_STRCMP */
+}
+  80047b:	83 c4 20             	add    $0x20,%esp
+  80047e:	5e                   	pop    %esi
+  80047f:	5f                   	pop    %edi
+  800480:	5d                   	pop    %ebp
+  800481:	c3                   	ret    
+
+00800482 <strncmp>:
+ * they are equal to each other, it continues with the following pairs until
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+  800482:	55                   	push   %ebp
+  800483:	89 e5                	mov    %esp,%ebp
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  800485:	eb 0c                	jmp    800493 <strncmp+0x11>
+        n --, s1 ++, s2 ++;
+  800487:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  80048b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  80048f:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  800493:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800497:	74 1a                	je     8004b3 <strncmp+0x31>
+  800499:	8b 45 08             	mov    0x8(%ebp),%eax
+  80049c:	0f b6 00             	movzbl (%eax),%eax
+  80049f:	84 c0                	test   %al,%al
+  8004a1:	74 10                	je     8004b3 <strncmp+0x31>
+  8004a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004a6:	0f b6 10             	movzbl (%eax),%edx
+  8004a9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004ac:	0f b6 00             	movzbl (%eax),%eax
+  8004af:	38 c2                	cmp    %al,%dl
+  8004b1:	74 d4                	je     800487 <strncmp+0x5>
+        n --, s1 ++, s2 ++;
+    }
+    return (n == 0) ? 0 : (int)((unsigned char)*s1 - (unsigned char)*s2);
+  8004b3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8004b7:	74 18                	je     8004d1 <strncmp+0x4f>
+  8004b9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004bc:	0f b6 00             	movzbl (%eax),%eax
+  8004bf:	0f b6 d0             	movzbl %al,%edx
+  8004c2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004c5:	0f b6 00             	movzbl (%eax),%eax
+  8004c8:	0f b6 c0             	movzbl %al,%eax
+  8004cb:	29 c2                	sub    %eax,%edx
+  8004cd:	89 d0                	mov    %edx,%eax
+  8004cf:	eb 05                	jmp    8004d6 <strncmp+0x54>
+  8004d1:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  8004d6:	5d                   	pop    %ebp
+  8004d7:	c3                   	ret    
+
+008004d8 <strchr>:
+ *
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+  8004d8:	55                   	push   %ebp
+  8004d9:	89 e5                	mov    %esp,%ebp
+  8004db:	83 ec 04             	sub    $0x4,%esp
+  8004de:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004e1:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  8004e4:	eb 14                	jmp    8004fa <strchr+0x22>
+        if (*s == c) {
+  8004e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004e9:	0f b6 00             	movzbl (%eax),%eax
+  8004ec:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  8004ef:	75 05                	jne    8004f6 <strchr+0x1e>
+            return (char *)s;
+  8004f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004f4:	eb 13                	jmp    800509 <strchr+0x31>
+        }
+        s ++;
+  8004f6:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+    while (*s != '\0') {
+  8004fa:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004fd:	0f b6 00             	movzbl (%eax),%eax
+  800500:	84 c0                	test   %al,%al
+  800502:	75 e2                	jne    8004e6 <strchr+0xe>
+        if (*s == c) {
+            return (char *)s;
+        }
+        s ++;
+    }
+    return NULL;
+  800504:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800509:	c9                   	leave  
+  80050a:	c3                   	ret    
+
+0080050b <strfind>:
+ * The strfind() function is like strchr() except that if @c is
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+  80050b:	55                   	push   %ebp
+  80050c:	89 e5                	mov    %esp,%ebp
+  80050e:	83 ec 04             	sub    $0x4,%esp
+  800511:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800514:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  800517:	eb 0f                	jmp    800528 <strfind+0x1d>
+        if (*s == c) {
+  800519:	8b 45 08             	mov    0x8(%ebp),%eax
+  80051c:	0f b6 00             	movzbl (%eax),%eax
+  80051f:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800522:	74 10                	je     800534 <strfind+0x29>
+            break;
+        }
+        s ++;
+  800524:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+    while (*s != '\0') {
+  800528:	8b 45 08             	mov    0x8(%ebp),%eax
+  80052b:	0f b6 00             	movzbl (%eax),%eax
+  80052e:	84 c0                	test   %al,%al
+  800530:	75 e7                	jne    800519 <strfind+0xe>
+  800532:	eb 01                	jmp    800535 <strfind+0x2a>
+        if (*s == c) {
+            break;
+  800534:	90                   	nop
+        }
+        s ++;
+    }
+    return (char *)s;
+  800535:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800538:	c9                   	leave  
+  800539:	c3                   	ret    
+
+0080053a <strtol>:
+ * an optional "0x" or "0X" prefix.
+ *
+ * The strtol() function returns the converted integral number as a long int value.
+ * */
+long
+strtol(const char *s, char **endptr, int base) {
+  80053a:	55                   	push   %ebp
+  80053b:	89 e5                	mov    %esp,%ebp
+  80053d:	83 ec 10             	sub    $0x10,%esp
+    int neg = 0;
+  800540:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    long val = 0;
+  800547:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  80054e:	eb 04                	jmp    800554 <strtol+0x1a>
+        s ++;
+  800550:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+strtol(const char *s, char **endptr, int base) {
+    int neg = 0;
+    long val = 0;
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  800554:	8b 45 08             	mov    0x8(%ebp),%eax
+  800557:	0f b6 00             	movzbl (%eax),%eax
+  80055a:	3c 20                	cmp    $0x20,%al
+  80055c:	74 f2                	je     800550 <strtol+0x16>
+  80055e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800561:	0f b6 00             	movzbl (%eax),%eax
+  800564:	3c 09                	cmp    $0x9,%al
+  800566:	74 e8                	je     800550 <strtol+0x16>
+        s ++;
+    }
+
+    // plus/minus sign
+    if (*s == '+') {
+  800568:	8b 45 08             	mov    0x8(%ebp),%eax
+  80056b:	0f b6 00             	movzbl (%eax),%eax
+  80056e:	3c 2b                	cmp    $0x2b,%al
+  800570:	75 06                	jne    800578 <strtol+0x3e>
+        s ++;
+  800572:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800576:	eb 15                	jmp    80058d <strtol+0x53>
+    }
+    else if (*s == '-') {
+  800578:	8b 45 08             	mov    0x8(%ebp),%eax
+  80057b:	0f b6 00             	movzbl (%eax),%eax
+  80057e:	3c 2d                	cmp    $0x2d,%al
+  800580:	75 0b                	jne    80058d <strtol+0x53>
+        s ++, neg = 1;
+  800582:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800586:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+    }
+
+    // hex or octal base prefix
+    if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x')) {
+  80058d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800591:	74 06                	je     800599 <strtol+0x5f>
+  800593:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+  800597:	75 24                	jne    8005bd <strtol+0x83>
+  800599:	8b 45 08             	mov    0x8(%ebp),%eax
+  80059c:	0f b6 00             	movzbl (%eax),%eax
+  80059f:	3c 30                	cmp    $0x30,%al
+  8005a1:	75 1a                	jne    8005bd <strtol+0x83>
+  8005a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005a6:	83 c0 01             	add    $0x1,%eax
+  8005a9:	0f b6 00             	movzbl (%eax),%eax
+  8005ac:	3c 78                	cmp    $0x78,%al
+  8005ae:	75 0d                	jne    8005bd <strtol+0x83>
+        s += 2, base = 16;
+  8005b0:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+  8005b4:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+  8005bb:	eb 2a                	jmp    8005e7 <strtol+0xad>
+    }
+    else if (base == 0 && s[0] == '0') {
+  8005bd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8005c1:	75 17                	jne    8005da <strtol+0xa0>
+  8005c3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005c6:	0f b6 00             	movzbl (%eax),%eax
+  8005c9:	3c 30                	cmp    $0x30,%al
+  8005cb:	75 0d                	jne    8005da <strtol+0xa0>
+        s ++, base = 8;
+  8005cd:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  8005d1:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+  8005d8:	eb 0d                	jmp    8005e7 <strtol+0xad>
+    }
+    else if (base == 0) {
+  8005da:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8005de:	75 07                	jne    8005e7 <strtol+0xad>
+        base = 10;
+  8005e0:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+    // digits
+    while (1) {
+        int dig;
+
+        if (*s >= '0' && *s <= '9') {
+  8005e7:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005ea:	0f b6 00             	movzbl (%eax),%eax
+  8005ed:	3c 2f                	cmp    $0x2f,%al
+  8005ef:	7e 1b                	jle    80060c <strtol+0xd2>
+  8005f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005f4:	0f b6 00             	movzbl (%eax),%eax
+  8005f7:	3c 39                	cmp    $0x39,%al
+  8005f9:	7f 11                	jg     80060c <strtol+0xd2>
+            dig = *s - '0';
+  8005fb:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005fe:	0f b6 00             	movzbl (%eax),%eax
+  800601:	0f be c0             	movsbl %al,%eax
+  800604:	83 e8 30             	sub    $0x30,%eax
+  800607:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80060a:	eb 48                	jmp    800654 <strtol+0x11a>
+        }
+        else if (*s >= 'a' && *s <= 'z') {
+  80060c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80060f:	0f b6 00             	movzbl (%eax),%eax
+  800612:	3c 60                	cmp    $0x60,%al
+  800614:	7e 1b                	jle    800631 <strtol+0xf7>
+  800616:	8b 45 08             	mov    0x8(%ebp),%eax
+  800619:	0f b6 00             	movzbl (%eax),%eax
+  80061c:	3c 7a                	cmp    $0x7a,%al
+  80061e:	7f 11                	jg     800631 <strtol+0xf7>
+            dig = *s - 'a' + 10;
+  800620:	8b 45 08             	mov    0x8(%ebp),%eax
+  800623:	0f b6 00             	movzbl (%eax),%eax
+  800626:	0f be c0             	movsbl %al,%eax
+  800629:	83 e8 57             	sub    $0x57,%eax
+  80062c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80062f:	eb 23                	jmp    800654 <strtol+0x11a>
+        }
+        else if (*s >= 'A' && *s <= 'Z') {
+  800631:	8b 45 08             	mov    0x8(%ebp),%eax
+  800634:	0f b6 00             	movzbl (%eax),%eax
+  800637:	3c 40                	cmp    $0x40,%al
+  800639:	7e 3c                	jle    800677 <strtol+0x13d>
+  80063b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80063e:	0f b6 00             	movzbl (%eax),%eax
+  800641:	3c 5a                	cmp    $0x5a,%al
+  800643:	7f 32                	jg     800677 <strtol+0x13d>
+            dig = *s - 'A' + 10;
+  800645:	8b 45 08             	mov    0x8(%ebp),%eax
+  800648:	0f b6 00             	movzbl (%eax),%eax
+  80064b:	0f be c0             	movsbl %al,%eax
+  80064e:	83 e8 37             	sub    $0x37,%eax
+  800651:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+  800654:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800657:	3b 45 10             	cmp    0x10(%ebp),%eax
+  80065a:	7d 1a                	jge    800676 <strtol+0x13c>
+            break;
+        }
+        s ++, val = (val * base) + dig;
+  80065c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800660:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800663:	0f af 45 10          	imul   0x10(%ebp),%eax
+  800667:	89 c2                	mov    %eax,%edx
+  800669:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  80066c:	01 d0                	add    %edx,%eax
+  80066e:	89 45 f8             	mov    %eax,-0x8(%ebp)
+        // we don't properly detect overflow!
+    }
+  800671:	e9 71 ff ff ff       	jmp    8005e7 <strtol+0xad>
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+            break;
+  800676:	90                   	nop
+        }
+        s ++, val = (val * base) + dig;
+        // we don't properly detect overflow!
+    }
+
+    if (endptr) {
+  800677:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  80067b:	74 08                	je     800685 <strtol+0x14b>
+        *endptr = (char *) s;
+  80067d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800680:	8b 55 08             	mov    0x8(%ebp),%edx
+  800683:	89 10                	mov    %edx,(%eax)
+    }
+    return (neg ? -val : val);
+  800685:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+  800689:	74 07                	je     800692 <strtol+0x158>
+  80068b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  80068e:	f7 d8                	neg    %eax
+  800690:	eb 03                	jmp    800695 <strtol+0x15b>
+  800692:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  800695:	c9                   	leave  
+  800696:	c3                   	ret    
+
+00800697 <memset>:
+ * @n:      number of bytes to be set to the value
+ *
+ * The memset() function returns @s.
+ * */
+void *
+memset(void *s, char c, size_t n) {
+  800697:	55                   	push   %ebp
+  800698:	89 e5                	mov    %esp,%ebp
+  80069a:	57                   	push   %edi
+  80069b:	83 ec 24             	sub    $0x24,%esp
+  80069e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006a1:	88 45 d8             	mov    %al,-0x28(%ebp)
+#ifdef __HAVE_ARCH_MEMSET
+    return __memset(s, c, n);
+  8006a4:	0f be 45 d8          	movsbl -0x28(%ebp),%eax
+  8006a8:	8b 55 08             	mov    0x8(%ebp),%edx
+  8006ab:	89 55 f8             	mov    %edx,-0x8(%ebp)
+  8006ae:	88 45 f7             	mov    %al,-0x9(%ebp)
+  8006b1:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_MEMSET
+#define __HAVE_ARCH_MEMSET
+static inline void *
+__memset(void *s, char c, size_t n) {
+    int d0, d1;
+    asm volatile (
+  8006b7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+  8006ba:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
+  8006be:	8b 55 f8             	mov    -0x8(%ebp),%edx
+  8006c1:	89 d7                	mov    %edx,%edi
+  8006c3:	f3 aa                	rep stos %al,%es:(%edi)
+  8006c5:	89 fa                	mov    %edi,%edx
+  8006c7:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  8006ca:	89 55 e8             	mov    %edx,-0x18(%ebp)
+        "rep; stosb;"
+        : "=&c" (d0), "=&D" (d1)
+        : "0" (n), "a" (c), "1" (s)
+        : "memory");
+    return s;
+  8006cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8006d0:	90                   	nop
+    while (n -- > 0) {
+        *p ++ = c;
+    }
+    return s;
+#endif /* __HAVE_ARCH_MEMSET */
+}
+  8006d1:	83 c4 24             	add    $0x24,%esp
+  8006d4:	5f                   	pop    %edi
+  8006d5:	5d                   	pop    %ebp
+  8006d6:	c3                   	ret    
+
+008006d7 <memmove>:
+ * @n:      number of bytes to copy
+ *
+ * The memmove() function returns @dst.
+ * */
+void *
+memmove(void *dst, const void *src, size_t n) {
+  8006d7:	55                   	push   %ebp
+  8006d8:	89 e5                	mov    %esp,%ebp
+  8006da:	57                   	push   %edi
+  8006db:	56                   	push   %esi
+  8006dc:	53                   	push   %ebx
+  8006dd:	83 ec 30             	sub    $0x30,%esp
+  8006e0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8006e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8006e6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  8006ec:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006ef:	89 45 e8             	mov    %eax,-0x18(%ebp)
+
+#ifndef __HAVE_ARCH_MEMMOVE
+#define __HAVE_ARCH_MEMMOVE
+static inline void *
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+  8006f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006f5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  8006f8:	73 42                	jae    80073c <memmove+0x65>
+  8006fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006fd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800700:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800703:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800706:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800709:	89 45 dc             	mov    %eax,-0x24(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  80070c:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  80070f:	c1 e8 02             	shr    $0x2,%eax
+  800712:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  800714:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800717:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80071a:	89 d7                	mov    %edx,%edi
+  80071c:	89 c6                	mov    %eax,%esi
+  80071e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800720:	8b 4d dc             	mov    -0x24(%ebp),%ecx
+  800723:	83 e1 03             	and    $0x3,%ecx
+  800726:	74 02                	je     80072a <memmove+0x53>
+  800728:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  80072a:	89 f0                	mov    %esi,%eax
+  80072c:	89 fa                	mov    %edi,%edx
+  80072e:	89 4d d8             	mov    %ecx,-0x28(%ebp)
+  800731:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  800734:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  800737:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMMOVE
+    return __memmove(dst, src, n);
+  80073a:	eb 36                	jmp    800772 <memmove+0x9b>
+    asm volatile (
+        "std;"
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+  80073c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80073f:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800742:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800745:	01 c2                	add    %eax,%edx
+  800747:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80074a:	8d 48 ff             	lea    -0x1(%eax),%ecx
+  80074d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800750:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+        return __memcpy(dst, src, n);
+    }
+    int d0, d1, d2;
+    asm volatile (
+  800753:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800756:	89 c1                	mov    %eax,%ecx
+  800758:	89 d8                	mov    %ebx,%eax
+  80075a:	89 d6                	mov    %edx,%esi
+  80075c:	89 c7                	mov    %eax,%edi
+  80075e:	fd                   	std    
+  80075f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  800761:	fc                   	cld    
+  800762:	89 f8                	mov    %edi,%eax
+  800764:	89 f2                	mov    %esi,%edx
+  800766:	89 4d cc             	mov    %ecx,-0x34(%ebp)
+  800769:	89 55 c8             	mov    %edx,-0x38(%ebp)
+  80076c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+        : "memory");
+    return dst;
+  80076f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+            *d ++ = *s ++;
+        }
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMMOVE */
+}
+  800772:	83 c4 30             	add    $0x30,%esp
+  800775:	5b                   	pop    %ebx
+  800776:	5e                   	pop    %esi
+  800777:	5f                   	pop    %edi
+  800778:	5d                   	pop    %ebp
+  800779:	c3                   	ret    
+
+0080077a <memcpy>:
+ * it always copies exactly @n bytes. To avoid overflows, the size of arrays pointed
+ * by both @src and @dst, should be at least @n bytes, and should not overlap
+ * (for overlapping memory area, memmove is a safer approach).
+ * */
+void *
+memcpy(void *dst, const void *src, size_t n) {
+  80077a:	55                   	push   %ebp
+  80077b:	89 e5                	mov    %esp,%ebp
+  80077d:	57                   	push   %edi
+  80077e:	56                   	push   %esi
+  80077f:	83 ec 20             	sub    $0x20,%esp
+  800782:	8b 45 08             	mov    0x8(%ebp),%eax
+  800785:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800788:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80078b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80078e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800791:	89 45 ec             	mov    %eax,-0x14(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  800794:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800797:	c1 e8 02             	shr    $0x2,%eax
+  80079a:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  80079c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80079f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8007a2:	89 d7                	mov    %edx,%edi
+  8007a4:	89 c6                	mov    %eax,%esi
+  8007a6:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  8007a8:	8b 4d ec             	mov    -0x14(%ebp),%ecx
+  8007ab:	83 e1 03             	and    $0x3,%ecx
+  8007ae:	74 02                	je     8007b2 <memcpy+0x38>
+  8007b0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  8007b2:	89 f0                	mov    %esi,%eax
+  8007b4:	89 fa                	mov    %edi,%edx
+  8007b6:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  8007b9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  8007bc:	89 45 e0             	mov    %eax,-0x20(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  8007bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMCPY
+    return __memcpy(dst, src, n);
+  8007c2:	90                   	nop
+    while (n -- > 0) {
+        *d ++ = *s ++;
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMCPY */
+}
+  8007c3:	83 c4 20             	add    $0x20,%esp
+  8007c6:	5e                   	pop    %esi
+  8007c7:	5f                   	pop    %edi
+  8007c8:	5d                   	pop    %ebp
+  8007c9:	c3                   	ret    
+
+008007ca <memcmp>:
+ *   match in both memory blocks has a greater value in @v1 than in @v2
+ *   as if evaluated as unsigned char values;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+  8007ca:	55                   	push   %ebp
+  8007cb:	89 e5                	mov    %esp,%ebp
+  8007cd:	83 ec 10             	sub    $0x10,%esp
+    const char *s1 = (const char *)v1;
+  8007d0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8007d3:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    const char *s2 = (const char *)v2;
+  8007d6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8007d9:	89 45 f8             	mov    %eax,-0x8(%ebp)
+    while (n -- > 0) {
+  8007dc:	eb 30                	jmp    80080e <memcmp+0x44>
+        if (*s1 != *s2) {
+  8007de:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8007e1:	0f b6 10             	movzbl (%eax),%edx
+  8007e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8007e7:	0f b6 00             	movzbl (%eax),%eax
+  8007ea:	38 c2                	cmp    %al,%dl
+  8007ec:	74 18                	je     800806 <memcmp+0x3c>
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+  8007ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8007f1:	0f b6 00             	movzbl (%eax),%eax
+  8007f4:	0f b6 d0             	movzbl %al,%edx
+  8007f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8007fa:	0f b6 00             	movzbl (%eax),%eax
+  8007fd:	0f b6 c0             	movzbl %al,%eax
+  800800:	29 c2                	sub    %eax,%edx
+  800802:	89 d0                	mov    %edx,%eax
+  800804:	eb 1a                	jmp    800820 <memcmp+0x56>
+        }
+        s1 ++, s2 ++;
+  800806:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  80080a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+    const char *s1 = (const char *)v1;
+    const char *s2 = (const char *)v2;
+    while (n -- > 0) {
+  80080e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800811:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800814:	89 55 10             	mov    %edx,0x10(%ebp)
+  800817:	85 c0                	test   %eax,%eax
+  800819:	75 c3                	jne    8007de <memcmp+0x14>
+        if (*s1 != *s2) {
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+        }
+        s1 ++, s2 ++;
+    }
+    return 0;
+  80081b:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800820:	c9                   	leave  
+  800821:	c3                   	ret    
+
+00800822 <printnum>:
+ * @width:      maximum number of digits, if the actual width is less than @width, use @padc instead
+ * @padc:       character that padded on the left if the actual width is less than @width
+ * */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+        unsigned long long num, unsigned base, int width, int padc) {
+  800822:	55                   	push   %ebp
+  800823:	89 e5                	mov    %esp,%ebp
+  800825:	83 ec 38             	sub    $0x38,%esp
+  800828:	8b 45 10             	mov    0x10(%ebp),%eax
+  80082b:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  80082e:	8b 45 14             	mov    0x14(%ebp),%eax
+  800831:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+    unsigned long long result = num;
+  800834:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  800837:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  80083a:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  80083d:	89 55 ec             	mov    %edx,-0x14(%ebp)
+    unsigned mod = do_div(result, base);
+  800840:	8b 45 18             	mov    0x18(%ebp),%eax
+  800843:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800846:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800849:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  80084c:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  80084f:	89 55 f0             	mov    %edx,-0x10(%ebp)
+  800852:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800855:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800858:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  80085c:	74 1c                	je     80087a <printnum+0x58>
+  80085e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800861:	ba 00 00 00 00       	mov    $0x0,%edx
+  800866:	f7 75 e4             	divl   -0x1c(%ebp)
+  800869:	89 55 f4             	mov    %edx,-0xc(%ebp)
+  80086c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  80086f:	ba 00 00 00 00       	mov    $0x0,%edx
+  800874:	f7 75 e4             	divl   -0x1c(%ebp)
+  800877:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80087a:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80087d:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800880:	f7 75 e4             	divl   -0x1c(%ebp)
+  800883:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800886:	89 55 dc             	mov    %edx,-0x24(%ebp)
+  800889:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80088c:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  80088f:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800892:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  800895:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  800898:	89 45 d8             	mov    %eax,-0x28(%ebp)
+
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+  80089b:	8b 45 18             	mov    0x18(%ebp),%eax
+  80089e:	ba 00 00 00 00       	mov    $0x0,%edx
+  8008a3:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  8008a6:	77 41                	ja     8008e9 <printnum+0xc7>
+  8008a8:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  8008ab:	72 05                	jb     8008b2 <printnum+0x90>
+  8008ad:	3b 45 d0             	cmp    -0x30(%ebp),%eax
+  8008b0:	77 37                	ja     8008e9 <printnum+0xc7>
+        printnum(putch, putdat, result, base, width - 1, padc);
+  8008b2:	8b 45 1c             	mov    0x1c(%ebp),%eax
+  8008b5:	83 e8 01             	sub    $0x1,%eax
+  8008b8:	83 ec 04             	sub    $0x4,%esp
+  8008bb:	ff 75 20             	pushl  0x20(%ebp)
+  8008be:	50                   	push   %eax
+  8008bf:	ff 75 18             	pushl  0x18(%ebp)
+  8008c2:	ff 75 ec             	pushl  -0x14(%ebp)
+  8008c5:	ff 75 e8             	pushl  -0x18(%ebp)
+  8008c8:	ff 75 0c             	pushl  0xc(%ebp)
+  8008cb:	ff 75 08             	pushl  0x8(%ebp)
+  8008ce:	e8 4f ff ff ff       	call   800822 <printnum>
+  8008d3:	83 c4 20             	add    $0x20,%esp
+  8008d6:	eb 1b                	jmp    8008f3 <printnum+0xd1>
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+            putch(padc, putdat);
+  8008d8:	83 ec 08             	sub    $0x8,%esp
+  8008db:	ff 75 0c             	pushl  0xc(%ebp)
+  8008de:	ff 75 20             	pushl  0x20(%ebp)
+  8008e1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8008e4:	ff d0                	call   *%eax
+  8008e6:	83 c4 10             	add    $0x10,%esp
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+        printnum(putch, putdat, result, base, width - 1, padc);
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+  8008e9:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+  8008ed:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+  8008f1:	7f e5                	jg     8008d8 <printnum+0xb6>
+            putch(padc, putdat);
+    }
+    // then print this (the least significant) digit
+    putch("0123456789abcdef"[mod], putdat);
+  8008f3:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  8008f6:	05 c4 11 80 00       	add    $0x8011c4,%eax
+  8008fb:	0f b6 00             	movzbl (%eax),%eax
+  8008fe:	0f be c0             	movsbl %al,%eax
+  800901:	83 ec 08             	sub    $0x8,%esp
+  800904:	ff 75 0c             	pushl  0xc(%ebp)
+  800907:	50                   	push   %eax
+  800908:	8b 45 08             	mov    0x8(%ebp),%eax
+  80090b:	ff d0                	call   *%eax
+  80090d:	83 c4 10             	add    $0x10,%esp
+}
+  800910:	90                   	nop
+  800911:	c9                   	leave  
+  800912:	c3                   	ret    
+
+00800913 <getuint>:
+ * getuint - get an unsigned int of various possible sizes from a varargs list
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static unsigned long long
+getuint(va_list *ap, int lflag) {
+  800913:	55                   	push   %ebp
+  800914:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  800916:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  80091a:	7e 14                	jle    800930 <getuint+0x1d>
+        return va_arg(*ap, unsigned long long);
+  80091c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80091f:	8b 00                	mov    (%eax),%eax
+  800921:	8d 48 08             	lea    0x8(%eax),%ecx
+  800924:	8b 55 08             	mov    0x8(%ebp),%edx
+  800927:	89 0a                	mov    %ecx,(%edx)
+  800929:	8b 50 04             	mov    0x4(%eax),%edx
+  80092c:	8b 00                	mov    (%eax),%eax
+  80092e:	eb 30                	jmp    800960 <getuint+0x4d>
+    }
+    else if (lflag) {
+  800930:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800934:	74 16                	je     80094c <getuint+0x39>
+        return va_arg(*ap, unsigned long);
+  800936:	8b 45 08             	mov    0x8(%ebp),%eax
+  800939:	8b 00                	mov    (%eax),%eax
+  80093b:	8d 48 04             	lea    0x4(%eax),%ecx
+  80093e:	8b 55 08             	mov    0x8(%ebp),%edx
+  800941:	89 0a                	mov    %ecx,(%edx)
+  800943:	8b 00                	mov    (%eax),%eax
+  800945:	ba 00 00 00 00       	mov    $0x0,%edx
+  80094a:	eb 14                	jmp    800960 <getuint+0x4d>
+    }
+    else {
+        return va_arg(*ap, unsigned int);
+  80094c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80094f:	8b 00                	mov    (%eax),%eax
+  800951:	8d 48 04             	lea    0x4(%eax),%ecx
+  800954:	8b 55 08             	mov    0x8(%ebp),%edx
+  800957:	89 0a                	mov    %ecx,(%edx)
+  800959:	8b 00                	mov    (%eax),%eax
+  80095b:	ba 00 00 00 00       	mov    $0x0,%edx
+    }
+}
+  800960:	5d                   	pop    %ebp
+  800961:	c3                   	ret    
+
+00800962 <getint>:
+ * getint - same as getuint but signed, we can't use getuint because of sign extension
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static long long
+getint(va_list *ap, int lflag) {
+  800962:	55                   	push   %ebp
+  800963:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  800965:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  800969:	7e 14                	jle    80097f <getint+0x1d>
+        return va_arg(*ap, long long);
+  80096b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80096e:	8b 00                	mov    (%eax),%eax
+  800970:	8d 48 08             	lea    0x8(%eax),%ecx
+  800973:	8b 55 08             	mov    0x8(%ebp),%edx
+  800976:	89 0a                	mov    %ecx,(%edx)
+  800978:	8b 50 04             	mov    0x4(%eax),%edx
+  80097b:	8b 00                	mov    (%eax),%eax
+  80097d:	eb 28                	jmp    8009a7 <getint+0x45>
+    }
+    else if (lflag) {
+  80097f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800983:	74 12                	je     800997 <getint+0x35>
+        return va_arg(*ap, long);
+  800985:	8b 45 08             	mov    0x8(%ebp),%eax
+  800988:	8b 00                	mov    (%eax),%eax
+  80098a:	8d 48 04             	lea    0x4(%eax),%ecx
+  80098d:	8b 55 08             	mov    0x8(%ebp),%edx
+  800990:	89 0a                	mov    %ecx,(%edx)
+  800992:	8b 00                	mov    (%eax),%eax
+  800994:	99                   	cltd   
+  800995:	eb 10                	jmp    8009a7 <getint+0x45>
+    }
+    else {
+        return va_arg(*ap, int);
+  800997:	8b 45 08             	mov    0x8(%ebp),%eax
+  80099a:	8b 00                	mov    (%eax),%eax
+  80099c:	8d 48 04             	lea    0x4(%eax),%ecx
+  80099f:	8b 55 08             	mov    0x8(%ebp),%edx
+  8009a2:	89 0a                	mov    %ecx,(%edx)
+  8009a4:	8b 00                	mov    (%eax),%eax
+  8009a6:	99                   	cltd   
+    }
+}
+  8009a7:	5d                   	pop    %ebp
+  8009a8:	c3                   	ret    
+
+008009a9 <printfmt>:
+ * @putch:      specified putch function, print a single character
+ * @putdat:     used by @putch function
+ * @fmt:        the format string to use
+ * */
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...) {
+  8009a9:	55                   	push   %ebp
+  8009aa:	89 e5                	mov    %esp,%ebp
+  8009ac:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  8009af:	8d 45 14             	lea    0x14(%ebp),%eax
+  8009b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    vprintfmt(putch, putdat, fmt, ap);
+  8009b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8009b8:	50                   	push   %eax
+  8009b9:	ff 75 10             	pushl  0x10(%ebp)
+  8009bc:	ff 75 0c             	pushl  0xc(%ebp)
+  8009bf:	ff 75 08             	pushl  0x8(%ebp)
+  8009c2:	e8 06 00 00 00       	call   8009cd <vprintfmt>
+  8009c7:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+  8009ca:	90                   	nop
+  8009cb:	c9                   	leave  
+  8009cc:	c3                   	ret    
+
+008009cd <vprintfmt>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want printfmt() instead.
+ * */
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap) {
+  8009cd:	55                   	push   %ebp
+  8009ce:	89 e5                	mov    %esp,%ebp
+  8009d0:	56                   	push   %esi
+  8009d1:	53                   	push   %ebx
+  8009d2:	83 ec 20             	sub    $0x20,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  8009d5:	eb 17                	jmp    8009ee <vprintfmt+0x21>
+            if (ch == '\0') {
+  8009d7:	85 db                	test   %ebx,%ebx
+  8009d9:	0f 84 8e 03 00 00    	je     800d6d <vprintfmt+0x3a0>
+                return;
+            }
+            putch(ch, putdat);
+  8009df:	83 ec 08             	sub    $0x8,%esp
+  8009e2:	ff 75 0c             	pushl  0xc(%ebp)
+  8009e5:	53                   	push   %ebx
+  8009e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009e9:	ff d0                	call   *%eax
+  8009eb:	83 c4 10             	add    $0x10,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  8009ee:	8b 45 10             	mov    0x10(%ebp),%eax
+  8009f1:	8d 50 01             	lea    0x1(%eax),%edx
+  8009f4:	89 55 10             	mov    %edx,0x10(%ebp)
+  8009f7:	0f b6 00             	movzbl (%eax),%eax
+  8009fa:	0f b6 d8             	movzbl %al,%ebx
+  8009fd:	83 fb 25             	cmp    $0x25,%ebx
+  800a00:	75 d5                	jne    8009d7 <vprintfmt+0xa>
+            }
+            putch(ch, putdat);
+        }
+
+        // Process a %-escape sequence
+        char padc = ' ';
+  800a02:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+        width = precision = -1;
+  800a06:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+  800a0d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800a10:	89 45 e8             	mov    %eax,-0x18(%ebp)
+        lflag = altflag = 0;
+  800a13:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+  800a1a:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  800a1d:	89 45 e0             	mov    %eax,-0x20(%ebp)
+
+    reswitch:
+        switch (ch = *(unsigned char *)fmt ++) {
+  800a20:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a23:	8d 50 01             	lea    0x1(%eax),%edx
+  800a26:	89 55 10             	mov    %edx,0x10(%ebp)
+  800a29:	0f b6 00             	movzbl (%eax),%eax
+  800a2c:	0f b6 d8             	movzbl %al,%ebx
+  800a2f:	8d 43 dd             	lea    -0x23(%ebx),%eax
+  800a32:	83 f8 55             	cmp    $0x55,%eax
+  800a35:	0f 87 05 03 00 00    	ja     800d40 <vprintfmt+0x373>
+  800a3b:	8b 04 85 e8 11 80 00 	mov    0x8011e8(,%eax,4),%eax
+  800a42:	ff e0                	jmp    *%eax
+
+        // flag to pad on the right
+        case '-':
+            padc = '-';
+  800a44:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+            goto reswitch;
+  800a48:	eb d6                	jmp    800a20 <vprintfmt+0x53>
+
+        // flag to pad with 0's instead of spaces
+        case '0':
+            padc = '0';
+  800a4a:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+            goto reswitch;
+  800a4e:	eb d0                	jmp    800a20 <vprintfmt+0x53>
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  800a50:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+                precision = precision * 10 + ch - '0';
+  800a57:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800a5a:	89 d0                	mov    %edx,%eax
+  800a5c:	c1 e0 02             	shl    $0x2,%eax
+  800a5f:	01 d0                	add    %edx,%eax
+  800a61:	01 c0                	add    %eax,%eax
+  800a63:	01 d8                	add    %ebx,%eax
+  800a65:	83 e8 30             	sub    $0x30,%eax
+  800a68:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+                ch = *fmt;
+  800a6b:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a6e:	0f b6 00             	movzbl (%eax),%eax
+  800a71:	0f be d8             	movsbl %al,%ebx
+                if (ch < '0' || ch > '9') {
+  800a74:	83 fb 2f             	cmp    $0x2f,%ebx
+  800a77:	7e 39                	jle    800ab2 <vprintfmt+0xe5>
+  800a79:	83 fb 39             	cmp    $0x39,%ebx
+  800a7c:	7f 34                	jg     800ab2 <vprintfmt+0xe5>
+            padc = '0';
+            goto reswitch;
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  800a7e:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+                precision = precision * 10 + ch - '0';
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+  800a82:	eb d3                	jmp    800a57 <vprintfmt+0x8a>
+            goto process_precision;
+
+        case '*':
+            precision = va_arg(ap, int);
+  800a84:	8b 45 14             	mov    0x14(%ebp),%eax
+  800a87:	8d 50 04             	lea    0x4(%eax),%edx
+  800a8a:	89 55 14             	mov    %edx,0x14(%ebp)
+  800a8d:	8b 00                	mov    (%eax),%eax
+  800a8f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+            goto process_precision;
+  800a92:	eb 1f                	jmp    800ab3 <vprintfmt+0xe6>
+
+        case '.':
+            if (width < 0)
+  800a94:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800a98:	79 86                	jns    800a20 <vprintfmt+0x53>
+                width = 0;
+  800a9a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+            goto reswitch;
+  800aa1:	e9 7a ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        case '#':
+            altflag = 1;
+  800aa6:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+            goto reswitch;
+  800aad:	e9 6e ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+            goto process_precision;
+  800ab2:	90                   	nop
+        case '#':
+            altflag = 1;
+            goto reswitch;
+
+        process_precision:
+            if (width < 0)
+  800ab3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ab7:	0f 89 63 ff ff ff    	jns    800a20 <vprintfmt+0x53>
+                width = precision, precision = -1;
+  800abd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800ac0:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800ac3:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+            goto reswitch;
+  800aca:	e9 51 ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        // long flag (doubled for long long)
+        case 'l':
+            lflag ++;
+  800acf:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
+            goto reswitch;
+  800ad3:	e9 48 ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        // character
+        case 'c':
+            putch(va_arg(ap, int), putdat);
+  800ad8:	8b 45 14             	mov    0x14(%ebp),%eax
+  800adb:	8d 50 04             	lea    0x4(%eax),%edx
+  800ade:	89 55 14             	mov    %edx,0x14(%ebp)
+  800ae1:	8b 00                	mov    (%eax),%eax
+  800ae3:	83 ec 08             	sub    $0x8,%esp
+  800ae6:	ff 75 0c             	pushl  0xc(%ebp)
+  800ae9:	50                   	push   %eax
+  800aea:	8b 45 08             	mov    0x8(%ebp),%eax
+  800aed:	ff d0                	call   *%eax
+  800aef:	83 c4 10             	add    $0x10,%esp
+            break;
+  800af2:	e9 71 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // error message
+        case 'e':
+            err = va_arg(ap, int);
+  800af7:	8b 45 14             	mov    0x14(%ebp),%eax
+  800afa:	8d 50 04             	lea    0x4(%eax),%edx
+  800afd:	89 55 14             	mov    %edx,0x14(%ebp)
+  800b00:	8b 18                	mov    (%eax),%ebx
+            if (err < 0) {
+  800b02:	85 db                	test   %ebx,%ebx
+  800b04:	79 02                	jns    800b08 <vprintfmt+0x13b>
+                err = -err;
+  800b06:	f7 db                	neg    %ebx
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+  800b08:	83 fb 18             	cmp    $0x18,%ebx
+  800b0b:	7f 0b                	jg     800b18 <vprintfmt+0x14b>
+  800b0d:	8b 34 9d 60 11 80 00 	mov    0x801160(,%ebx,4),%esi
+  800b14:	85 f6                	test   %esi,%esi
+  800b16:	75 19                	jne    800b31 <vprintfmt+0x164>
+                printfmt(putch, putdat, "error %d", err);
+  800b18:	53                   	push   %ebx
+  800b19:	68 d5 11 80 00       	push   $0x8011d5
+  800b1e:	ff 75 0c             	pushl  0xc(%ebp)
+  800b21:	ff 75 08             	pushl  0x8(%ebp)
+  800b24:	e8 80 fe ff ff       	call   8009a9 <printfmt>
+  800b29:	83 c4 10             	add    $0x10,%esp
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+            }
+            break;
+  800b2c:	e9 37 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+                printfmt(putch, putdat, "error %d", err);
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+  800b31:	56                   	push   %esi
+  800b32:	68 de 11 80 00       	push   $0x8011de
+  800b37:	ff 75 0c             	pushl  0xc(%ebp)
+  800b3a:	ff 75 08             	pushl  0x8(%ebp)
+  800b3d:	e8 67 fe ff ff       	call   8009a9 <printfmt>
+  800b42:	83 c4 10             	add    $0x10,%esp
+            }
+            break;
+  800b45:	e9 1e 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // string
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+  800b4a:	8b 45 14             	mov    0x14(%ebp),%eax
+  800b4d:	8d 50 04             	lea    0x4(%eax),%edx
+  800b50:	89 55 14             	mov    %edx,0x14(%ebp)
+  800b53:	8b 30                	mov    (%eax),%esi
+  800b55:	85 f6                	test   %esi,%esi
+  800b57:	75 05                	jne    800b5e <vprintfmt+0x191>
+                p = "(null)";
+  800b59:	be e1 11 80 00       	mov    $0x8011e1,%esi
+            }
+            if (width > 0 && padc != '-') {
+  800b5e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800b62:	7e 76                	jle    800bda <vprintfmt+0x20d>
+  800b64:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+  800b68:	74 70                	je     800bda <vprintfmt+0x20d>
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  800b6a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800b6d:	83 ec 08             	sub    $0x8,%esp
+  800b70:	50                   	push   %eax
+  800b71:	56                   	push   %esi
+  800b72:	e8 17 f8 ff ff       	call   80038e <strnlen>
+  800b77:	83 c4 10             	add    $0x10,%esp
+  800b7a:	89 c2                	mov    %eax,%edx
+  800b7c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800b7f:	29 d0                	sub    %edx,%eax
+  800b81:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800b84:	eb 17                	jmp    800b9d <vprintfmt+0x1d0>
+                    putch(padc, putdat);
+  800b86:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+  800b8a:	83 ec 08             	sub    $0x8,%esp
+  800b8d:	ff 75 0c             	pushl  0xc(%ebp)
+  800b90:	50                   	push   %eax
+  800b91:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b94:	ff d0                	call   *%eax
+  800b96:	83 c4 10             	add    $0x10,%esp
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+                p = "(null)";
+            }
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  800b99:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800b9d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ba1:	7f e3                	jg     800b86 <vprintfmt+0x1b9>
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  800ba3:	eb 35                	jmp    800bda <vprintfmt+0x20d>
+                if (altflag && (ch < ' ' || ch > '~')) {
+  800ba5:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+  800ba9:	74 1c                	je     800bc7 <vprintfmt+0x1fa>
+  800bab:	83 fb 1f             	cmp    $0x1f,%ebx
+  800bae:	7e 05                	jle    800bb5 <vprintfmt+0x1e8>
+  800bb0:	83 fb 7e             	cmp    $0x7e,%ebx
+  800bb3:	7e 12                	jle    800bc7 <vprintfmt+0x1fa>
+                    putch('?', putdat);
+  800bb5:	83 ec 08             	sub    $0x8,%esp
+  800bb8:	ff 75 0c             	pushl  0xc(%ebp)
+  800bbb:	6a 3f                	push   $0x3f
+  800bbd:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bc0:	ff d0                	call   *%eax
+  800bc2:	83 c4 10             	add    $0x10,%esp
+  800bc5:	eb 0f                	jmp    800bd6 <vprintfmt+0x209>
+                }
+                else {
+                    putch(ch, putdat);
+  800bc7:	83 ec 08             	sub    $0x8,%esp
+  800bca:	ff 75 0c             	pushl  0xc(%ebp)
+  800bcd:	53                   	push   %ebx
+  800bce:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bd1:	ff d0                	call   *%eax
+  800bd3:	83 c4 10             	add    $0x10,%esp
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  800bd6:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800bda:	89 f0                	mov    %esi,%eax
+  800bdc:	8d 70 01             	lea    0x1(%eax),%esi
+  800bdf:	0f b6 00             	movzbl (%eax),%eax
+  800be2:	0f be d8             	movsbl %al,%ebx
+  800be5:	85 db                	test   %ebx,%ebx
+  800be7:	74 26                	je     800c0f <vprintfmt+0x242>
+  800be9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800bed:	78 b6                	js     800ba5 <vprintfmt+0x1d8>
+  800bef:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800bf3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800bf7:	79 ac                	jns    800ba5 <vprintfmt+0x1d8>
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  800bf9:	eb 14                	jmp    800c0f <vprintfmt+0x242>
+                putch(' ', putdat);
+  800bfb:	83 ec 08             	sub    $0x8,%esp
+  800bfe:	ff 75 0c             	pushl  0xc(%ebp)
+  800c01:	6a 20                	push   $0x20
+  800c03:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c06:	ff d0                	call   *%eax
+  800c08:	83 c4 10             	add    $0x10,%esp
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  800c0b:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800c0f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800c13:	7f e6                	jg     800bfb <vprintfmt+0x22e>
+                putch(' ', putdat);
+            }
+            break;
+  800c15:	e9 4e 01 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // (signed) decimal
+        case 'd':
+            num = getint(&ap, lflag);
+  800c1a:	83 ec 08             	sub    $0x8,%esp
+  800c1d:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c20:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c23:	50                   	push   %eax
+  800c24:	e8 39 fd ff ff       	call   800962 <getint>
+  800c29:	83 c4 10             	add    $0x10,%esp
+  800c2c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c2f:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            if ((long long)num < 0) {
+  800c32:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c35:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800c38:	85 d2                	test   %edx,%edx
+  800c3a:	79 23                	jns    800c5f <vprintfmt+0x292>
+                putch('-', putdat);
+  800c3c:	83 ec 08             	sub    $0x8,%esp
+  800c3f:	ff 75 0c             	pushl  0xc(%ebp)
+  800c42:	6a 2d                	push   $0x2d
+  800c44:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c47:	ff d0                	call   *%eax
+  800c49:	83 c4 10             	add    $0x10,%esp
+                num = -(long long)num;
+  800c4c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c4f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800c52:	f7 d8                	neg    %eax
+  800c54:	83 d2 00             	adc    $0x0,%edx
+  800c57:	f7 da                	neg    %edx
+  800c59:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c5c:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            }
+            base = 10;
+  800c5f:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  800c66:	e9 9f 00 00 00       	jmp    800d0a <vprintfmt+0x33d>
+
+        // unsigned decimal
+        case 'u':
+            num = getuint(&ap, lflag);
+  800c6b:	83 ec 08             	sub    $0x8,%esp
+  800c6e:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c71:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c74:	50                   	push   %eax
+  800c75:	e8 99 fc ff ff       	call   800913 <getuint>
+  800c7a:	83 c4 10             	add    $0x10,%esp
+  800c7d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c80:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 10;
+  800c83:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  800c8a:	eb 7e                	jmp    800d0a <vprintfmt+0x33d>
+
+        // (unsigned) octal
+        case 'o':
+            num = getuint(&ap, lflag);
+  800c8c:	83 ec 08             	sub    $0x8,%esp
+  800c8f:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c92:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c95:	50                   	push   %eax
+  800c96:	e8 78 fc ff ff       	call   800913 <getuint>
+  800c9b:	83 c4 10             	add    $0x10,%esp
+  800c9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800ca1:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 8;
+  800ca4:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+            goto number;
+  800cab:	eb 5d                	jmp    800d0a <vprintfmt+0x33d>
+
+        // pointer
+        case 'p':
+            putch('0', putdat);
+  800cad:	83 ec 08             	sub    $0x8,%esp
+  800cb0:	ff 75 0c             	pushl  0xc(%ebp)
+  800cb3:	6a 30                	push   $0x30
+  800cb5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cb8:	ff d0                	call   *%eax
+  800cba:	83 c4 10             	add    $0x10,%esp
+            putch('x', putdat);
+  800cbd:	83 ec 08             	sub    $0x8,%esp
+  800cc0:	ff 75 0c             	pushl  0xc(%ebp)
+  800cc3:	6a 78                	push   $0x78
+  800cc5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cc8:	ff d0                	call   *%eax
+  800cca:	83 c4 10             	add    $0x10,%esp
+            num = (unsigned long long)(uintptr_t)va_arg(ap, void *);
+  800ccd:	8b 45 14             	mov    0x14(%ebp),%eax
+  800cd0:	8d 50 04             	lea    0x4(%eax),%edx
+  800cd3:	89 55 14             	mov    %edx,0x14(%ebp)
+  800cd6:	8b 00                	mov    (%eax),%eax
+  800cd8:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800cdb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+            base = 16;
+  800ce2:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+            goto number;
+  800ce9:	eb 1f                	jmp    800d0a <vprintfmt+0x33d>
+
+        // (unsigned) hexadecimal
+        case 'x':
+            num = getuint(&ap, lflag);
+  800ceb:	83 ec 08             	sub    $0x8,%esp
+  800cee:	ff 75 e0             	pushl  -0x20(%ebp)
+  800cf1:	8d 45 14             	lea    0x14(%ebp),%eax
+  800cf4:	50                   	push   %eax
+  800cf5:	e8 19 fc ff ff       	call   800913 <getuint>
+  800cfa:	83 c4 10             	add    $0x10,%esp
+  800cfd:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800d00:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 16;
+  800d03:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+        number:
+            printnum(putch, putdat, num, base, width, padc);
+  800d0a:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+  800d0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800d11:	83 ec 04             	sub    $0x4,%esp
+  800d14:	52                   	push   %edx
+  800d15:	ff 75 e8             	pushl  -0x18(%ebp)
+  800d18:	50                   	push   %eax
+  800d19:	ff 75 f4             	pushl  -0xc(%ebp)
+  800d1c:	ff 75 f0             	pushl  -0x10(%ebp)
+  800d1f:	ff 75 0c             	pushl  0xc(%ebp)
+  800d22:	ff 75 08             	pushl  0x8(%ebp)
+  800d25:	e8 f8 fa ff ff       	call   800822 <printnum>
+  800d2a:	83 c4 20             	add    $0x20,%esp
+            break;
+  800d2d:	eb 39                	jmp    800d68 <vprintfmt+0x39b>
+
+        // escaped '%' character
+        case '%':
+            putch(ch, putdat);
+  800d2f:	83 ec 08             	sub    $0x8,%esp
+  800d32:	ff 75 0c             	pushl  0xc(%ebp)
+  800d35:	53                   	push   %ebx
+  800d36:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d39:	ff d0                	call   *%eax
+  800d3b:	83 c4 10             	add    $0x10,%esp
+            break;
+  800d3e:	eb 28                	jmp    800d68 <vprintfmt+0x39b>
+
+        // unrecognized escape sequence - just print it literally
+        default:
+            putch('%', putdat);
+  800d40:	83 ec 08             	sub    $0x8,%esp
+  800d43:	ff 75 0c             	pushl  0xc(%ebp)
+  800d46:	6a 25                	push   $0x25
+  800d48:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d4b:	ff d0                	call   *%eax
+  800d4d:	83 c4 10             	add    $0x10,%esp
+            for (fmt --; fmt[-1] != '%'; fmt --)
+  800d50:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800d54:	eb 04                	jmp    800d5a <vprintfmt+0x38d>
+  800d56:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800d5a:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d5d:	83 e8 01             	sub    $0x1,%eax
+  800d60:	0f b6 00             	movzbl (%eax),%eax
+  800d63:	3c 25                	cmp    $0x25,%al
+  800d65:	75 ef                	jne    800d56 <vprintfmt+0x389>
+                /* do nothing */;
+            break;
+  800d67:	90                   	nop
+        }
+    }
+  800d68:	e9 68 fc ff ff       	jmp    8009d5 <vprintfmt+0x8>
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+            if (ch == '\0') {
+                return;
+  800d6d:	90                   	nop
+            for (fmt --; fmt[-1] != '%'; fmt --)
+                /* do nothing */;
+            break;
+        }
+    }
+}
+  800d6e:	8d 65 f8             	lea    -0x8(%ebp),%esp
+  800d71:	5b                   	pop    %ebx
+  800d72:	5e                   	pop    %esi
+  800d73:	5d                   	pop    %ebp
+  800d74:	c3                   	ret    
+
+00800d75 <sprintputch>:
+ * sprintputch - 'print' a single character in a buffer
+ * @ch:         the character will be printed
+ * @b:          the buffer to place the character @ch
+ * */
+static void
+sprintputch(int ch, struct sprintbuf *b) {
+  800d75:	55                   	push   %ebp
+  800d76:	89 e5                	mov    %esp,%ebp
+    b->cnt ++;
+  800d78:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d7b:	8b 40 08             	mov    0x8(%eax),%eax
+  800d7e:	8d 50 01             	lea    0x1(%eax),%edx
+  800d81:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d84:	89 50 08             	mov    %edx,0x8(%eax)
+    if (b->buf < b->ebuf) {
+  800d87:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8a:	8b 10                	mov    (%eax),%edx
+  800d8c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8f:	8b 40 04             	mov    0x4(%eax),%eax
+  800d92:	39 c2                	cmp    %eax,%edx
+  800d94:	73 12                	jae    800da8 <sprintputch+0x33>
+        *b->buf ++ = ch;
+  800d96:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d99:	8b 00                	mov    (%eax),%eax
+  800d9b:	8d 48 01             	lea    0x1(%eax),%ecx
+  800d9e:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800da1:	89 0a                	mov    %ecx,(%edx)
+  800da3:	8b 55 08             	mov    0x8(%ebp),%edx
+  800da6:	88 10                	mov    %dl,(%eax)
+    }
+}
+  800da8:	90                   	nop
+  800da9:	5d                   	pop    %ebp
+  800daa:	c3                   	ret    
+
+00800dab <snprintf>:
+ * @str:        the buffer to place the result into
+ * @size:       the size of buffer, including the trailing null space
+ * @fmt:        the format string to use
+ * */
+int
+snprintf(char *str, size_t size, const char *fmt, ...) {
+  800dab:	55                   	push   %ebp
+  800dac:	89 e5                	mov    %esp,%ebp
+  800dae:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    int cnt;
+    va_start(ap, fmt);
+  800db1:	8d 45 14             	lea    0x14(%ebp),%eax
+  800db4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    cnt = vsnprintf(str, size, fmt, ap);
+  800db7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800dba:	50                   	push   %eax
+  800dbb:	ff 75 10             	pushl  0x10(%ebp)
+  800dbe:	ff 75 0c             	pushl  0xc(%ebp)
+  800dc1:	ff 75 08             	pushl  0x8(%ebp)
+  800dc4:	e8 0b 00 00 00       	call   800dd4 <vsnprintf>
+  800dc9:	83 c4 10             	add    $0x10,%esp
+  800dcc:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+    return cnt;
+  800dcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800dd2:	c9                   	leave  
+  800dd3:	c3                   	ret    
+
+00800dd4 <vsnprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want snprintf() instead.
+ * */
+int
+vsnprintf(char *str, size_t size, const char *fmt, va_list ap) {
+  800dd4:	55                   	push   %ebp
+  800dd5:	89 e5                	mov    %esp,%ebp
+  800dd7:	83 ec 18             	sub    $0x18,%esp
+    struct sprintbuf b = {str, str + size - 1, 0};
+  800dda:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ddd:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800de0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800de3:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800de6:	8b 45 08             	mov    0x8(%ebp),%eax
+  800de9:	01 d0                	add    %edx,%eax
+  800deb:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800dee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    if (str == NULL || b.buf > b.ebuf) {
+  800df5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  800df9:	74 0a                	je     800e05 <vsnprintf+0x31>
+  800dfb:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  800dfe:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800e01:	39 c2                	cmp    %eax,%edx
+  800e03:	76 07                	jbe    800e0c <vsnprintf+0x38>
+        return -E_INVAL;
+  800e05:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+  800e0a:	eb 20                	jmp    800e2c <vsnprintf+0x58>
+    }
+    // print the string to the buffer
+    vprintfmt((void*)sprintputch, &b, fmt, ap);
+  800e0c:	ff 75 14             	pushl  0x14(%ebp)
+  800e0f:	ff 75 10             	pushl  0x10(%ebp)
+  800e12:	8d 45 ec             	lea    -0x14(%ebp),%eax
+  800e15:	50                   	push   %eax
+  800e16:	68 75 0d 80 00       	push   $0x800d75
+  800e1b:	e8 ad fb ff ff       	call   8009cd <vprintfmt>
+  800e20:	83 c4 10             	add    $0x10,%esp
+    // null terminate the buffer
+    *b.buf = '\0';
+  800e23:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e26:	c6 00 00             	movb   $0x0,(%eax)
+    return b.cnt;
+  800e29:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800e2c:	c9                   	leave  
+  800e2d:	c3                   	ret    
+
+00800e2e <hash32>:
+ * @bits:   the number of bits in a return value
+ *
+ * High bits are more random, so we use them.
+ * */
+uint32_t
+hash32(uint32_t val, unsigned int bits) {
+  800e2e:	55                   	push   %ebp
+  800e2f:	89 e5                	mov    %esp,%ebp
+  800e31:	83 ec 10             	sub    $0x10,%esp
+    uint32_t hash = val * GOLDEN_RATIO_PRIME_32;
+  800e34:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e37:	69 c0 01 00 37 9e    	imul   $0x9e370001,%eax,%eax
+  800e3d:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    return (hash >> (32 - bits));
+  800e40:	b8 20 00 00 00       	mov    $0x20,%eax
+  800e45:	2b 45 0c             	sub    0xc(%ebp),%eax
+  800e48:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  800e4b:	89 c1                	mov    %eax,%ecx
+  800e4d:	d3 ea                	shr    %cl,%edx
+  800e4f:	89 d0                	mov    %edx,%eax
+}
+  800e51:	c9                   	leave  
+  800e52:	c3                   	ret    
+
+00800e53 <rand>:
+ * rand - returns a pseudo-random integer
+ *
+ * The rand() function return a value in the range [0, RAND_MAX].
+ * */
+int
+rand(void) {
+  800e53:	55                   	push   %ebp
+  800e54:	89 e5                	mov    %esp,%ebp
+  800e56:	57                   	push   %edi
+  800e57:	56                   	push   %esi
+  800e58:	53                   	push   %ebx
+  800e59:	83 ec 24             	sub    $0x24,%esp
+    next = (next * 0x5DEECE66DLL + 0xBLL) & ((1LL << 48) - 1);
+  800e5c:	a1 00 20 80 00       	mov    0x802000,%eax
+  800e61:	8b 15 04 20 80 00    	mov    0x802004,%edx
+  800e67:	69 fa 6d e6 ec de    	imul   $0xdeece66d,%edx,%edi
+  800e6d:	6b f0 05             	imul   $0x5,%eax,%esi
+  800e70:	01 fe                	add    %edi,%esi
+  800e72:	bf 6d e6 ec de       	mov    $0xdeece66d,%edi
+  800e77:	f7 e7                	mul    %edi
+  800e79:	01 d6                	add    %edx,%esi
+  800e7b:	89 f2                	mov    %esi,%edx
+  800e7d:	83 c0 0b             	add    $0xb,%eax
+  800e80:	83 d2 00             	adc    $0x0,%edx
+  800e83:	89 c7                	mov    %eax,%edi
+  800e85:	83 e7 ff             	and    $0xffffffff,%edi
+  800e88:	89 f9                	mov    %edi,%ecx
+  800e8a:	0f b7 da             	movzwl %dx,%ebx
+  800e8d:	89 0d 00 20 80 00    	mov    %ecx,0x802000
+  800e93:	89 1d 04 20 80 00    	mov    %ebx,0x802004
+    unsigned long long result = (next >> 12);
+  800e99:	a1 00 20 80 00       	mov    0x802000,%eax
+  800e9e:	8b 15 04 20 80 00    	mov    0x802004,%edx
+  800ea4:	0f ac d0 0c          	shrd   $0xc,%edx,%eax
+  800ea8:	c1 ea 0c             	shr    $0xc,%edx
+  800eab:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800eae:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+    return (int)do_div(result, RAND_MAX + 1);
+  800eb1:	c7 45 dc 00 00 00 80 	movl   $0x80000000,-0x24(%ebp)
+  800eb8:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  800ebb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800ebe:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  800ec1:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  800ec4:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ec7:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800eca:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ece:	74 1c                	je     800eec <rand+0x99>
+  800ed0:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ed3:	ba 00 00 00 00       	mov    $0x0,%edx
+  800ed8:	f7 75 dc             	divl   -0x24(%ebp)
+  800edb:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  800ede:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ee1:	ba 00 00 00 00       	mov    $0x0,%edx
+  800ee6:	f7 75 dc             	divl   -0x24(%ebp)
+  800ee9:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800eec:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  800eef:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  800ef2:	f7 75 dc             	divl   -0x24(%ebp)
+  800ef5:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  800ef8:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  800efb:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  800efe:	8b 55 e8             	mov    -0x18(%ebp),%edx
+  800f01:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800f04:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  800f07:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+}
+  800f0a:	83 c4 24             	add    $0x24,%esp
+  800f0d:	5b                   	pop    %ebx
+  800f0e:	5e                   	pop    %esi
+  800f0f:	5f                   	pop    %edi
+  800f10:	5d                   	pop    %ebp
+  800f11:	c3                   	ret    
+
+00800f12 <srand>:
+/* *
+ * srand - seed the random number generator with the given number
+ * @seed:   the required seed number
+ * */
+void
+srand(unsigned int seed) {
+  800f12:	55                   	push   %ebp
+  800f13:	89 e5                	mov    %esp,%ebp
+    next = seed;
+  800f15:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f18:	ba 00 00 00 00       	mov    $0x0,%edx
+  800f1d:	a3 00 20 80 00       	mov    %eax,0x802000
+  800f22:	89 15 04 20 80 00    	mov    %edx,0x802004
+}
+  800f28:	90                   	nop
+  800f29:	5d                   	pop    %ebp
+  800f2a:	c3                   	ret    
+
+00800f2b <main>:
+#include <stdio.h>
+#include <ulib.h>
+
+int
+main(void) {
+  800f2b:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+  800f2f:	83 e4 f0             	and    $0xfffffff0,%esp
+  800f32:	ff 71 fc             	pushl  -0x4(%ecx)
+  800f35:	55                   	push   %ebp
+  800f36:	89 e5                	mov    %esp,%ebp
+  800f38:	51                   	push   %ecx
+  800f39:	83 ec 14             	sub    $0x14,%esp
+    int pid, exit_code;
+    if ((pid = fork()) == 0) {
+  800f3c:	e8 9c f2 ff ff       	call   8001dd <fork>
+  800f41:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800f44:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  800f48:	75 35                	jne    800f7f <main+0x54>
+        cprintf("fork ok.\n");
+  800f4a:	83 ec 0c             	sub    $0xc,%esp
+  800f4d:	68 40 13 80 00       	push   $0x801340
+  800f52:	e8 82 f3 ff ff       	call   8002d9 <cprintf>
+  800f57:	83 c4 10             	add    $0x10,%esp
+        int i;
+        for (i = 0; i < 10; i ++) {
+  800f5a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  800f61:	eb 09                	jmp    800f6c <main+0x41>
+            yield();
+  800f63:	e8 b2 f2 ff ff       	call   80021a <yield>
+main(void) {
+    int pid, exit_code;
+    if ((pid = fork()) == 0) {
+        cprintf("fork ok.\n");
+        int i;
+        for (i = 0; i < 10; i ++) {
+  800f68:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  800f6c:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
+  800f70:	7e f1                	jle    800f63 <main+0x38>
+            yield();
+        }
+        exit(0xbeaf);
+  800f72:	83 ec 0c             	sub    $0xc,%esp
+  800f75:	68 af be 00 00       	push   $0xbeaf
+  800f7a:	e8 38 f2 ff ff       	call   8001b7 <exit>
+    }
+    assert(pid > 0);
+  800f7f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  800f83:	7f 16                	jg     800f9b <main+0x70>
+  800f85:	68 4a 13 80 00       	push   $0x80134a
+  800f8a:	68 52 13 80 00       	push   $0x801352
+  800f8f:	6a 0f                	push   $0xf
+  800f91:	68 67 13 80 00       	push   $0x801367
+  800f96:	e8 85 f0 ff ff       	call   800020 <__panic>
+    assert(waitpid(-1, NULL) != 0);
+  800f9b:	83 ec 08             	sub    $0x8,%esp
+  800f9e:	6a 00                	push   $0x0
+  800fa0:	6a ff                	push   $0xffffffff
+  800fa2:	e8 5a f2 ff ff       	call   800201 <waitpid>
+  800fa7:	83 c4 10             	add    $0x10,%esp
+  800faa:	85 c0                	test   %eax,%eax
+  800fac:	75 16                	jne    800fc4 <main+0x99>
+  800fae:	68 75 13 80 00       	push   $0x801375
+  800fb3:	68 52 13 80 00       	push   $0x801352
+  800fb8:	6a 10                	push   $0x10
+  800fba:	68 67 13 80 00       	push   $0x801367
+  800fbf:	e8 5c f0 ff ff       	call   800020 <__panic>
+    assert(waitpid(pid, (void *)0xC0000000) != 0);
+  800fc4:	83 ec 08             	sub    $0x8,%esp
+  800fc7:	68 00 00 00 c0       	push   $0xc0000000
+  800fcc:	ff 75 f0             	pushl  -0x10(%ebp)
+  800fcf:	e8 2d f2 ff ff       	call   800201 <waitpid>
+  800fd4:	83 c4 10             	add    $0x10,%esp
+  800fd7:	85 c0                	test   %eax,%eax
+  800fd9:	75 16                	jne    800ff1 <main+0xc6>
+  800fdb:	68 8c 13 80 00       	push   $0x80138c
+  800fe0:	68 52 13 80 00       	push   $0x801352
+  800fe5:	6a 11                	push   $0x11
+  800fe7:	68 67 13 80 00       	push   $0x801367
+  800fec:	e8 2f f0 ff ff       	call   800020 <__panic>
+    assert(waitpid(pid, &exit_code) == 0 && exit_code == 0xbeaf);
+  800ff1:	83 ec 08             	sub    $0x8,%esp
+  800ff4:	8d 45 ec             	lea    -0x14(%ebp),%eax
+  800ff7:	50                   	push   %eax
+  800ff8:	ff 75 f0             	pushl  -0x10(%ebp)
+  800ffb:	e8 01 f2 ff ff       	call   800201 <waitpid>
+  801000:	83 c4 10             	add    $0x10,%esp
+  801003:	85 c0                	test   %eax,%eax
+  801005:	75 0a                	jne    801011 <main+0xe6>
+  801007:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  80100a:	3d af be 00 00       	cmp    $0xbeaf,%eax
+  80100f:	74 16                	je     801027 <main+0xfc>
+  801011:	68 b4 13 80 00       	push   $0x8013b4
+  801016:	68 52 13 80 00       	push   $0x801352
+  80101b:	6a 12                	push   $0x12
+  80101d:	68 67 13 80 00       	push   $0x801367
+  801022:	e8 f9 ef ff ff       	call   800020 <__panic>
+    cprintf("badarg pass.\n");
+  801027:	83 ec 0c             	sub    $0xc,%esp
+  80102a:	68 e9 13 80 00       	push   $0x8013e9
+  80102f:	e8 a5 f2 ff ff       	call   8002d9 <cprintf>
+  801034:	83 c4 10             	add    $0x10,%esp
+    return 0;
+  801037:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  80103c:	8b 4d fc             	mov    -0x4(%ebp),%ecx
+  80103f:	c9                   	leave  
+  801040:	8d 61 fc             	lea    -0x4(%ecx),%esp
+  801043:	c3                   	ret    
diff -r -u -P lab6_origin/obj/user/badarg.d lab6/obj/user/badarg.d
--- lab6_origin/obj/user/badarg.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/badarg.d	2019-05-13 17:39:38.358057700 +0800
@@ -0,0 +1,2 @@
+obj/user/badarg.o obj/user/badarg.d: user/badarg.c libs/stdio.h \
+ libs/defs.h libs/stdarg.h user/libs/ulib.h
Binary files lab6_origin/obj/user/badarg.o and lab6/obj/user/badarg.o differ
diff -r -u -P lab6_origin/obj/user/badarg.sym lab6/obj/user/badarg.sym
--- lab6_origin/obj/user/badarg.sym	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/badarg.sym	2019-05-13 17:39:43.770949600 +0800
@@ -0,0 +1,76 @@
+00800020 .text
+00801060 .rodata
+00802000 .data
+00200000 .stab_info
+00200010 .stab
+00202dad .stabstr
+00000000 panic.c
+00000000 syscall.c
+008000b5 syscall
+00000000 ulib.c
+00000000 stdio.c
+0080028c cputch
+00000000 umain.c
+00000000 string.c
+00000000 printfmt.c
+00801160 error_string
+00800822 printnum
+00800913 getuint
+00800962 getint
+00800d75 sprintputch
+00000000 hash.c
+00000000 rand.c
+00802000 next
+00000000 badarg.c
+008003be strcpy
+0080021a yield
+00800201 waitpid
+00800141 sys_yield
+008006d7 memmove
+00800dab snprintf
+008009cd vprintfmt
+0080011d sys_fork
+008002d9 cprintf
+0080023e getpid
+0080077a memcpy
+00800266 lab6_set_priority
+00800dd4 vsnprintf
+0080034d umain
+00202dac __STAB_END__
+00800150 sys_kill
+00202dad __STABSTR_BEGIN__
+00800020 __panic
+0080053a strtol
+0080038e strnlen
+0080024b print_pgdir
+00800228 kill
+0080050b strfind
+008001ea wait
+0080027d _start
+00800e53 rand
+00800482 strncmp
+00800171 sys_putc
+008003fe strncpy
+008007ca memcmp
+008001dd fork
+00800697 memset
+00800f2b main
+00800f12 srand
+00800e2e hash32
+008009a9 printfmt
+00203ba6 __STABSTR_END__
+00800438 strcmp
+00800259 gettime_msec
+00800192 sys_gettime
+008002b0 vcprintf
+0080006e __warn
+008002ff cputs
+008001a1 sys_lab6_set_priority
+008001b7 exit
+0080012c sys_wait
+0080010b sys_exit
+00200010 __STAB_BEGIN__
+00800366 strlen
+00800183 sys_pgdir
+008004d8 strchr
+00800162 sys_getpid
diff -r -u -P lab6_origin/obj/user/badsegment.asm lab6/obj/user/badsegment.asm
--- lab6_origin/obj/user/badsegment.asm	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/badsegment.asm	2019-05-13 17:39:43.705987200 +0800
@@ -0,0 +1,2580 @@
+
+obj/__user_badsegment.out:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00800020 <__panic>:
+#include <stdio.h>
+#include <ulib.h>
+#include <error.h>
+
+void
+__panic(const char *file, int line, const char *fmt, ...) {
+  800020:	55                   	push   %ebp
+  800021:	89 e5                	mov    %esp,%ebp
+  800023:	83 ec 18             	sub    $0x18,%esp
+    // print the 'message'
+    va_list ap;
+    va_start(ap, fmt);
+  800026:	8d 45 14             	lea    0x14(%ebp),%eax
+  800029:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("user panic at %s:%d:\n    ", file, line);
+  80002c:	83 ec 04             	sub    $0x4,%esp
+  80002f:	ff 75 0c             	pushl  0xc(%ebp)
+  800032:	ff 75 08             	pushl  0x8(%ebp)
+  800035:	68 60 0f 80 00       	push   $0x800f60
+  80003a:	e8 9a 02 00 00       	call   8002d9 <cprintf>
+  80003f:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+  800042:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800045:	83 ec 08             	sub    $0x8,%esp
+  800048:	50                   	push   %eax
+  800049:	ff 75 10             	pushl  0x10(%ebp)
+  80004c:	e8 5f 02 00 00       	call   8002b0 <vcprintf>
+  800051:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+  800054:	83 ec 0c             	sub    $0xc,%esp
+  800057:	68 7a 0f 80 00       	push   $0x800f7a
+  80005c:	e8 78 02 00 00       	call   8002d9 <cprintf>
+  800061:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+    exit(-E_PANIC);
+  800064:	83 ec 0c             	sub    $0xc,%esp
+  800067:	6a f6                	push   $0xfffffff6
+  800069:	e8 49 01 00 00       	call   8001b7 <exit>
+
+0080006e <__warn>:
+}
+
+void
+__warn(const char *file, int line, const char *fmt, ...) {
+  80006e:	55                   	push   %ebp
+  80006f:	89 e5                	mov    %esp,%ebp
+  800071:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    va_start(ap, fmt);
+  800074:	8d 45 14             	lea    0x14(%ebp),%eax
+  800077:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("user warning at %s:%d:\n    ", file, line);
+  80007a:	83 ec 04             	sub    $0x4,%esp
+  80007d:	ff 75 0c             	pushl  0xc(%ebp)
+  800080:	ff 75 08             	pushl  0x8(%ebp)
+  800083:	68 7c 0f 80 00       	push   $0x800f7c
+  800088:	e8 4c 02 00 00       	call   8002d9 <cprintf>
+  80008d:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+  800090:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800093:	83 ec 08             	sub    $0x8,%esp
+  800096:	50                   	push   %eax
+  800097:	ff 75 10             	pushl  0x10(%ebp)
+  80009a:	e8 11 02 00 00       	call   8002b0 <vcprintf>
+  80009f:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+  8000a2:	83 ec 0c             	sub    $0xc,%esp
+  8000a5:	68 7a 0f 80 00       	push   $0x800f7a
+  8000aa:	e8 2a 02 00 00       	call   8002d9 <cprintf>
+  8000af:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+  8000b2:	90                   	nop
+  8000b3:	c9                   	leave  
+  8000b4:	c3                   	ret    
+
+008000b5 <syscall>:
+#include <syscall.h>
+
+#define MAX_ARGS            5
+
+static inline int
+syscall(int num, ...) {
+  8000b5:	55                   	push   %ebp
+  8000b6:	89 e5                	mov    %esp,%ebp
+  8000b8:	57                   	push   %edi
+  8000b9:	56                   	push   %esi
+  8000ba:	53                   	push   %ebx
+  8000bb:	83 ec 20             	sub    $0x20,%esp
+    va_list ap;
+    va_start(ap, num);
+  8000be:	8d 45 0c             	lea    0xc(%ebp),%eax
+  8000c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    uint32_t a[MAX_ARGS];
+    int i, ret;
+    for (i = 0; i < MAX_ARGS; i ++) {
+  8000c4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  8000cb:	eb 16                	jmp    8000e3 <syscall+0x2e>
+        a[i] = va_arg(ap, uint32_t);
+  8000cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8000d0:	8d 50 04             	lea    0x4(%eax),%edx
+  8000d3:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  8000d6:	8b 10                	mov    (%eax),%edx
+  8000d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8000db:	89 54 85 d4          	mov    %edx,-0x2c(%ebp,%eax,4)
+syscall(int num, ...) {
+    va_list ap;
+    va_start(ap, num);
+    uint32_t a[MAX_ARGS];
+    int i, ret;
+    for (i = 0; i < MAX_ARGS; i ++) {
+  8000df:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+  8000e3:	83 7d f0 04          	cmpl   $0x4,-0x10(%ebp)
+  8000e7:	7e e4                	jle    8000cd <syscall+0x18>
+    asm volatile (
+        "int %1;"
+        : "=a" (ret)
+        : "i" (T_SYSCALL),
+          "a" (num),
+          "d" (a[0]),
+  8000e9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+          "c" (a[1]),
+  8000ec:	8b 4d d8             	mov    -0x28(%ebp),%ecx
+          "b" (a[2]),
+  8000ef:	8b 5d dc             	mov    -0x24(%ebp),%ebx
+          "D" (a[3]),
+  8000f2:	8b 7d e0             	mov    -0x20(%ebp),%edi
+          "S" (a[4])
+  8000f5:	8b 75 e4             	mov    -0x1c(%ebp),%esi
+    for (i = 0; i < MAX_ARGS; i ++) {
+        a[i] = va_arg(ap, uint32_t);
+    }
+    va_end(ap);
+
+    asm volatile (
+  8000f8:	8b 45 08             	mov    0x8(%ebp),%eax
+  8000fb:	cd 80                	int    $0x80
+  8000fd:	89 45 ec             	mov    %eax,-0x14(%ebp)
+          "c" (a[1]),
+          "b" (a[2]),
+          "D" (a[3]),
+          "S" (a[4])
+        : "cc", "memory");
+    return ret;
+  800100:	8b 45 ec             	mov    -0x14(%ebp),%eax
+}
+  800103:	83 c4 20             	add    $0x20,%esp
+  800106:	5b                   	pop    %ebx
+  800107:	5e                   	pop    %esi
+  800108:	5f                   	pop    %edi
+  800109:	5d                   	pop    %ebp
+  80010a:	c3                   	ret    
+
+0080010b <sys_exit>:
+
+int
+sys_exit(int error_code) {
+  80010b:	55                   	push   %ebp
+  80010c:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_exit, error_code);
+  80010e:	ff 75 08             	pushl  0x8(%ebp)
+  800111:	6a 01                	push   $0x1
+  800113:	e8 9d ff ff ff       	call   8000b5 <syscall>
+  800118:	83 c4 08             	add    $0x8,%esp
+}
+  80011b:	c9                   	leave  
+  80011c:	c3                   	ret    
+
+0080011d <sys_fork>:
+
+int
+sys_fork(void) {
+  80011d:	55                   	push   %ebp
+  80011e:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_fork);
+  800120:	6a 02                	push   $0x2
+  800122:	e8 8e ff ff ff       	call   8000b5 <syscall>
+  800127:	83 c4 04             	add    $0x4,%esp
+}
+  80012a:	c9                   	leave  
+  80012b:	c3                   	ret    
+
+0080012c <sys_wait>:
+
+int
+sys_wait(int pid, int *store) {
+  80012c:	55                   	push   %ebp
+  80012d:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_wait, pid, store);
+  80012f:	ff 75 0c             	pushl  0xc(%ebp)
+  800132:	ff 75 08             	pushl  0x8(%ebp)
+  800135:	6a 03                	push   $0x3
+  800137:	e8 79 ff ff ff       	call   8000b5 <syscall>
+  80013c:	83 c4 0c             	add    $0xc,%esp
+}
+  80013f:	c9                   	leave  
+  800140:	c3                   	ret    
+
+00800141 <sys_yield>:
+
+int
+sys_yield(void) {
+  800141:	55                   	push   %ebp
+  800142:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_yield);
+  800144:	6a 0a                	push   $0xa
+  800146:	e8 6a ff ff ff       	call   8000b5 <syscall>
+  80014b:	83 c4 04             	add    $0x4,%esp
+}
+  80014e:	c9                   	leave  
+  80014f:	c3                   	ret    
+
+00800150 <sys_kill>:
+
+int
+sys_kill(int pid) {
+  800150:	55                   	push   %ebp
+  800151:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_kill, pid);
+  800153:	ff 75 08             	pushl  0x8(%ebp)
+  800156:	6a 0c                	push   $0xc
+  800158:	e8 58 ff ff ff       	call   8000b5 <syscall>
+  80015d:	83 c4 08             	add    $0x8,%esp
+}
+  800160:	c9                   	leave  
+  800161:	c3                   	ret    
+
+00800162 <sys_getpid>:
+
+int
+sys_getpid(void) {
+  800162:	55                   	push   %ebp
+  800163:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_getpid);
+  800165:	6a 12                	push   $0x12
+  800167:	e8 49 ff ff ff       	call   8000b5 <syscall>
+  80016c:	83 c4 04             	add    $0x4,%esp
+}
+  80016f:	c9                   	leave  
+  800170:	c3                   	ret    
+
+00800171 <sys_putc>:
+
+int
+sys_putc(int c) {
+  800171:	55                   	push   %ebp
+  800172:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_putc, c);
+  800174:	ff 75 08             	pushl  0x8(%ebp)
+  800177:	6a 1e                	push   $0x1e
+  800179:	e8 37 ff ff ff       	call   8000b5 <syscall>
+  80017e:	83 c4 08             	add    $0x8,%esp
+}
+  800181:	c9                   	leave  
+  800182:	c3                   	ret    
+
+00800183 <sys_pgdir>:
+
+int
+sys_pgdir(void) {
+  800183:	55                   	push   %ebp
+  800184:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_pgdir);
+  800186:	6a 1f                	push   $0x1f
+  800188:	e8 28 ff ff ff       	call   8000b5 <syscall>
+  80018d:	83 c4 04             	add    $0x4,%esp
+}
+  800190:	c9                   	leave  
+  800191:	c3                   	ret    
+
+00800192 <sys_gettime>:
+
+int
+sys_gettime(void) {
+  800192:	55                   	push   %ebp
+  800193:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_gettime);
+  800195:	6a 11                	push   $0x11
+  800197:	e8 19 ff ff ff       	call   8000b5 <syscall>
+  80019c:	83 c4 04             	add    $0x4,%esp
+}
+  80019f:	c9                   	leave  
+  8001a0:	c3                   	ret    
+
+008001a1 <sys_lab6_set_priority>:
+
+void
+sys_lab6_set_priority(uint32_t priority)
+{
+  8001a1:	55                   	push   %ebp
+  8001a2:	89 e5                	mov    %esp,%ebp
+    syscall(SYS_lab6_set_priority, priority);
+  8001a4:	ff 75 08             	pushl  0x8(%ebp)
+  8001a7:	68 ff 00 00 00       	push   $0xff
+  8001ac:	e8 04 ff ff ff       	call   8000b5 <syscall>
+  8001b1:	83 c4 08             	add    $0x8,%esp
+}
+  8001b4:	90                   	nop
+  8001b5:	c9                   	leave  
+  8001b6:	c3                   	ret    
+
+008001b7 <exit>:
+#include <syscall.h>
+#include <stdio.h>
+#include <ulib.h>
+
+void
+exit(int error_code) {
+  8001b7:	55                   	push   %ebp
+  8001b8:	89 e5                	mov    %esp,%ebp
+  8001ba:	83 ec 08             	sub    $0x8,%esp
+    sys_exit(error_code);
+  8001bd:	83 ec 0c             	sub    $0xc,%esp
+  8001c0:	ff 75 08             	pushl  0x8(%ebp)
+  8001c3:	e8 43 ff ff ff       	call   80010b <sys_exit>
+  8001c8:	83 c4 10             	add    $0x10,%esp
+    cprintf("BUG: exit failed.\n");
+  8001cb:	83 ec 0c             	sub    $0xc,%esp
+  8001ce:	68 98 0f 80 00       	push   $0x800f98
+  8001d3:	e8 01 01 00 00       	call   8002d9 <cprintf>
+  8001d8:	83 c4 10             	add    $0x10,%esp
+    while (1);
+  8001db:	eb fe                	jmp    8001db <exit+0x24>
+
+008001dd <fork>:
+}
+
+int
+fork(void) {
+  8001dd:	55                   	push   %ebp
+  8001de:	89 e5                	mov    %esp,%ebp
+  8001e0:	83 ec 08             	sub    $0x8,%esp
+    return sys_fork();
+  8001e3:	e8 35 ff ff ff       	call   80011d <sys_fork>
+}
+  8001e8:	c9                   	leave  
+  8001e9:	c3                   	ret    
+
+008001ea <wait>:
+
+int
+wait(void) {
+  8001ea:	55                   	push   %ebp
+  8001eb:	89 e5                	mov    %esp,%ebp
+  8001ed:	83 ec 08             	sub    $0x8,%esp
+    return sys_wait(0, NULL);
+  8001f0:	83 ec 08             	sub    $0x8,%esp
+  8001f3:	6a 00                	push   $0x0
+  8001f5:	6a 00                	push   $0x0
+  8001f7:	e8 30 ff ff ff       	call   80012c <sys_wait>
+  8001fc:	83 c4 10             	add    $0x10,%esp
+}
+  8001ff:	c9                   	leave  
+  800200:	c3                   	ret    
+
+00800201 <waitpid>:
+
+int
+waitpid(int pid, int *store) {
+  800201:	55                   	push   %ebp
+  800202:	89 e5                	mov    %esp,%ebp
+  800204:	83 ec 08             	sub    $0x8,%esp
+    return sys_wait(pid, store);
+  800207:	83 ec 08             	sub    $0x8,%esp
+  80020a:	ff 75 0c             	pushl  0xc(%ebp)
+  80020d:	ff 75 08             	pushl  0x8(%ebp)
+  800210:	e8 17 ff ff ff       	call   80012c <sys_wait>
+  800215:	83 c4 10             	add    $0x10,%esp
+}
+  800218:	c9                   	leave  
+  800219:	c3                   	ret    
+
+0080021a <yield>:
+
+void
+yield(void) {
+  80021a:	55                   	push   %ebp
+  80021b:	89 e5                	mov    %esp,%ebp
+  80021d:	83 ec 08             	sub    $0x8,%esp
+    sys_yield();
+  800220:	e8 1c ff ff ff       	call   800141 <sys_yield>
+}
+  800225:	90                   	nop
+  800226:	c9                   	leave  
+  800227:	c3                   	ret    
+
+00800228 <kill>:
+
+int
+kill(int pid) {
+  800228:	55                   	push   %ebp
+  800229:	89 e5                	mov    %esp,%ebp
+  80022b:	83 ec 08             	sub    $0x8,%esp
+    return sys_kill(pid);
+  80022e:	83 ec 0c             	sub    $0xc,%esp
+  800231:	ff 75 08             	pushl  0x8(%ebp)
+  800234:	e8 17 ff ff ff       	call   800150 <sys_kill>
+  800239:	83 c4 10             	add    $0x10,%esp
+}
+  80023c:	c9                   	leave  
+  80023d:	c3                   	ret    
+
+0080023e <getpid>:
+
+int
+getpid(void) {
+  80023e:	55                   	push   %ebp
+  80023f:	89 e5                	mov    %esp,%ebp
+  800241:	83 ec 08             	sub    $0x8,%esp
+    return sys_getpid();
+  800244:	e8 19 ff ff ff       	call   800162 <sys_getpid>
+}
+  800249:	c9                   	leave  
+  80024a:	c3                   	ret    
+
+0080024b <print_pgdir>:
+
+//print_pgdir - print the PDT&PT
+void
+print_pgdir(void) {
+  80024b:	55                   	push   %ebp
+  80024c:	89 e5                	mov    %esp,%ebp
+  80024e:	83 ec 08             	sub    $0x8,%esp
+    sys_pgdir();
+  800251:	e8 2d ff ff ff       	call   800183 <sys_pgdir>
+}
+  800256:	90                   	nop
+  800257:	c9                   	leave  
+  800258:	c3                   	ret    
+
+00800259 <gettime_msec>:
+
+unsigned int
+gettime_msec(void) {
+  800259:	55                   	push   %ebp
+  80025a:	89 e5                	mov    %esp,%ebp
+  80025c:	83 ec 08             	sub    $0x8,%esp
+    return (unsigned int)sys_gettime();
+  80025f:	e8 2e ff ff ff       	call   800192 <sys_gettime>
+}
+  800264:	c9                   	leave  
+  800265:	c3                   	ret    
+
+00800266 <lab6_set_priority>:
+
+void
+lab6_set_priority(uint32_t priority)
+{
+  800266:	55                   	push   %ebp
+  800267:	89 e5                	mov    %esp,%ebp
+  800269:	83 ec 08             	sub    $0x8,%esp
+    sys_lab6_set_priority(priority);
+  80026c:	83 ec 0c             	sub    $0xc,%esp
+  80026f:	ff 75 08             	pushl  0x8(%ebp)
+  800272:	e8 2a ff ff ff       	call   8001a1 <sys_lab6_set_priority>
+  800277:	83 c4 10             	add    $0x10,%esp
+}
+  80027a:	90                   	nop
+  80027b:	c9                   	leave  
+  80027c:	c3                   	ret    
+
+0080027d <_start>:
+.text
+.globl _start
+_start:
+    # set ebp for backtrace
+    movl $0x0, %ebp
+  80027d:	bd 00 00 00 00       	mov    $0x0,%ebp
+
+    # move down the esp register
+    # since it may cause page fault in backtrace
+    subl $0x20, %esp
+  800282:	83 ec 20             	sub    $0x20,%esp
+
+    # call user-program function
+    call umain
+  800285:	e8 c3 00 00 00       	call   80034d <umain>
+1:  jmp 1b
+  80028a:	eb fe                	jmp    80028a <_start+0xd>
+
+0080028c <cputch>:
+/* *
+ * cputch - writes a single character @c to stdout, and it will
+ * increace the value of counter pointed by @cnt.
+ * */
+static void
+cputch(int c, int *cnt) {
+  80028c:	55                   	push   %ebp
+  80028d:	89 e5                	mov    %esp,%ebp
+  80028f:	83 ec 08             	sub    $0x8,%esp
+    sys_putc(c);
+  800292:	83 ec 0c             	sub    $0xc,%esp
+  800295:	ff 75 08             	pushl  0x8(%ebp)
+  800298:	e8 d4 fe ff ff       	call   800171 <sys_putc>
+  80029d:	83 c4 10             	add    $0x10,%esp
+    (*cnt) ++;
+  8002a0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002a3:	8b 00                	mov    (%eax),%eax
+  8002a5:	8d 50 01             	lea    0x1(%eax),%edx
+  8002a8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002ab:	89 10                	mov    %edx,(%eax)
+}
+  8002ad:	90                   	nop
+  8002ae:	c9                   	leave  
+  8002af:	c3                   	ret    
+
+008002b0 <vcprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want cprintf() instead.
+ * */
+int
+vcprintf(const char *fmt, va_list ap) {
+  8002b0:	55                   	push   %ebp
+  8002b1:	89 e5                	mov    %esp,%ebp
+  8002b3:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+  8002b6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    vprintfmt((void*)cputch, &cnt, fmt, ap);
+  8002bd:	ff 75 0c             	pushl  0xc(%ebp)
+  8002c0:	ff 75 08             	pushl  0x8(%ebp)
+  8002c3:	8d 45 f4             	lea    -0xc(%ebp),%eax
+  8002c6:	50                   	push   %eax
+  8002c7:	68 8c 02 80 00       	push   $0x80028c
+  8002cc:	e8 fc 06 00 00       	call   8009cd <vprintfmt>
+  8002d1:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+  8002d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8002d7:	c9                   	leave  
+  8002d8:	c3                   	ret    
+
+008002d9 <cprintf>:
+ *
+ * The return value is the number of characters which would be
+ * written to stdout.
+ * */
+int
+cprintf(const char *fmt, ...) {
+  8002d9:	55                   	push   %ebp
+  8002da:	89 e5                	mov    %esp,%ebp
+  8002dc:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  8002df:	8d 45 0c             	lea    0xc(%ebp),%eax
+  8002e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    int cnt = vcprintf(fmt, ap);
+  8002e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8002e8:	83 ec 08             	sub    $0x8,%esp
+  8002eb:	50                   	push   %eax
+  8002ec:	ff 75 08             	pushl  0x8(%ebp)
+  8002ef:	e8 bc ff ff ff       	call   8002b0 <vcprintf>
+  8002f4:	83 c4 10             	add    $0x10,%esp
+  8002f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+
+    return cnt;
+  8002fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8002fd:	c9                   	leave  
+  8002fe:	c3                   	ret    
+
+008002ff <cputs>:
+/* *
+ * cputs- writes the string pointed by @str to stdout and
+ * appends a newline character.
+ * */
+int
+cputs(const char *str) {
+  8002ff:	55                   	push   %ebp
+  800300:	89 e5                	mov    %esp,%ebp
+  800302:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+  800305:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    char c;
+    while ((c = *str ++) != '\0') {
+  80030c:	eb 14                	jmp    800322 <cputs+0x23>
+        cputch(c, &cnt);
+  80030e:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
+  800312:	83 ec 08             	sub    $0x8,%esp
+  800315:	8d 55 f0             	lea    -0x10(%ebp),%edx
+  800318:	52                   	push   %edx
+  800319:	50                   	push   %eax
+  80031a:	e8 6d ff ff ff       	call   80028c <cputch>
+  80031f:	83 c4 10             	add    $0x10,%esp
+ * */
+int
+cputs(const char *str) {
+    int cnt = 0;
+    char c;
+    while ((c = *str ++) != '\0') {
+  800322:	8b 45 08             	mov    0x8(%ebp),%eax
+  800325:	8d 50 01             	lea    0x1(%eax),%edx
+  800328:	89 55 08             	mov    %edx,0x8(%ebp)
+  80032b:	0f b6 00             	movzbl (%eax),%eax
+  80032e:	88 45 f7             	mov    %al,-0x9(%ebp)
+  800331:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
+  800335:	75 d7                	jne    80030e <cputs+0xf>
+        cputch(c, &cnt);
+    }
+    cputch('\n', &cnt);
+  800337:	83 ec 08             	sub    $0x8,%esp
+  80033a:	8d 45 f0             	lea    -0x10(%ebp),%eax
+  80033d:	50                   	push   %eax
+  80033e:	6a 0a                	push   $0xa
+  800340:	e8 47 ff ff ff       	call   80028c <cputch>
+  800345:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+  800348:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+  80034b:	c9                   	leave  
+  80034c:	c3                   	ret    
+
+0080034d <umain>:
+#include <ulib.h>
+
+int main(void);
+
+void
+umain(void) {
+  80034d:	55                   	push   %ebp
+  80034e:	89 e5                	mov    %esp,%ebp
+  800350:	83 ec 18             	sub    $0x18,%esp
+    int ret = main();
+  800353:	e8 d3 0b 00 00       	call   800f2b <main>
+  800358:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    exit(ret);
+  80035b:	83 ec 0c             	sub    $0xc,%esp
+  80035e:	ff 75 f4             	pushl  -0xc(%ebp)
+  800361:	e8 51 fe ff ff       	call   8001b7 <exit>
+
+00800366 <strlen>:
+ * @s:      the input string
+ *
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+  800366:	55                   	push   %ebp
+  800367:	89 e5                	mov    %esp,%ebp
+  800369:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  80036c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (*s ++ != '\0') {
+  800373:	eb 04                	jmp    800379 <strlen+0x13>
+        cnt ++;
+  800375:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+    size_t cnt = 0;
+    while (*s ++ != '\0') {
+  800379:	8b 45 08             	mov    0x8(%ebp),%eax
+  80037c:	8d 50 01             	lea    0x1(%eax),%edx
+  80037f:	89 55 08             	mov    %edx,0x8(%ebp)
+  800382:	0f b6 00             	movzbl (%eax),%eax
+  800385:	84 c0                	test   %al,%al
+  800387:	75 ec                	jne    800375 <strlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  800389:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  80038c:	c9                   	leave  
+  80038d:	c3                   	ret    
+
+0080038e <strnlen>:
+ * The return value is strlen(s), if that is less than @len, or
+ * @len if there is no '\0' character among the first @len characters
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+  80038e:	55                   	push   %ebp
+  80038f:	89 e5                	mov    %esp,%ebp
+  800391:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  800394:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (cnt < len && *s ++ != '\0') {
+  80039b:	eb 04                	jmp    8003a1 <strnlen+0x13>
+        cnt ++;
+  80039d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+    size_t cnt = 0;
+    while (cnt < len && *s ++ != '\0') {
+  8003a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8003a4:	3b 45 0c             	cmp    0xc(%ebp),%eax
+  8003a7:	73 10                	jae    8003b9 <strnlen+0x2b>
+  8003a9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003ac:	8d 50 01             	lea    0x1(%eax),%edx
+  8003af:	89 55 08             	mov    %edx,0x8(%ebp)
+  8003b2:	0f b6 00             	movzbl (%eax),%eax
+  8003b5:	84 c0                	test   %al,%al
+  8003b7:	75 e4                	jne    80039d <strnlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  8003b9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  8003bc:	c9                   	leave  
+  8003bd:	c3                   	ret    
+
+008003be <strcpy>:
+ * To avoid overflows, the size of array pointed by @dst should be long enough to
+ * contain the same string as @src (including the terminating null character), and
+ * should not overlap in memory with @src.
+ * */
+char *
+strcpy(char *dst, const char *src) {
+  8003be:	55                   	push   %ebp
+  8003bf:	89 e5                	mov    %esp,%ebp
+  8003c1:	57                   	push   %edi
+  8003c2:	56                   	push   %esi
+  8003c3:	83 ec 20             	sub    $0x20,%esp
+  8003c6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  8003cc:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8003cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCPY
+#define __HAVE_ARCH_STRCPY
+static inline char *
+__strcpy(char *dst, const char *src) {
+    int d0, d1, d2;
+    asm volatile (
+  8003d2:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  8003d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8003d8:	89 d1                	mov    %edx,%ecx
+  8003da:	89 c2                	mov    %eax,%edx
+  8003dc:	89 ce                	mov    %ecx,%esi
+  8003de:	89 d7                	mov    %edx,%edi
+  8003e0:	ac                   	lods   %ds:(%esi),%al
+  8003e1:	aa                   	stos   %al,%es:(%edi)
+  8003e2:	84 c0                	test   %al,%al
+  8003e4:	75 fa                	jne    8003e0 <strcpy+0x22>
+  8003e6:	89 fa                	mov    %edi,%edx
+  8003e8:	89 f1                	mov    %esi,%ecx
+  8003ea:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  8003ed:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  8003f0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+        "stosb;"
+        "testb %%al, %%al;"
+        "jne 1b;"
+        : "=&S" (d0), "=&D" (d1), "=&a" (d2)
+        : "0" (src), "1" (dst) : "memory");
+    return dst;
+  8003f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCPY
+    return __strcpy(dst, src);
+  8003f6:	90                   	nop
+    char *p = dst;
+    while ((*p ++ = *src ++) != '\0')
+        /* nothing */;
+    return dst;
+#endif /* __HAVE_ARCH_STRCPY */
+}
+  8003f7:	83 c4 20             	add    $0x20,%esp
+  8003fa:	5e                   	pop    %esi
+  8003fb:	5f                   	pop    %edi
+  8003fc:	5d                   	pop    %ebp
+  8003fd:	c3                   	ret    
+
+008003fe <strncpy>:
+ * @len:    maximum number of characters to be copied from @src
+ *
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+  8003fe:	55                   	push   %ebp
+  8003ff:	89 e5                	mov    %esp,%ebp
+  800401:	83 ec 10             	sub    $0x10,%esp
+    char *p = dst;
+  800404:	8b 45 08             	mov    0x8(%ebp),%eax
+  800407:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    while (len > 0) {
+  80040a:	eb 21                	jmp    80042d <strncpy+0x2f>
+        if ((*p = *src) != '\0') {
+  80040c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80040f:	0f b6 10             	movzbl (%eax),%edx
+  800412:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800415:	88 10                	mov    %dl,(%eax)
+  800417:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  80041a:	0f b6 00             	movzbl (%eax),%eax
+  80041d:	84 c0                	test   %al,%al
+  80041f:	74 04                	je     800425 <strncpy+0x27>
+            src ++;
+  800421:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+        }
+        p ++, len --;
+  800425:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800429:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+    char *p = dst;
+    while (len > 0) {
+  80042d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800431:	75 d9                	jne    80040c <strncpy+0xe>
+        if ((*p = *src) != '\0') {
+            src ++;
+        }
+        p ++, len --;
+    }
+    return dst;
+  800433:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800436:	c9                   	leave  
+  800437:	c3                   	ret    
+
+00800438 <strcmp>:
+ * - A value greater than zero indicates that the first character that does
+ *   not match has a greater value in @s1 than in @s2;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+strcmp(const char *s1, const char *s2) {
+  800438:	55                   	push   %ebp
+  800439:	89 e5                	mov    %esp,%ebp
+  80043b:	57                   	push   %edi
+  80043c:	56                   	push   %esi
+  80043d:	83 ec 20             	sub    $0x20,%esp
+  800440:	8b 45 08             	mov    0x8(%ebp),%eax
+  800443:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800446:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800449:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCMP
+#define __HAVE_ARCH_STRCMP
+static inline int
+__strcmp(const char *s1, const char *s2) {
+    int d0, d1, ret;
+    asm volatile (
+  80044c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80044f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800452:	89 d1                	mov    %edx,%ecx
+  800454:	89 c2                	mov    %eax,%edx
+  800456:	89 ce                	mov    %ecx,%esi
+  800458:	89 d7                	mov    %edx,%edi
+  80045a:	ac                   	lods   %ds:(%esi),%al
+  80045b:	ae                   	scas   %es:(%edi),%al
+  80045c:	75 08                	jne    800466 <strcmp+0x2e>
+  80045e:	84 c0                	test   %al,%al
+  800460:	75 f8                	jne    80045a <strcmp+0x22>
+  800462:	31 c0                	xor    %eax,%eax
+  800464:	eb 04                	jmp    80046a <strcmp+0x32>
+  800466:	19 c0                	sbb    %eax,%eax
+  800468:	0c 01                	or     $0x1,%al
+  80046a:	89 fa                	mov    %edi,%edx
+  80046c:	89 f1                	mov    %esi,%ecx
+  80046e:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800471:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  800474:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+        "orb $1, %%al;"
+        "3:"
+        : "=a" (ret), "=&S" (d0), "=&D" (d1)
+        : "1" (s1), "2" (s2)
+        : "memory");
+    return ret;
+  800477:	8b 45 ec             	mov    -0x14(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCMP
+    return __strcmp(s1, s2);
+  80047a:	90                   	nop
+    while (*s1 != '\0' && *s1 == *s2) {
+        s1 ++, s2 ++;
+    }
+    return (int)((unsigned char)*s1 - (unsigned char)*s2);
+#endif /* __HAVE_ARCH_STRCMP */
+}
+  80047b:	83 c4 20             	add    $0x20,%esp
+  80047e:	5e                   	pop    %esi
+  80047f:	5f                   	pop    %edi
+  800480:	5d                   	pop    %ebp
+  800481:	c3                   	ret    
+
+00800482 <strncmp>:
+ * they are equal to each other, it continues with the following pairs until
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+  800482:	55                   	push   %ebp
+  800483:	89 e5                	mov    %esp,%ebp
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  800485:	eb 0c                	jmp    800493 <strncmp+0x11>
+        n --, s1 ++, s2 ++;
+  800487:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  80048b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  80048f:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  800493:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800497:	74 1a                	je     8004b3 <strncmp+0x31>
+  800499:	8b 45 08             	mov    0x8(%ebp),%eax
+  80049c:	0f b6 00             	movzbl (%eax),%eax
+  80049f:	84 c0                	test   %al,%al
+  8004a1:	74 10                	je     8004b3 <strncmp+0x31>
+  8004a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004a6:	0f b6 10             	movzbl (%eax),%edx
+  8004a9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004ac:	0f b6 00             	movzbl (%eax),%eax
+  8004af:	38 c2                	cmp    %al,%dl
+  8004b1:	74 d4                	je     800487 <strncmp+0x5>
+        n --, s1 ++, s2 ++;
+    }
+    return (n == 0) ? 0 : (int)((unsigned char)*s1 - (unsigned char)*s2);
+  8004b3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8004b7:	74 18                	je     8004d1 <strncmp+0x4f>
+  8004b9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004bc:	0f b6 00             	movzbl (%eax),%eax
+  8004bf:	0f b6 d0             	movzbl %al,%edx
+  8004c2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004c5:	0f b6 00             	movzbl (%eax),%eax
+  8004c8:	0f b6 c0             	movzbl %al,%eax
+  8004cb:	29 c2                	sub    %eax,%edx
+  8004cd:	89 d0                	mov    %edx,%eax
+  8004cf:	eb 05                	jmp    8004d6 <strncmp+0x54>
+  8004d1:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  8004d6:	5d                   	pop    %ebp
+  8004d7:	c3                   	ret    
+
+008004d8 <strchr>:
+ *
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+  8004d8:	55                   	push   %ebp
+  8004d9:	89 e5                	mov    %esp,%ebp
+  8004db:	83 ec 04             	sub    $0x4,%esp
+  8004de:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004e1:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  8004e4:	eb 14                	jmp    8004fa <strchr+0x22>
+        if (*s == c) {
+  8004e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004e9:	0f b6 00             	movzbl (%eax),%eax
+  8004ec:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  8004ef:	75 05                	jne    8004f6 <strchr+0x1e>
+            return (char *)s;
+  8004f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004f4:	eb 13                	jmp    800509 <strchr+0x31>
+        }
+        s ++;
+  8004f6:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+    while (*s != '\0') {
+  8004fa:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004fd:	0f b6 00             	movzbl (%eax),%eax
+  800500:	84 c0                	test   %al,%al
+  800502:	75 e2                	jne    8004e6 <strchr+0xe>
+        if (*s == c) {
+            return (char *)s;
+        }
+        s ++;
+    }
+    return NULL;
+  800504:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800509:	c9                   	leave  
+  80050a:	c3                   	ret    
+
+0080050b <strfind>:
+ * The strfind() function is like strchr() except that if @c is
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+  80050b:	55                   	push   %ebp
+  80050c:	89 e5                	mov    %esp,%ebp
+  80050e:	83 ec 04             	sub    $0x4,%esp
+  800511:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800514:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  800517:	eb 0f                	jmp    800528 <strfind+0x1d>
+        if (*s == c) {
+  800519:	8b 45 08             	mov    0x8(%ebp),%eax
+  80051c:	0f b6 00             	movzbl (%eax),%eax
+  80051f:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800522:	74 10                	je     800534 <strfind+0x29>
+            break;
+        }
+        s ++;
+  800524:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+    while (*s != '\0') {
+  800528:	8b 45 08             	mov    0x8(%ebp),%eax
+  80052b:	0f b6 00             	movzbl (%eax),%eax
+  80052e:	84 c0                	test   %al,%al
+  800530:	75 e7                	jne    800519 <strfind+0xe>
+  800532:	eb 01                	jmp    800535 <strfind+0x2a>
+        if (*s == c) {
+            break;
+  800534:	90                   	nop
+        }
+        s ++;
+    }
+    return (char *)s;
+  800535:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800538:	c9                   	leave  
+  800539:	c3                   	ret    
+
+0080053a <strtol>:
+ * an optional "0x" or "0X" prefix.
+ *
+ * The strtol() function returns the converted integral number as a long int value.
+ * */
+long
+strtol(const char *s, char **endptr, int base) {
+  80053a:	55                   	push   %ebp
+  80053b:	89 e5                	mov    %esp,%ebp
+  80053d:	83 ec 10             	sub    $0x10,%esp
+    int neg = 0;
+  800540:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    long val = 0;
+  800547:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  80054e:	eb 04                	jmp    800554 <strtol+0x1a>
+        s ++;
+  800550:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+strtol(const char *s, char **endptr, int base) {
+    int neg = 0;
+    long val = 0;
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  800554:	8b 45 08             	mov    0x8(%ebp),%eax
+  800557:	0f b6 00             	movzbl (%eax),%eax
+  80055a:	3c 20                	cmp    $0x20,%al
+  80055c:	74 f2                	je     800550 <strtol+0x16>
+  80055e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800561:	0f b6 00             	movzbl (%eax),%eax
+  800564:	3c 09                	cmp    $0x9,%al
+  800566:	74 e8                	je     800550 <strtol+0x16>
+        s ++;
+    }
+
+    // plus/minus sign
+    if (*s == '+') {
+  800568:	8b 45 08             	mov    0x8(%ebp),%eax
+  80056b:	0f b6 00             	movzbl (%eax),%eax
+  80056e:	3c 2b                	cmp    $0x2b,%al
+  800570:	75 06                	jne    800578 <strtol+0x3e>
+        s ++;
+  800572:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800576:	eb 15                	jmp    80058d <strtol+0x53>
+    }
+    else if (*s == '-') {
+  800578:	8b 45 08             	mov    0x8(%ebp),%eax
+  80057b:	0f b6 00             	movzbl (%eax),%eax
+  80057e:	3c 2d                	cmp    $0x2d,%al
+  800580:	75 0b                	jne    80058d <strtol+0x53>
+        s ++, neg = 1;
+  800582:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800586:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+    }
+
+    // hex or octal base prefix
+    if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x')) {
+  80058d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800591:	74 06                	je     800599 <strtol+0x5f>
+  800593:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+  800597:	75 24                	jne    8005bd <strtol+0x83>
+  800599:	8b 45 08             	mov    0x8(%ebp),%eax
+  80059c:	0f b6 00             	movzbl (%eax),%eax
+  80059f:	3c 30                	cmp    $0x30,%al
+  8005a1:	75 1a                	jne    8005bd <strtol+0x83>
+  8005a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005a6:	83 c0 01             	add    $0x1,%eax
+  8005a9:	0f b6 00             	movzbl (%eax),%eax
+  8005ac:	3c 78                	cmp    $0x78,%al
+  8005ae:	75 0d                	jne    8005bd <strtol+0x83>
+        s += 2, base = 16;
+  8005b0:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+  8005b4:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+  8005bb:	eb 2a                	jmp    8005e7 <strtol+0xad>
+    }
+    else if (base == 0 && s[0] == '0') {
+  8005bd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8005c1:	75 17                	jne    8005da <strtol+0xa0>
+  8005c3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005c6:	0f b6 00             	movzbl (%eax),%eax
+  8005c9:	3c 30                	cmp    $0x30,%al
+  8005cb:	75 0d                	jne    8005da <strtol+0xa0>
+        s ++, base = 8;
+  8005cd:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  8005d1:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+  8005d8:	eb 0d                	jmp    8005e7 <strtol+0xad>
+    }
+    else if (base == 0) {
+  8005da:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8005de:	75 07                	jne    8005e7 <strtol+0xad>
+        base = 10;
+  8005e0:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+    // digits
+    while (1) {
+        int dig;
+
+        if (*s >= '0' && *s <= '9') {
+  8005e7:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005ea:	0f b6 00             	movzbl (%eax),%eax
+  8005ed:	3c 2f                	cmp    $0x2f,%al
+  8005ef:	7e 1b                	jle    80060c <strtol+0xd2>
+  8005f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005f4:	0f b6 00             	movzbl (%eax),%eax
+  8005f7:	3c 39                	cmp    $0x39,%al
+  8005f9:	7f 11                	jg     80060c <strtol+0xd2>
+            dig = *s - '0';
+  8005fb:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005fe:	0f b6 00             	movzbl (%eax),%eax
+  800601:	0f be c0             	movsbl %al,%eax
+  800604:	83 e8 30             	sub    $0x30,%eax
+  800607:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80060a:	eb 48                	jmp    800654 <strtol+0x11a>
+        }
+        else if (*s >= 'a' && *s <= 'z') {
+  80060c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80060f:	0f b6 00             	movzbl (%eax),%eax
+  800612:	3c 60                	cmp    $0x60,%al
+  800614:	7e 1b                	jle    800631 <strtol+0xf7>
+  800616:	8b 45 08             	mov    0x8(%ebp),%eax
+  800619:	0f b6 00             	movzbl (%eax),%eax
+  80061c:	3c 7a                	cmp    $0x7a,%al
+  80061e:	7f 11                	jg     800631 <strtol+0xf7>
+            dig = *s - 'a' + 10;
+  800620:	8b 45 08             	mov    0x8(%ebp),%eax
+  800623:	0f b6 00             	movzbl (%eax),%eax
+  800626:	0f be c0             	movsbl %al,%eax
+  800629:	83 e8 57             	sub    $0x57,%eax
+  80062c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80062f:	eb 23                	jmp    800654 <strtol+0x11a>
+        }
+        else if (*s >= 'A' && *s <= 'Z') {
+  800631:	8b 45 08             	mov    0x8(%ebp),%eax
+  800634:	0f b6 00             	movzbl (%eax),%eax
+  800637:	3c 40                	cmp    $0x40,%al
+  800639:	7e 3c                	jle    800677 <strtol+0x13d>
+  80063b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80063e:	0f b6 00             	movzbl (%eax),%eax
+  800641:	3c 5a                	cmp    $0x5a,%al
+  800643:	7f 32                	jg     800677 <strtol+0x13d>
+            dig = *s - 'A' + 10;
+  800645:	8b 45 08             	mov    0x8(%ebp),%eax
+  800648:	0f b6 00             	movzbl (%eax),%eax
+  80064b:	0f be c0             	movsbl %al,%eax
+  80064e:	83 e8 37             	sub    $0x37,%eax
+  800651:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+  800654:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800657:	3b 45 10             	cmp    0x10(%ebp),%eax
+  80065a:	7d 1a                	jge    800676 <strtol+0x13c>
+            break;
+        }
+        s ++, val = (val * base) + dig;
+  80065c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800660:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800663:	0f af 45 10          	imul   0x10(%ebp),%eax
+  800667:	89 c2                	mov    %eax,%edx
+  800669:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  80066c:	01 d0                	add    %edx,%eax
+  80066e:	89 45 f8             	mov    %eax,-0x8(%ebp)
+        // we don't properly detect overflow!
+    }
+  800671:	e9 71 ff ff ff       	jmp    8005e7 <strtol+0xad>
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+            break;
+  800676:	90                   	nop
+        }
+        s ++, val = (val * base) + dig;
+        // we don't properly detect overflow!
+    }
+
+    if (endptr) {
+  800677:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  80067b:	74 08                	je     800685 <strtol+0x14b>
+        *endptr = (char *) s;
+  80067d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800680:	8b 55 08             	mov    0x8(%ebp),%edx
+  800683:	89 10                	mov    %edx,(%eax)
+    }
+    return (neg ? -val : val);
+  800685:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+  800689:	74 07                	je     800692 <strtol+0x158>
+  80068b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  80068e:	f7 d8                	neg    %eax
+  800690:	eb 03                	jmp    800695 <strtol+0x15b>
+  800692:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  800695:	c9                   	leave  
+  800696:	c3                   	ret    
+
+00800697 <memset>:
+ * @n:      number of bytes to be set to the value
+ *
+ * The memset() function returns @s.
+ * */
+void *
+memset(void *s, char c, size_t n) {
+  800697:	55                   	push   %ebp
+  800698:	89 e5                	mov    %esp,%ebp
+  80069a:	57                   	push   %edi
+  80069b:	83 ec 24             	sub    $0x24,%esp
+  80069e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006a1:	88 45 d8             	mov    %al,-0x28(%ebp)
+#ifdef __HAVE_ARCH_MEMSET
+    return __memset(s, c, n);
+  8006a4:	0f be 45 d8          	movsbl -0x28(%ebp),%eax
+  8006a8:	8b 55 08             	mov    0x8(%ebp),%edx
+  8006ab:	89 55 f8             	mov    %edx,-0x8(%ebp)
+  8006ae:	88 45 f7             	mov    %al,-0x9(%ebp)
+  8006b1:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_MEMSET
+#define __HAVE_ARCH_MEMSET
+static inline void *
+__memset(void *s, char c, size_t n) {
+    int d0, d1;
+    asm volatile (
+  8006b7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+  8006ba:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
+  8006be:	8b 55 f8             	mov    -0x8(%ebp),%edx
+  8006c1:	89 d7                	mov    %edx,%edi
+  8006c3:	f3 aa                	rep stos %al,%es:(%edi)
+  8006c5:	89 fa                	mov    %edi,%edx
+  8006c7:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  8006ca:	89 55 e8             	mov    %edx,-0x18(%ebp)
+        "rep; stosb;"
+        : "=&c" (d0), "=&D" (d1)
+        : "0" (n), "a" (c), "1" (s)
+        : "memory");
+    return s;
+  8006cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8006d0:	90                   	nop
+    while (n -- > 0) {
+        *p ++ = c;
+    }
+    return s;
+#endif /* __HAVE_ARCH_MEMSET */
+}
+  8006d1:	83 c4 24             	add    $0x24,%esp
+  8006d4:	5f                   	pop    %edi
+  8006d5:	5d                   	pop    %ebp
+  8006d6:	c3                   	ret    
+
+008006d7 <memmove>:
+ * @n:      number of bytes to copy
+ *
+ * The memmove() function returns @dst.
+ * */
+void *
+memmove(void *dst, const void *src, size_t n) {
+  8006d7:	55                   	push   %ebp
+  8006d8:	89 e5                	mov    %esp,%ebp
+  8006da:	57                   	push   %edi
+  8006db:	56                   	push   %esi
+  8006dc:	53                   	push   %ebx
+  8006dd:	83 ec 30             	sub    $0x30,%esp
+  8006e0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8006e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8006e6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  8006ec:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006ef:	89 45 e8             	mov    %eax,-0x18(%ebp)
+
+#ifndef __HAVE_ARCH_MEMMOVE
+#define __HAVE_ARCH_MEMMOVE
+static inline void *
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+  8006f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006f5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  8006f8:	73 42                	jae    80073c <memmove+0x65>
+  8006fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006fd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800700:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800703:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800706:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800709:	89 45 dc             	mov    %eax,-0x24(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  80070c:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  80070f:	c1 e8 02             	shr    $0x2,%eax
+  800712:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  800714:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800717:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80071a:	89 d7                	mov    %edx,%edi
+  80071c:	89 c6                	mov    %eax,%esi
+  80071e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800720:	8b 4d dc             	mov    -0x24(%ebp),%ecx
+  800723:	83 e1 03             	and    $0x3,%ecx
+  800726:	74 02                	je     80072a <memmove+0x53>
+  800728:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  80072a:	89 f0                	mov    %esi,%eax
+  80072c:	89 fa                	mov    %edi,%edx
+  80072e:	89 4d d8             	mov    %ecx,-0x28(%ebp)
+  800731:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  800734:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  800737:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMMOVE
+    return __memmove(dst, src, n);
+  80073a:	eb 36                	jmp    800772 <memmove+0x9b>
+    asm volatile (
+        "std;"
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+  80073c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80073f:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800742:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800745:	01 c2                	add    %eax,%edx
+  800747:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80074a:	8d 48 ff             	lea    -0x1(%eax),%ecx
+  80074d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800750:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+        return __memcpy(dst, src, n);
+    }
+    int d0, d1, d2;
+    asm volatile (
+  800753:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800756:	89 c1                	mov    %eax,%ecx
+  800758:	89 d8                	mov    %ebx,%eax
+  80075a:	89 d6                	mov    %edx,%esi
+  80075c:	89 c7                	mov    %eax,%edi
+  80075e:	fd                   	std    
+  80075f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  800761:	fc                   	cld    
+  800762:	89 f8                	mov    %edi,%eax
+  800764:	89 f2                	mov    %esi,%edx
+  800766:	89 4d cc             	mov    %ecx,-0x34(%ebp)
+  800769:	89 55 c8             	mov    %edx,-0x38(%ebp)
+  80076c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+        : "memory");
+    return dst;
+  80076f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+            *d ++ = *s ++;
+        }
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMMOVE */
+}
+  800772:	83 c4 30             	add    $0x30,%esp
+  800775:	5b                   	pop    %ebx
+  800776:	5e                   	pop    %esi
+  800777:	5f                   	pop    %edi
+  800778:	5d                   	pop    %ebp
+  800779:	c3                   	ret    
+
+0080077a <memcpy>:
+ * it always copies exactly @n bytes. To avoid overflows, the size of arrays pointed
+ * by both @src and @dst, should be at least @n bytes, and should not overlap
+ * (for overlapping memory area, memmove is a safer approach).
+ * */
+void *
+memcpy(void *dst, const void *src, size_t n) {
+  80077a:	55                   	push   %ebp
+  80077b:	89 e5                	mov    %esp,%ebp
+  80077d:	57                   	push   %edi
+  80077e:	56                   	push   %esi
+  80077f:	83 ec 20             	sub    $0x20,%esp
+  800782:	8b 45 08             	mov    0x8(%ebp),%eax
+  800785:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800788:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80078b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80078e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800791:	89 45 ec             	mov    %eax,-0x14(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  800794:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800797:	c1 e8 02             	shr    $0x2,%eax
+  80079a:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  80079c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80079f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8007a2:	89 d7                	mov    %edx,%edi
+  8007a4:	89 c6                	mov    %eax,%esi
+  8007a6:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  8007a8:	8b 4d ec             	mov    -0x14(%ebp),%ecx
+  8007ab:	83 e1 03             	and    $0x3,%ecx
+  8007ae:	74 02                	je     8007b2 <memcpy+0x38>
+  8007b0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  8007b2:	89 f0                	mov    %esi,%eax
+  8007b4:	89 fa                	mov    %edi,%edx
+  8007b6:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  8007b9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  8007bc:	89 45 e0             	mov    %eax,-0x20(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  8007bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMCPY
+    return __memcpy(dst, src, n);
+  8007c2:	90                   	nop
+    while (n -- > 0) {
+        *d ++ = *s ++;
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMCPY */
+}
+  8007c3:	83 c4 20             	add    $0x20,%esp
+  8007c6:	5e                   	pop    %esi
+  8007c7:	5f                   	pop    %edi
+  8007c8:	5d                   	pop    %ebp
+  8007c9:	c3                   	ret    
+
+008007ca <memcmp>:
+ *   match in both memory blocks has a greater value in @v1 than in @v2
+ *   as if evaluated as unsigned char values;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+  8007ca:	55                   	push   %ebp
+  8007cb:	89 e5                	mov    %esp,%ebp
+  8007cd:	83 ec 10             	sub    $0x10,%esp
+    const char *s1 = (const char *)v1;
+  8007d0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8007d3:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    const char *s2 = (const char *)v2;
+  8007d6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8007d9:	89 45 f8             	mov    %eax,-0x8(%ebp)
+    while (n -- > 0) {
+  8007dc:	eb 30                	jmp    80080e <memcmp+0x44>
+        if (*s1 != *s2) {
+  8007de:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8007e1:	0f b6 10             	movzbl (%eax),%edx
+  8007e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8007e7:	0f b6 00             	movzbl (%eax),%eax
+  8007ea:	38 c2                	cmp    %al,%dl
+  8007ec:	74 18                	je     800806 <memcmp+0x3c>
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+  8007ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8007f1:	0f b6 00             	movzbl (%eax),%eax
+  8007f4:	0f b6 d0             	movzbl %al,%edx
+  8007f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8007fa:	0f b6 00             	movzbl (%eax),%eax
+  8007fd:	0f b6 c0             	movzbl %al,%eax
+  800800:	29 c2                	sub    %eax,%edx
+  800802:	89 d0                	mov    %edx,%eax
+  800804:	eb 1a                	jmp    800820 <memcmp+0x56>
+        }
+        s1 ++, s2 ++;
+  800806:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  80080a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+    const char *s1 = (const char *)v1;
+    const char *s2 = (const char *)v2;
+    while (n -- > 0) {
+  80080e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800811:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800814:	89 55 10             	mov    %edx,0x10(%ebp)
+  800817:	85 c0                	test   %eax,%eax
+  800819:	75 c3                	jne    8007de <memcmp+0x14>
+        if (*s1 != *s2) {
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+        }
+        s1 ++, s2 ++;
+    }
+    return 0;
+  80081b:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800820:	c9                   	leave  
+  800821:	c3                   	ret    
+
+00800822 <printnum>:
+ * @width:      maximum number of digits, if the actual width is less than @width, use @padc instead
+ * @padc:       character that padded on the left if the actual width is less than @width
+ * */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+        unsigned long long num, unsigned base, int width, int padc) {
+  800822:	55                   	push   %ebp
+  800823:	89 e5                	mov    %esp,%ebp
+  800825:	83 ec 38             	sub    $0x38,%esp
+  800828:	8b 45 10             	mov    0x10(%ebp),%eax
+  80082b:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  80082e:	8b 45 14             	mov    0x14(%ebp),%eax
+  800831:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+    unsigned long long result = num;
+  800834:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  800837:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  80083a:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  80083d:	89 55 ec             	mov    %edx,-0x14(%ebp)
+    unsigned mod = do_div(result, base);
+  800840:	8b 45 18             	mov    0x18(%ebp),%eax
+  800843:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800846:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800849:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  80084c:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  80084f:	89 55 f0             	mov    %edx,-0x10(%ebp)
+  800852:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800855:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800858:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  80085c:	74 1c                	je     80087a <printnum+0x58>
+  80085e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800861:	ba 00 00 00 00       	mov    $0x0,%edx
+  800866:	f7 75 e4             	divl   -0x1c(%ebp)
+  800869:	89 55 f4             	mov    %edx,-0xc(%ebp)
+  80086c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  80086f:	ba 00 00 00 00       	mov    $0x0,%edx
+  800874:	f7 75 e4             	divl   -0x1c(%ebp)
+  800877:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80087a:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80087d:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800880:	f7 75 e4             	divl   -0x1c(%ebp)
+  800883:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800886:	89 55 dc             	mov    %edx,-0x24(%ebp)
+  800889:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80088c:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  80088f:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800892:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  800895:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  800898:	89 45 d8             	mov    %eax,-0x28(%ebp)
+
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+  80089b:	8b 45 18             	mov    0x18(%ebp),%eax
+  80089e:	ba 00 00 00 00       	mov    $0x0,%edx
+  8008a3:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  8008a6:	77 41                	ja     8008e9 <printnum+0xc7>
+  8008a8:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  8008ab:	72 05                	jb     8008b2 <printnum+0x90>
+  8008ad:	3b 45 d0             	cmp    -0x30(%ebp),%eax
+  8008b0:	77 37                	ja     8008e9 <printnum+0xc7>
+        printnum(putch, putdat, result, base, width - 1, padc);
+  8008b2:	8b 45 1c             	mov    0x1c(%ebp),%eax
+  8008b5:	83 e8 01             	sub    $0x1,%eax
+  8008b8:	83 ec 04             	sub    $0x4,%esp
+  8008bb:	ff 75 20             	pushl  0x20(%ebp)
+  8008be:	50                   	push   %eax
+  8008bf:	ff 75 18             	pushl  0x18(%ebp)
+  8008c2:	ff 75 ec             	pushl  -0x14(%ebp)
+  8008c5:	ff 75 e8             	pushl  -0x18(%ebp)
+  8008c8:	ff 75 0c             	pushl  0xc(%ebp)
+  8008cb:	ff 75 08             	pushl  0x8(%ebp)
+  8008ce:	e8 4f ff ff ff       	call   800822 <printnum>
+  8008d3:	83 c4 20             	add    $0x20,%esp
+  8008d6:	eb 1b                	jmp    8008f3 <printnum+0xd1>
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+            putch(padc, putdat);
+  8008d8:	83 ec 08             	sub    $0x8,%esp
+  8008db:	ff 75 0c             	pushl  0xc(%ebp)
+  8008de:	ff 75 20             	pushl  0x20(%ebp)
+  8008e1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8008e4:	ff d0                	call   *%eax
+  8008e6:	83 c4 10             	add    $0x10,%esp
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+        printnum(putch, putdat, result, base, width - 1, padc);
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+  8008e9:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+  8008ed:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+  8008f1:	7f e5                	jg     8008d8 <printnum+0xb6>
+            putch(padc, putdat);
+    }
+    // then print this (the least significant) digit
+    putch("0123456789abcdef"[mod], putdat);
+  8008f3:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  8008f6:	05 c4 10 80 00       	add    $0x8010c4,%eax
+  8008fb:	0f b6 00             	movzbl (%eax),%eax
+  8008fe:	0f be c0             	movsbl %al,%eax
+  800901:	83 ec 08             	sub    $0x8,%esp
+  800904:	ff 75 0c             	pushl  0xc(%ebp)
+  800907:	50                   	push   %eax
+  800908:	8b 45 08             	mov    0x8(%ebp),%eax
+  80090b:	ff d0                	call   *%eax
+  80090d:	83 c4 10             	add    $0x10,%esp
+}
+  800910:	90                   	nop
+  800911:	c9                   	leave  
+  800912:	c3                   	ret    
+
+00800913 <getuint>:
+ * getuint - get an unsigned int of various possible sizes from a varargs list
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static unsigned long long
+getuint(va_list *ap, int lflag) {
+  800913:	55                   	push   %ebp
+  800914:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  800916:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  80091a:	7e 14                	jle    800930 <getuint+0x1d>
+        return va_arg(*ap, unsigned long long);
+  80091c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80091f:	8b 00                	mov    (%eax),%eax
+  800921:	8d 48 08             	lea    0x8(%eax),%ecx
+  800924:	8b 55 08             	mov    0x8(%ebp),%edx
+  800927:	89 0a                	mov    %ecx,(%edx)
+  800929:	8b 50 04             	mov    0x4(%eax),%edx
+  80092c:	8b 00                	mov    (%eax),%eax
+  80092e:	eb 30                	jmp    800960 <getuint+0x4d>
+    }
+    else if (lflag) {
+  800930:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800934:	74 16                	je     80094c <getuint+0x39>
+        return va_arg(*ap, unsigned long);
+  800936:	8b 45 08             	mov    0x8(%ebp),%eax
+  800939:	8b 00                	mov    (%eax),%eax
+  80093b:	8d 48 04             	lea    0x4(%eax),%ecx
+  80093e:	8b 55 08             	mov    0x8(%ebp),%edx
+  800941:	89 0a                	mov    %ecx,(%edx)
+  800943:	8b 00                	mov    (%eax),%eax
+  800945:	ba 00 00 00 00       	mov    $0x0,%edx
+  80094a:	eb 14                	jmp    800960 <getuint+0x4d>
+    }
+    else {
+        return va_arg(*ap, unsigned int);
+  80094c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80094f:	8b 00                	mov    (%eax),%eax
+  800951:	8d 48 04             	lea    0x4(%eax),%ecx
+  800954:	8b 55 08             	mov    0x8(%ebp),%edx
+  800957:	89 0a                	mov    %ecx,(%edx)
+  800959:	8b 00                	mov    (%eax),%eax
+  80095b:	ba 00 00 00 00       	mov    $0x0,%edx
+    }
+}
+  800960:	5d                   	pop    %ebp
+  800961:	c3                   	ret    
+
+00800962 <getint>:
+ * getint - same as getuint but signed, we can't use getuint because of sign extension
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static long long
+getint(va_list *ap, int lflag) {
+  800962:	55                   	push   %ebp
+  800963:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  800965:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  800969:	7e 14                	jle    80097f <getint+0x1d>
+        return va_arg(*ap, long long);
+  80096b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80096e:	8b 00                	mov    (%eax),%eax
+  800970:	8d 48 08             	lea    0x8(%eax),%ecx
+  800973:	8b 55 08             	mov    0x8(%ebp),%edx
+  800976:	89 0a                	mov    %ecx,(%edx)
+  800978:	8b 50 04             	mov    0x4(%eax),%edx
+  80097b:	8b 00                	mov    (%eax),%eax
+  80097d:	eb 28                	jmp    8009a7 <getint+0x45>
+    }
+    else if (lflag) {
+  80097f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800983:	74 12                	je     800997 <getint+0x35>
+        return va_arg(*ap, long);
+  800985:	8b 45 08             	mov    0x8(%ebp),%eax
+  800988:	8b 00                	mov    (%eax),%eax
+  80098a:	8d 48 04             	lea    0x4(%eax),%ecx
+  80098d:	8b 55 08             	mov    0x8(%ebp),%edx
+  800990:	89 0a                	mov    %ecx,(%edx)
+  800992:	8b 00                	mov    (%eax),%eax
+  800994:	99                   	cltd   
+  800995:	eb 10                	jmp    8009a7 <getint+0x45>
+    }
+    else {
+        return va_arg(*ap, int);
+  800997:	8b 45 08             	mov    0x8(%ebp),%eax
+  80099a:	8b 00                	mov    (%eax),%eax
+  80099c:	8d 48 04             	lea    0x4(%eax),%ecx
+  80099f:	8b 55 08             	mov    0x8(%ebp),%edx
+  8009a2:	89 0a                	mov    %ecx,(%edx)
+  8009a4:	8b 00                	mov    (%eax),%eax
+  8009a6:	99                   	cltd   
+    }
+}
+  8009a7:	5d                   	pop    %ebp
+  8009a8:	c3                   	ret    
+
+008009a9 <printfmt>:
+ * @putch:      specified putch function, print a single character
+ * @putdat:     used by @putch function
+ * @fmt:        the format string to use
+ * */
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...) {
+  8009a9:	55                   	push   %ebp
+  8009aa:	89 e5                	mov    %esp,%ebp
+  8009ac:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  8009af:	8d 45 14             	lea    0x14(%ebp),%eax
+  8009b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    vprintfmt(putch, putdat, fmt, ap);
+  8009b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8009b8:	50                   	push   %eax
+  8009b9:	ff 75 10             	pushl  0x10(%ebp)
+  8009bc:	ff 75 0c             	pushl  0xc(%ebp)
+  8009bf:	ff 75 08             	pushl  0x8(%ebp)
+  8009c2:	e8 06 00 00 00       	call   8009cd <vprintfmt>
+  8009c7:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+  8009ca:	90                   	nop
+  8009cb:	c9                   	leave  
+  8009cc:	c3                   	ret    
+
+008009cd <vprintfmt>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want printfmt() instead.
+ * */
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap) {
+  8009cd:	55                   	push   %ebp
+  8009ce:	89 e5                	mov    %esp,%ebp
+  8009d0:	56                   	push   %esi
+  8009d1:	53                   	push   %ebx
+  8009d2:	83 ec 20             	sub    $0x20,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  8009d5:	eb 17                	jmp    8009ee <vprintfmt+0x21>
+            if (ch == '\0') {
+  8009d7:	85 db                	test   %ebx,%ebx
+  8009d9:	0f 84 8e 03 00 00    	je     800d6d <vprintfmt+0x3a0>
+                return;
+            }
+            putch(ch, putdat);
+  8009df:	83 ec 08             	sub    $0x8,%esp
+  8009e2:	ff 75 0c             	pushl  0xc(%ebp)
+  8009e5:	53                   	push   %ebx
+  8009e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009e9:	ff d0                	call   *%eax
+  8009eb:	83 c4 10             	add    $0x10,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  8009ee:	8b 45 10             	mov    0x10(%ebp),%eax
+  8009f1:	8d 50 01             	lea    0x1(%eax),%edx
+  8009f4:	89 55 10             	mov    %edx,0x10(%ebp)
+  8009f7:	0f b6 00             	movzbl (%eax),%eax
+  8009fa:	0f b6 d8             	movzbl %al,%ebx
+  8009fd:	83 fb 25             	cmp    $0x25,%ebx
+  800a00:	75 d5                	jne    8009d7 <vprintfmt+0xa>
+            }
+            putch(ch, putdat);
+        }
+
+        // Process a %-escape sequence
+        char padc = ' ';
+  800a02:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+        width = precision = -1;
+  800a06:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+  800a0d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800a10:	89 45 e8             	mov    %eax,-0x18(%ebp)
+        lflag = altflag = 0;
+  800a13:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+  800a1a:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  800a1d:	89 45 e0             	mov    %eax,-0x20(%ebp)
+
+    reswitch:
+        switch (ch = *(unsigned char *)fmt ++) {
+  800a20:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a23:	8d 50 01             	lea    0x1(%eax),%edx
+  800a26:	89 55 10             	mov    %edx,0x10(%ebp)
+  800a29:	0f b6 00             	movzbl (%eax),%eax
+  800a2c:	0f b6 d8             	movzbl %al,%ebx
+  800a2f:	8d 43 dd             	lea    -0x23(%ebx),%eax
+  800a32:	83 f8 55             	cmp    $0x55,%eax
+  800a35:	0f 87 05 03 00 00    	ja     800d40 <vprintfmt+0x373>
+  800a3b:	8b 04 85 e8 10 80 00 	mov    0x8010e8(,%eax,4),%eax
+  800a42:	ff e0                	jmp    *%eax
+
+        // flag to pad on the right
+        case '-':
+            padc = '-';
+  800a44:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+            goto reswitch;
+  800a48:	eb d6                	jmp    800a20 <vprintfmt+0x53>
+
+        // flag to pad with 0's instead of spaces
+        case '0':
+            padc = '0';
+  800a4a:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+            goto reswitch;
+  800a4e:	eb d0                	jmp    800a20 <vprintfmt+0x53>
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  800a50:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+                precision = precision * 10 + ch - '0';
+  800a57:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800a5a:	89 d0                	mov    %edx,%eax
+  800a5c:	c1 e0 02             	shl    $0x2,%eax
+  800a5f:	01 d0                	add    %edx,%eax
+  800a61:	01 c0                	add    %eax,%eax
+  800a63:	01 d8                	add    %ebx,%eax
+  800a65:	83 e8 30             	sub    $0x30,%eax
+  800a68:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+                ch = *fmt;
+  800a6b:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a6e:	0f b6 00             	movzbl (%eax),%eax
+  800a71:	0f be d8             	movsbl %al,%ebx
+                if (ch < '0' || ch > '9') {
+  800a74:	83 fb 2f             	cmp    $0x2f,%ebx
+  800a77:	7e 39                	jle    800ab2 <vprintfmt+0xe5>
+  800a79:	83 fb 39             	cmp    $0x39,%ebx
+  800a7c:	7f 34                	jg     800ab2 <vprintfmt+0xe5>
+            padc = '0';
+            goto reswitch;
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  800a7e:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+                precision = precision * 10 + ch - '0';
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+  800a82:	eb d3                	jmp    800a57 <vprintfmt+0x8a>
+            goto process_precision;
+
+        case '*':
+            precision = va_arg(ap, int);
+  800a84:	8b 45 14             	mov    0x14(%ebp),%eax
+  800a87:	8d 50 04             	lea    0x4(%eax),%edx
+  800a8a:	89 55 14             	mov    %edx,0x14(%ebp)
+  800a8d:	8b 00                	mov    (%eax),%eax
+  800a8f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+            goto process_precision;
+  800a92:	eb 1f                	jmp    800ab3 <vprintfmt+0xe6>
+
+        case '.':
+            if (width < 0)
+  800a94:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800a98:	79 86                	jns    800a20 <vprintfmt+0x53>
+                width = 0;
+  800a9a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+            goto reswitch;
+  800aa1:	e9 7a ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        case '#':
+            altflag = 1;
+  800aa6:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+            goto reswitch;
+  800aad:	e9 6e ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+            goto process_precision;
+  800ab2:	90                   	nop
+        case '#':
+            altflag = 1;
+            goto reswitch;
+
+        process_precision:
+            if (width < 0)
+  800ab3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ab7:	0f 89 63 ff ff ff    	jns    800a20 <vprintfmt+0x53>
+                width = precision, precision = -1;
+  800abd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800ac0:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800ac3:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+            goto reswitch;
+  800aca:	e9 51 ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        // long flag (doubled for long long)
+        case 'l':
+            lflag ++;
+  800acf:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
+            goto reswitch;
+  800ad3:	e9 48 ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        // character
+        case 'c':
+            putch(va_arg(ap, int), putdat);
+  800ad8:	8b 45 14             	mov    0x14(%ebp),%eax
+  800adb:	8d 50 04             	lea    0x4(%eax),%edx
+  800ade:	89 55 14             	mov    %edx,0x14(%ebp)
+  800ae1:	8b 00                	mov    (%eax),%eax
+  800ae3:	83 ec 08             	sub    $0x8,%esp
+  800ae6:	ff 75 0c             	pushl  0xc(%ebp)
+  800ae9:	50                   	push   %eax
+  800aea:	8b 45 08             	mov    0x8(%ebp),%eax
+  800aed:	ff d0                	call   *%eax
+  800aef:	83 c4 10             	add    $0x10,%esp
+            break;
+  800af2:	e9 71 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // error message
+        case 'e':
+            err = va_arg(ap, int);
+  800af7:	8b 45 14             	mov    0x14(%ebp),%eax
+  800afa:	8d 50 04             	lea    0x4(%eax),%edx
+  800afd:	89 55 14             	mov    %edx,0x14(%ebp)
+  800b00:	8b 18                	mov    (%eax),%ebx
+            if (err < 0) {
+  800b02:	85 db                	test   %ebx,%ebx
+  800b04:	79 02                	jns    800b08 <vprintfmt+0x13b>
+                err = -err;
+  800b06:	f7 db                	neg    %ebx
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+  800b08:	83 fb 18             	cmp    $0x18,%ebx
+  800b0b:	7f 0b                	jg     800b18 <vprintfmt+0x14b>
+  800b0d:	8b 34 9d 60 10 80 00 	mov    0x801060(,%ebx,4),%esi
+  800b14:	85 f6                	test   %esi,%esi
+  800b16:	75 19                	jne    800b31 <vprintfmt+0x164>
+                printfmt(putch, putdat, "error %d", err);
+  800b18:	53                   	push   %ebx
+  800b19:	68 d5 10 80 00       	push   $0x8010d5
+  800b1e:	ff 75 0c             	pushl  0xc(%ebp)
+  800b21:	ff 75 08             	pushl  0x8(%ebp)
+  800b24:	e8 80 fe ff ff       	call   8009a9 <printfmt>
+  800b29:	83 c4 10             	add    $0x10,%esp
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+            }
+            break;
+  800b2c:	e9 37 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+                printfmt(putch, putdat, "error %d", err);
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+  800b31:	56                   	push   %esi
+  800b32:	68 de 10 80 00       	push   $0x8010de
+  800b37:	ff 75 0c             	pushl  0xc(%ebp)
+  800b3a:	ff 75 08             	pushl  0x8(%ebp)
+  800b3d:	e8 67 fe ff ff       	call   8009a9 <printfmt>
+  800b42:	83 c4 10             	add    $0x10,%esp
+            }
+            break;
+  800b45:	e9 1e 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // string
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+  800b4a:	8b 45 14             	mov    0x14(%ebp),%eax
+  800b4d:	8d 50 04             	lea    0x4(%eax),%edx
+  800b50:	89 55 14             	mov    %edx,0x14(%ebp)
+  800b53:	8b 30                	mov    (%eax),%esi
+  800b55:	85 f6                	test   %esi,%esi
+  800b57:	75 05                	jne    800b5e <vprintfmt+0x191>
+                p = "(null)";
+  800b59:	be e1 10 80 00       	mov    $0x8010e1,%esi
+            }
+            if (width > 0 && padc != '-') {
+  800b5e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800b62:	7e 76                	jle    800bda <vprintfmt+0x20d>
+  800b64:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+  800b68:	74 70                	je     800bda <vprintfmt+0x20d>
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  800b6a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800b6d:	83 ec 08             	sub    $0x8,%esp
+  800b70:	50                   	push   %eax
+  800b71:	56                   	push   %esi
+  800b72:	e8 17 f8 ff ff       	call   80038e <strnlen>
+  800b77:	83 c4 10             	add    $0x10,%esp
+  800b7a:	89 c2                	mov    %eax,%edx
+  800b7c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800b7f:	29 d0                	sub    %edx,%eax
+  800b81:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800b84:	eb 17                	jmp    800b9d <vprintfmt+0x1d0>
+                    putch(padc, putdat);
+  800b86:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+  800b8a:	83 ec 08             	sub    $0x8,%esp
+  800b8d:	ff 75 0c             	pushl  0xc(%ebp)
+  800b90:	50                   	push   %eax
+  800b91:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b94:	ff d0                	call   *%eax
+  800b96:	83 c4 10             	add    $0x10,%esp
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+                p = "(null)";
+            }
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  800b99:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800b9d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ba1:	7f e3                	jg     800b86 <vprintfmt+0x1b9>
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  800ba3:	eb 35                	jmp    800bda <vprintfmt+0x20d>
+                if (altflag && (ch < ' ' || ch > '~')) {
+  800ba5:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+  800ba9:	74 1c                	je     800bc7 <vprintfmt+0x1fa>
+  800bab:	83 fb 1f             	cmp    $0x1f,%ebx
+  800bae:	7e 05                	jle    800bb5 <vprintfmt+0x1e8>
+  800bb0:	83 fb 7e             	cmp    $0x7e,%ebx
+  800bb3:	7e 12                	jle    800bc7 <vprintfmt+0x1fa>
+                    putch('?', putdat);
+  800bb5:	83 ec 08             	sub    $0x8,%esp
+  800bb8:	ff 75 0c             	pushl  0xc(%ebp)
+  800bbb:	6a 3f                	push   $0x3f
+  800bbd:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bc0:	ff d0                	call   *%eax
+  800bc2:	83 c4 10             	add    $0x10,%esp
+  800bc5:	eb 0f                	jmp    800bd6 <vprintfmt+0x209>
+                }
+                else {
+                    putch(ch, putdat);
+  800bc7:	83 ec 08             	sub    $0x8,%esp
+  800bca:	ff 75 0c             	pushl  0xc(%ebp)
+  800bcd:	53                   	push   %ebx
+  800bce:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bd1:	ff d0                	call   *%eax
+  800bd3:	83 c4 10             	add    $0x10,%esp
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  800bd6:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800bda:	89 f0                	mov    %esi,%eax
+  800bdc:	8d 70 01             	lea    0x1(%eax),%esi
+  800bdf:	0f b6 00             	movzbl (%eax),%eax
+  800be2:	0f be d8             	movsbl %al,%ebx
+  800be5:	85 db                	test   %ebx,%ebx
+  800be7:	74 26                	je     800c0f <vprintfmt+0x242>
+  800be9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800bed:	78 b6                	js     800ba5 <vprintfmt+0x1d8>
+  800bef:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800bf3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800bf7:	79 ac                	jns    800ba5 <vprintfmt+0x1d8>
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  800bf9:	eb 14                	jmp    800c0f <vprintfmt+0x242>
+                putch(' ', putdat);
+  800bfb:	83 ec 08             	sub    $0x8,%esp
+  800bfe:	ff 75 0c             	pushl  0xc(%ebp)
+  800c01:	6a 20                	push   $0x20
+  800c03:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c06:	ff d0                	call   *%eax
+  800c08:	83 c4 10             	add    $0x10,%esp
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  800c0b:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800c0f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800c13:	7f e6                	jg     800bfb <vprintfmt+0x22e>
+                putch(' ', putdat);
+            }
+            break;
+  800c15:	e9 4e 01 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // (signed) decimal
+        case 'd':
+            num = getint(&ap, lflag);
+  800c1a:	83 ec 08             	sub    $0x8,%esp
+  800c1d:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c20:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c23:	50                   	push   %eax
+  800c24:	e8 39 fd ff ff       	call   800962 <getint>
+  800c29:	83 c4 10             	add    $0x10,%esp
+  800c2c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c2f:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            if ((long long)num < 0) {
+  800c32:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c35:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800c38:	85 d2                	test   %edx,%edx
+  800c3a:	79 23                	jns    800c5f <vprintfmt+0x292>
+                putch('-', putdat);
+  800c3c:	83 ec 08             	sub    $0x8,%esp
+  800c3f:	ff 75 0c             	pushl  0xc(%ebp)
+  800c42:	6a 2d                	push   $0x2d
+  800c44:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c47:	ff d0                	call   *%eax
+  800c49:	83 c4 10             	add    $0x10,%esp
+                num = -(long long)num;
+  800c4c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c4f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800c52:	f7 d8                	neg    %eax
+  800c54:	83 d2 00             	adc    $0x0,%edx
+  800c57:	f7 da                	neg    %edx
+  800c59:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c5c:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            }
+            base = 10;
+  800c5f:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  800c66:	e9 9f 00 00 00       	jmp    800d0a <vprintfmt+0x33d>
+
+        // unsigned decimal
+        case 'u':
+            num = getuint(&ap, lflag);
+  800c6b:	83 ec 08             	sub    $0x8,%esp
+  800c6e:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c71:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c74:	50                   	push   %eax
+  800c75:	e8 99 fc ff ff       	call   800913 <getuint>
+  800c7a:	83 c4 10             	add    $0x10,%esp
+  800c7d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c80:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 10;
+  800c83:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  800c8a:	eb 7e                	jmp    800d0a <vprintfmt+0x33d>
+
+        // (unsigned) octal
+        case 'o':
+            num = getuint(&ap, lflag);
+  800c8c:	83 ec 08             	sub    $0x8,%esp
+  800c8f:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c92:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c95:	50                   	push   %eax
+  800c96:	e8 78 fc ff ff       	call   800913 <getuint>
+  800c9b:	83 c4 10             	add    $0x10,%esp
+  800c9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800ca1:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 8;
+  800ca4:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+            goto number;
+  800cab:	eb 5d                	jmp    800d0a <vprintfmt+0x33d>
+
+        // pointer
+        case 'p':
+            putch('0', putdat);
+  800cad:	83 ec 08             	sub    $0x8,%esp
+  800cb0:	ff 75 0c             	pushl  0xc(%ebp)
+  800cb3:	6a 30                	push   $0x30
+  800cb5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cb8:	ff d0                	call   *%eax
+  800cba:	83 c4 10             	add    $0x10,%esp
+            putch('x', putdat);
+  800cbd:	83 ec 08             	sub    $0x8,%esp
+  800cc0:	ff 75 0c             	pushl  0xc(%ebp)
+  800cc3:	6a 78                	push   $0x78
+  800cc5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cc8:	ff d0                	call   *%eax
+  800cca:	83 c4 10             	add    $0x10,%esp
+            num = (unsigned long long)(uintptr_t)va_arg(ap, void *);
+  800ccd:	8b 45 14             	mov    0x14(%ebp),%eax
+  800cd0:	8d 50 04             	lea    0x4(%eax),%edx
+  800cd3:	89 55 14             	mov    %edx,0x14(%ebp)
+  800cd6:	8b 00                	mov    (%eax),%eax
+  800cd8:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800cdb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+            base = 16;
+  800ce2:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+            goto number;
+  800ce9:	eb 1f                	jmp    800d0a <vprintfmt+0x33d>
+
+        // (unsigned) hexadecimal
+        case 'x':
+            num = getuint(&ap, lflag);
+  800ceb:	83 ec 08             	sub    $0x8,%esp
+  800cee:	ff 75 e0             	pushl  -0x20(%ebp)
+  800cf1:	8d 45 14             	lea    0x14(%ebp),%eax
+  800cf4:	50                   	push   %eax
+  800cf5:	e8 19 fc ff ff       	call   800913 <getuint>
+  800cfa:	83 c4 10             	add    $0x10,%esp
+  800cfd:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800d00:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 16;
+  800d03:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+        number:
+            printnum(putch, putdat, num, base, width, padc);
+  800d0a:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+  800d0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800d11:	83 ec 04             	sub    $0x4,%esp
+  800d14:	52                   	push   %edx
+  800d15:	ff 75 e8             	pushl  -0x18(%ebp)
+  800d18:	50                   	push   %eax
+  800d19:	ff 75 f4             	pushl  -0xc(%ebp)
+  800d1c:	ff 75 f0             	pushl  -0x10(%ebp)
+  800d1f:	ff 75 0c             	pushl  0xc(%ebp)
+  800d22:	ff 75 08             	pushl  0x8(%ebp)
+  800d25:	e8 f8 fa ff ff       	call   800822 <printnum>
+  800d2a:	83 c4 20             	add    $0x20,%esp
+            break;
+  800d2d:	eb 39                	jmp    800d68 <vprintfmt+0x39b>
+
+        // escaped '%' character
+        case '%':
+            putch(ch, putdat);
+  800d2f:	83 ec 08             	sub    $0x8,%esp
+  800d32:	ff 75 0c             	pushl  0xc(%ebp)
+  800d35:	53                   	push   %ebx
+  800d36:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d39:	ff d0                	call   *%eax
+  800d3b:	83 c4 10             	add    $0x10,%esp
+            break;
+  800d3e:	eb 28                	jmp    800d68 <vprintfmt+0x39b>
+
+        // unrecognized escape sequence - just print it literally
+        default:
+            putch('%', putdat);
+  800d40:	83 ec 08             	sub    $0x8,%esp
+  800d43:	ff 75 0c             	pushl  0xc(%ebp)
+  800d46:	6a 25                	push   $0x25
+  800d48:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d4b:	ff d0                	call   *%eax
+  800d4d:	83 c4 10             	add    $0x10,%esp
+            for (fmt --; fmt[-1] != '%'; fmt --)
+  800d50:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800d54:	eb 04                	jmp    800d5a <vprintfmt+0x38d>
+  800d56:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800d5a:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d5d:	83 e8 01             	sub    $0x1,%eax
+  800d60:	0f b6 00             	movzbl (%eax),%eax
+  800d63:	3c 25                	cmp    $0x25,%al
+  800d65:	75 ef                	jne    800d56 <vprintfmt+0x389>
+                /* do nothing */;
+            break;
+  800d67:	90                   	nop
+        }
+    }
+  800d68:	e9 68 fc ff ff       	jmp    8009d5 <vprintfmt+0x8>
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+            if (ch == '\0') {
+                return;
+  800d6d:	90                   	nop
+            for (fmt --; fmt[-1] != '%'; fmt --)
+                /* do nothing */;
+            break;
+        }
+    }
+}
+  800d6e:	8d 65 f8             	lea    -0x8(%ebp),%esp
+  800d71:	5b                   	pop    %ebx
+  800d72:	5e                   	pop    %esi
+  800d73:	5d                   	pop    %ebp
+  800d74:	c3                   	ret    
+
+00800d75 <sprintputch>:
+ * sprintputch - 'print' a single character in a buffer
+ * @ch:         the character will be printed
+ * @b:          the buffer to place the character @ch
+ * */
+static void
+sprintputch(int ch, struct sprintbuf *b) {
+  800d75:	55                   	push   %ebp
+  800d76:	89 e5                	mov    %esp,%ebp
+    b->cnt ++;
+  800d78:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d7b:	8b 40 08             	mov    0x8(%eax),%eax
+  800d7e:	8d 50 01             	lea    0x1(%eax),%edx
+  800d81:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d84:	89 50 08             	mov    %edx,0x8(%eax)
+    if (b->buf < b->ebuf) {
+  800d87:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8a:	8b 10                	mov    (%eax),%edx
+  800d8c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8f:	8b 40 04             	mov    0x4(%eax),%eax
+  800d92:	39 c2                	cmp    %eax,%edx
+  800d94:	73 12                	jae    800da8 <sprintputch+0x33>
+        *b->buf ++ = ch;
+  800d96:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d99:	8b 00                	mov    (%eax),%eax
+  800d9b:	8d 48 01             	lea    0x1(%eax),%ecx
+  800d9e:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800da1:	89 0a                	mov    %ecx,(%edx)
+  800da3:	8b 55 08             	mov    0x8(%ebp),%edx
+  800da6:	88 10                	mov    %dl,(%eax)
+    }
+}
+  800da8:	90                   	nop
+  800da9:	5d                   	pop    %ebp
+  800daa:	c3                   	ret    
+
+00800dab <snprintf>:
+ * @str:        the buffer to place the result into
+ * @size:       the size of buffer, including the trailing null space
+ * @fmt:        the format string to use
+ * */
+int
+snprintf(char *str, size_t size, const char *fmt, ...) {
+  800dab:	55                   	push   %ebp
+  800dac:	89 e5                	mov    %esp,%ebp
+  800dae:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    int cnt;
+    va_start(ap, fmt);
+  800db1:	8d 45 14             	lea    0x14(%ebp),%eax
+  800db4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    cnt = vsnprintf(str, size, fmt, ap);
+  800db7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800dba:	50                   	push   %eax
+  800dbb:	ff 75 10             	pushl  0x10(%ebp)
+  800dbe:	ff 75 0c             	pushl  0xc(%ebp)
+  800dc1:	ff 75 08             	pushl  0x8(%ebp)
+  800dc4:	e8 0b 00 00 00       	call   800dd4 <vsnprintf>
+  800dc9:	83 c4 10             	add    $0x10,%esp
+  800dcc:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+    return cnt;
+  800dcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800dd2:	c9                   	leave  
+  800dd3:	c3                   	ret    
+
+00800dd4 <vsnprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want snprintf() instead.
+ * */
+int
+vsnprintf(char *str, size_t size, const char *fmt, va_list ap) {
+  800dd4:	55                   	push   %ebp
+  800dd5:	89 e5                	mov    %esp,%ebp
+  800dd7:	83 ec 18             	sub    $0x18,%esp
+    struct sprintbuf b = {str, str + size - 1, 0};
+  800dda:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ddd:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800de0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800de3:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800de6:	8b 45 08             	mov    0x8(%ebp),%eax
+  800de9:	01 d0                	add    %edx,%eax
+  800deb:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800dee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    if (str == NULL || b.buf > b.ebuf) {
+  800df5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  800df9:	74 0a                	je     800e05 <vsnprintf+0x31>
+  800dfb:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  800dfe:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800e01:	39 c2                	cmp    %eax,%edx
+  800e03:	76 07                	jbe    800e0c <vsnprintf+0x38>
+        return -E_INVAL;
+  800e05:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+  800e0a:	eb 20                	jmp    800e2c <vsnprintf+0x58>
+    }
+    // print the string to the buffer
+    vprintfmt((void*)sprintputch, &b, fmt, ap);
+  800e0c:	ff 75 14             	pushl  0x14(%ebp)
+  800e0f:	ff 75 10             	pushl  0x10(%ebp)
+  800e12:	8d 45 ec             	lea    -0x14(%ebp),%eax
+  800e15:	50                   	push   %eax
+  800e16:	68 75 0d 80 00       	push   $0x800d75
+  800e1b:	e8 ad fb ff ff       	call   8009cd <vprintfmt>
+  800e20:	83 c4 10             	add    $0x10,%esp
+    // null terminate the buffer
+    *b.buf = '\0';
+  800e23:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e26:	c6 00 00             	movb   $0x0,(%eax)
+    return b.cnt;
+  800e29:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800e2c:	c9                   	leave  
+  800e2d:	c3                   	ret    
+
+00800e2e <hash32>:
+ * @bits:   the number of bits in a return value
+ *
+ * High bits are more random, so we use them.
+ * */
+uint32_t
+hash32(uint32_t val, unsigned int bits) {
+  800e2e:	55                   	push   %ebp
+  800e2f:	89 e5                	mov    %esp,%ebp
+  800e31:	83 ec 10             	sub    $0x10,%esp
+    uint32_t hash = val * GOLDEN_RATIO_PRIME_32;
+  800e34:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e37:	69 c0 01 00 37 9e    	imul   $0x9e370001,%eax,%eax
+  800e3d:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    return (hash >> (32 - bits));
+  800e40:	b8 20 00 00 00       	mov    $0x20,%eax
+  800e45:	2b 45 0c             	sub    0xc(%ebp),%eax
+  800e48:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  800e4b:	89 c1                	mov    %eax,%ecx
+  800e4d:	d3 ea                	shr    %cl,%edx
+  800e4f:	89 d0                	mov    %edx,%eax
+}
+  800e51:	c9                   	leave  
+  800e52:	c3                   	ret    
+
+00800e53 <rand>:
+ * rand - returns a pseudo-random integer
+ *
+ * The rand() function return a value in the range [0, RAND_MAX].
+ * */
+int
+rand(void) {
+  800e53:	55                   	push   %ebp
+  800e54:	89 e5                	mov    %esp,%ebp
+  800e56:	57                   	push   %edi
+  800e57:	56                   	push   %esi
+  800e58:	53                   	push   %ebx
+  800e59:	83 ec 24             	sub    $0x24,%esp
+    next = (next * 0x5DEECE66DLL + 0xBLL) & ((1LL << 48) - 1);
+  800e5c:	a1 00 20 80 00       	mov    0x802000,%eax
+  800e61:	8b 15 04 20 80 00    	mov    0x802004,%edx
+  800e67:	69 fa 6d e6 ec de    	imul   $0xdeece66d,%edx,%edi
+  800e6d:	6b f0 05             	imul   $0x5,%eax,%esi
+  800e70:	01 fe                	add    %edi,%esi
+  800e72:	bf 6d e6 ec de       	mov    $0xdeece66d,%edi
+  800e77:	f7 e7                	mul    %edi
+  800e79:	01 d6                	add    %edx,%esi
+  800e7b:	89 f2                	mov    %esi,%edx
+  800e7d:	83 c0 0b             	add    $0xb,%eax
+  800e80:	83 d2 00             	adc    $0x0,%edx
+  800e83:	89 c7                	mov    %eax,%edi
+  800e85:	83 e7 ff             	and    $0xffffffff,%edi
+  800e88:	89 f9                	mov    %edi,%ecx
+  800e8a:	0f b7 da             	movzwl %dx,%ebx
+  800e8d:	89 0d 00 20 80 00    	mov    %ecx,0x802000
+  800e93:	89 1d 04 20 80 00    	mov    %ebx,0x802004
+    unsigned long long result = (next >> 12);
+  800e99:	a1 00 20 80 00       	mov    0x802000,%eax
+  800e9e:	8b 15 04 20 80 00    	mov    0x802004,%edx
+  800ea4:	0f ac d0 0c          	shrd   $0xc,%edx,%eax
+  800ea8:	c1 ea 0c             	shr    $0xc,%edx
+  800eab:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800eae:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+    return (int)do_div(result, RAND_MAX + 1);
+  800eb1:	c7 45 dc 00 00 00 80 	movl   $0x80000000,-0x24(%ebp)
+  800eb8:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  800ebb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800ebe:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  800ec1:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  800ec4:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ec7:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800eca:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ece:	74 1c                	je     800eec <rand+0x99>
+  800ed0:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ed3:	ba 00 00 00 00       	mov    $0x0,%edx
+  800ed8:	f7 75 dc             	divl   -0x24(%ebp)
+  800edb:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  800ede:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ee1:	ba 00 00 00 00       	mov    $0x0,%edx
+  800ee6:	f7 75 dc             	divl   -0x24(%ebp)
+  800ee9:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800eec:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  800eef:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  800ef2:	f7 75 dc             	divl   -0x24(%ebp)
+  800ef5:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  800ef8:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  800efb:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  800efe:	8b 55 e8             	mov    -0x18(%ebp),%edx
+  800f01:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800f04:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  800f07:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+}
+  800f0a:	83 c4 24             	add    $0x24,%esp
+  800f0d:	5b                   	pop    %ebx
+  800f0e:	5e                   	pop    %esi
+  800f0f:	5f                   	pop    %edi
+  800f10:	5d                   	pop    %ebp
+  800f11:	c3                   	ret    
+
+00800f12 <srand>:
+/* *
+ * srand - seed the random number generator with the given number
+ * @seed:   the required seed number
+ * */
+void
+srand(unsigned int seed) {
+  800f12:	55                   	push   %ebp
+  800f13:	89 e5                	mov    %esp,%ebp
+    next = seed;
+  800f15:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f18:	ba 00 00 00 00       	mov    $0x0,%edx
+  800f1d:	a3 00 20 80 00       	mov    %eax,0x802000
+  800f22:	89 15 04 20 80 00    	mov    %edx,0x802004
+}
+  800f28:	90                   	nop
+  800f29:	5d                   	pop    %ebp
+  800f2a:	c3                   	ret    
+
+00800f2b <main>:
+#include <ulib.h>
+
+/* try to load the kernel's TSS selector into the DS register */
+
+int
+main(void) {
+  800f2b:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+  800f2f:	83 e4 f0             	and    $0xfffffff0,%esp
+  800f32:	ff 71 fc             	pushl  -0x4(%ecx)
+  800f35:	55                   	push   %ebp
+  800f36:	89 e5                	mov    %esp,%ebp
+  800f38:	51                   	push   %ecx
+  800f39:	83 ec 04             	sub    $0x4,%esp
+    asm volatile("movw $0x28,%ax; movw %ax,%ds");
+  800f3c:	66 b8 28 00          	mov    $0x28,%ax
+  800f40:	8e d8                	mov    %eax,%ds
+    panic("FAIL: T.T\n");
+  800f42:	83 ec 04             	sub    $0x4,%esp
+  800f45:	68 40 12 80 00       	push   $0x801240
+  800f4a:	6a 09                	push   $0x9
+  800f4c:	68 4b 12 80 00       	push   $0x80124b
+  800f51:	e8 ca f0 ff ff       	call   800020 <__panic>
diff -r -u -P lab6_origin/obj/user/badsegment.d lab6/obj/user/badsegment.d
--- lab6_origin/obj/user/badsegment.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/badsegment.d	2019-05-13 17:39:38.517965900 +0800
@@ -0,0 +1,2 @@
+obj/user/badsegment.o obj/user/badsegment.d: user/badsegment.c \
+ libs/stdio.h libs/defs.h libs/stdarg.h user/libs/ulib.h
Binary files lab6_origin/obj/user/badsegment.o and lab6/obj/user/badsegment.o differ
diff -r -u -P lab6_origin/obj/user/badsegment.sym lab6/obj/user/badsegment.sym
--- lab6_origin/obj/user/badsegment.sym	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/badsegment.sym	2019-05-13 17:39:43.890881600 +0800
@@ -0,0 +1,76 @@
+00800020 .text
+00800f60 .rodata
+00802000 .data
+00200000 .stab_info
+00200010 .stab
+00202c8d .stabstr
+00000000 panic.c
+00000000 syscall.c
+008000b5 syscall
+00000000 ulib.c
+00000000 stdio.c
+0080028c cputch
+00000000 umain.c
+00000000 string.c
+00000000 printfmt.c
+00801060 error_string
+00800822 printnum
+00800913 getuint
+00800962 getint
+00800d75 sprintputch
+00000000 hash.c
+00000000 rand.c
+00802000 next
+00000000 badsegment.c
+008003be strcpy
+0080021a yield
+00800201 waitpid
+00800141 sys_yield
+008006d7 memmove
+00800dab snprintf
+008009cd vprintfmt
+0080011d sys_fork
+008002d9 cprintf
+0080023e getpid
+0080077a memcpy
+00800266 lab6_set_priority
+00800dd4 vsnprintf
+0080034d umain
+00202c8c __STAB_END__
+00800150 sys_kill
+00202c8d __STABSTR_BEGIN__
+00800020 __panic
+0080053a strtol
+0080038e strnlen
+0080024b print_pgdir
+00800228 kill
+0080050b strfind
+008001ea wait
+0080027d _start
+00800e53 rand
+00800482 strncmp
+00800171 sys_putc
+008003fe strncpy
+008007ca memcmp
+008001dd fork
+00800697 memset
+00800f2b main
+00800f12 srand
+00800e2e hash32
+008009a9 printfmt
+00203a70 __STABSTR_END__
+00800438 strcmp
+00800259 gettime_msec
+00800192 sys_gettime
+008002b0 vcprintf
+0080006e __warn
+008002ff cputs
+008001a1 sys_lab6_set_priority
+008001b7 exit
+0080012c sys_wait
+0080010b sys_exit
+00200010 __STAB_BEGIN__
+00800366 strlen
+00800183 sys_pgdir
+008004d8 strchr
+00800162 sys_getpid
diff -r -u -P lab6_origin/obj/user/divzero.asm lab6/obj/user/divzero.asm
--- lab6_origin/obj/user/divzero.asm	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/divzero.asm	2019-05-13 17:39:43.253247200 +0800
@@ -0,0 +1,2587 @@
+
+obj/__user_divzero.out:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00800020 <__panic>:
+#include <stdio.h>
+#include <ulib.h>
+#include <error.h>
+
+void
+__panic(const char *file, int line, const char *fmt, ...) {
+  800020:	55                   	push   %ebp
+  800021:	89 e5                	mov    %esp,%ebp
+  800023:	83 ec 18             	sub    $0x18,%esp
+    // print the 'message'
+    va_list ap;
+    va_start(ap, fmt);
+  800026:	8d 45 14             	lea    0x14(%ebp),%eax
+  800029:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("user panic at %s:%d:\n    ", file, line);
+  80002c:	83 ec 04             	sub    $0x4,%esp
+  80002f:	ff 75 0c             	pushl  0xc(%ebp)
+  800032:	ff 75 08             	pushl  0x8(%ebp)
+  800035:	68 80 0f 80 00       	push   $0x800f80
+  80003a:	e8 9a 02 00 00       	call   8002d9 <cprintf>
+  80003f:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+  800042:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800045:	83 ec 08             	sub    $0x8,%esp
+  800048:	50                   	push   %eax
+  800049:	ff 75 10             	pushl  0x10(%ebp)
+  80004c:	e8 5f 02 00 00       	call   8002b0 <vcprintf>
+  800051:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+  800054:	83 ec 0c             	sub    $0xc,%esp
+  800057:	68 9a 0f 80 00       	push   $0x800f9a
+  80005c:	e8 78 02 00 00       	call   8002d9 <cprintf>
+  800061:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+    exit(-E_PANIC);
+  800064:	83 ec 0c             	sub    $0xc,%esp
+  800067:	6a f6                	push   $0xfffffff6
+  800069:	e8 49 01 00 00       	call   8001b7 <exit>
+
+0080006e <__warn>:
+}
+
+void
+__warn(const char *file, int line, const char *fmt, ...) {
+  80006e:	55                   	push   %ebp
+  80006f:	89 e5                	mov    %esp,%ebp
+  800071:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    va_start(ap, fmt);
+  800074:	8d 45 14             	lea    0x14(%ebp),%eax
+  800077:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("user warning at %s:%d:\n    ", file, line);
+  80007a:	83 ec 04             	sub    $0x4,%esp
+  80007d:	ff 75 0c             	pushl  0xc(%ebp)
+  800080:	ff 75 08             	pushl  0x8(%ebp)
+  800083:	68 9c 0f 80 00       	push   $0x800f9c
+  800088:	e8 4c 02 00 00       	call   8002d9 <cprintf>
+  80008d:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+  800090:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800093:	83 ec 08             	sub    $0x8,%esp
+  800096:	50                   	push   %eax
+  800097:	ff 75 10             	pushl  0x10(%ebp)
+  80009a:	e8 11 02 00 00       	call   8002b0 <vcprintf>
+  80009f:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+  8000a2:	83 ec 0c             	sub    $0xc,%esp
+  8000a5:	68 9a 0f 80 00       	push   $0x800f9a
+  8000aa:	e8 2a 02 00 00       	call   8002d9 <cprintf>
+  8000af:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+  8000b2:	90                   	nop
+  8000b3:	c9                   	leave  
+  8000b4:	c3                   	ret    
+
+008000b5 <syscall>:
+#include <syscall.h>
+
+#define MAX_ARGS            5
+
+static inline int
+syscall(int num, ...) {
+  8000b5:	55                   	push   %ebp
+  8000b6:	89 e5                	mov    %esp,%ebp
+  8000b8:	57                   	push   %edi
+  8000b9:	56                   	push   %esi
+  8000ba:	53                   	push   %ebx
+  8000bb:	83 ec 20             	sub    $0x20,%esp
+    va_list ap;
+    va_start(ap, num);
+  8000be:	8d 45 0c             	lea    0xc(%ebp),%eax
+  8000c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    uint32_t a[MAX_ARGS];
+    int i, ret;
+    for (i = 0; i < MAX_ARGS; i ++) {
+  8000c4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  8000cb:	eb 16                	jmp    8000e3 <syscall+0x2e>
+        a[i] = va_arg(ap, uint32_t);
+  8000cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8000d0:	8d 50 04             	lea    0x4(%eax),%edx
+  8000d3:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  8000d6:	8b 10                	mov    (%eax),%edx
+  8000d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8000db:	89 54 85 d4          	mov    %edx,-0x2c(%ebp,%eax,4)
+syscall(int num, ...) {
+    va_list ap;
+    va_start(ap, num);
+    uint32_t a[MAX_ARGS];
+    int i, ret;
+    for (i = 0; i < MAX_ARGS; i ++) {
+  8000df:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+  8000e3:	83 7d f0 04          	cmpl   $0x4,-0x10(%ebp)
+  8000e7:	7e e4                	jle    8000cd <syscall+0x18>
+    asm volatile (
+        "int %1;"
+        : "=a" (ret)
+        : "i" (T_SYSCALL),
+          "a" (num),
+          "d" (a[0]),
+  8000e9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+          "c" (a[1]),
+  8000ec:	8b 4d d8             	mov    -0x28(%ebp),%ecx
+          "b" (a[2]),
+  8000ef:	8b 5d dc             	mov    -0x24(%ebp),%ebx
+          "D" (a[3]),
+  8000f2:	8b 7d e0             	mov    -0x20(%ebp),%edi
+          "S" (a[4])
+  8000f5:	8b 75 e4             	mov    -0x1c(%ebp),%esi
+    for (i = 0; i < MAX_ARGS; i ++) {
+        a[i] = va_arg(ap, uint32_t);
+    }
+    va_end(ap);
+
+    asm volatile (
+  8000f8:	8b 45 08             	mov    0x8(%ebp),%eax
+  8000fb:	cd 80                	int    $0x80
+  8000fd:	89 45 ec             	mov    %eax,-0x14(%ebp)
+          "c" (a[1]),
+          "b" (a[2]),
+          "D" (a[3]),
+          "S" (a[4])
+        : "cc", "memory");
+    return ret;
+  800100:	8b 45 ec             	mov    -0x14(%ebp),%eax
+}
+  800103:	83 c4 20             	add    $0x20,%esp
+  800106:	5b                   	pop    %ebx
+  800107:	5e                   	pop    %esi
+  800108:	5f                   	pop    %edi
+  800109:	5d                   	pop    %ebp
+  80010a:	c3                   	ret    
+
+0080010b <sys_exit>:
+
+int
+sys_exit(int error_code) {
+  80010b:	55                   	push   %ebp
+  80010c:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_exit, error_code);
+  80010e:	ff 75 08             	pushl  0x8(%ebp)
+  800111:	6a 01                	push   $0x1
+  800113:	e8 9d ff ff ff       	call   8000b5 <syscall>
+  800118:	83 c4 08             	add    $0x8,%esp
+}
+  80011b:	c9                   	leave  
+  80011c:	c3                   	ret    
+
+0080011d <sys_fork>:
+
+int
+sys_fork(void) {
+  80011d:	55                   	push   %ebp
+  80011e:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_fork);
+  800120:	6a 02                	push   $0x2
+  800122:	e8 8e ff ff ff       	call   8000b5 <syscall>
+  800127:	83 c4 04             	add    $0x4,%esp
+}
+  80012a:	c9                   	leave  
+  80012b:	c3                   	ret    
+
+0080012c <sys_wait>:
+
+int
+sys_wait(int pid, int *store) {
+  80012c:	55                   	push   %ebp
+  80012d:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_wait, pid, store);
+  80012f:	ff 75 0c             	pushl  0xc(%ebp)
+  800132:	ff 75 08             	pushl  0x8(%ebp)
+  800135:	6a 03                	push   $0x3
+  800137:	e8 79 ff ff ff       	call   8000b5 <syscall>
+  80013c:	83 c4 0c             	add    $0xc,%esp
+}
+  80013f:	c9                   	leave  
+  800140:	c3                   	ret    
+
+00800141 <sys_yield>:
+
+int
+sys_yield(void) {
+  800141:	55                   	push   %ebp
+  800142:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_yield);
+  800144:	6a 0a                	push   $0xa
+  800146:	e8 6a ff ff ff       	call   8000b5 <syscall>
+  80014b:	83 c4 04             	add    $0x4,%esp
+}
+  80014e:	c9                   	leave  
+  80014f:	c3                   	ret    
+
+00800150 <sys_kill>:
+
+int
+sys_kill(int pid) {
+  800150:	55                   	push   %ebp
+  800151:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_kill, pid);
+  800153:	ff 75 08             	pushl  0x8(%ebp)
+  800156:	6a 0c                	push   $0xc
+  800158:	e8 58 ff ff ff       	call   8000b5 <syscall>
+  80015d:	83 c4 08             	add    $0x8,%esp
+}
+  800160:	c9                   	leave  
+  800161:	c3                   	ret    
+
+00800162 <sys_getpid>:
+
+int
+sys_getpid(void) {
+  800162:	55                   	push   %ebp
+  800163:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_getpid);
+  800165:	6a 12                	push   $0x12
+  800167:	e8 49 ff ff ff       	call   8000b5 <syscall>
+  80016c:	83 c4 04             	add    $0x4,%esp
+}
+  80016f:	c9                   	leave  
+  800170:	c3                   	ret    
+
+00800171 <sys_putc>:
+
+int
+sys_putc(int c) {
+  800171:	55                   	push   %ebp
+  800172:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_putc, c);
+  800174:	ff 75 08             	pushl  0x8(%ebp)
+  800177:	6a 1e                	push   $0x1e
+  800179:	e8 37 ff ff ff       	call   8000b5 <syscall>
+  80017e:	83 c4 08             	add    $0x8,%esp
+}
+  800181:	c9                   	leave  
+  800182:	c3                   	ret    
+
+00800183 <sys_pgdir>:
+
+int
+sys_pgdir(void) {
+  800183:	55                   	push   %ebp
+  800184:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_pgdir);
+  800186:	6a 1f                	push   $0x1f
+  800188:	e8 28 ff ff ff       	call   8000b5 <syscall>
+  80018d:	83 c4 04             	add    $0x4,%esp
+}
+  800190:	c9                   	leave  
+  800191:	c3                   	ret    
+
+00800192 <sys_gettime>:
+
+int
+sys_gettime(void) {
+  800192:	55                   	push   %ebp
+  800193:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_gettime);
+  800195:	6a 11                	push   $0x11
+  800197:	e8 19 ff ff ff       	call   8000b5 <syscall>
+  80019c:	83 c4 04             	add    $0x4,%esp
+}
+  80019f:	c9                   	leave  
+  8001a0:	c3                   	ret    
+
+008001a1 <sys_lab6_set_priority>:
+
+void
+sys_lab6_set_priority(uint32_t priority)
+{
+  8001a1:	55                   	push   %ebp
+  8001a2:	89 e5                	mov    %esp,%ebp
+    syscall(SYS_lab6_set_priority, priority);
+  8001a4:	ff 75 08             	pushl  0x8(%ebp)
+  8001a7:	68 ff 00 00 00       	push   $0xff
+  8001ac:	e8 04 ff ff ff       	call   8000b5 <syscall>
+  8001b1:	83 c4 08             	add    $0x8,%esp
+}
+  8001b4:	90                   	nop
+  8001b5:	c9                   	leave  
+  8001b6:	c3                   	ret    
+
+008001b7 <exit>:
+#include <syscall.h>
+#include <stdio.h>
+#include <ulib.h>
+
+void
+exit(int error_code) {
+  8001b7:	55                   	push   %ebp
+  8001b8:	89 e5                	mov    %esp,%ebp
+  8001ba:	83 ec 08             	sub    $0x8,%esp
+    sys_exit(error_code);
+  8001bd:	83 ec 0c             	sub    $0xc,%esp
+  8001c0:	ff 75 08             	pushl  0x8(%ebp)
+  8001c3:	e8 43 ff ff ff       	call   80010b <sys_exit>
+  8001c8:	83 c4 10             	add    $0x10,%esp
+    cprintf("BUG: exit failed.\n");
+  8001cb:	83 ec 0c             	sub    $0xc,%esp
+  8001ce:	68 b8 0f 80 00       	push   $0x800fb8
+  8001d3:	e8 01 01 00 00       	call   8002d9 <cprintf>
+  8001d8:	83 c4 10             	add    $0x10,%esp
+    while (1);
+  8001db:	eb fe                	jmp    8001db <exit+0x24>
+
+008001dd <fork>:
+}
+
+int
+fork(void) {
+  8001dd:	55                   	push   %ebp
+  8001de:	89 e5                	mov    %esp,%ebp
+  8001e0:	83 ec 08             	sub    $0x8,%esp
+    return sys_fork();
+  8001e3:	e8 35 ff ff ff       	call   80011d <sys_fork>
+}
+  8001e8:	c9                   	leave  
+  8001e9:	c3                   	ret    
+
+008001ea <wait>:
+
+int
+wait(void) {
+  8001ea:	55                   	push   %ebp
+  8001eb:	89 e5                	mov    %esp,%ebp
+  8001ed:	83 ec 08             	sub    $0x8,%esp
+    return sys_wait(0, NULL);
+  8001f0:	83 ec 08             	sub    $0x8,%esp
+  8001f3:	6a 00                	push   $0x0
+  8001f5:	6a 00                	push   $0x0
+  8001f7:	e8 30 ff ff ff       	call   80012c <sys_wait>
+  8001fc:	83 c4 10             	add    $0x10,%esp
+}
+  8001ff:	c9                   	leave  
+  800200:	c3                   	ret    
+
+00800201 <waitpid>:
+
+int
+waitpid(int pid, int *store) {
+  800201:	55                   	push   %ebp
+  800202:	89 e5                	mov    %esp,%ebp
+  800204:	83 ec 08             	sub    $0x8,%esp
+    return sys_wait(pid, store);
+  800207:	83 ec 08             	sub    $0x8,%esp
+  80020a:	ff 75 0c             	pushl  0xc(%ebp)
+  80020d:	ff 75 08             	pushl  0x8(%ebp)
+  800210:	e8 17 ff ff ff       	call   80012c <sys_wait>
+  800215:	83 c4 10             	add    $0x10,%esp
+}
+  800218:	c9                   	leave  
+  800219:	c3                   	ret    
+
+0080021a <yield>:
+
+void
+yield(void) {
+  80021a:	55                   	push   %ebp
+  80021b:	89 e5                	mov    %esp,%ebp
+  80021d:	83 ec 08             	sub    $0x8,%esp
+    sys_yield();
+  800220:	e8 1c ff ff ff       	call   800141 <sys_yield>
+}
+  800225:	90                   	nop
+  800226:	c9                   	leave  
+  800227:	c3                   	ret    
+
+00800228 <kill>:
+
+int
+kill(int pid) {
+  800228:	55                   	push   %ebp
+  800229:	89 e5                	mov    %esp,%ebp
+  80022b:	83 ec 08             	sub    $0x8,%esp
+    return sys_kill(pid);
+  80022e:	83 ec 0c             	sub    $0xc,%esp
+  800231:	ff 75 08             	pushl  0x8(%ebp)
+  800234:	e8 17 ff ff ff       	call   800150 <sys_kill>
+  800239:	83 c4 10             	add    $0x10,%esp
+}
+  80023c:	c9                   	leave  
+  80023d:	c3                   	ret    
+
+0080023e <getpid>:
+
+int
+getpid(void) {
+  80023e:	55                   	push   %ebp
+  80023f:	89 e5                	mov    %esp,%ebp
+  800241:	83 ec 08             	sub    $0x8,%esp
+    return sys_getpid();
+  800244:	e8 19 ff ff ff       	call   800162 <sys_getpid>
+}
+  800249:	c9                   	leave  
+  80024a:	c3                   	ret    
+
+0080024b <print_pgdir>:
+
+//print_pgdir - print the PDT&PT
+void
+print_pgdir(void) {
+  80024b:	55                   	push   %ebp
+  80024c:	89 e5                	mov    %esp,%ebp
+  80024e:	83 ec 08             	sub    $0x8,%esp
+    sys_pgdir();
+  800251:	e8 2d ff ff ff       	call   800183 <sys_pgdir>
+}
+  800256:	90                   	nop
+  800257:	c9                   	leave  
+  800258:	c3                   	ret    
+
+00800259 <gettime_msec>:
+
+unsigned int
+gettime_msec(void) {
+  800259:	55                   	push   %ebp
+  80025a:	89 e5                	mov    %esp,%ebp
+  80025c:	83 ec 08             	sub    $0x8,%esp
+    return (unsigned int)sys_gettime();
+  80025f:	e8 2e ff ff ff       	call   800192 <sys_gettime>
+}
+  800264:	c9                   	leave  
+  800265:	c3                   	ret    
+
+00800266 <lab6_set_priority>:
+
+void
+lab6_set_priority(uint32_t priority)
+{
+  800266:	55                   	push   %ebp
+  800267:	89 e5                	mov    %esp,%ebp
+  800269:	83 ec 08             	sub    $0x8,%esp
+    sys_lab6_set_priority(priority);
+  80026c:	83 ec 0c             	sub    $0xc,%esp
+  80026f:	ff 75 08             	pushl  0x8(%ebp)
+  800272:	e8 2a ff ff ff       	call   8001a1 <sys_lab6_set_priority>
+  800277:	83 c4 10             	add    $0x10,%esp
+}
+  80027a:	90                   	nop
+  80027b:	c9                   	leave  
+  80027c:	c3                   	ret    
+
+0080027d <_start>:
+.text
+.globl _start
+_start:
+    # set ebp for backtrace
+    movl $0x0, %ebp
+  80027d:	bd 00 00 00 00       	mov    $0x0,%ebp
+
+    # move down the esp register
+    # since it may cause page fault in backtrace
+    subl $0x20, %esp
+  800282:	83 ec 20             	sub    $0x20,%esp
+
+    # call user-program function
+    call umain
+  800285:	e8 c3 00 00 00       	call   80034d <umain>
+1:  jmp 1b
+  80028a:	eb fe                	jmp    80028a <_start+0xd>
+
+0080028c <cputch>:
+/* *
+ * cputch - writes a single character @c to stdout, and it will
+ * increace the value of counter pointed by @cnt.
+ * */
+static void
+cputch(int c, int *cnt) {
+  80028c:	55                   	push   %ebp
+  80028d:	89 e5                	mov    %esp,%ebp
+  80028f:	83 ec 08             	sub    $0x8,%esp
+    sys_putc(c);
+  800292:	83 ec 0c             	sub    $0xc,%esp
+  800295:	ff 75 08             	pushl  0x8(%ebp)
+  800298:	e8 d4 fe ff ff       	call   800171 <sys_putc>
+  80029d:	83 c4 10             	add    $0x10,%esp
+    (*cnt) ++;
+  8002a0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002a3:	8b 00                	mov    (%eax),%eax
+  8002a5:	8d 50 01             	lea    0x1(%eax),%edx
+  8002a8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002ab:	89 10                	mov    %edx,(%eax)
+}
+  8002ad:	90                   	nop
+  8002ae:	c9                   	leave  
+  8002af:	c3                   	ret    
+
+008002b0 <vcprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want cprintf() instead.
+ * */
+int
+vcprintf(const char *fmt, va_list ap) {
+  8002b0:	55                   	push   %ebp
+  8002b1:	89 e5                	mov    %esp,%ebp
+  8002b3:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+  8002b6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    vprintfmt((void*)cputch, &cnt, fmt, ap);
+  8002bd:	ff 75 0c             	pushl  0xc(%ebp)
+  8002c0:	ff 75 08             	pushl  0x8(%ebp)
+  8002c3:	8d 45 f4             	lea    -0xc(%ebp),%eax
+  8002c6:	50                   	push   %eax
+  8002c7:	68 8c 02 80 00       	push   $0x80028c
+  8002cc:	e8 fc 06 00 00       	call   8009cd <vprintfmt>
+  8002d1:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+  8002d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8002d7:	c9                   	leave  
+  8002d8:	c3                   	ret    
+
+008002d9 <cprintf>:
+ *
+ * The return value is the number of characters which would be
+ * written to stdout.
+ * */
+int
+cprintf(const char *fmt, ...) {
+  8002d9:	55                   	push   %ebp
+  8002da:	89 e5                	mov    %esp,%ebp
+  8002dc:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  8002df:	8d 45 0c             	lea    0xc(%ebp),%eax
+  8002e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    int cnt = vcprintf(fmt, ap);
+  8002e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8002e8:	83 ec 08             	sub    $0x8,%esp
+  8002eb:	50                   	push   %eax
+  8002ec:	ff 75 08             	pushl  0x8(%ebp)
+  8002ef:	e8 bc ff ff ff       	call   8002b0 <vcprintf>
+  8002f4:	83 c4 10             	add    $0x10,%esp
+  8002f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+
+    return cnt;
+  8002fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8002fd:	c9                   	leave  
+  8002fe:	c3                   	ret    
+
+008002ff <cputs>:
+/* *
+ * cputs- writes the string pointed by @str to stdout and
+ * appends a newline character.
+ * */
+int
+cputs(const char *str) {
+  8002ff:	55                   	push   %ebp
+  800300:	89 e5                	mov    %esp,%ebp
+  800302:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+  800305:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    char c;
+    while ((c = *str ++) != '\0') {
+  80030c:	eb 14                	jmp    800322 <cputs+0x23>
+        cputch(c, &cnt);
+  80030e:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
+  800312:	83 ec 08             	sub    $0x8,%esp
+  800315:	8d 55 f0             	lea    -0x10(%ebp),%edx
+  800318:	52                   	push   %edx
+  800319:	50                   	push   %eax
+  80031a:	e8 6d ff ff ff       	call   80028c <cputch>
+  80031f:	83 c4 10             	add    $0x10,%esp
+ * */
+int
+cputs(const char *str) {
+    int cnt = 0;
+    char c;
+    while ((c = *str ++) != '\0') {
+  800322:	8b 45 08             	mov    0x8(%ebp),%eax
+  800325:	8d 50 01             	lea    0x1(%eax),%edx
+  800328:	89 55 08             	mov    %edx,0x8(%ebp)
+  80032b:	0f b6 00             	movzbl (%eax),%eax
+  80032e:	88 45 f7             	mov    %al,-0x9(%ebp)
+  800331:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
+  800335:	75 d7                	jne    80030e <cputs+0xf>
+        cputch(c, &cnt);
+    }
+    cputch('\n', &cnt);
+  800337:	83 ec 08             	sub    $0x8,%esp
+  80033a:	8d 45 f0             	lea    -0x10(%ebp),%eax
+  80033d:	50                   	push   %eax
+  80033e:	6a 0a                	push   $0xa
+  800340:	e8 47 ff ff ff       	call   80028c <cputch>
+  800345:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+  800348:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+  80034b:	c9                   	leave  
+  80034c:	c3                   	ret    
+
+0080034d <umain>:
+#include <ulib.h>
+
+int main(void);
+
+void
+umain(void) {
+  80034d:	55                   	push   %ebp
+  80034e:	89 e5                	mov    %esp,%ebp
+  800350:	83 ec 18             	sub    $0x18,%esp
+    int ret = main();
+  800353:	e8 d3 0b 00 00       	call   800f2b <main>
+  800358:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    exit(ret);
+  80035b:	83 ec 0c             	sub    $0xc,%esp
+  80035e:	ff 75 f4             	pushl  -0xc(%ebp)
+  800361:	e8 51 fe ff ff       	call   8001b7 <exit>
+
+00800366 <strlen>:
+ * @s:      the input string
+ *
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+  800366:	55                   	push   %ebp
+  800367:	89 e5                	mov    %esp,%ebp
+  800369:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  80036c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (*s ++ != '\0') {
+  800373:	eb 04                	jmp    800379 <strlen+0x13>
+        cnt ++;
+  800375:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+    size_t cnt = 0;
+    while (*s ++ != '\0') {
+  800379:	8b 45 08             	mov    0x8(%ebp),%eax
+  80037c:	8d 50 01             	lea    0x1(%eax),%edx
+  80037f:	89 55 08             	mov    %edx,0x8(%ebp)
+  800382:	0f b6 00             	movzbl (%eax),%eax
+  800385:	84 c0                	test   %al,%al
+  800387:	75 ec                	jne    800375 <strlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  800389:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  80038c:	c9                   	leave  
+  80038d:	c3                   	ret    
+
+0080038e <strnlen>:
+ * The return value is strlen(s), if that is less than @len, or
+ * @len if there is no '\0' character among the first @len characters
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+  80038e:	55                   	push   %ebp
+  80038f:	89 e5                	mov    %esp,%ebp
+  800391:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  800394:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (cnt < len && *s ++ != '\0') {
+  80039b:	eb 04                	jmp    8003a1 <strnlen+0x13>
+        cnt ++;
+  80039d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+    size_t cnt = 0;
+    while (cnt < len && *s ++ != '\0') {
+  8003a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8003a4:	3b 45 0c             	cmp    0xc(%ebp),%eax
+  8003a7:	73 10                	jae    8003b9 <strnlen+0x2b>
+  8003a9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003ac:	8d 50 01             	lea    0x1(%eax),%edx
+  8003af:	89 55 08             	mov    %edx,0x8(%ebp)
+  8003b2:	0f b6 00             	movzbl (%eax),%eax
+  8003b5:	84 c0                	test   %al,%al
+  8003b7:	75 e4                	jne    80039d <strnlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  8003b9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  8003bc:	c9                   	leave  
+  8003bd:	c3                   	ret    
+
+008003be <strcpy>:
+ * To avoid overflows, the size of array pointed by @dst should be long enough to
+ * contain the same string as @src (including the terminating null character), and
+ * should not overlap in memory with @src.
+ * */
+char *
+strcpy(char *dst, const char *src) {
+  8003be:	55                   	push   %ebp
+  8003bf:	89 e5                	mov    %esp,%ebp
+  8003c1:	57                   	push   %edi
+  8003c2:	56                   	push   %esi
+  8003c3:	83 ec 20             	sub    $0x20,%esp
+  8003c6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  8003cc:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8003cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCPY
+#define __HAVE_ARCH_STRCPY
+static inline char *
+__strcpy(char *dst, const char *src) {
+    int d0, d1, d2;
+    asm volatile (
+  8003d2:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  8003d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8003d8:	89 d1                	mov    %edx,%ecx
+  8003da:	89 c2                	mov    %eax,%edx
+  8003dc:	89 ce                	mov    %ecx,%esi
+  8003de:	89 d7                	mov    %edx,%edi
+  8003e0:	ac                   	lods   %ds:(%esi),%al
+  8003e1:	aa                   	stos   %al,%es:(%edi)
+  8003e2:	84 c0                	test   %al,%al
+  8003e4:	75 fa                	jne    8003e0 <strcpy+0x22>
+  8003e6:	89 fa                	mov    %edi,%edx
+  8003e8:	89 f1                	mov    %esi,%ecx
+  8003ea:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  8003ed:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  8003f0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+        "stosb;"
+        "testb %%al, %%al;"
+        "jne 1b;"
+        : "=&S" (d0), "=&D" (d1), "=&a" (d2)
+        : "0" (src), "1" (dst) : "memory");
+    return dst;
+  8003f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCPY
+    return __strcpy(dst, src);
+  8003f6:	90                   	nop
+    char *p = dst;
+    while ((*p ++ = *src ++) != '\0')
+        /* nothing */;
+    return dst;
+#endif /* __HAVE_ARCH_STRCPY */
+}
+  8003f7:	83 c4 20             	add    $0x20,%esp
+  8003fa:	5e                   	pop    %esi
+  8003fb:	5f                   	pop    %edi
+  8003fc:	5d                   	pop    %ebp
+  8003fd:	c3                   	ret    
+
+008003fe <strncpy>:
+ * @len:    maximum number of characters to be copied from @src
+ *
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+  8003fe:	55                   	push   %ebp
+  8003ff:	89 e5                	mov    %esp,%ebp
+  800401:	83 ec 10             	sub    $0x10,%esp
+    char *p = dst;
+  800404:	8b 45 08             	mov    0x8(%ebp),%eax
+  800407:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    while (len > 0) {
+  80040a:	eb 21                	jmp    80042d <strncpy+0x2f>
+        if ((*p = *src) != '\0') {
+  80040c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80040f:	0f b6 10             	movzbl (%eax),%edx
+  800412:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800415:	88 10                	mov    %dl,(%eax)
+  800417:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  80041a:	0f b6 00             	movzbl (%eax),%eax
+  80041d:	84 c0                	test   %al,%al
+  80041f:	74 04                	je     800425 <strncpy+0x27>
+            src ++;
+  800421:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+        }
+        p ++, len --;
+  800425:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800429:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+    char *p = dst;
+    while (len > 0) {
+  80042d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800431:	75 d9                	jne    80040c <strncpy+0xe>
+        if ((*p = *src) != '\0') {
+            src ++;
+        }
+        p ++, len --;
+    }
+    return dst;
+  800433:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800436:	c9                   	leave  
+  800437:	c3                   	ret    
+
+00800438 <strcmp>:
+ * - A value greater than zero indicates that the first character that does
+ *   not match has a greater value in @s1 than in @s2;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+strcmp(const char *s1, const char *s2) {
+  800438:	55                   	push   %ebp
+  800439:	89 e5                	mov    %esp,%ebp
+  80043b:	57                   	push   %edi
+  80043c:	56                   	push   %esi
+  80043d:	83 ec 20             	sub    $0x20,%esp
+  800440:	8b 45 08             	mov    0x8(%ebp),%eax
+  800443:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800446:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800449:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCMP
+#define __HAVE_ARCH_STRCMP
+static inline int
+__strcmp(const char *s1, const char *s2) {
+    int d0, d1, ret;
+    asm volatile (
+  80044c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80044f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800452:	89 d1                	mov    %edx,%ecx
+  800454:	89 c2                	mov    %eax,%edx
+  800456:	89 ce                	mov    %ecx,%esi
+  800458:	89 d7                	mov    %edx,%edi
+  80045a:	ac                   	lods   %ds:(%esi),%al
+  80045b:	ae                   	scas   %es:(%edi),%al
+  80045c:	75 08                	jne    800466 <strcmp+0x2e>
+  80045e:	84 c0                	test   %al,%al
+  800460:	75 f8                	jne    80045a <strcmp+0x22>
+  800462:	31 c0                	xor    %eax,%eax
+  800464:	eb 04                	jmp    80046a <strcmp+0x32>
+  800466:	19 c0                	sbb    %eax,%eax
+  800468:	0c 01                	or     $0x1,%al
+  80046a:	89 fa                	mov    %edi,%edx
+  80046c:	89 f1                	mov    %esi,%ecx
+  80046e:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800471:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  800474:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+        "orb $1, %%al;"
+        "3:"
+        : "=a" (ret), "=&S" (d0), "=&D" (d1)
+        : "1" (s1), "2" (s2)
+        : "memory");
+    return ret;
+  800477:	8b 45 ec             	mov    -0x14(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCMP
+    return __strcmp(s1, s2);
+  80047a:	90                   	nop
+    while (*s1 != '\0' && *s1 == *s2) {
+        s1 ++, s2 ++;
+    }
+    return (int)((unsigned char)*s1 - (unsigned char)*s2);
+#endif /* __HAVE_ARCH_STRCMP */
+}
+  80047b:	83 c4 20             	add    $0x20,%esp
+  80047e:	5e                   	pop    %esi
+  80047f:	5f                   	pop    %edi
+  800480:	5d                   	pop    %ebp
+  800481:	c3                   	ret    
+
+00800482 <strncmp>:
+ * they are equal to each other, it continues with the following pairs until
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+  800482:	55                   	push   %ebp
+  800483:	89 e5                	mov    %esp,%ebp
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  800485:	eb 0c                	jmp    800493 <strncmp+0x11>
+        n --, s1 ++, s2 ++;
+  800487:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  80048b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  80048f:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  800493:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800497:	74 1a                	je     8004b3 <strncmp+0x31>
+  800499:	8b 45 08             	mov    0x8(%ebp),%eax
+  80049c:	0f b6 00             	movzbl (%eax),%eax
+  80049f:	84 c0                	test   %al,%al
+  8004a1:	74 10                	je     8004b3 <strncmp+0x31>
+  8004a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004a6:	0f b6 10             	movzbl (%eax),%edx
+  8004a9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004ac:	0f b6 00             	movzbl (%eax),%eax
+  8004af:	38 c2                	cmp    %al,%dl
+  8004b1:	74 d4                	je     800487 <strncmp+0x5>
+        n --, s1 ++, s2 ++;
+    }
+    return (n == 0) ? 0 : (int)((unsigned char)*s1 - (unsigned char)*s2);
+  8004b3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8004b7:	74 18                	je     8004d1 <strncmp+0x4f>
+  8004b9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004bc:	0f b6 00             	movzbl (%eax),%eax
+  8004bf:	0f b6 d0             	movzbl %al,%edx
+  8004c2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004c5:	0f b6 00             	movzbl (%eax),%eax
+  8004c8:	0f b6 c0             	movzbl %al,%eax
+  8004cb:	29 c2                	sub    %eax,%edx
+  8004cd:	89 d0                	mov    %edx,%eax
+  8004cf:	eb 05                	jmp    8004d6 <strncmp+0x54>
+  8004d1:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  8004d6:	5d                   	pop    %ebp
+  8004d7:	c3                   	ret    
+
+008004d8 <strchr>:
+ *
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+  8004d8:	55                   	push   %ebp
+  8004d9:	89 e5                	mov    %esp,%ebp
+  8004db:	83 ec 04             	sub    $0x4,%esp
+  8004de:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004e1:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  8004e4:	eb 14                	jmp    8004fa <strchr+0x22>
+        if (*s == c) {
+  8004e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004e9:	0f b6 00             	movzbl (%eax),%eax
+  8004ec:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  8004ef:	75 05                	jne    8004f6 <strchr+0x1e>
+            return (char *)s;
+  8004f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004f4:	eb 13                	jmp    800509 <strchr+0x31>
+        }
+        s ++;
+  8004f6:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+    while (*s != '\0') {
+  8004fa:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004fd:	0f b6 00             	movzbl (%eax),%eax
+  800500:	84 c0                	test   %al,%al
+  800502:	75 e2                	jne    8004e6 <strchr+0xe>
+        if (*s == c) {
+            return (char *)s;
+        }
+        s ++;
+    }
+    return NULL;
+  800504:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800509:	c9                   	leave  
+  80050a:	c3                   	ret    
+
+0080050b <strfind>:
+ * The strfind() function is like strchr() except that if @c is
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+  80050b:	55                   	push   %ebp
+  80050c:	89 e5                	mov    %esp,%ebp
+  80050e:	83 ec 04             	sub    $0x4,%esp
+  800511:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800514:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  800517:	eb 0f                	jmp    800528 <strfind+0x1d>
+        if (*s == c) {
+  800519:	8b 45 08             	mov    0x8(%ebp),%eax
+  80051c:	0f b6 00             	movzbl (%eax),%eax
+  80051f:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800522:	74 10                	je     800534 <strfind+0x29>
+            break;
+        }
+        s ++;
+  800524:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+    while (*s != '\0') {
+  800528:	8b 45 08             	mov    0x8(%ebp),%eax
+  80052b:	0f b6 00             	movzbl (%eax),%eax
+  80052e:	84 c0                	test   %al,%al
+  800530:	75 e7                	jne    800519 <strfind+0xe>
+  800532:	eb 01                	jmp    800535 <strfind+0x2a>
+        if (*s == c) {
+            break;
+  800534:	90                   	nop
+        }
+        s ++;
+    }
+    return (char *)s;
+  800535:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800538:	c9                   	leave  
+  800539:	c3                   	ret    
+
+0080053a <strtol>:
+ * an optional "0x" or "0X" prefix.
+ *
+ * The strtol() function returns the converted integral number as a long int value.
+ * */
+long
+strtol(const char *s, char **endptr, int base) {
+  80053a:	55                   	push   %ebp
+  80053b:	89 e5                	mov    %esp,%ebp
+  80053d:	83 ec 10             	sub    $0x10,%esp
+    int neg = 0;
+  800540:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    long val = 0;
+  800547:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  80054e:	eb 04                	jmp    800554 <strtol+0x1a>
+        s ++;
+  800550:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+strtol(const char *s, char **endptr, int base) {
+    int neg = 0;
+    long val = 0;
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  800554:	8b 45 08             	mov    0x8(%ebp),%eax
+  800557:	0f b6 00             	movzbl (%eax),%eax
+  80055a:	3c 20                	cmp    $0x20,%al
+  80055c:	74 f2                	je     800550 <strtol+0x16>
+  80055e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800561:	0f b6 00             	movzbl (%eax),%eax
+  800564:	3c 09                	cmp    $0x9,%al
+  800566:	74 e8                	je     800550 <strtol+0x16>
+        s ++;
+    }
+
+    // plus/minus sign
+    if (*s == '+') {
+  800568:	8b 45 08             	mov    0x8(%ebp),%eax
+  80056b:	0f b6 00             	movzbl (%eax),%eax
+  80056e:	3c 2b                	cmp    $0x2b,%al
+  800570:	75 06                	jne    800578 <strtol+0x3e>
+        s ++;
+  800572:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800576:	eb 15                	jmp    80058d <strtol+0x53>
+    }
+    else if (*s == '-') {
+  800578:	8b 45 08             	mov    0x8(%ebp),%eax
+  80057b:	0f b6 00             	movzbl (%eax),%eax
+  80057e:	3c 2d                	cmp    $0x2d,%al
+  800580:	75 0b                	jne    80058d <strtol+0x53>
+        s ++, neg = 1;
+  800582:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800586:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+    }
+
+    // hex or octal base prefix
+    if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x')) {
+  80058d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800591:	74 06                	je     800599 <strtol+0x5f>
+  800593:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+  800597:	75 24                	jne    8005bd <strtol+0x83>
+  800599:	8b 45 08             	mov    0x8(%ebp),%eax
+  80059c:	0f b6 00             	movzbl (%eax),%eax
+  80059f:	3c 30                	cmp    $0x30,%al
+  8005a1:	75 1a                	jne    8005bd <strtol+0x83>
+  8005a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005a6:	83 c0 01             	add    $0x1,%eax
+  8005a9:	0f b6 00             	movzbl (%eax),%eax
+  8005ac:	3c 78                	cmp    $0x78,%al
+  8005ae:	75 0d                	jne    8005bd <strtol+0x83>
+        s += 2, base = 16;
+  8005b0:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+  8005b4:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+  8005bb:	eb 2a                	jmp    8005e7 <strtol+0xad>
+    }
+    else if (base == 0 && s[0] == '0') {
+  8005bd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8005c1:	75 17                	jne    8005da <strtol+0xa0>
+  8005c3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005c6:	0f b6 00             	movzbl (%eax),%eax
+  8005c9:	3c 30                	cmp    $0x30,%al
+  8005cb:	75 0d                	jne    8005da <strtol+0xa0>
+        s ++, base = 8;
+  8005cd:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  8005d1:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+  8005d8:	eb 0d                	jmp    8005e7 <strtol+0xad>
+    }
+    else if (base == 0) {
+  8005da:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8005de:	75 07                	jne    8005e7 <strtol+0xad>
+        base = 10;
+  8005e0:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+    // digits
+    while (1) {
+        int dig;
+
+        if (*s >= '0' && *s <= '9') {
+  8005e7:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005ea:	0f b6 00             	movzbl (%eax),%eax
+  8005ed:	3c 2f                	cmp    $0x2f,%al
+  8005ef:	7e 1b                	jle    80060c <strtol+0xd2>
+  8005f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005f4:	0f b6 00             	movzbl (%eax),%eax
+  8005f7:	3c 39                	cmp    $0x39,%al
+  8005f9:	7f 11                	jg     80060c <strtol+0xd2>
+            dig = *s - '0';
+  8005fb:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005fe:	0f b6 00             	movzbl (%eax),%eax
+  800601:	0f be c0             	movsbl %al,%eax
+  800604:	83 e8 30             	sub    $0x30,%eax
+  800607:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80060a:	eb 48                	jmp    800654 <strtol+0x11a>
+        }
+        else if (*s >= 'a' && *s <= 'z') {
+  80060c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80060f:	0f b6 00             	movzbl (%eax),%eax
+  800612:	3c 60                	cmp    $0x60,%al
+  800614:	7e 1b                	jle    800631 <strtol+0xf7>
+  800616:	8b 45 08             	mov    0x8(%ebp),%eax
+  800619:	0f b6 00             	movzbl (%eax),%eax
+  80061c:	3c 7a                	cmp    $0x7a,%al
+  80061e:	7f 11                	jg     800631 <strtol+0xf7>
+            dig = *s - 'a' + 10;
+  800620:	8b 45 08             	mov    0x8(%ebp),%eax
+  800623:	0f b6 00             	movzbl (%eax),%eax
+  800626:	0f be c0             	movsbl %al,%eax
+  800629:	83 e8 57             	sub    $0x57,%eax
+  80062c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80062f:	eb 23                	jmp    800654 <strtol+0x11a>
+        }
+        else if (*s >= 'A' && *s <= 'Z') {
+  800631:	8b 45 08             	mov    0x8(%ebp),%eax
+  800634:	0f b6 00             	movzbl (%eax),%eax
+  800637:	3c 40                	cmp    $0x40,%al
+  800639:	7e 3c                	jle    800677 <strtol+0x13d>
+  80063b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80063e:	0f b6 00             	movzbl (%eax),%eax
+  800641:	3c 5a                	cmp    $0x5a,%al
+  800643:	7f 32                	jg     800677 <strtol+0x13d>
+            dig = *s - 'A' + 10;
+  800645:	8b 45 08             	mov    0x8(%ebp),%eax
+  800648:	0f b6 00             	movzbl (%eax),%eax
+  80064b:	0f be c0             	movsbl %al,%eax
+  80064e:	83 e8 37             	sub    $0x37,%eax
+  800651:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+  800654:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800657:	3b 45 10             	cmp    0x10(%ebp),%eax
+  80065a:	7d 1a                	jge    800676 <strtol+0x13c>
+            break;
+        }
+        s ++, val = (val * base) + dig;
+  80065c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800660:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800663:	0f af 45 10          	imul   0x10(%ebp),%eax
+  800667:	89 c2                	mov    %eax,%edx
+  800669:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  80066c:	01 d0                	add    %edx,%eax
+  80066e:	89 45 f8             	mov    %eax,-0x8(%ebp)
+        // we don't properly detect overflow!
+    }
+  800671:	e9 71 ff ff ff       	jmp    8005e7 <strtol+0xad>
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+            break;
+  800676:	90                   	nop
+        }
+        s ++, val = (val * base) + dig;
+        // we don't properly detect overflow!
+    }
+
+    if (endptr) {
+  800677:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  80067b:	74 08                	je     800685 <strtol+0x14b>
+        *endptr = (char *) s;
+  80067d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800680:	8b 55 08             	mov    0x8(%ebp),%edx
+  800683:	89 10                	mov    %edx,(%eax)
+    }
+    return (neg ? -val : val);
+  800685:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+  800689:	74 07                	je     800692 <strtol+0x158>
+  80068b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  80068e:	f7 d8                	neg    %eax
+  800690:	eb 03                	jmp    800695 <strtol+0x15b>
+  800692:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  800695:	c9                   	leave  
+  800696:	c3                   	ret    
+
+00800697 <memset>:
+ * @n:      number of bytes to be set to the value
+ *
+ * The memset() function returns @s.
+ * */
+void *
+memset(void *s, char c, size_t n) {
+  800697:	55                   	push   %ebp
+  800698:	89 e5                	mov    %esp,%ebp
+  80069a:	57                   	push   %edi
+  80069b:	83 ec 24             	sub    $0x24,%esp
+  80069e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006a1:	88 45 d8             	mov    %al,-0x28(%ebp)
+#ifdef __HAVE_ARCH_MEMSET
+    return __memset(s, c, n);
+  8006a4:	0f be 45 d8          	movsbl -0x28(%ebp),%eax
+  8006a8:	8b 55 08             	mov    0x8(%ebp),%edx
+  8006ab:	89 55 f8             	mov    %edx,-0x8(%ebp)
+  8006ae:	88 45 f7             	mov    %al,-0x9(%ebp)
+  8006b1:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_MEMSET
+#define __HAVE_ARCH_MEMSET
+static inline void *
+__memset(void *s, char c, size_t n) {
+    int d0, d1;
+    asm volatile (
+  8006b7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+  8006ba:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
+  8006be:	8b 55 f8             	mov    -0x8(%ebp),%edx
+  8006c1:	89 d7                	mov    %edx,%edi
+  8006c3:	f3 aa                	rep stos %al,%es:(%edi)
+  8006c5:	89 fa                	mov    %edi,%edx
+  8006c7:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  8006ca:	89 55 e8             	mov    %edx,-0x18(%ebp)
+        "rep; stosb;"
+        : "=&c" (d0), "=&D" (d1)
+        : "0" (n), "a" (c), "1" (s)
+        : "memory");
+    return s;
+  8006cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8006d0:	90                   	nop
+    while (n -- > 0) {
+        *p ++ = c;
+    }
+    return s;
+#endif /* __HAVE_ARCH_MEMSET */
+}
+  8006d1:	83 c4 24             	add    $0x24,%esp
+  8006d4:	5f                   	pop    %edi
+  8006d5:	5d                   	pop    %ebp
+  8006d6:	c3                   	ret    
+
+008006d7 <memmove>:
+ * @n:      number of bytes to copy
+ *
+ * The memmove() function returns @dst.
+ * */
+void *
+memmove(void *dst, const void *src, size_t n) {
+  8006d7:	55                   	push   %ebp
+  8006d8:	89 e5                	mov    %esp,%ebp
+  8006da:	57                   	push   %edi
+  8006db:	56                   	push   %esi
+  8006dc:	53                   	push   %ebx
+  8006dd:	83 ec 30             	sub    $0x30,%esp
+  8006e0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8006e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8006e6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  8006ec:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006ef:	89 45 e8             	mov    %eax,-0x18(%ebp)
+
+#ifndef __HAVE_ARCH_MEMMOVE
+#define __HAVE_ARCH_MEMMOVE
+static inline void *
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+  8006f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006f5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  8006f8:	73 42                	jae    80073c <memmove+0x65>
+  8006fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006fd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800700:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800703:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800706:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800709:	89 45 dc             	mov    %eax,-0x24(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  80070c:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  80070f:	c1 e8 02             	shr    $0x2,%eax
+  800712:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  800714:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800717:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80071a:	89 d7                	mov    %edx,%edi
+  80071c:	89 c6                	mov    %eax,%esi
+  80071e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800720:	8b 4d dc             	mov    -0x24(%ebp),%ecx
+  800723:	83 e1 03             	and    $0x3,%ecx
+  800726:	74 02                	je     80072a <memmove+0x53>
+  800728:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  80072a:	89 f0                	mov    %esi,%eax
+  80072c:	89 fa                	mov    %edi,%edx
+  80072e:	89 4d d8             	mov    %ecx,-0x28(%ebp)
+  800731:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  800734:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  800737:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMMOVE
+    return __memmove(dst, src, n);
+  80073a:	eb 36                	jmp    800772 <memmove+0x9b>
+    asm volatile (
+        "std;"
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+  80073c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80073f:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800742:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800745:	01 c2                	add    %eax,%edx
+  800747:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80074a:	8d 48 ff             	lea    -0x1(%eax),%ecx
+  80074d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800750:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+        return __memcpy(dst, src, n);
+    }
+    int d0, d1, d2;
+    asm volatile (
+  800753:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800756:	89 c1                	mov    %eax,%ecx
+  800758:	89 d8                	mov    %ebx,%eax
+  80075a:	89 d6                	mov    %edx,%esi
+  80075c:	89 c7                	mov    %eax,%edi
+  80075e:	fd                   	std    
+  80075f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  800761:	fc                   	cld    
+  800762:	89 f8                	mov    %edi,%eax
+  800764:	89 f2                	mov    %esi,%edx
+  800766:	89 4d cc             	mov    %ecx,-0x34(%ebp)
+  800769:	89 55 c8             	mov    %edx,-0x38(%ebp)
+  80076c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+        : "memory");
+    return dst;
+  80076f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+            *d ++ = *s ++;
+        }
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMMOVE */
+}
+  800772:	83 c4 30             	add    $0x30,%esp
+  800775:	5b                   	pop    %ebx
+  800776:	5e                   	pop    %esi
+  800777:	5f                   	pop    %edi
+  800778:	5d                   	pop    %ebp
+  800779:	c3                   	ret    
+
+0080077a <memcpy>:
+ * it always copies exactly @n bytes. To avoid overflows, the size of arrays pointed
+ * by both @src and @dst, should be at least @n bytes, and should not overlap
+ * (for overlapping memory area, memmove is a safer approach).
+ * */
+void *
+memcpy(void *dst, const void *src, size_t n) {
+  80077a:	55                   	push   %ebp
+  80077b:	89 e5                	mov    %esp,%ebp
+  80077d:	57                   	push   %edi
+  80077e:	56                   	push   %esi
+  80077f:	83 ec 20             	sub    $0x20,%esp
+  800782:	8b 45 08             	mov    0x8(%ebp),%eax
+  800785:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800788:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80078b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80078e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800791:	89 45 ec             	mov    %eax,-0x14(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  800794:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800797:	c1 e8 02             	shr    $0x2,%eax
+  80079a:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  80079c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80079f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8007a2:	89 d7                	mov    %edx,%edi
+  8007a4:	89 c6                	mov    %eax,%esi
+  8007a6:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  8007a8:	8b 4d ec             	mov    -0x14(%ebp),%ecx
+  8007ab:	83 e1 03             	and    $0x3,%ecx
+  8007ae:	74 02                	je     8007b2 <memcpy+0x38>
+  8007b0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  8007b2:	89 f0                	mov    %esi,%eax
+  8007b4:	89 fa                	mov    %edi,%edx
+  8007b6:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  8007b9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  8007bc:	89 45 e0             	mov    %eax,-0x20(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  8007bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMCPY
+    return __memcpy(dst, src, n);
+  8007c2:	90                   	nop
+    while (n -- > 0) {
+        *d ++ = *s ++;
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMCPY */
+}
+  8007c3:	83 c4 20             	add    $0x20,%esp
+  8007c6:	5e                   	pop    %esi
+  8007c7:	5f                   	pop    %edi
+  8007c8:	5d                   	pop    %ebp
+  8007c9:	c3                   	ret    
+
+008007ca <memcmp>:
+ *   match in both memory blocks has a greater value in @v1 than in @v2
+ *   as if evaluated as unsigned char values;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+  8007ca:	55                   	push   %ebp
+  8007cb:	89 e5                	mov    %esp,%ebp
+  8007cd:	83 ec 10             	sub    $0x10,%esp
+    const char *s1 = (const char *)v1;
+  8007d0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8007d3:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    const char *s2 = (const char *)v2;
+  8007d6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8007d9:	89 45 f8             	mov    %eax,-0x8(%ebp)
+    while (n -- > 0) {
+  8007dc:	eb 30                	jmp    80080e <memcmp+0x44>
+        if (*s1 != *s2) {
+  8007de:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8007e1:	0f b6 10             	movzbl (%eax),%edx
+  8007e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8007e7:	0f b6 00             	movzbl (%eax),%eax
+  8007ea:	38 c2                	cmp    %al,%dl
+  8007ec:	74 18                	je     800806 <memcmp+0x3c>
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+  8007ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8007f1:	0f b6 00             	movzbl (%eax),%eax
+  8007f4:	0f b6 d0             	movzbl %al,%edx
+  8007f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8007fa:	0f b6 00             	movzbl (%eax),%eax
+  8007fd:	0f b6 c0             	movzbl %al,%eax
+  800800:	29 c2                	sub    %eax,%edx
+  800802:	89 d0                	mov    %edx,%eax
+  800804:	eb 1a                	jmp    800820 <memcmp+0x56>
+        }
+        s1 ++, s2 ++;
+  800806:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  80080a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+    const char *s1 = (const char *)v1;
+    const char *s2 = (const char *)v2;
+    while (n -- > 0) {
+  80080e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800811:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800814:	89 55 10             	mov    %edx,0x10(%ebp)
+  800817:	85 c0                	test   %eax,%eax
+  800819:	75 c3                	jne    8007de <memcmp+0x14>
+        if (*s1 != *s2) {
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+        }
+        s1 ++, s2 ++;
+    }
+    return 0;
+  80081b:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800820:	c9                   	leave  
+  800821:	c3                   	ret    
+
+00800822 <printnum>:
+ * @width:      maximum number of digits, if the actual width is less than @width, use @padc instead
+ * @padc:       character that padded on the left if the actual width is less than @width
+ * */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+        unsigned long long num, unsigned base, int width, int padc) {
+  800822:	55                   	push   %ebp
+  800823:	89 e5                	mov    %esp,%ebp
+  800825:	83 ec 38             	sub    $0x38,%esp
+  800828:	8b 45 10             	mov    0x10(%ebp),%eax
+  80082b:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  80082e:	8b 45 14             	mov    0x14(%ebp),%eax
+  800831:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+    unsigned long long result = num;
+  800834:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  800837:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  80083a:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  80083d:	89 55 ec             	mov    %edx,-0x14(%ebp)
+    unsigned mod = do_div(result, base);
+  800840:	8b 45 18             	mov    0x18(%ebp),%eax
+  800843:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800846:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800849:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  80084c:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  80084f:	89 55 f0             	mov    %edx,-0x10(%ebp)
+  800852:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800855:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800858:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  80085c:	74 1c                	je     80087a <printnum+0x58>
+  80085e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800861:	ba 00 00 00 00       	mov    $0x0,%edx
+  800866:	f7 75 e4             	divl   -0x1c(%ebp)
+  800869:	89 55 f4             	mov    %edx,-0xc(%ebp)
+  80086c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  80086f:	ba 00 00 00 00       	mov    $0x0,%edx
+  800874:	f7 75 e4             	divl   -0x1c(%ebp)
+  800877:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80087a:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80087d:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800880:	f7 75 e4             	divl   -0x1c(%ebp)
+  800883:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800886:	89 55 dc             	mov    %edx,-0x24(%ebp)
+  800889:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80088c:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  80088f:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800892:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  800895:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  800898:	89 45 d8             	mov    %eax,-0x28(%ebp)
+
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+  80089b:	8b 45 18             	mov    0x18(%ebp),%eax
+  80089e:	ba 00 00 00 00       	mov    $0x0,%edx
+  8008a3:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  8008a6:	77 41                	ja     8008e9 <printnum+0xc7>
+  8008a8:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  8008ab:	72 05                	jb     8008b2 <printnum+0x90>
+  8008ad:	3b 45 d0             	cmp    -0x30(%ebp),%eax
+  8008b0:	77 37                	ja     8008e9 <printnum+0xc7>
+        printnum(putch, putdat, result, base, width - 1, padc);
+  8008b2:	8b 45 1c             	mov    0x1c(%ebp),%eax
+  8008b5:	83 e8 01             	sub    $0x1,%eax
+  8008b8:	83 ec 04             	sub    $0x4,%esp
+  8008bb:	ff 75 20             	pushl  0x20(%ebp)
+  8008be:	50                   	push   %eax
+  8008bf:	ff 75 18             	pushl  0x18(%ebp)
+  8008c2:	ff 75 ec             	pushl  -0x14(%ebp)
+  8008c5:	ff 75 e8             	pushl  -0x18(%ebp)
+  8008c8:	ff 75 0c             	pushl  0xc(%ebp)
+  8008cb:	ff 75 08             	pushl  0x8(%ebp)
+  8008ce:	e8 4f ff ff ff       	call   800822 <printnum>
+  8008d3:	83 c4 20             	add    $0x20,%esp
+  8008d6:	eb 1b                	jmp    8008f3 <printnum+0xd1>
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+            putch(padc, putdat);
+  8008d8:	83 ec 08             	sub    $0x8,%esp
+  8008db:	ff 75 0c             	pushl  0xc(%ebp)
+  8008de:	ff 75 20             	pushl  0x20(%ebp)
+  8008e1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8008e4:	ff d0                	call   *%eax
+  8008e6:	83 c4 10             	add    $0x10,%esp
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+        printnum(putch, putdat, result, base, width - 1, padc);
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+  8008e9:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+  8008ed:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+  8008f1:	7f e5                	jg     8008d8 <printnum+0xb6>
+            putch(padc, putdat);
+    }
+    // then print this (the least significant) digit
+    putch("0123456789abcdef"[mod], putdat);
+  8008f3:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  8008f6:	05 e4 10 80 00       	add    $0x8010e4,%eax
+  8008fb:	0f b6 00             	movzbl (%eax),%eax
+  8008fe:	0f be c0             	movsbl %al,%eax
+  800901:	83 ec 08             	sub    $0x8,%esp
+  800904:	ff 75 0c             	pushl  0xc(%ebp)
+  800907:	50                   	push   %eax
+  800908:	8b 45 08             	mov    0x8(%ebp),%eax
+  80090b:	ff d0                	call   *%eax
+  80090d:	83 c4 10             	add    $0x10,%esp
+}
+  800910:	90                   	nop
+  800911:	c9                   	leave  
+  800912:	c3                   	ret    
+
+00800913 <getuint>:
+ * getuint - get an unsigned int of various possible sizes from a varargs list
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static unsigned long long
+getuint(va_list *ap, int lflag) {
+  800913:	55                   	push   %ebp
+  800914:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  800916:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  80091a:	7e 14                	jle    800930 <getuint+0x1d>
+        return va_arg(*ap, unsigned long long);
+  80091c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80091f:	8b 00                	mov    (%eax),%eax
+  800921:	8d 48 08             	lea    0x8(%eax),%ecx
+  800924:	8b 55 08             	mov    0x8(%ebp),%edx
+  800927:	89 0a                	mov    %ecx,(%edx)
+  800929:	8b 50 04             	mov    0x4(%eax),%edx
+  80092c:	8b 00                	mov    (%eax),%eax
+  80092e:	eb 30                	jmp    800960 <getuint+0x4d>
+    }
+    else if (lflag) {
+  800930:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800934:	74 16                	je     80094c <getuint+0x39>
+        return va_arg(*ap, unsigned long);
+  800936:	8b 45 08             	mov    0x8(%ebp),%eax
+  800939:	8b 00                	mov    (%eax),%eax
+  80093b:	8d 48 04             	lea    0x4(%eax),%ecx
+  80093e:	8b 55 08             	mov    0x8(%ebp),%edx
+  800941:	89 0a                	mov    %ecx,(%edx)
+  800943:	8b 00                	mov    (%eax),%eax
+  800945:	ba 00 00 00 00       	mov    $0x0,%edx
+  80094a:	eb 14                	jmp    800960 <getuint+0x4d>
+    }
+    else {
+        return va_arg(*ap, unsigned int);
+  80094c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80094f:	8b 00                	mov    (%eax),%eax
+  800951:	8d 48 04             	lea    0x4(%eax),%ecx
+  800954:	8b 55 08             	mov    0x8(%ebp),%edx
+  800957:	89 0a                	mov    %ecx,(%edx)
+  800959:	8b 00                	mov    (%eax),%eax
+  80095b:	ba 00 00 00 00       	mov    $0x0,%edx
+    }
+}
+  800960:	5d                   	pop    %ebp
+  800961:	c3                   	ret    
+
+00800962 <getint>:
+ * getint - same as getuint but signed, we can't use getuint because of sign extension
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static long long
+getint(va_list *ap, int lflag) {
+  800962:	55                   	push   %ebp
+  800963:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  800965:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  800969:	7e 14                	jle    80097f <getint+0x1d>
+        return va_arg(*ap, long long);
+  80096b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80096e:	8b 00                	mov    (%eax),%eax
+  800970:	8d 48 08             	lea    0x8(%eax),%ecx
+  800973:	8b 55 08             	mov    0x8(%ebp),%edx
+  800976:	89 0a                	mov    %ecx,(%edx)
+  800978:	8b 50 04             	mov    0x4(%eax),%edx
+  80097b:	8b 00                	mov    (%eax),%eax
+  80097d:	eb 28                	jmp    8009a7 <getint+0x45>
+    }
+    else if (lflag) {
+  80097f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800983:	74 12                	je     800997 <getint+0x35>
+        return va_arg(*ap, long);
+  800985:	8b 45 08             	mov    0x8(%ebp),%eax
+  800988:	8b 00                	mov    (%eax),%eax
+  80098a:	8d 48 04             	lea    0x4(%eax),%ecx
+  80098d:	8b 55 08             	mov    0x8(%ebp),%edx
+  800990:	89 0a                	mov    %ecx,(%edx)
+  800992:	8b 00                	mov    (%eax),%eax
+  800994:	99                   	cltd   
+  800995:	eb 10                	jmp    8009a7 <getint+0x45>
+    }
+    else {
+        return va_arg(*ap, int);
+  800997:	8b 45 08             	mov    0x8(%ebp),%eax
+  80099a:	8b 00                	mov    (%eax),%eax
+  80099c:	8d 48 04             	lea    0x4(%eax),%ecx
+  80099f:	8b 55 08             	mov    0x8(%ebp),%edx
+  8009a2:	89 0a                	mov    %ecx,(%edx)
+  8009a4:	8b 00                	mov    (%eax),%eax
+  8009a6:	99                   	cltd   
+    }
+}
+  8009a7:	5d                   	pop    %ebp
+  8009a8:	c3                   	ret    
+
+008009a9 <printfmt>:
+ * @putch:      specified putch function, print a single character
+ * @putdat:     used by @putch function
+ * @fmt:        the format string to use
+ * */
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...) {
+  8009a9:	55                   	push   %ebp
+  8009aa:	89 e5                	mov    %esp,%ebp
+  8009ac:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  8009af:	8d 45 14             	lea    0x14(%ebp),%eax
+  8009b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    vprintfmt(putch, putdat, fmt, ap);
+  8009b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8009b8:	50                   	push   %eax
+  8009b9:	ff 75 10             	pushl  0x10(%ebp)
+  8009bc:	ff 75 0c             	pushl  0xc(%ebp)
+  8009bf:	ff 75 08             	pushl  0x8(%ebp)
+  8009c2:	e8 06 00 00 00       	call   8009cd <vprintfmt>
+  8009c7:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+  8009ca:	90                   	nop
+  8009cb:	c9                   	leave  
+  8009cc:	c3                   	ret    
+
+008009cd <vprintfmt>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want printfmt() instead.
+ * */
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap) {
+  8009cd:	55                   	push   %ebp
+  8009ce:	89 e5                	mov    %esp,%ebp
+  8009d0:	56                   	push   %esi
+  8009d1:	53                   	push   %ebx
+  8009d2:	83 ec 20             	sub    $0x20,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  8009d5:	eb 17                	jmp    8009ee <vprintfmt+0x21>
+            if (ch == '\0') {
+  8009d7:	85 db                	test   %ebx,%ebx
+  8009d9:	0f 84 8e 03 00 00    	je     800d6d <vprintfmt+0x3a0>
+                return;
+            }
+            putch(ch, putdat);
+  8009df:	83 ec 08             	sub    $0x8,%esp
+  8009e2:	ff 75 0c             	pushl  0xc(%ebp)
+  8009e5:	53                   	push   %ebx
+  8009e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009e9:	ff d0                	call   *%eax
+  8009eb:	83 c4 10             	add    $0x10,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  8009ee:	8b 45 10             	mov    0x10(%ebp),%eax
+  8009f1:	8d 50 01             	lea    0x1(%eax),%edx
+  8009f4:	89 55 10             	mov    %edx,0x10(%ebp)
+  8009f7:	0f b6 00             	movzbl (%eax),%eax
+  8009fa:	0f b6 d8             	movzbl %al,%ebx
+  8009fd:	83 fb 25             	cmp    $0x25,%ebx
+  800a00:	75 d5                	jne    8009d7 <vprintfmt+0xa>
+            }
+            putch(ch, putdat);
+        }
+
+        // Process a %-escape sequence
+        char padc = ' ';
+  800a02:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+        width = precision = -1;
+  800a06:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+  800a0d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800a10:	89 45 e8             	mov    %eax,-0x18(%ebp)
+        lflag = altflag = 0;
+  800a13:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+  800a1a:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  800a1d:	89 45 e0             	mov    %eax,-0x20(%ebp)
+
+    reswitch:
+        switch (ch = *(unsigned char *)fmt ++) {
+  800a20:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a23:	8d 50 01             	lea    0x1(%eax),%edx
+  800a26:	89 55 10             	mov    %edx,0x10(%ebp)
+  800a29:	0f b6 00             	movzbl (%eax),%eax
+  800a2c:	0f b6 d8             	movzbl %al,%ebx
+  800a2f:	8d 43 dd             	lea    -0x23(%ebx),%eax
+  800a32:	83 f8 55             	cmp    $0x55,%eax
+  800a35:	0f 87 05 03 00 00    	ja     800d40 <vprintfmt+0x373>
+  800a3b:	8b 04 85 08 11 80 00 	mov    0x801108(,%eax,4),%eax
+  800a42:	ff e0                	jmp    *%eax
+
+        // flag to pad on the right
+        case '-':
+            padc = '-';
+  800a44:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+            goto reswitch;
+  800a48:	eb d6                	jmp    800a20 <vprintfmt+0x53>
+
+        // flag to pad with 0's instead of spaces
+        case '0':
+            padc = '0';
+  800a4a:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+            goto reswitch;
+  800a4e:	eb d0                	jmp    800a20 <vprintfmt+0x53>
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  800a50:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+                precision = precision * 10 + ch - '0';
+  800a57:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800a5a:	89 d0                	mov    %edx,%eax
+  800a5c:	c1 e0 02             	shl    $0x2,%eax
+  800a5f:	01 d0                	add    %edx,%eax
+  800a61:	01 c0                	add    %eax,%eax
+  800a63:	01 d8                	add    %ebx,%eax
+  800a65:	83 e8 30             	sub    $0x30,%eax
+  800a68:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+                ch = *fmt;
+  800a6b:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a6e:	0f b6 00             	movzbl (%eax),%eax
+  800a71:	0f be d8             	movsbl %al,%ebx
+                if (ch < '0' || ch > '9') {
+  800a74:	83 fb 2f             	cmp    $0x2f,%ebx
+  800a77:	7e 39                	jle    800ab2 <vprintfmt+0xe5>
+  800a79:	83 fb 39             	cmp    $0x39,%ebx
+  800a7c:	7f 34                	jg     800ab2 <vprintfmt+0xe5>
+            padc = '0';
+            goto reswitch;
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  800a7e:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+                precision = precision * 10 + ch - '0';
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+  800a82:	eb d3                	jmp    800a57 <vprintfmt+0x8a>
+            goto process_precision;
+
+        case '*':
+            precision = va_arg(ap, int);
+  800a84:	8b 45 14             	mov    0x14(%ebp),%eax
+  800a87:	8d 50 04             	lea    0x4(%eax),%edx
+  800a8a:	89 55 14             	mov    %edx,0x14(%ebp)
+  800a8d:	8b 00                	mov    (%eax),%eax
+  800a8f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+            goto process_precision;
+  800a92:	eb 1f                	jmp    800ab3 <vprintfmt+0xe6>
+
+        case '.':
+            if (width < 0)
+  800a94:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800a98:	79 86                	jns    800a20 <vprintfmt+0x53>
+                width = 0;
+  800a9a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+            goto reswitch;
+  800aa1:	e9 7a ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        case '#':
+            altflag = 1;
+  800aa6:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+            goto reswitch;
+  800aad:	e9 6e ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+            goto process_precision;
+  800ab2:	90                   	nop
+        case '#':
+            altflag = 1;
+            goto reswitch;
+
+        process_precision:
+            if (width < 0)
+  800ab3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ab7:	0f 89 63 ff ff ff    	jns    800a20 <vprintfmt+0x53>
+                width = precision, precision = -1;
+  800abd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800ac0:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800ac3:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+            goto reswitch;
+  800aca:	e9 51 ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        // long flag (doubled for long long)
+        case 'l':
+            lflag ++;
+  800acf:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
+            goto reswitch;
+  800ad3:	e9 48 ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        // character
+        case 'c':
+            putch(va_arg(ap, int), putdat);
+  800ad8:	8b 45 14             	mov    0x14(%ebp),%eax
+  800adb:	8d 50 04             	lea    0x4(%eax),%edx
+  800ade:	89 55 14             	mov    %edx,0x14(%ebp)
+  800ae1:	8b 00                	mov    (%eax),%eax
+  800ae3:	83 ec 08             	sub    $0x8,%esp
+  800ae6:	ff 75 0c             	pushl  0xc(%ebp)
+  800ae9:	50                   	push   %eax
+  800aea:	8b 45 08             	mov    0x8(%ebp),%eax
+  800aed:	ff d0                	call   *%eax
+  800aef:	83 c4 10             	add    $0x10,%esp
+            break;
+  800af2:	e9 71 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // error message
+        case 'e':
+            err = va_arg(ap, int);
+  800af7:	8b 45 14             	mov    0x14(%ebp),%eax
+  800afa:	8d 50 04             	lea    0x4(%eax),%edx
+  800afd:	89 55 14             	mov    %edx,0x14(%ebp)
+  800b00:	8b 18                	mov    (%eax),%ebx
+            if (err < 0) {
+  800b02:	85 db                	test   %ebx,%ebx
+  800b04:	79 02                	jns    800b08 <vprintfmt+0x13b>
+                err = -err;
+  800b06:	f7 db                	neg    %ebx
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+  800b08:	83 fb 18             	cmp    $0x18,%ebx
+  800b0b:	7f 0b                	jg     800b18 <vprintfmt+0x14b>
+  800b0d:	8b 34 9d 80 10 80 00 	mov    0x801080(,%ebx,4),%esi
+  800b14:	85 f6                	test   %esi,%esi
+  800b16:	75 19                	jne    800b31 <vprintfmt+0x164>
+                printfmt(putch, putdat, "error %d", err);
+  800b18:	53                   	push   %ebx
+  800b19:	68 f5 10 80 00       	push   $0x8010f5
+  800b1e:	ff 75 0c             	pushl  0xc(%ebp)
+  800b21:	ff 75 08             	pushl  0x8(%ebp)
+  800b24:	e8 80 fe ff ff       	call   8009a9 <printfmt>
+  800b29:	83 c4 10             	add    $0x10,%esp
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+            }
+            break;
+  800b2c:	e9 37 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+                printfmt(putch, putdat, "error %d", err);
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+  800b31:	56                   	push   %esi
+  800b32:	68 fe 10 80 00       	push   $0x8010fe
+  800b37:	ff 75 0c             	pushl  0xc(%ebp)
+  800b3a:	ff 75 08             	pushl  0x8(%ebp)
+  800b3d:	e8 67 fe ff ff       	call   8009a9 <printfmt>
+  800b42:	83 c4 10             	add    $0x10,%esp
+            }
+            break;
+  800b45:	e9 1e 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // string
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+  800b4a:	8b 45 14             	mov    0x14(%ebp),%eax
+  800b4d:	8d 50 04             	lea    0x4(%eax),%edx
+  800b50:	89 55 14             	mov    %edx,0x14(%ebp)
+  800b53:	8b 30                	mov    (%eax),%esi
+  800b55:	85 f6                	test   %esi,%esi
+  800b57:	75 05                	jne    800b5e <vprintfmt+0x191>
+                p = "(null)";
+  800b59:	be 01 11 80 00       	mov    $0x801101,%esi
+            }
+            if (width > 0 && padc != '-') {
+  800b5e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800b62:	7e 76                	jle    800bda <vprintfmt+0x20d>
+  800b64:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+  800b68:	74 70                	je     800bda <vprintfmt+0x20d>
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  800b6a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800b6d:	83 ec 08             	sub    $0x8,%esp
+  800b70:	50                   	push   %eax
+  800b71:	56                   	push   %esi
+  800b72:	e8 17 f8 ff ff       	call   80038e <strnlen>
+  800b77:	83 c4 10             	add    $0x10,%esp
+  800b7a:	89 c2                	mov    %eax,%edx
+  800b7c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800b7f:	29 d0                	sub    %edx,%eax
+  800b81:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800b84:	eb 17                	jmp    800b9d <vprintfmt+0x1d0>
+                    putch(padc, putdat);
+  800b86:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+  800b8a:	83 ec 08             	sub    $0x8,%esp
+  800b8d:	ff 75 0c             	pushl  0xc(%ebp)
+  800b90:	50                   	push   %eax
+  800b91:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b94:	ff d0                	call   *%eax
+  800b96:	83 c4 10             	add    $0x10,%esp
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+                p = "(null)";
+            }
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  800b99:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800b9d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ba1:	7f e3                	jg     800b86 <vprintfmt+0x1b9>
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  800ba3:	eb 35                	jmp    800bda <vprintfmt+0x20d>
+                if (altflag && (ch < ' ' || ch > '~')) {
+  800ba5:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+  800ba9:	74 1c                	je     800bc7 <vprintfmt+0x1fa>
+  800bab:	83 fb 1f             	cmp    $0x1f,%ebx
+  800bae:	7e 05                	jle    800bb5 <vprintfmt+0x1e8>
+  800bb0:	83 fb 7e             	cmp    $0x7e,%ebx
+  800bb3:	7e 12                	jle    800bc7 <vprintfmt+0x1fa>
+                    putch('?', putdat);
+  800bb5:	83 ec 08             	sub    $0x8,%esp
+  800bb8:	ff 75 0c             	pushl  0xc(%ebp)
+  800bbb:	6a 3f                	push   $0x3f
+  800bbd:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bc0:	ff d0                	call   *%eax
+  800bc2:	83 c4 10             	add    $0x10,%esp
+  800bc5:	eb 0f                	jmp    800bd6 <vprintfmt+0x209>
+                }
+                else {
+                    putch(ch, putdat);
+  800bc7:	83 ec 08             	sub    $0x8,%esp
+  800bca:	ff 75 0c             	pushl  0xc(%ebp)
+  800bcd:	53                   	push   %ebx
+  800bce:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bd1:	ff d0                	call   *%eax
+  800bd3:	83 c4 10             	add    $0x10,%esp
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  800bd6:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800bda:	89 f0                	mov    %esi,%eax
+  800bdc:	8d 70 01             	lea    0x1(%eax),%esi
+  800bdf:	0f b6 00             	movzbl (%eax),%eax
+  800be2:	0f be d8             	movsbl %al,%ebx
+  800be5:	85 db                	test   %ebx,%ebx
+  800be7:	74 26                	je     800c0f <vprintfmt+0x242>
+  800be9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800bed:	78 b6                	js     800ba5 <vprintfmt+0x1d8>
+  800bef:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800bf3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800bf7:	79 ac                	jns    800ba5 <vprintfmt+0x1d8>
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  800bf9:	eb 14                	jmp    800c0f <vprintfmt+0x242>
+                putch(' ', putdat);
+  800bfb:	83 ec 08             	sub    $0x8,%esp
+  800bfe:	ff 75 0c             	pushl  0xc(%ebp)
+  800c01:	6a 20                	push   $0x20
+  800c03:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c06:	ff d0                	call   *%eax
+  800c08:	83 c4 10             	add    $0x10,%esp
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  800c0b:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800c0f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800c13:	7f e6                	jg     800bfb <vprintfmt+0x22e>
+                putch(' ', putdat);
+            }
+            break;
+  800c15:	e9 4e 01 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // (signed) decimal
+        case 'd':
+            num = getint(&ap, lflag);
+  800c1a:	83 ec 08             	sub    $0x8,%esp
+  800c1d:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c20:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c23:	50                   	push   %eax
+  800c24:	e8 39 fd ff ff       	call   800962 <getint>
+  800c29:	83 c4 10             	add    $0x10,%esp
+  800c2c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c2f:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            if ((long long)num < 0) {
+  800c32:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c35:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800c38:	85 d2                	test   %edx,%edx
+  800c3a:	79 23                	jns    800c5f <vprintfmt+0x292>
+                putch('-', putdat);
+  800c3c:	83 ec 08             	sub    $0x8,%esp
+  800c3f:	ff 75 0c             	pushl  0xc(%ebp)
+  800c42:	6a 2d                	push   $0x2d
+  800c44:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c47:	ff d0                	call   *%eax
+  800c49:	83 c4 10             	add    $0x10,%esp
+                num = -(long long)num;
+  800c4c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c4f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800c52:	f7 d8                	neg    %eax
+  800c54:	83 d2 00             	adc    $0x0,%edx
+  800c57:	f7 da                	neg    %edx
+  800c59:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c5c:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            }
+            base = 10;
+  800c5f:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  800c66:	e9 9f 00 00 00       	jmp    800d0a <vprintfmt+0x33d>
+
+        // unsigned decimal
+        case 'u':
+            num = getuint(&ap, lflag);
+  800c6b:	83 ec 08             	sub    $0x8,%esp
+  800c6e:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c71:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c74:	50                   	push   %eax
+  800c75:	e8 99 fc ff ff       	call   800913 <getuint>
+  800c7a:	83 c4 10             	add    $0x10,%esp
+  800c7d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c80:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 10;
+  800c83:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  800c8a:	eb 7e                	jmp    800d0a <vprintfmt+0x33d>
+
+        // (unsigned) octal
+        case 'o':
+            num = getuint(&ap, lflag);
+  800c8c:	83 ec 08             	sub    $0x8,%esp
+  800c8f:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c92:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c95:	50                   	push   %eax
+  800c96:	e8 78 fc ff ff       	call   800913 <getuint>
+  800c9b:	83 c4 10             	add    $0x10,%esp
+  800c9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800ca1:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 8;
+  800ca4:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+            goto number;
+  800cab:	eb 5d                	jmp    800d0a <vprintfmt+0x33d>
+
+        // pointer
+        case 'p':
+            putch('0', putdat);
+  800cad:	83 ec 08             	sub    $0x8,%esp
+  800cb0:	ff 75 0c             	pushl  0xc(%ebp)
+  800cb3:	6a 30                	push   $0x30
+  800cb5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cb8:	ff d0                	call   *%eax
+  800cba:	83 c4 10             	add    $0x10,%esp
+            putch('x', putdat);
+  800cbd:	83 ec 08             	sub    $0x8,%esp
+  800cc0:	ff 75 0c             	pushl  0xc(%ebp)
+  800cc3:	6a 78                	push   $0x78
+  800cc5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cc8:	ff d0                	call   *%eax
+  800cca:	83 c4 10             	add    $0x10,%esp
+            num = (unsigned long long)(uintptr_t)va_arg(ap, void *);
+  800ccd:	8b 45 14             	mov    0x14(%ebp),%eax
+  800cd0:	8d 50 04             	lea    0x4(%eax),%edx
+  800cd3:	89 55 14             	mov    %edx,0x14(%ebp)
+  800cd6:	8b 00                	mov    (%eax),%eax
+  800cd8:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800cdb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+            base = 16;
+  800ce2:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+            goto number;
+  800ce9:	eb 1f                	jmp    800d0a <vprintfmt+0x33d>
+
+        // (unsigned) hexadecimal
+        case 'x':
+            num = getuint(&ap, lflag);
+  800ceb:	83 ec 08             	sub    $0x8,%esp
+  800cee:	ff 75 e0             	pushl  -0x20(%ebp)
+  800cf1:	8d 45 14             	lea    0x14(%ebp),%eax
+  800cf4:	50                   	push   %eax
+  800cf5:	e8 19 fc ff ff       	call   800913 <getuint>
+  800cfa:	83 c4 10             	add    $0x10,%esp
+  800cfd:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800d00:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 16;
+  800d03:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+        number:
+            printnum(putch, putdat, num, base, width, padc);
+  800d0a:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+  800d0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800d11:	83 ec 04             	sub    $0x4,%esp
+  800d14:	52                   	push   %edx
+  800d15:	ff 75 e8             	pushl  -0x18(%ebp)
+  800d18:	50                   	push   %eax
+  800d19:	ff 75 f4             	pushl  -0xc(%ebp)
+  800d1c:	ff 75 f0             	pushl  -0x10(%ebp)
+  800d1f:	ff 75 0c             	pushl  0xc(%ebp)
+  800d22:	ff 75 08             	pushl  0x8(%ebp)
+  800d25:	e8 f8 fa ff ff       	call   800822 <printnum>
+  800d2a:	83 c4 20             	add    $0x20,%esp
+            break;
+  800d2d:	eb 39                	jmp    800d68 <vprintfmt+0x39b>
+
+        // escaped '%' character
+        case '%':
+            putch(ch, putdat);
+  800d2f:	83 ec 08             	sub    $0x8,%esp
+  800d32:	ff 75 0c             	pushl  0xc(%ebp)
+  800d35:	53                   	push   %ebx
+  800d36:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d39:	ff d0                	call   *%eax
+  800d3b:	83 c4 10             	add    $0x10,%esp
+            break;
+  800d3e:	eb 28                	jmp    800d68 <vprintfmt+0x39b>
+
+        // unrecognized escape sequence - just print it literally
+        default:
+            putch('%', putdat);
+  800d40:	83 ec 08             	sub    $0x8,%esp
+  800d43:	ff 75 0c             	pushl  0xc(%ebp)
+  800d46:	6a 25                	push   $0x25
+  800d48:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d4b:	ff d0                	call   *%eax
+  800d4d:	83 c4 10             	add    $0x10,%esp
+            for (fmt --; fmt[-1] != '%'; fmt --)
+  800d50:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800d54:	eb 04                	jmp    800d5a <vprintfmt+0x38d>
+  800d56:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800d5a:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d5d:	83 e8 01             	sub    $0x1,%eax
+  800d60:	0f b6 00             	movzbl (%eax),%eax
+  800d63:	3c 25                	cmp    $0x25,%al
+  800d65:	75 ef                	jne    800d56 <vprintfmt+0x389>
+                /* do nothing */;
+            break;
+  800d67:	90                   	nop
+        }
+    }
+  800d68:	e9 68 fc ff ff       	jmp    8009d5 <vprintfmt+0x8>
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+            if (ch == '\0') {
+                return;
+  800d6d:	90                   	nop
+            for (fmt --; fmt[-1] != '%'; fmt --)
+                /* do nothing */;
+            break;
+        }
+    }
+}
+  800d6e:	8d 65 f8             	lea    -0x8(%ebp),%esp
+  800d71:	5b                   	pop    %ebx
+  800d72:	5e                   	pop    %esi
+  800d73:	5d                   	pop    %ebp
+  800d74:	c3                   	ret    
+
+00800d75 <sprintputch>:
+ * sprintputch - 'print' a single character in a buffer
+ * @ch:         the character will be printed
+ * @b:          the buffer to place the character @ch
+ * */
+static void
+sprintputch(int ch, struct sprintbuf *b) {
+  800d75:	55                   	push   %ebp
+  800d76:	89 e5                	mov    %esp,%ebp
+    b->cnt ++;
+  800d78:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d7b:	8b 40 08             	mov    0x8(%eax),%eax
+  800d7e:	8d 50 01             	lea    0x1(%eax),%edx
+  800d81:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d84:	89 50 08             	mov    %edx,0x8(%eax)
+    if (b->buf < b->ebuf) {
+  800d87:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8a:	8b 10                	mov    (%eax),%edx
+  800d8c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8f:	8b 40 04             	mov    0x4(%eax),%eax
+  800d92:	39 c2                	cmp    %eax,%edx
+  800d94:	73 12                	jae    800da8 <sprintputch+0x33>
+        *b->buf ++ = ch;
+  800d96:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d99:	8b 00                	mov    (%eax),%eax
+  800d9b:	8d 48 01             	lea    0x1(%eax),%ecx
+  800d9e:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800da1:	89 0a                	mov    %ecx,(%edx)
+  800da3:	8b 55 08             	mov    0x8(%ebp),%edx
+  800da6:	88 10                	mov    %dl,(%eax)
+    }
+}
+  800da8:	90                   	nop
+  800da9:	5d                   	pop    %ebp
+  800daa:	c3                   	ret    
+
+00800dab <snprintf>:
+ * @str:        the buffer to place the result into
+ * @size:       the size of buffer, including the trailing null space
+ * @fmt:        the format string to use
+ * */
+int
+snprintf(char *str, size_t size, const char *fmt, ...) {
+  800dab:	55                   	push   %ebp
+  800dac:	89 e5                	mov    %esp,%ebp
+  800dae:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    int cnt;
+    va_start(ap, fmt);
+  800db1:	8d 45 14             	lea    0x14(%ebp),%eax
+  800db4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    cnt = vsnprintf(str, size, fmt, ap);
+  800db7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800dba:	50                   	push   %eax
+  800dbb:	ff 75 10             	pushl  0x10(%ebp)
+  800dbe:	ff 75 0c             	pushl  0xc(%ebp)
+  800dc1:	ff 75 08             	pushl  0x8(%ebp)
+  800dc4:	e8 0b 00 00 00       	call   800dd4 <vsnprintf>
+  800dc9:	83 c4 10             	add    $0x10,%esp
+  800dcc:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+    return cnt;
+  800dcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800dd2:	c9                   	leave  
+  800dd3:	c3                   	ret    
+
+00800dd4 <vsnprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want snprintf() instead.
+ * */
+int
+vsnprintf(char *str, size_t size, const char *fmt, va_list ap) {
+  800dd4:	55                   	push   %ebp
+  800dd5:	89 e5                	mov    %esp,%ebp
+  800dd7:	83 ec 18             	sub    $0x18,%esp
+    struct sprintbuf b = {str, str + size - 1, 0};
+  800dda:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ddd:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800de0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800de3:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800de6:	8b 45 08             	mov    0x8(%ebp),%eax
+  800de9:	01 d0                	add    %edx,%eax
+  800deb:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800dee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    if (str == NULL || b.buf > b.ebuf) {
+  800df5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  800df9:	74 0a                	je     800e05 <vsnprintf+0x31>
+  800dfb:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  800dfe:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800e01:	39 c2                	cmp    %eax,%edx
+  800e03:	76 07                	jbe    800e0c <vsnprintf+0x38>
+        return -E_INVAL;
+  800e05:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+  800e0a:	eb 20                	jmp    800e2c <vsnprintf+0x58>
+    }
+    // print the string to the buffer
+    vprintfmt((void*)sprintputch, &b, fmt, ap);
+  800e0c:	ff 75 14             	pushl  0x14(%ebp)
+  800e0f:	ff 75 10             	pushl  0x10(%ebp)
+  800e12:	8d 45 ec             	lea    -0x14(%ebp),%eax
+  800e15:	50                   	push   %eax
+  800e16:	68 75 0d 80 00       	push   $0x800d75
+  800e1b:	e8 ad fb ff ff       	call   8009cd <vprintfmt>
+  800e20:	83 c4 10             	add    $0x10,%esp
+    // null terminate the buffer
+    *b.buf = '\0';
+  800e23:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e26:	c6 00 00             	movb   $0x0,(%eax)
+    return b.cnt;
+  800e29:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800e2c:	c9                   	leave  
+  800e2d:	c3                   	ret    
+
+00800e2e <hash32>:
+ * @bits:   the number of bits in a return value
+ *
+ * High bits are more random, so we use them.
+ * */
+uint32_t
+hash32(uint32_t val, unsigned int bits) {
+  800e2e:	55                   	push   %ebp
+  800e2f:	89 e5                	mov    %esp,%ebp
+  800e31:	83 ec 10             	sub    $0x10,%esp
+    uint32_t hash = val * GOLDEN_RATIO_PRIME_32;
+  800e34:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e37:	69 c0 01 00 37 9e    	imul   $0x9e370001,%eax,%eax
+  800e3d:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    return (hash >> (32 - bits));
+  800e40:	b8 20 00 00 00       	mov    $0x20,%eax
+  800e45:	2b 45 0c             	sub    0xc(%ebp),%eax
+  800e48:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  800e4b:	89 c1                	mov    %eax,%ecx
+  800e4d:	d3 ea                	shr    %cl,%edx
+  800e4f:	89 d0                	mov    %edx,%eax
+}
+  800e51:	c9                   	leave  
+  800e52:	c3                   	ret    
+
+00800e53 <rand>:
+ * rand - returns a pseudo-random integer
+ *
+ * The rand() function return a value in the range [0, RAND_MAX].
+ * */
+int
+rand(void) {
+  800e53:	55                   	push   %ebp
+  800e54:	89 e5                	mov    %esp,%ebp
+  800e56:	57                   	push   %edi
+  800e57:	56                   	push   %esi
+  800e58:	53                   	push   %ebx
+  800e59:	83 ec 24             	sub    $0x24,%esp
+    next = (next * 0x5DEECE66DLL + 0xBLL) & ((1LL << 48) - 1);
+  800e5c:	a1 00 20 80 00       	mov    0x802000,%eax
+  800e61:	8b 15 04 20 80 00    	mov    0x802004,%edx
+  800e67:	69 fa 6d e6 ec de    	imul   $0xdeece66d,%edx,%edi
+  800e6d:	6b f0 05             	imul   $0x5,%eax,%esi
+  800e70:	01 fe                	add    %edi,%esi
+  800e72:	bf 6d e6 ec de       	mov    $0xdeece66d,%edi
+  800e77:	f7 e7                	mul    %edi
+  800e79:	01 d6                	add    %edx,%esi
+  800e7b:	89 f2                	mov    %esi,%edx
+  800e7d:	83 c0 0b             	add    $0xb,%eax
+  800e80:	83 d2 00             	adc    $0x0,%edx
+  800e83:	89 c7                	mov    %eax,%edi
+  800e85:	83 e7 ff             	and    $0xffffffff,%edi
+  800e88:	89 f9                	mov    %edi,%ecx
+  800e8a:	0f b7 da             	movzwl %dx,%ebx
+  800e8d:	89 0d 00 20 80 00    	mov    %ecx,0x802000
+  800e93:	89 1d 04 20 80 00    	mov    %ebx,0x802004
+    unsigned long long result = (next >> 12);
+  800e99:	a1 00 20 80 00       	mov    0x802000,%eax
+  800e9e:	8b 15 04 20 80 00    	mov    0x802004,%edx
+  800ea4:	0f ac d0 0c          	shrd   $0xc,%edx,%eax
+  800ea8:	c1 ea 0c             	shr    $0xc,%edx
+  800eab:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800eae:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+    return (int)do_div(result, RAND_MAX + 1);
+  800eb1:	c7 45 dc 00 00 00 80 	movl   $0x80000000,-0x24(%ebp)
+  800eb8:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  800ebb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800ebe:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  800ec1:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  800ec4:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ec7:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800eca:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ece:	74 1c                	je     800eec <rand+0x99>
+  800ed0:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ed3:	ba 00 00 00 00       	mov    $0x0,%edx
+  800ed8:	f7 75 dc             	divl   -0x24(%ebp)
+  800edb:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  800ede:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ee1:	ba 00 00 00 00       	mov    $0x0,%edx
+  800ee6:	f7 75 dc             	divl   -0x24(%ebp)
+  800ee9:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800eec:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  800eef:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  800ef2:	f7 75 dc             	divl   -0x24(%ebp)
+  800ef5:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  800ef8:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  800efb:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  800efe:	8b 55 e8             	mov    -0x18(%ebp),%edx
+  800f01:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800f04:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  800f07:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+}
+  800f0a:	83 c4 24             	add    $0x24,%esp
+  800f0d:	5b                   	pop    %ebx
+  800f0e:	5e                   	pop    %esi
+  800f0f:	5f                   	pop    %edi
+  800f10:	5d                   	pop    %ebp
+  800f11:	c3                   	ret    
+
+00800f12 <srand>:
+/* *
+ * srand - seed the random number generator with the given number
+ * @seed:   the required seed number
+ * */
+void
+srand(unsigned int seed) {
+  800f12:	55                   	push   %ebp
+  800f13:	89 e5                	mov    %esp,%ebp
+    next = seed;
+  800f15:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f18:	ba 00 00 00 00       	mov    $0x0,%edx
+  800f1d:	a3 00 20 80 00       	mov    %eax,0x802000
+  800f22:	89 15 04 20 80 00    	mov    %edx,0x802004
+}
+  800f28:	90                   	nop
+  800f29:	5d                   	pop    %ebp
+  800f2a:	c3                   	ret    
+
+00800f2b <main>:
+#include <ulib.h>
+
+int zero;
+
+int
+main(void) {
+  800f2b:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+  800f2f:	83 e4 f0             	and    $0xfffffff0,%esp
+  800f32:	ff 71 fc             	pushl  -0x4(%ecx)
+  800f35:	55                   	push   %ebp
+  800f36:	89 e5                	mov    %esp,%ebp
+  800f38:	51                   	push   %ecx
+  800f39:	83 ec 04             	sub    $0x4,%esp
+    cprintf("value is %d.\n", 1 / zero);
+  800f3c:	8b 0d 08 20 80 00    	mov    0x802008,%ecx
+  800f42:	b8 01 00 00 00       	mov    $0x1,%eax
+  800f47:	99                   	cltd   
+  800f48:	f7 f9                	idiv   %ecx
+  800f4a:	83 ec 08             	sub    $0x8,%esp
+  800f4d:	50                   	push   %eax
+  800f4e:	68 60 12 80 00       	push   $0x801260
+  800f53:	e8 81 f3 ff ff       	call   8002d9 <cprintf>
+  800f58:	83 c4 10             	add    $0x10,%esp
+    panic("FAIL: T.T\n");
+  800f5b:	83 ec 04             	sub    $0x4,%esp
+  800f5e:	68 6e 12 80 00       	push   $0x80126e
+  800f63:	6a 09                	push   $0x9
+  800f65:	68 79 12 80 00       	push   $0x801279
+  800f6a:	e8 b1 f0 ff ff       	call   800020 <__panic>
diff -r -u -P lab6_origin/obj/user/divzero.d lab6/obj/user/divzero.d
--- lab6_origin/obj/user/divzero.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/divzero.d	2019-05-13 17:39:38.349063100 +0800
@@ -0,0 +1,2 @@
+obj/user/divzero.o obj/user/divzero.d: user/divzero.c libs/stdio.h \
+ libs/defs.h libs/stdarg.h user/libs/ulib.h
Binary files lab6_origin/obj/user/divzero.o and lab6/obj/user/divzero.o differ
diff -r -u -P lab6_origin/obj/user/divzero.sym lab6/obj/user/divzero.sym
--- lab6_origin/obj/user/divzero.sym	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/divzero.sym	2019-05-13 17:39:43.701989700 +0800
@@ -0,0 +1,78 @@
+00800020 .text
+00800f80 .rodata
+00802000 .data
+00802008 .bss
+00200000 .stab_info
+00200010 .stab
+00202c99 .stabstr
+00000000 panic.c
+00000000 syscall.c
+008000b5 syscall
+00000000 ulib.c
+00000000 stdio.c
+0080028c cputch
+00000000 umain.c
+00000000 string.c
+00000000 printfmt.c
+00801080 error_string
+00800822 printnum
+00800913 getuint
+00800962 getint
+00800d75 sprintputch
+00000000 hash.c
+00000000 rand.c
+00802000 next
+00000000 divzero.c
+008003be strcpy
+0080021a yield
+00800201 waitpid
+00800141 sys_yield
+008006d7 memmove
+00800dab snprintf
+008009cd vprintfmt
+0080011d sys_fork
+008002d9 cprintf
+0080023e getpid
+0080077a memcpy
+00800266 lab6_set_priority
+00800dd4 vsnprintf
+0080034d umain
+00202c98 __STAB_END__
+00800150 sys_kill
+00202c99 __STABSTR_BEGIN__
+00800020 __panic
+0080053a strtol
+0080038e strnlen
+0080024b print_pgdir
+00800228 kill
+0080050b strfind
+008001ea wait
+0080027d _start
+00800e53 rand
+00800482 strncmp
+00800171 sys_putc
+008003fe strncpy
+008007ca memcmp
+008001dd fork
+00800697 memset
+00800f2b main
+00800f12 srand
+00800e2e hash32
+008009a9 printfmt
+00203a85 __STABSTR_END__
+00800438 strcmp
+00802008 zero
+00800259 gettime_msec
+00800192 sys_gettime
+008002b0 vcprintf
+0080006e __warn
+008002ff cputs
+008001a1 sys_lab6_set_priority
+008001b7 exit
+0080012c sys_wait
+0080010b sys_exit
+00200010 __STAB_BEGIN__
+00800366 strlen
+00800183 sys_pgdir
+008004d8 strchr
+00800162 sys_getpid
diff -r -u -P lab6_origin/obj/user/exit.asm lab6/obj/user/exit.asm
--- lab6_origin/obj/user/exit.asm	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/exit.asm	2019-05-13 17:39:43.259243800 +0800
@@ -0,0 +1,2683 @@
+
+obj/__user_exit.out:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00800020 <__panic>:
+#include <stdio.h>
+#include <ulib.h>
+#include <error.h>
+
+void
+__panic(const char *file, int line, const char *fmt, ...) {
+  800020:	55                   	push   %ebp
+  800021:	89 e5                	mov    %esp,%ebp
+  800023:	83 ec 18             	sub    $0x18,%esp
+    // print the 'message'
+    va_list ap;
+    va_start(ap, fmt);
+  800026:	8d 45 14             	lea    0x14(%ebp),%eax
+  800029:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("user panic at %s:%d:\n    ", file, line);
+  80002c:	83 ec 04             	sub    $0x4,%esp
+  80002f:	ff 75 0c             	pushl  0xc(%ebp)
+  800032:	ff 75 08             	pushl  0x8(%ebp)
+  800035:	68 80 10 80 00       	push   $0x801080
+  80003a:	e8 9a 02 00 00       	call   8002d9 <cprintf>
+  80003f:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+  800042:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800045:	83 ec 08             	sub    $0x8,%esp
+  800048:	50                   	push   %eax
+  800049:	ff 75 10             	pushl  0x10(%ebp)
+  80004c:	e8 5f 02 00 00       	call   8002b0 <vcprintf>
+  800051:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+  800054:	83 ec 0c             	sub    $0xc,%esp
+  800057:	68 9a 10 80 00       	push   $0x80109a
+  80005c:	e8 78 02 00 00       	call   8002d9 <cprintf>
+  800061:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+    exit(-E_PANIC);
+  800064:	83 ec 0c             	sub    $0xc,%esp
+  800067:	6a f6                	push   $0xfffffff6
+  800069:	e8 49 01 00 00       	call   8001b7 <exit>
+
+0080006e <__warn>:
+}
+
+void
+__warn(const char *file, int line, const char *fmt, ...) {
+  80006e:	55                   	push   %ebp
+  80006f:	89 e5                	mov    %esp,%ebp
+  800071:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    va_start(ap, fmt);
+  800074:	8d 45 14             	lea    0x14(%ebp),%eax
+  800077:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("user warning at %s:%d:\n    ", file, line);
+  80007a:	83 ec 04             	sub    $0x4,%esp
+  80007d:	ff 75 0c             	pushl  0xc(%ebp)
+  800080:	ff 75 08             	pushl  0x8(%ebp)
+  800083:	68 9c 10 80 00       	push   $0x80109c
+  800088:	e8 4c 02 00 00       	call   8002d9 <cprintf>
+  80008d:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+  800090:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800093:	83 ec 08             	sub    $0x8,%esp
+  800096:	50                   	push   %eax
+  800097:	ff 75 10             	pushl  0x10(%ebp)
+  80009a:	e8 11 02 00 00       	call   8002b0 <vcprintf>
+  80009f:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+  8000a2:	83 ec 0c             	sub    $0xc,%esp
+  8000a5:	68 9a 10 80 00       	push   $0x80109a
+  8000aa:	e8 2a 02 00 00       	call   8002d9 <cprintf>
+  8000af:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+  8000b2:	90                   	nop
+  8000b3:	c9                   	leave  
+  8000b4:	c3                   	ret    
+
+008000b5 <syscall>:
+#include <syscall.h>
+
+#define MAX_ARGS            5
+
+static inline int
+syscall(int num, ...) {
+  8000b5:	55                   	push   %ebp
+  8000b6:	89 e5                	mov    %esp,%ebp
+  8000b8:	57                   	push   %edi
+  8000b9:	56                   	push   %esi
+  8000ba:	53                   	push   %ebx
+  8000bb:	83 ec 20             	sub    $0x20,%esp
+    va_list ap;
+    va_start(ap, num);
+  8000be:	8d 45 0c             	lea    0xc(%ebp),%eax
+  8000c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    uint32_t a[MAX_ARGS];
+    int i, ret;
+    for (i = 0; i < MAX_ARGS; i ++) {
+  8000c4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  8000cb:	eb 16                	jmp    8000e3 <syscall+0x2e>
+        a[i] = va_arg(ap, uint32_t);
+  8000cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8000d0:	8d 50 04             	lea    0x4(%eax),%edx
+  8000d3:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  8000d6:	8b 10                	mov    (%eax),%edx
+  8000d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8000db:	89 54 85 d4          	mov    %edx,-0x2c(%ebp,%eax,4)
+syscall(int num, ...) {
+    va_list ap;
+    va_start(ap, num);
+    uint32_t a[MAX_ARGS];
+    int i, ret;
+    for (i = 0; i < MAX_ARGS; i ++) {
+  8000df:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+  8000e3:	83 7d f0 04          	cmpl   $0x4,-0x10(%ebp)
+  8000e7:	7e e4                	jle    8000cd <syscall+0x18>
+    asm volatile (
+        "int %1;"
+        : "=a" (ret)
+        : "i" (T_SYSCALL),
+          "a" (num),
+          "d" (a[0]),
+  8000e9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+          "c" (a[1]),
+  8000ec:	8b 4d d8             	mov    -0x28(%ebp),%ecx
+          "b" (a[2]),
+  8000ef:	8b 5d dc             	mov    -0x24(%ebp),%ebx
+          "D" (a[3]),
+  8000f2:	8b 7d e0             	mov    -0x20(%ebp),%edi
+          "S" (a[4])
+  8000f5:	8b 75 e4             	mov    -0x1c(%ebp),%esi
+    for (i = 0; i < MAX_ARGS; i ++) {
+        a[i] = va_arg(ap, uint32_t);
+    }
+    va_end(ap);
+
+    asm volatile (
+  8000f8:	8b 45 08             	mov    0x8(%ebp),%eax
+  8000fb:	cd 80                	int    $0x80
+  8000fd:	89 45 ec             	mov    %eax,-0x14(%ebp)
+          "c" (a[1]),
+          "b" (a[2]),
+          "D" (a[3]),
+          "S" (a[4])
+        : "cc", "memory");
+    return ret;
+  800100:	8b 45 ec             	mov    -0x14(%ebp),%eax
+}
+  800103:	83 c4 20             	add    $0x20,%esp
+  800106:	5b                   	pop    %ebx
+  800107:	5e                   	pop    %esi
+  800108:	5f                   	pop    %edi
+  800109:	5d                   	pop    %ebp
+  80010a:	c3                   	ret    
+
+0080010b <sys_exit>:
+
+int
+sys_exit(int error_code) {
+  80010b:	55                   	push   %ebp
+  80010c:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_exit, error_code);
+  80010e:	ff 75 08             	pushl  0x8(%ebp)
+  800111:	6a 01                	push   $0x1
+  800113:	e8 9d ff ff ff       	call   8000b5 <syscall>
+  800118:	83 c4 08             	add    $0x8,%esp
+}
+  80011b:	c9                   	leave  
+  80011c:	c3                   	ret    
+
+0080011d <sys_fork>:
+
+int
+sys_fork(void) {
+  80011d:	55                   	push   %ebp
+  80011e:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_fork);
+  800120:	6a 02                	push   $0x2
+  800122:	e8 8e ff ff ff       	call   8000b5 <syscall>
+  800127:	83 c4 04             	add    $0x4,%esp
+}
+  80012a:	c9                   	leave  
+  80012b:	c3                   	ret    
+
+0080012c <sys_wait>:
+
+int
+sys_wait(int pid, int *store) {
+  80012c:	55                   	push   %ebp
+  80012d:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_wait, pid, store);
+  80012f:	ff 75 0c             	pushl  0xc(%ebp)
+  800132:	ff 75 08             	pushl  0x8(%ebp)
+  800135:	6a 03                	push   $0x3
+  800137:	e8 79 ff ff ff       	call   8000b5 <syscall>
+  80013c:	83 c4 0c             	add    $0xc,%esp
+}
+  80013f:	c9                   	leave  
+  800140:	c3                   	ret    
+
+00800141 <sys_yield>:
+
+int
+sys_yield(void) {
+  800141:	55                   	push   %ebp
+  800142:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_yield);
+  800144:	6a 0a                	push   $0xa
+  800146:	e8 6a ff ff ff       	call   8000b5 <syscall>
+  80014b:	83 c4 04             	add    $0x4,%esp
+}
+  80014e:	c9                   	leave  
+  80014f:	c3                   	ret    
+
+00800150 <sys_kill>:
+
+int
+sys_kill(int pid) {
+  800150:	55                   	push   %ebp
+  800151:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_kill, pid);
+  800153:	ff 75 08             	pushl  0x8(%ebp)
+  800156:	6a 0c                	push   $0xc
+  800158:	e8 58 ff ff ff       	call   8000b5 <syscall>
+  80015d:	83 c4 08             	add    $0x8,%esp
+}
+  800160:	c9                   	leave  
+  800161:	c3                   	ret    
+
+00800162 <sys_getpid>:
+
+int
+sys_getpid(void) {
+  800162:	55                   	push   %ebp
+  800163:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_getpid);
+  800165:	6a 12                	push   $0x12
+  800167:	e8 49 ff ff ff       	call   8000b5 <syscall>
+  80016c:	83 c4 04             	add    $0x4,%esp
+}
+  80016f:	c9                   	leave  
+  800170:	c3                   	ret    
+
+00800171 <sys_putc>:
+
+int
+sys_putc(int c) {
+  800171:	55                   	push   %ebp
+  800172:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_putc, c);
+  800174:	ff 75 08             	pushl  0x8(%ebp)
+  800177:	6a 1e                	push   $0x1e
+  800179:	e8 37 ff ff ff       	call   8000b5 <syscall>
+  80017e:	83 c4 08             	add    $0x8,%esp
+}
+  800181:	c9                   	leave  
+  800182:	c3                   	ret    
+
+00800183 <sys_pgdir>:
+
+int
+sys_pgdir(void) {
+  800183:	55                   	push   %ebp
+  800184:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_pgdir);
+  800186:	6a 1f                	push   $0x1f
+  800188:	e8 28 ff ff ff       	call   8000b5 <syscall>
+  80018d:	83 c4 04             	add    $0x4,%esp
+}
+  800190:	c9                   	leave  
+  800191:	c3                   	ret    
+
+00800192 <sys_gettime>:
+
+int
+sys_gettime(void) {
+  800192:	55                   	push   %ebp
+  800193:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_gettime);
+  800195:	6a 11                	push   $0x11
+  800197:	e8 19 ff ff ff       	call   8000b5 <syscall>
+  80019c:	83 c4 04             	add    $0x4,%esp
+}
+  80019f:	c9                   	leave  
+  8001a0:	c3                   	ret    
+
+008001a1 <sys_lab6_set_priority>:
+
+void
+sys_lab6_set_priority(uint32_t priority)
+{
+  8001a1:	55                   	push   %ebp
+  8001a2:	89 e5                	mov    %esp,%ebp
+    syscall(SYS_lab6_set_priority, priority);
+  8001a4:	ff 75 08             	pushl  0x8(%ebp)
+  8001a7:	68 ff 00 00 00       	push   $0xff
+  8001ac:	e8 04 ff ff ff       	call   8000b5 <syscall>
+  8001b1:	83 c4 08             	add    $0x8,%esp
+}
+  8001b4:	90                   	nop
+  8001b5:	c9                   	leave  
+  8001b6:	c3                   	ret    
+
+008001b7 <exit>:
+#include <syscall.h>
+#include <stdio.h>
+#include <ulib.h>
+
+void
+exit(int error_code) {
+  8001b7:	55                   	push   %ebp
+  8001b8:	89 e5                	mov    %esp,%ebp
+  8001ba:	83 ec 08             	sub    $0x8,%esp
+    sys_exit(error_code);
+  8001bd:	83 ec 0c             	sub    $0xc,%esp
+  8001c0:	ff 75 08             	pushl  0x8(%ebp)
+  8001c3:	e8 43 ff ff ff       	call   80010b <sys_exit>
+  8001c8:	83 c4 10             	add    $0x10,%esp
+    cprintf("BUG: exit failed.\n");
+  8001cb:	83 ec 0c             	sub    $0xc,%esp
+  8001ce:	68 b8 10 80 00       	push   $0x8010b8
+  8001d3:	e8 01 01 00 00       	call   8002d9 <cprintf>
+  8001d8:	83 c4 10             	add    $0x10,%esp
+    while (1);
+  8001db:	eb fe                	jmp    8001db <exit+0x24>
+
+008001dd <fork>:
+}
+
+int
+fork(void) {
+  8001dd:	55                   	push   %ebp
+  8001de:	89 e5                	mov    %esp,%ebp
+  8001e0:	83 ec 08             	sub    $0x8,%esp
+    return sys_fork();
+  8001e3:	e8 35 ff ff ff       	call   80011d <sys_fork>
+}
+  8001e8:	c9                   	leave  
+  8001e9:	c3                   	ret    
+
+008001ea <wait>:
+
+int
+wait(void) {
+  8001ea:	55                   	push   %ebp
+  8001eb:	89 e5                	mov    %esp,%ebp
+  8001ed:	83 ec 08             	sub    $0x8,%esp
+    return sys_wait(0, NULL);
+  8001f0:	83 ec 08             	sub    $0x8,%esp
+  8001f3:	6a 00                	push   $0x0
+  8001f5:	6a 00                	push   $0x0
+  8001f7:	e8 30 ff ff ff       	call   80012c <sys_wait>
+  8001fc:	83 c4 10             	add    $0x10,%esp
+}
+  8001ff:	c9                   	leave  
+  800200:	c3                   	ret    
+
+00800201 <waitpid>:
+
+int
+waitpid(int pid, int *store) {
+  800201:	55                   	push   %ebp
+  800202:	89 e5                	mov    %esp,%ebp
+  800204:	83 ec 08             	sub    $0x8,%esp
+    return sys_wait(pid, store);
+  800207:	83 ec 08             	sub    $0x8,%esp
+  80020a:	ff 75 0c             	pushl  0xc(%ebp)
+  80020d:	ff 75 08             	pushl  0x8(%ebp)
+  800210:	e8 17 ff ff ff       	call   80012c <sys_wait>
+  800215:	83 c4 10             	add    $0x10,%esp
+}
+  800218:	c9                   	leave  
+  800219:	c3                   	ret    
+
+0080021a <yield>:
+
+void
+yield(void) {
+  80021a:	55                   	push   %ebp
+  80021b:	89 e5                	mov    %esp,%ebp
+  80021d:	83 ec 08             	sub    $0x8,%esp
+    sys_yield();
+  800220:	e8 1c ff ff ff       	call   800141 <sys_yield>
+}
+  800225:	90                   	nop
+  800226:	c9                   	leave  
+  800227:	c3                   	ret    
+
+00800228 <kill>:
+
+int
+kill(int pid) {
+  800228:	55                   	push   %ebp
+  800229:	89 e5                	mov    %esp,%ebp
+  80022b:	83 ec 08             	sub    $0x8,%esp
+    return sys_kill(pid);
+  80022e:	83 ec 0c             	sub    $0xc,%esp
+  800231:	ff 75 08             	pushl  0x8(%ebp)
+  800234:	e8 17 ff ff ff       	call   800150 <sys_kill>
+  800239:	83 c4 10             	add    $0x10,%esp
+}
+  80023c:	c9                   	leave  
+  80023d:	c3                   	ret    
+
+0080023e <getpid>:
+
+int
+getpid(void) {
+  80023e:	55                   	push   %ebp
+  80023f:	89 e5                	mov    %esp,%ebp
+  800241:	83 ec 08             	sub    $0x8,%esp
+    return sys_getpid();
+  800244:	e8 19 ff ff ff       	call   800162 <sys_getpid>
+}
+  800249:	c9                   	leave  
+  80024a:	c3                   	ret    
+
+0080024b <print_pgdir>:
+
+//print_pgdir - print the PDT&PT
+void
+print_pgdir(void) {
+  80024b:	55                   	push   %ebp
+  80024c:	89 e5                	mov    %esp,%ebp
+  80024e:	83 ec 08             	sub    $0x8,%esp
+    sys_pgdir();
+  800251:	e8 2d ff ff ff       	call   800183 <sys_pgdir>
+}
+  800256:	90                   	nop
+  800257:	c9                   	leave  
+  800258:	c3                   	ret    
+
+00800259 <gettime_msec>:
+
+unsigned int
+gettime_msec(void) {
+  800259:	55                   	push   %ebp
+  80025a:	89 e5                	mov    %esp,%ebp
+  80025c:	83 ec 08             	sub    $0x8,%esp
+    return (unsigned int)sys_gettime();
+  80025f:	e8 2e ff ff ff       	call   800192 <sys_gettime>
+}
+  800264:	c9                   	leave  
+  800265:	c3                   	ret    
+
+00800266 <lab6_set_priority>:
+
+void
+lab6_set_priority(uint32_t priority)
+{
+  800266:	55                   	push   %ebp
+  800267:	89 e5                	mov    %esp,%ebp
+  800269:	83 ec 08             	sub    $0x8,%esp
+    sys_lab6_set_priority(priority);
+  80026c:	83 ec 0c             	sub    $0xc,%esp
+  80026f:	ff 75 08             	pushl  0x8(%ebp)
+  800272:	e8 2a ff ff ff       	call   8001a1 <sys_lab6_set_priority>
+  800277:	83 c4 10             	add    $0x10,%esp
+}
+  80027a:	90                   	nop
+  80027b:	c9                   	leave  
+  80027c:	c3                   	ret    
+
+0080027d <_start>:
+.text
+.globl _start
+_start:
+    # set ebp for backtrace
+    movl $0x0, %ebp
+  80027d:	bd 00 00 00 00       	mov    $0x0,%ebp
+
+    # move down the esp register
+    # since it may cause page fault in backtrace
+    subl $0x20, %esp
+  800282:	83 ec 20             	sub    $0x20,%esp
+
+    # call user-program function
+    call umain
+  800285:	e8 c3 00 00 00       	call   80034d <umain>
+1:  jmp 1b
+  80028a:	eb fe                	jmp    80028a <_start+0xd>
+
+0080028c <cputch>:
+/* *
+ * cputch - writes a single character @c to stdout, and it will
+ * increace the value of counter pointed by @cnt.
+ * */
+static void
+cputch(int c, int *cnt) {
+  80028c:	55                   	push   %ebp
+  80028d:	89 e5                	mov    %esp,%ebp
+  80028f:	83 ec 08             	sub    $0x8,%esp
+    sys_putc(c);
+  800292:	83 ec 0c             	sub    $0xc,%esp
+  800295:	ff 75 08             	pushl  0x8(%ebp)
+  800298:	e8 d4 fe ff ff       	call   800171 <sys_putc>
+  80029d:	83 c4 10             	add    $0x10,%esp
+    (*cnt) ++;
+  8002a0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002a3:	8b 00                	mov    (%eax),%eax
+  8002a5:	8d 50 01             	lea    0x1(%eax),%edx
+  8002a8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002ab:	89 10                	mov    %edx,(%eax)
+}
+  8002ad:	90                   	nop
+  8002ae:	c9                   	leave  
+  8002af:	c3                   	ret    
+
+008002b0 <vcprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want cprintf() instead.
+ * */
+int
+vcprintf(const char *fmt, va_list ap) {
+  8002b0:	55                   	push   %ebp
+  8002b1:	89 e5                	mov    %esp,%ebp
+  8002b3:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+  8002b6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    vprintfmt((void*)cputch, &cnt, fmt, ap);
+  8002bd:	ff 75 0c             	pushl  0xc(%ebp)
+  8002c0:	ff 75 08             	pushl  0x8(%ebp)
+  8002c3:	8d 45 f4             	lea    -0xc(%ebp),%eax
+  8002c6:	50                   	push   %eax
+  8002c7:	68 8c 02 80 00       	push   $0x80028c
+  8002cc:	e8 fc 06 00 00       	call   8009cd <vprintfmt>
+  8002d1:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+  8002d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8002d7:	c9                   	leave  
+  8002d8:	c3                   	ret    
+
+008002d9 <cprintf>:
+ *
+ * The return value is the number of characters which would be
+ * written to stdout.
+ * */
+int
+cprintf(const char *fmt, ...) {
+  8002d9:	55                   	push   %ebp
+  8002da:	89 e5                	mov    %esp,%ebp
+  8002dc:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  8002df:	8d 45 0c             	lea    0xc(%ebp),%eax
+  8002e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    int cnt = vcprintf(fmt, ap);
+  8002e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8002e8:	83 ec 08             	sub    $0x8,%esp
+  8002eb:	50                   	push   %eax
+  8002ec:	ff 75 08             	pushl  0x8(%ebp)
+  8002ef:	e8 bc ff ff ff       	call   8002b0 <vcprintf>
+  8002f4:	83 c4 10             	add    $0x10,%esp
+  8002f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+
+    return cnt;
+  8002fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8002fd:	c9                   	leave  
+  8002fe:	c3                   	ret    
+
+008002ff <cputs>:
+/* *
+ * cputs- writes the string pointed by @str to stdout and
+ * appends a newline character.
+ * */
+int
+cputs(const char *str) {
+  8002ff:	55                   	push   %ebp
+  800300:	89 e5                	mov    %esp,%ebp
+  800302:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+  800305:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    char c;
+    while ((c = *str ++) != '\0') {
+  80030c:	eb 14                	jmp    800322 <cputs+0x23>
+        cputch(c, &cnt);
+  80030e:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
+  800312:	83 ec 08             	sub    $0x8,%esp
+  800315:	8d 55 f0             	lea    -0x10(%ebp),%edx
+  800318:	52                   	push   %edx
+  800319:	50                   	push   %eax
+  80031a:	e8 6d ff ff ff       	call   80028c <cputch>
+  80031f:	83 c4 10             	add    $0x10,%esp
+ * */
+int
+cputs(const char *str) {
+    int cnt = 0;
+    char c;
+    while ((c = *str ++) != '\0') {
+  800322:	8b 45 08             	mov    0x8(%ebp),%eax
+  800325:	8d 50 01             	lea    0x1(%eax),%edx
+  800328:	89 55 08             	mov    %edx,0x8(%ebp)
+  80032b:	0f b6 00             	movzbl (%eax),%eax
+  80032e:	88 45 f7             	mov    %al,-0x9(%ebp)
+  800331:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
+  800335:	75 d7                	jne    80030e <cputs+0xf>
+        cputch(c, &cnt);
+    }
+    cputch('\n', &cnt);
+  800337:	83 ec 08             	sub    $0x8,%esp
+  80033a:	8d 45 f0             	lea    -0x10(%ebp),%eax
+  80033d:	50                   	push   %eax
+  80033e:	6a 0a                	push   $0xa
+  800340:	e8 47 ff ff ff       	call   80028c <cputch>
+  800345:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+  800348:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+  80034b:	c9                   	leave  
+  80034c:	c3                   	ret    
+
+0080034d <umain>:
+#include <ulib.h>
+
+int main(void);
+
+void
+umain(void) {
+  80034d:	55                   	push   %ebp
+  80034e:	89 e5                	mov    %esp,%ebp
+  800350:	83 ec 18             	sub    $0x18,%esp
+    int ret = main();
+  800353:	e8 d3 0b 00 00       	call   800f2b <main>
+  800358:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    exit(ret);
+  80035b:	83 ec 0c             	sub    $0xc,%esp
+  80035e:	ff 75 f4             	pushl  -0xc(%ebp)
+  800361:	e8 51 fe ff ff       	call   8001b7 <exit>
+
+00800366 <strlen>:
+ * @s:      the input string
+ *
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+  800366:	55                   	push   %ebp
+  800367:	89 e5                	mov    %esp,%ebp
+  800369:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  80036c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (*s ++ != '\0') {
+  800373:	eb 04                	jmp    800379 <strlen+0x13>
+        cnt ++;
+  800375:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+    size_t cnt = 0;
+    while (*s ++ != '\0') {
+  800379:	8b 45 08             	mov    0x8(%ebp),%eax
+  80037c:	8d 50 01             	lea    0x1(%eax),%edx
+  80037f:	89 55 08             	mov    %edx,0x8(%ebp)
+  800382:	0f b6 00             	movzbl (%eax),%eax
+  800385:	84 c0                	test   %al,%al
+  800387:	75 ec                	jne    800375 <strlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  800389:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  80038c:	c9                   	leave  
+  80038d:	c3                   	ret    
+
+0080038e <strnlen>:
+ * The return value is strlen(s), if that is less than @len, or
+ * @len if there is no '\0' character among the first @len characters
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+  80038e:	55                   	push   %ebp
+  80038f:	89 e5                	mov    %esp,%ebp
+  800391:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  800394:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (cnt < len && *s ++ != '\0') {
+  80039b:	eb 04                	jmp    8003a1 <strnlen+0x13>
+        cnt ++;
+  80039d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+    size_t cnt = 0;
+    while (cnt < len && *s ++ != '\0') {
+  8003a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8003a4:	3b 45 0c             	cmp    0xc(%ebp),%eax
+  8003a7:	73 10                	jae    8003b9 <strnlen+0x2b>
+  8003a9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003ac:	8d 50 01             	lea    0x1(%eax),%edx
+  8003af:	89 55 08             	mov    %edx,0x8(%ebp)
+  8003b2:	0f b6 00             	movzbl (%eax),%eax
+  8003b5:	84 c0                	test   %al,%al
+  8003b7:	75 e4                	jne    80039d <strnlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  8003b9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  8003bc:	c9                   	leave  
+  8003bd:	c3                   	ret    
+
+008003be <strcpy>:
+ * To avoid overflows, the size of array pointed by @dst should be long enough to
+ * contain the same string as @src (including the terminating null character), and
+ * should not overlap in memory with @src.
+ * */
+char *
+strcpy(char *dst, const char *src) {
+  8003be:	55                   	push   %ebp
+  8003bf:	89 e5                	mov    %esp,%ebp
+  8003c1:	57                   	push   %edi
+  8003c2:	56                   	push   %esi
+  8003c3:	83 ec 20             	sub    $0x20,%esp
+  8003c6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  8003cc:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8003cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCPY
+#define __HAVE_ARCH_STRCPY
+static inline char *
+__strcpy(char *dst, const char *src) {
+    int d0, d1, d2;
+    asm volatile (
+  8003d2:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  8003d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8003d8:	89 d1                	mov    %edx,%ecx
+  8003da:	89 c2                	mov    %eax,%edx
+  8003dc:	89 ce                	mov    %ecx,%esi
+  8003de:	89 d7                	mov    %edx,%edi
+  8003e0:	ac                   	lods   %ds:(%esi),%al
+  8003e1:	aa                   	stos   %al,%es:(%edi)
+  8003e2:	84 c0                	test   %al,%al
+  8003e4:	75 fa                	jne    8003e0 <strcpy+0x22>
+  8003e6:	89 fa                	mov    %edi,%edx
+  8003e8:	89 f1                	mov    %esi,%ecx
+  8003ea:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  8003ed:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  8003f0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+        "stosb;"
+        "testb %%al, %%al;"
+        "jne 1b;"
+        : "=&S" (d0), "=&D" (d1), "=&a" (d2)
+        : "0" (src), "1" (dst) : "memory");
+    return dst;
+  8003f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCPY
+    return __strcpy(dst, src);
+  8003f6:	90                   	nop
+    char *p = dst;
+    while ((*p ++ = *src ++) != '\0')
+        /* nothing */;
+    return dst;
+#endif /* __HAVE_ARCH_STRCPY */
+}
+  8003f7:	83 c4 20             	add    $0x20,%esp
+  8003fa:	5e                   	pop    %esi
+  8003fb:	5f                   	pop    %edi
+  8003fc:	5d                   	pop    %ebp
+  8003fd:	c3                   	ret    
+
+008003fe <strncpy>:
+ * @len:    maximum number of characters to be copied from @src
+ *
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+  8003fe:	55                   	push   %ebp
+  8003ff:	89 e5                	mov    %esp,%ebp
+  800401:	83 ec 10             	sub    $0x10,%esp
+    char *p = dst;
+  800404:	8b 45 08             	mov    0x8(%ebp),%eax
+  800407:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    while (len > 0) {
+  80040a:	eb 21                	jmp    80042d <strncpy+0x2f>
+        if ((*p = *src) != '\0') {
+  80040c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80040f:	0f b6 10             	movzbl (%eax),%edx
+  800412:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800415:	88 10                	mov    %dl,(%eax)
+  800417:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  80041a:	0f b6 00             	movzbl (%eax),%eax
+  80041d:	84 c0                	test   %al,%al
+  80041f:	74 04                	je     800425 <strncpy+0x27>
+            src ++;
+  800421:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+        }
+        p ++, len --;
+  800425:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800429:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+    char *p = dst;
+    while (len > 0) {
+  80042d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800431:	75 d9                	jne    80040c <strncpy+0xe>
+        if ((*p = *src) != '\0') {
+            src ++;
+        }
+        p ++, len --;
+    }
+    return dst;
+  800433:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800436:	c9                   	leave  
+  800437:	c3                   	ret    
+
+00800438 <strcmp>:
+ * - A value greater than zero indicates that the first character that does
+ *   not match has a greater value in @s1 than in @s2;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+strcmp(const char *s1, const char *s2) {
+  800438:	55                   	push   %ebp
+  800439:	89 e5                	mov    %esp,%ebp
+  80043b:	57                   	push   %edi
+  80043c:	56                   	push   %esi
+  80043d:	83 ec 20             	sub    $0x20,%esp
+  800440:	8b 45 08             	mov    0x8(%ebp),%eax
+  800443:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800446:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800449:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCMP
+#define __HAVE_ARCH_STRCMP
+static inline int
+__strcmp(const char *s1, const char *s2) {
+    int d0, d1, ret;
+    asm volatile (
+  80044c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80044f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800452:	89 d1                	mov    %edx,%ecx
+  800454:	89 c2                	mov    %eax,%edx
+  800456:	89 ce                	mov    %ecx,%esi
+  800458:	89 d7                	mov    %edx,%edi
+  80045a:	ac                   	lods   %ds:(%esi),%al
+  80045b:	ae                   	scas   %es:(%edi),%al
+  80045c:	75 08                	jne    800466 <strcmp+0x2e>
+  80045e:	84 c0                	test   %al,%al
+  800460:	75 f8                	jne    80045a <strcmp+0x22>
+  800462:	31 c0                	xor    %eax,%eax
+  800464:	eb 04                	jmp    80046a <strcmp+0x32>
+  800466:	19 c0                	sbb    %eax,%eax
+  800468:	0c 01                	or     $0x1,%al
+  80046a:	89 fa                	mov    %edi,%edx
+  80046c:	89 f1                	mov    %esi,%ecx
+  80046e:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800471:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  800474:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+        "orb $1, %%al;"
+        "3:"
+        : "=a" (ret), "=&S" (d0), "=&D" (d1)
+        : "1" (s1), "2" (s2)
+        : "memory");
+    return ret;
+  800477:	8b 45 ec             	mov    -0x14(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCMP
+    return __strcmp(s1, s2);
+  80047a:	90                   	nop
+    while (*s1 != '\0' && *s1 == *s2) {
+        s1 ++, s2 ++;
+    }
+    return (int)((unsigned char)*s1 - (unsigned char)*s2);
+#endif /* __HAVE_ARCH_STRCMP */
+}
+  80047b:	83 c4 20             	add    $0x20,%esp
+  80047e:	5e                   	pop    %esi
+  80047f:	5f                   	pop    %edi
+  800480:	5d                   	pop    %ebp
+  800481:	c3                   	ret    
+
+00800482 <strncmp>:
+ * they are equal to each other, it continues with the following pairs until
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+  800482:	55                   	push   %ebp
+  800483:	89 e5                	mov    %esp,%ebp
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  800485:	eb 0c                	jmp    800493 <strncmp+0x11>
+        n --, s1 ++, s2 ++;
+  800487:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  80048b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  80048f:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  800493:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800497:	74 1a                	je     8004b3 <strncmp+0x31>
+  800499:	8b 45 08             	mov    0x8(%ebp),%eax
+  80049c:	0f b6 00             	movzbl (%eax),%eax
+  80049f:	84 c0                	test   %al,%al
+  8004a1:	74 10                	je     8004b3 <strncmp+0x31>
+  8004a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004a6:	0f b6 10             	movzbl (%eax),%edx
+  8004a9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004ac:	0f b6 00             	movzbl (%eax),%eax
+  8004af:	38 c2                	cmp    %al,%dl
+  8004b1:	74 d4                	je     800487 <strncmp+0x5>
+        n --, s1 ++, s2 ++;
+    }
+    return (n == 0) ? 0 : (int)((unsigned char)*s1 - (unsigned char)*s2);
+  8004b3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8004b7:	74 18                	je     8004d1 <strncmp+0x4f>
+  8004b9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004bc:	0f b6 00             	movzbl (%eax),%eax
+  8004bf:	0f b6 d0             	movzbl %al,%edx
+  8004c2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004c5:	0f b6 00             	movzbl (%eax),%eax
+  8004c8:	0f b6 c0             	movzbl %al,%eax
+  8004cb:	29 c2                	sub    %eax,%edx
+  8004cd:	89 d0                	mov    %edx,%eax
+  8004cf:	eb 05                	jmp    8004d6 <strncmp+0x54>
+  8004d1:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  8004d6:	5d                   	pop    %ebp
+  8004d7:	c3                   	ret    
+
+008004d8 <strchr>:
+ *
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+  8004d8:	55                   	push   %ebp
+  8004d9:	89 e5                	mov    %esp,%ebp
+  8004db:	83 ec 04             	sub    $0x4,%esp
+  8004de:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004e1:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  8004e4:	eb 14                	jmp    8004fa <strchr+0x22>
+        if (*s == c) {
+  8004e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004e9:	0f b6 00             	movzbl (%eax),%eax
+  8004ec:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  8004ef:	75 05                	jne    8004f6 <strchr+0x1e>
+            return (char *)s;
+  8004f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004f4:	eb 13                	jmp    800509 <strchr+0x31>
+        }
+        s ++;
+  8004f6:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+    while (*s != '\0') {
+  8004fa:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004fd:	0f b6 00             	movzbl (%eax),%eax
+  800500:	84 c0                	test   %al,%al
+  800502:	75 e2                	jne    8004e6 <strchr+0xe>
+        if (*s == c) {
+            return (char *)s;
+        }
+        s ++;
+    }
+    return NULL;
+  800504:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800509:	c9                   	leave  
+  80050a:	c3                   	ret    
+
+0080050b <strfind>:
+ * The strfind() function is like strchr() except that if @c is
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+  80050b:	55                   	push   %ebp
+  80050c:	89 e5                	mov    %esp,%ebp
+  80050e:	83 ec 04             	sub    $0x4,%esp
+  800511:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800514:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  800517:	eb 0f                	jmp    800528 <strfind+0x1d>
+        if (*s == c) {
+  800519:	8b 45 08             	mov    0x8(%ebp),%eax
+  80051c:	0f b6 00             	movzbl (%eax),%eax
+  80051f:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800522:	74 10                	je     800534 <strfind+0x29>
+            break;
+        }
+        s ++;
+  800524:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+    while (*s != '\0') {
+  800528:	8b 45 08             	mov    0x8(%ebp),%eax
+  80052b:	0f b6 00             	movzbl (%eax),%eax
+  80052e:	84 c0                	test   %al,%al
+  800530:	75 e7                	jne    800519 <strfind+0xe>
+  800532:	eb 01                	jmp    800535 <strfind+0x2a>
+        if (*s == c) {
+            break;
+  800534:	90                   	nop
+        }
+        s ++;
+    }
+    return (char *)s;
+  800535:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800538:	c9                   	leave  
+  800539:	c3                   	ret    
+
+0080053a <strtol>:
+ * an optional "0x" or "0X" prefix.
+ *
+ * The strtol() function returns the converted integral number as a long int value.
+ * */
+long
+strtol(const char *s, char **endptr, int base) {
+  80053a:	55                   	push   %ebp
+  80053b:	89 e5                	mov    %esp,%ebp
+  80053d:	83 ec 10             	sub    $0x10,%esp
+    int neg = 0;
+  800540:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    long val = 0;
+  800547:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  80054e:	eb 04                	jmp    800554 <strtol+0x1a>
+        s ++;
+  800550:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+strtol(const char *s, char **endptr, int base) {
+    int neg = 0;
+    long val = 0;
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  800554:	8b 45 08             	mov    0x8(%ebp),%eax
+  800557:	0f b6 00             	movzbl (%eax),%eax
+  80055a:	3c 20                	cmp    $0x20,%al
+  80055c:	74 f2                	je     800550 <strtol+0x16>
+  80055e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800561:	0f b6 00             	movzbl (%eax),%eax
+  800564:	3c 09                	cmp    $0x9,%al
+  800566:	74 e8                	je     800550 <strtol+0x16>
+        s ++;
+    }
+
+    // plus/minus sign
+    if (*s == '+') {
+  800568:	8b 45 08             	mov    0x8(%ebp),%eax
+  80056b:	0f b6 00             	movzbl (%eax),%eax
+  80056e:	3c 2b                	cmp    $0x2b,%al
+  800570:	75 06                	jne    800578 <strtol+0x3e>
+        s ++;
+  800572:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800576:	eb 15                	jmp    80058d <strtol+0x53>
+    }
+    else if (*s == '-') {
+  800578:	8b 45 08             	mov    0x8(%ebp),%eax
+  80057b:	0f b6 00             	movzbl (%eax),%eax
+  80057e:	3c 2d                	cmp    $0x2d,%al
+  800580:	75 0b                	jne    80058d <strtol+0x53>
+        s ++, neg = 1;
+  800582:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800586:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+    }
+
+    // hex or octal base prefix
+    if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x')) {
+  80058d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800591:	74 06                	je     800599 <strtol+0x5f>
+  800593:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+  800597:	75 24                	jne    8005bd <strtol+0x83>
+  800599:	8b 45 08             	mov    0x8(%ebp),%eax
+  80059c:	0f b6 00             	movzbl (%eax),%eax
+  80059f:	3c 30                	cmp    $0x30,%al
+  8005a1:	75 1a                	jne    8005bd <strtol+0x83>
+  8005a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005a6:	83 c0 01             	add    $0x1,%eax
+  8005a9:	0f b6 00             	movzbl (%eax),%eax
+  8005ac:	3c 78                	cmp    $0x78,%al
+  8005ae:	75 0d                	jne    8005bd <strtol+0x83>
+        s += 2, base = 16;
+  8005b0:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+  8005b4:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+  8005bb:	eb 2a                	jmp    8005e7 <strtol+0xad>
+    }
+    else if (base == 0 && s[0] == '0') {
+  8005bd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8005c1:	75 17                	jne    8005da <strtol+0xa0>
+  8005c3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005c6:	0f b6 00             	movzbl (%eax),%eax
+  8005c9:	3c 30                	cmp    $0x30,%al
+  8005cb:	75 0d                	jne    8005da <strtol+0xa0>
+        s ++, base = 8;
+  8005cd:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  8005d1:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+  8005d8:	eb 0d                	jmp    8005e7 <strtol+0xad>
+    }
+    else if (base == 0) {
+  8005da:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8005de:	75 07                	jne    8005e7 <strtol+0xad>
+        base = 10;
+  8005e0:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+    // digits
+    while (1) {
+        int dig;
+
+        if (*s >= '0' && *s <= '9') {
+  8005e7:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005ea:	0f b6 00             	movzbl (%eax),%eax
+  8005ed:	3c 2f                	cmp    $0x2f,%al
+  8005ef:	7e 1b                	jle    80060c <strtol+0xd2>
+  8005f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005f4:	0f b6 00             	movzbl (%eax),%eax
+  8005f7:	3c 39                	cmp    $0x39,%al
+  8005f9:	7f 11                	jg     80060c <strtol+0xd2>
+            dig = *s - '0';
+  8005fb:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005fe:	0f b6 00             	movzbl (%eax),%eax
+  800601:	0f be c0             	movsbl %al,%eax
+  800604:	83 e8 30             	sub    $0x30,%eax
+  800607:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80060a:	eb 48                	jmp    800654 <strtol+0x11a>
+        }
+        else if (*s >= 'a' && *s <= 'z') {
+  80060c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80060f:	0f b6 00             	movzbl (%eax),%eax
+  800612:	3c 60                	cmp    $0x60,%al
+  800614:	7e 1b                	jle    800631 <strtol+0xf7>
+  800616:	8b 45 08             	mov    0x8(%ebp),%eax
+  800619:	0f b6 00             	movzbl (%eax),%eax
+  80061c:	3c 7a                	cmp    $0x7a,%al
+  80061e:	7f 11                	jg     800631 <strtol+0xf7>
+            dig = *s - 'a' + 10;
+  800620:	8b 45 08             	mov    0x8(%ebp),%eax
+  800623:	0f b6 00             	movzbl (%eax),%eax
+  800626:	0f be c0             	movsbl %al,%eax
+  800629:	83 e8 57             	sub    $0x57,%eax
+  80062c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80062f:	eb 23                	jmp    800654 <strtol+0x11a>
+        }
+        else if (*s >= 'A' && *s <= 'Z') {
+  800631:	8b 45 08             	mov    0x8(%ebp),%eax
+  800634:	0f b6 00             	movzbl (%eax),%eax
+  800637:	3c 40                	cmp    $0x40,%al
+  800639:	7e 3c                	jle    800677 <strtol+0x13d>
+  80063b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80063e:	0f b6 00             	movzbl (%eax),%eax
+  800641:	3c 5a                	cmp    $0x5a,%al
+  800643:	7f 32                	jg     800677 <strtol+0x13d>
+            dig = *s - 'A' + 10;
+  800645:	8b 45 08             	mov    0x8(%ebp),%eax
+  800648:	0f b6 00             	movzbl (%eax),%eax
+  80064b:	0f be c0             	movsbl %al,%eax
+  80064e:	83 e8 37             	sub    $0x37,%eax
+  800651:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+  800654:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800657:	3b 45 10             	cmp    0x10(%ebp),%eax
+  80065a:	7d 1a                	jge    800676 <strtol+0x13c>
+            break;
+        }
+        s ++, val = (val * base) + dig;
+  80065c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800660:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800663:	0f af 45 10          	imul   0x10(%ebp),%eax
+  800667:	89 c2                	mov    %eax,%edx
+  800669:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  80066c:	01 d0                	add    %edx,%eax
+  80066e:	89 45 f8             	mov    %eax,-0x8(%ebp)
+        // we don't properly detect overflow!
+    }
+  800671:	e9 71 ff ff ff       	jmp    8005e7 <strtol+0xad>
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+            break;
+  800676:	90                   	nop
+        }
+        s ++, val = (val * base) + dig;
+        // we don't properly detect overflow!
+    }
+
+    if (endptr) {
+  800677:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  80067b:	74 08                	je     800685 <strtol+0x14b>
+        *endptr = (char *) s;
+  80067d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800680:	8b 55 08             	mov    0x8(%ebp),%edx
+  800683:	89 10                	mov    %edx,(%eax)
+    }
+    return (neg ? -val : val);
+  800685:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+  800689:	74 07                	je     800692 <strtol+0x158>
+  80068b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  80068e:	f7 d8                	neg    %eax
+  800690:	eb 03                	jmp    800695 <strtol+0x15b>
+  800692:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  800695:	c9                   	leave  
+  800696:	c3                   	ret    
+
+00800697 <memset>:
+ * @n:      number of bytes to be set to the value
+ *
+ * The memset() function returns @s.
+ * */
+void *
+memset(void *s, char c, size_t n) {
+  800697:	55                   	push   %ebp
+  800698:	89 e5                	mov    %esp,%ebp
+  80069a:	57                   	push   %edi
+  80069b:	83 ec 24             	sub    $0x24,%esp
+  80069e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006a1:	88 45 d8             	mov    %al,-0x28(%ebp)
+#ifdef __HAVE_ARCH_MEMSET
+    return __memset(s, c, n);
+  8006a4:	0f be 45 d8          	movsbl -0x28(%ebp),%eax
+  8006a8:	8b 55 08             	mov    0x8(%ebp),%edx
+  8006ab:	89 55 f8             	mov    %edx,-0x8(%ebp)
+  8006ae:	88 45 f7             	mov    %al,-0x9(%ebp)
+  8006b1:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_MEMSET
+#define __HAVE_ARCH_MEMSET
+static inline void *
+__memset(void *s, char c, size_t n) {
+    int d0, d1;
+    asm volatile (
+  8006b7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+  8006ba:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
+  8006be:	8b 55 f8             	mov    -0x8(%ebp),%edx
+  8006c1:	89 d7                	mov    %edx,%edi
+  8006c3:	f3 aa                	rep stos %al,%es:(%edi)
+  8006c5:	89 fa                	mov    %edi,%edx
+  8006c7:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  8006ca:	89 55 e8             	mov    %edx,-0x18(%ebp)
+        "rep; stosb;"
+        : "=&c" (d0), "=&D" (d1)
+        : "0" (n), "a" (c), "1" (s)
+        : "memory");
+    return s;
+  8006cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8006d0:	90                   	nop
+    while (n -- > 0) {
+        *p ++ = c;
+    }
+    return s;
+#endif /* __HAVE_ARCH_MEMSET */
+}
+  8006d1:	83 c4 24             	add    $0x24,%esp
+  8006d4:	5f                   	pop    %edi
+  8006d5:	5d                   	pop    %ebp
+  8006d6:	c3                   	ret    
+
+008006d7 <memmove>:
+ * @n:      number of bytes to copy
+ *
+ * The memmove() function returns @dst.
+ * */
+void *
+memmove(void *dst, const void *src, size_t n) {
+  8006d7:	55                   	push   %ebp
+  8006d8:	89 e5                	mov    %esp,%ebp
+  8006da:	57                   	push   %edi
+  8006db:	56                   	push   %esi
+  8006dc:	53                   	push   %ebx
+  8006dd:	83 ec 30             	sub    $0x30,%esp
+  8006e0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8006e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8006e6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  8006ec:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006ef:	89 45 e8             	mov    %eax,-0x18(%ebp)
+
+#ifndef __HAVE_ARCH_MEMMOVE
+#define __HAVE_ARCH_MEMMOVE
+static inline void *
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+  8006f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006f5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  8006f8:	73 42                	jae    80073c <memmove+0x65>
+  8006fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006fd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800700:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800703:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800706:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800709:	89 45 dc             	mov    %eax,-0x24(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  80070c:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  80070f:	c1 e8 02             	shr    $0x2,%eax
+  800712:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  800714:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800717:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80071a:	89 d7                	mov    %edx,%edi
+  80071c:	89 c6                	mov    %eax,%esi
+  80071e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800720:	8b 4d dc             	mov    -0x24(%ebp),%ecx
+  800723:	83 e1 03             	and    $0x3,%ecx
+  800726:	74 02                	je     80072a <memmove+0x53>
+  800728:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  80072a:	89 f0                	mov    %esi,%eax
+  80072c:	89 fa                	mov    %edi,%edx
+  80072e:	89 4d d8             	mov    %ecx,-0x28(%ebp)
+  800731:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  800734:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  800737:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMMOVE
+    return __memmove(dst, src, n);
+  80073a:	eb 36                	jmp    800772 <memmove+0x9b>
+    asm volatile (
+        "std;"
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+  80073c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80073f:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800742:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800745:	01 c2                	add    %eax,%edx
+  800747:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80074a:	8d 48 ff             	lea    -0x1(%eax),%ecx
+  80074d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800750:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+        return __memcpy(dst, src, n);
+    }
+    int d0, d1, d2;
+    asm volatile (
+  800753:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800756:	89 c1                	mov    %eax,%ecx
+  800758:	89 d8                	mov    %ebx,%eax
+  80075a:	89 d6                	mov    %edx,%esi
+  80075c:	89 c7                	mov    %eax,%edi
+  80075e:	fd                   	std    
+  80075f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  800761:	fc                   	cld    
+  800762:	89 f8                	mov    %edi,%eax
+  800764:	89 f2                	mov    %esi,%edx
+  800766:	89 4d cc             	mov    %ecx,-0x34(%ebp)
+  800769:	89 55 c8             	mov    %edx,-0x38(%ebp)
+  80076c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+        : "memory");
+    return dst;
+  80076f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+            *d ++ = *s ++;
+        }
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMMOVE */
+}
+  800772:	83 c4 30             	add    $0x30,%esp
+  800775:	5b                   	pop    %ebx
+  800776:	5e                   	pop    %esi
+  800777:	5f                   	pop    %edi
+  800778:	5d                   	pop    %ebp
+  800779:	c3                   	ret    
+
+0080077a <memcpy>:
+ * it always copies exactly @n bytes. To avoid overflows, the size of arrays pointed
+ * by both @src and @dst, should be at least @n bytes, and should not overlap
+ * (for overlapping memory area, memmove is a safer approach).
+ * */
+void *
+memcpy(void *dst, const void *src, size_t n) {
+  80077a:	55                   	push   %ebp
+  80077b:	89 e5                	mov    %esp,%ebp
+  80077d:	57                   	push   %edi
+  80077e:	56                   	push   %esi
+  80077f:	83 ec 20             	sub    $0x20,%esp
+  800782:	8b 45 08             	mov    0x8(%ebp),%eax
+  800785:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800788:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80078b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80078e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800791:	89 45 ec             	mov    %eax,-0x14(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  800794:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800797:	c1 e8 02             	shr    $0x2,%eax
+  80079a:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  80079c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80079f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8007a2:	89 d7                	mov    %edx,%edi
+  8007a4:	89 c6                	mov    %eax,%esi
+  8007a6:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  8007a8:	8b 4d ec             	mov    -0x14(%ebp),%ecx
+  8007ab:	83 e1 03             	and    $0x3,%ecx
+  8007ae:	74 02                	je     8007b2 <memcpy+0x38>
+  8007b0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  8007b2:	89 f0                	mov    %esi,%eax
+  8007b4:	89 fa                	mov    %edi,%edx
+  8007b6:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  8007b9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  8007bc:	89 45 e0             	mov    %eax,-0x20(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  8007bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMCPY
+    return __memcpy(dst, src, n);
+  8007c2:	90                   	nop
+    while (n -- > 0) {
+        *d ++ = *s ++;
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMCPY */
+}
+  8007c3:	83 c4 20             	add    $0x20,%esp
+  8007c6:	5e                   	pop    %esi
+  8007c7:	5f                   	pop    %edi
+  8007c8:	5d                   	pop    %ebp
+  8007c9:	c3                   	ret    
+
+008007ca <memcmp>:
+ *   match in both memory blocks has a greater value in @v1 than in @v2
+ *   as if evaluated as unsigned char values;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+  8007ca:	55                   	push   %ebp
+  8007cb:	89 e5                	mov    %esp,%ebp
+  8007cd:	83 ec 10             	sub    $0x10,%esp
+    const char *s1 = (const char *)v1;
+  8007d0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8007d3:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    const char *s2 = (const char *)v2;
+  8007d6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8007d9:	89 45 f8             	mov    %eax,-0x8(%ebp)
+    while (n -- > 0) {
+  8007dc:	eb 30                	jmp    80080e <memcmp+0x44>
+        if (*s1 != *s2) {
+  8007de:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8007e1:	0f b6 10             	movzbl (%eax),%edx
+  8007e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8007e7:	0f b6 00             	movzbl (%eax),%eax
+  8007ea:	38 c2                	cmp    %al,%dl
+  8007ec:	74 18                	je     800806 <memcmp+0x3c>
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+  8007ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8007f1:	0f b6 00             	movzbl (%eax),%eax
+  8007f4:	0f b6 d0             	movzbl %al,%edx
+  8007f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8007fa:	0f b6 00             	movzbl (%eax),%eax
+  8007fd:	0f b6 c0             	movzbl %al,%eax
+  800800:	29 c2                	sub    %eax,%edx
+  800802:	89 d0                	mov    %edx,%eax
+  800804:	eb 1a                	jmp    800820 <memcmp+0x56>
+        }
+        s1 ++, s2 ++;
+  800806:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  80080a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+    const char *s1 = (const char *)v1;
+    const char *s2 = (const char *)v2;
+    while (n -- > 0) {
+  80080e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800811:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800814:	89 55 10             	mov    %edx,0x10(%ebp)
+  800817:	85 c0                	test   %eax,%eax
+  800819:	75 c3                	jne    8007de <memcmp+0x14>
+        if (*s1 != *s2) {
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+        }
+        s1 ++, s2 ++;
+    }
+    return 0;
+  80081b:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800820:	c9                   	leave  
+  800821:	c3                   	ret    
+
+00800822 <printnum>:
+ * @width:      maximum number of digits, if the actual width is less than @width, use @padc instead
+ * @padc:       character that padded on the left if the actual width is less than @width
+ * */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+        unsigned long long num, unsigned base, int width, int padc) {
+  800822:	55                   	push   %ebp
+  800823:	89 e5                	mov    %esp,%ebp
+  800825:	83 ec 38             	sub    $0x38,%esp
+  800828:	8b 45 10             	mov    0x10(%ebp),%eax
+  80082b:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  80082e:	8b 45 14             	mov    0x14(%ebp),%eax
+  800831:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+    unsigned long long result = num;
+  800834:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  800837:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  80083a:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  80083d:	89 55 ec             	mov    %edx,-0x14(%ebp)
+    unsigned mod = do_div(result, base);
+  800840:	8b 45 18             	mov    0x18(%ebp),%eax
+  800843:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800846:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800849:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  80084c:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  80084f:	89 55 f0             	mov    %edx,-0x10(%ebp)
+  800852:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800855:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800858:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  80085c:	74 1c                	je     80087a <printnum+0x58>
+  80085e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800861:	ba 00 00 00 00       	mov    $0x0,%edx
+  800866:	f7 75 e4             	divl   -0x1c(%ebp)
+  800869:	89 55 f4             	mov    %edx,-0xc(%ebp)
+  80086c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  80086f:	ba 00 00 00 00       	mov    $0x0,%edx
+  800874:	f7 75 e4             	divl   -0x1c(%ebp)
+  800877:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80087a:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80087d:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800880:	f7 75 e4             	divl   -0x1c(%ebp)
+  800883:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800886:	89 55 dc             	mov    %edx,-0x24(%ebp)
+  800889:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80088c:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  80088f:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800892:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  800895:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  800898:	89 45 d8             	mov    %eax,-0x28(%ebp)
+
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+  80089b:	8b 45 18             	mov    0x18(%ebp),%eax
+  80089e:	ba 00 00 00 00       	mov    $0x0,%edx
+  8008a3:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  8008a6:	77 41                	ja     8008e9 <printnum+0xc7>
+  8008a8:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  8008ab:	72 05                	jb     8008b2 <printnum+0x90>
+  8008ad:	3b 45 d0             	cmp    -0x30(%ebp),%eax
+  8008b0:	77 37                	ja     8008e9 <printnum+0xc7>
+        printnum(putch, putdat, result, base, width - 1, padc);
+  8008b2:	8b 45 1c             	mov    0x1c(%ebp),%eax
+  8008b5:	83 e8 01             	sub    $0x1,%eax
+  8008b8:	83 ec 04             	sub    $0x4,%esp
+  8008bb:	ff 75 20             	pushl  0x20(%ebp)
+  8008be:	50                   	push   %eax
+  8008bf:	ff 75 18             	pushl  0x18(%ebp)
+  8008c2:	ff 75 ec             	pushl  -0x14(%ebp)
+  8008c5:	ff 75 e8             	pushl  -0x18(%ebp)
+  8008c8:	ff 75 0c             	pushl  0xc(%ebp)
+  8008cb:	ff 75 08             	pushl  0x8(%ebp)
+  8008ce:	e8 4f ff ff ff       	call   800822 <printnum>
+  8008d3:	83 c4 20             	add    $0x20,%esp
+  8008d6:	eb 1b                	jmp    8008f3 <printnum+0xd1>
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+            putch(padc, putdat);
+  8008d8:	83 ec 08             	sub    $0x8,%esp
+  8008db:	ff 75 0c             	pushl  0xc(%ebp)
+  8008de:	ff 75 20             	pushl  0x20(%ebp)
+  8008e1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8008e4:	ff d0                	call   *%eax
+  8008e6:	83 c4 10             	add    $0x10,%esp
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+        printnum(putch, putdat, result, base, width - 1, padc);
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+  8008e9:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+  8008ed:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+  8008f1:	7f e5                	jg     8008d8 <printnum+0xb6>
+            putch(padc, putdat);
+    }
+    // then print this (the least significant) digit
+    putch("0123456789abcdef"[mod], putdat);
+  8008f3:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  8008f6:	05 e4 11 80 00       	add    $0x8011e4,%eax
+  8008fb:	0f b6 00             	movzbl (%eax),%eax
+  8008fe:	0f be c0             	movsbl %al,%eax
+  800901:	83 ec 08             	sub    $0x8,%esp
+  800904:	ff 75 0c             	pushl  0xc(%ebp)
+  800907:	50                   	push   %eax
+  800908:	8b 45 08             	mov    0x8(%ebp),%eax
+  80090b:	ff d0                	call   *%eax
+  80090d:	83 c4 10             	add    $0x10,%esp
+}
+  800910:	90                   	nop
+  800911:	c9                   	leave  
+  800912:	c3                   	ret    
+
+00800913 <getuint>:
+ * getuint - get an unsigned int of various possible sizes from a varargs list
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static unsigned long long
+getuint(va_list *ap, int lflag) {
+  800913:	55                   	push   %ebp
+  800914:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  800916:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  80091a:	7e 14                	jle    800930 <getuint+0x1d>
+        return va_arg(*ap, unsigned long long);
+  80091c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80091f:	8b 00                	mov    (%eax),%eax
+  800921:	8d 48 08             	lea    0x8(%eax),%ecx
+  800924:	8b 55 08             	mov    0x8(%ebp),%edx
+  800927:	89 0a                	mov    %ecx,(%edx)
+  800929:	8b 50 04             	mov    0x4(%eax),%edx
+  80092c:	8b 00                	mov    (%eax),%eax
+  80092e:	eb 30                	jmp    800960 <getuint+0x4d>
+    }
+    else if (lflag) {
+  800930:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800934:	74 16                	je     80094c <getuint+0x39>
+        return va_arg(*ap, unsigned long);
+  800936:	8b 45 08             	mov    0x8(%ebp),%eax
+  800939:	8b 00                	mov    (%eax),%eax
+  80093b:	8d 48 04             	lea    0x4(%eax),%ecx
+  80093e:	8b 55 08             	mov    0x8(%ebp),%edx
+  800941:	89 0a                	mov    %ecx,(%edx)
+  800943:	8b 00                	mov    (%eax),%eax
+  800945:	ba 00 00 00 00       	mov    $0x0,%edx
+  80094a:	eb 14                	jmp    800960 <getuint+0x4d>
+    }
+    else {
+        return va_arg(*ap, unsigned int);
+  80094c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80094f:	8b 00                	mov    (%eax),%eax
+  800951:	8d 48 04             	lea    0x4(%eax),%ecx
+  800954:	8b 55 08             	mov    0x8(%ebp),%edx
+  800957:	89 0a                	mov    %ecx,(%edx)
+  800959:	8b 00                	mov    (%eax),%eax
+  80095b:	ba 00 00 00 00       	mov    $0x0,%edx
+    }
+}
+  800960:	5d                   	pop    %ebp
+  800961:	c3                   	ret    
+
+00800962 <getint>:
+ * getint - same as getuint but signed, we can't use getuint because of sign extension
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static long long
+getint(va_list *ap, int lflag) {
+  800962:	55                   	push   %ebp
+  800963:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  800965:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  800969:	7e 14                	jle    80097f <getint+0x1d>
+        return va_arg(*ap, long long);
+  80096b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80096e:	8b 00                	mov    (%eax),%eax
+  800970:	8d 48 08             	lea    0x8(%eax),%ecx
+  800973:	8b 55 08             	mov    0x8(%ebp),%edx
+  800976:	89 0a                	mov    %ecx,(%edx)
+  800978:	8b 50 04             	mov    0x4(%eax),%edx
+  80097b:	8b 00                	mov    (%eax),%eax
+  80097d:	eb 28                	jmp    8009a7 <getint+0x45>
+    }
+    else if (lflag) {
+  80097f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800983:	74 12                	je     800997 <getint+0x35>
+        return va_arg(*ap, long);
+  800985:	8b 45 08             	mov    0x8(%ebp),%eax
+  800988:	8b 00                	mov    (%eax),%eax
+  80098a:	8d 48 04             	lea    0x4(%eax),%ecx
+  80098d:	8b 55 08             	mov    0x8(%ebp),%edx
+  800990:	89 0a                	mov    %ecx,(%edx)
+  800992:	8b 00                	mov    (%eax),%eax
+  800994:	99                   	cltd   
+  800995:	eb 10                	jmp    8009a7 <getint+0x45>
+    }
+    else {
+        return va_arg(*ap, int);
+  800997:	8b 45 08             	mov    0x8(%ebp),%eax
+  80099a:	8b 00                	mov    (%eax),%eax
+  80099c:	8d 48 04             	lea    0x4(%eax),%ecx
+  80099f:	8b 55 08             	mov    0x8(%ebp),%edx
+  8009a2:	89 0a                	mov    %ecx,(%edx)
+  8009a4:	8b 00                	mov    (%eax),%eax
+  8009a6:	99                   	cltd   
+    }
+}
+  8009a7:	5d                   	pop    %ebp
+  8009a8:	c3                   	ret    
+
+008009a9 <printfmt>:
+ * @putch:      specified putch function, print a single character
+ * @putdat:     used by @putch function
+ * @fmt:        the format string to use
+ * */
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...) {
+  8009a9:	55                   	push   %ebp
+  8009aa:	89 e5                	mov    %esp,%ebp
+  8009ac:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  8009af:	8d 45 14             	lea    0x14(%ebp),%eax
+  8009b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    vprintfmt(putch, putdat, fmt, ap);
+  8009b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8009b8:	50                   	push   %eax
+  8009b9:	ff 75 10             	pushl  0x10(%ebp)
+  8009bc:	ff 75 0c             	pushl  0xc(%ebp)
+  8009bf:	ff 75 08             	pushl  0x8(%ebp)
+  8009c2:	e8 06 00 00 00       	call   8009cd <vprintfmt>
+  8009c7:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+  8009ca:	90                   	nop
+  8009cb:	c9                   	leave  
+  8009cc:	c3                   	ret    
+
+008009cd <vprintfmt>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want printfmt() instead.
+ * */
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap) {
+  8009cd:	55                   	push   %ebp
+  8009ce:	89 e5                	mov    %esp,%ebp
+  8009d0:	56                   	push   %esi
+  8009d1:	53                   	push   %ebx
+  8009d2:	83 ec 20             	sub    $0x20,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  8009d5:	eb 17                	jmp    8009ee <vprintfmt+0x21>
+            if (ch == '\0') {
+  8009d7:	85 db                	test   %ebx,%ebx
+  8009d9:	0f 84 8e 03 00 00    	je     800d6d <vprintfmt+0x3a0>
+                return;
+            }
+            putch(ch, putdat);
+  8009df:	83 ec 08             	sub    $0x8,%esp
+  8009e2:	ff 75 0c             	pushl  0xc(%ebp)
+  8009e5:	53                   	push   %ebx
+  8009e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009e9:	ff d0                	call   *%eax
+  8009eb:	83 c4 10             	add    $0x10,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  8009ee:	8b 45 10             	mov    0x10(%ebp),%eax
+  8009f1:	8d 50 01             	lea    0x1(%eax),%edx
+  8009f4:	89 55 10             	mov    %edx,0x10(%ebp)
+  8009f7:	0f b6 00             	movzbl (%eax),%eax
+  8009fa:	0f b6 d8             	movzbl %al,%ebx
+  8009fd:	83 fb 25             	cmp    $0x25,%ebx
+  800a00:	75 d5                	jne    8009d7 <vprintfmt+0xa>
+            }
+            putch(ch, putdat);
+        }
+
+        // Process a %-escape sequence
+        char padc = ' ';
+  800a02:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+        width = precision = -1;
+  800a06:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+  800a0d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800a10:	89 45 e8             	mov    %eax,-0x18(%ebp)
+        lflag = altflag = 0;
+  800a13:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+  800a1a:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  800a1d:	89 45 e0             	mov    %eax,-0x20(%ebp)
+
+    reswitch:
+        switch (ch = *(unsigned char *)fmt ++) {
+  800a20:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a23:	8d 50 01             	lea    0x1(%eax),%edx
+  800a26:	89 55 10             	mov    %edx,0x10(%ebp)
+  800a29:	0f b6 00             	movzbl (%eax),%eax
+  800a2c:	0f b6 d8             	movzbl %al,%ebx
+  800a2f:	8d 43 dd             	lea    -0x23(%ebx),%eax
+  800a32:	83 f8 55             	cmp    $0x55,%eax
+  800a35:	0f 87 05 03 00 00    	ja     800d40 <vprintfmt+0x373>
+  800a3b:	8b 04 85 08 12 80 00 	mov    0x801208(,%eax,4),%eax
+  800a42:	ff e0                	jmp    *%eax
+
+        // flag to pad on the right
+        case '-':
+            padc = '-';
+  800a44:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+            goto reswitch;
+  800a48:	eb d6                	jmp    800a20 <vprintfmt+0x53>
+
+        // flag to pad with 0's instead of spaces
+        case '0':
+            padc = '0';
+  800a4a:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+            goto reswitch;
+  800a4e:	eb d0                	jmp    800a20 <vprintfmt+0x53>
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  800a50:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+                precision = precision * 10 + ch - '0';
+  800a57:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800a5a:	89 d0                	mov    %edx,%eax
+  800a5c:	c1 e0 02             	shl    $0x2,%eax
+  800a5f:	01 d0                	add    %edx,%eax
+  800a61:	01 c0                	add    %eax,%eax
+  800a63:	01 d8                	add    %ebx,%eax
+  800a65:	83 e8 30             	sub    $0x30,%eax
+  800a68:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+                ch = *fmt;
+  800a6b:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a6e:	0f b6 00             	movzbl (%eax),%eax
+  800a71:	0f be d8             	movsbl %al,%ebx
+                if (ch < '0' || ch > '9') {
+  800a74:	83 fb 2f             	cmp    $0x2f,%ebx
+  800a77:	7e 39                	jle    800ab2 <vprintfmt+0xe5>
+  800a79:	83 fb 39             	cmp    $0x39,%ebx
+  800a7c:	7f 34                	jg     800ab2 <vprintfmt+0xe5>
+            padc = '0';
+            goto reswitch;
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  800a7e:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+                precision = precision * 10 + ch - '0';
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+  800a82:	eb d3                	jmp    800a57 <vprintfmt+0x8a>
+            goto process_precision;
+
+        case '*':
+            precision = va_arg(ap, int);
+  800a84:	8b 45 14             	mov    0x14(%ebp),%eax
+  800a87:	8d 50 04             	lea    0x4(%eax),%edx
+  800a8a:	89 55 14             	mov    %edx,0x14(%ebp)
+  800a8d:	8b 00                	mov    (%eax),%eax
+  800a8f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+            goto process_precision;
+  800a92:	eb 1f                	jmp    800ab3 <vprintfmt+0xe6>
+
+        case '.':
+            if (width < 0)
+  800a94:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800a98:	79 86                	jns    800a20 <vprintfmt+0x53>
+                width = 0;
+  800a9a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+            goto reswitch;
+  800aa1:	e9 7a ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        case '#':
+            altflag = 1;
+  800aa6:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+            goto reswitch;
+  800aad:	e9 6e ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+            goto process_precision;
+  800ab2:	90                   	nop
+        case '#':
+            altflag = 1;
+            goto reswitch;
+
+        process_precision:
+            if (width < 0)
+  800ab3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ab7:	0f 89 63 ff ff ff    	jns    800a20 <vprintfmt+0x53>
+                width = precision, precision = -1;
+  800abd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800ac0:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800ac3:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+            goto reswitch;
+  800aca:	e9 51 ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        // long flag (doubled for long long)
+        case 'l':
+            lflag ++;
+  800acf:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
+            goto reswitch;
+  800ad3:	e9 48 ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        // character
+        case 'c':
+            putch(va_arg(ap, int), putdat);
+  800ad8:	8b 45 14             	mov    0x14(%ebp),%eax
+  800adb:	8d 50 04             	lea    0x4(%eax),%edx
+  800ade:	89 55 14             	mov    %edx,0x14(%ebp)
+  800ae1:	8b 00                	mov    (%eax),%eax
+  800ae3:	83 ec 08             	sub    $0x8,%esp
+  800ae6:	ff 75 0c             	pushl  0xc(%ebp)
+  800ae9:	50                   	push   %eax
+  800aea:	8b 45 08             	mov    0x8(%ebp),%eax
+  800aed:	ff d0                	call   *%eax
+  800aef:	83 c4 10             	add    $0x10,%esp
+            break;
+  800af2:	e9 71 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // error message
+        case 'e':
+            err = va_arg(ap, int);
+  800af7:	8b 45 14             	mov    0x14(%ebp),%eax
+  800afa:	8d 50 04             	lea    0x4(%eax),%edx
+  800afd:	89 55 14             	mov    %edx,0x14(%ebp)
+  800b00:	8b 18                	mov    (%eax),%ebx
+            if (err < 0) {
+  800b02:	85 db                	test   %ebx,%ebx
+  800b04:	79 02                	jns    800b08 <vprintfmt+0x13b>
+                err = -err;
+  800b06:	f7 db                	neg    %ebx
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+  800b08:	83 fb 18             	cmp    $0x18,%ebx
+  800b0b:	7f 0b                	jg     800b18 <vprintfmt+0x14b>
+  800b0d:	8b 34 9d 80 11 80 00 	mov    0x801180(,%ebx,4),%esi
+  800b14:	85 f6                	test   %esi,%esi
+  800b16:	75 19                	jne    800b31 <vprintfmt+0x164>
+                printfmt(putch, putdat, "error %d", err);
+  800b18:	53                   	push   %ebx
+  800b19:	68 f5 11 80 00       	push   $0x8011f5
+  800b1e:	ff 75 0c             	pushl  0xc(%ebp)
+  800b21:	ff 75 08             	pushl  0x8(%ebp)
+  800b24:	e8 80 fe ff ff       	call   8009a9 <printfmt>
+  800b29:	83 c4 10             	add    $0x10,%esp
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+            }
+            break;
+  800b2c:	e9 37 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+                printfmt(putch, putdat, "error %d", err);
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+  800b31:	56                   	push   %esi
+  800b32:	68 fe 11 80 00       	push   $0x8011fe
+  800b37:	ff 75 0c             	pushl  0xc(%ebp)
+  800b3a:	ff 75 08             	pushl  0x8(%ebp)
+  800b3d:	e8 67 fe ff ff       	call   8009a9 <printfmt>
+  800b42:	83 c4 10             	add    $0x10,%esp
+            }
+            break;
+  800b45:	e9 1e 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // string
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+  800b4a:	8b 45 14             	mov    0x14(%ebp),%eax
+  800b4d:	8d 50 04             	lea    0x4(%eax),%edx
+  800b50:	89 55 14             	mov    %edx,0x14(%ebp)
+  800b53:	8b 30                	mov    (%eax),%esi
+  800b55:	85 f6                	test   %esi,%esi
+  800b57:	75 05                	jne    800b5e <vprintfmt+0x191>
+                p = "(null)";
+  800b59:	be 01 12 80 00       	mov    $0x801201,%esi
+            }
+            if (width > 0 && padc != '-') {
+  800b5e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800b62:	7e 76                	jle    800bda <vprintfmt+0x20d>
+  800b64:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+  800b68:	74 70                	je     800bda <vprintfmt+0x20d>
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  800b6a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800b6d:	83 ec 08             	sub    $0x8,%esp
+  800b70:	50                   	push   %eax
+  800b71:	56                   	push   %esi
+  800b72:	e8 17 f8 ff ff       	call   80038e <strnlen>
+  800b77:	83 c4 10             	add    $0x10,%esp
+  800b7a:	89 c2                	mov    %eax,%edx
+  800b7c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800b7f:	29 d0                	sub    %edx,%eax
+  800b81:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800b84:	eb 17                	jmp    800b9d <vprintfmt+0x1d0>
+                    putch(padc, putdat);
+  800b86:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+  800b8a:	83 ec 08             	sub    $0x8,%esp
+  800b8d:	ff 75 0c             	pushl  0xc(%ebp)
+  800b90:	50                   	push   %eax
+  800b91:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b94:	ff d0                	call   *%eax
+  800b96:	83 c4 10             	add    $0x10,%esp
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+                p = "(null)";
+            }
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  800b99:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800b9d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ba1:	7f e3                	jg     800b86 <vprintfmt+0x1b9>
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  800ba3:	eb 35                	jmp    800bda <vprintfmt+0x20d>
+                if (altflag && (ch < ' ' || ch > '~')) {
+  800ba5:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+  800ba9:	74 1c                	je     800bc7 <vprintfmt+0x1fa>
+  800bab:	83 fb 1f             	cmp    $0x1f,%ebx
+  800bae:	7e 05                	jle    800bb5 <vprintfmt+0x1e8>
+  800bb0:	83 fb 7e             	cmp    $0x7e,%ebx
+  800bb3:	7e 12                	jle    800bc7 <vprintfmt+0x1fa>
+                    putch('?', putdat);
+  800bb5:	83 ec 08             	sub    $0x8,%esp
+  800bb8:	ff 75 0c             	pushl  0xc(%ebp)
+  800bbb:	6a 3f                	push   $0x3f
+  800bbd:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bc0:	ff d0                	call   *%eax
+  800bc2:	83 c4 10             	add    $0x10,%esp
+  800bc5:	eb 0f                	jmp    800bd6 <vprintfmt+0x209>
+                }
+                else {
+                    putch(ch, putdat);
+  800bc7:	83 ec 08             	sub    $0x8,%esp
+  800bca:	ff 75 0c             	pushl  0xc(%ebp)
+  800bcd:	53                   	push   %ebx
+  800bce:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bd1:	ff d0                	call   *%eax
+  800bd3:	83 c4 10             	add    $0x10,%esp
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  800bd6:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800bda:	89 f0                	mov    %esi,%eax
+  800bdc:	8d 70 01             	lea    0x1(%eax),%esi
+  800bdf:	0f b6 00             	movzbl (%eax),%eax
+  800be2:	0f be d8             	movsbl %al,%ebx
+  800be5:	85 db                	test   %ebx,%ebx
+  800be7:	74 26                	je     800c0f <vprintfmt+0x242>
+  800be9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800bed:	78 b6                	js     800ba5 <vprintfmt+0x1d8>
+  800bef:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800bf3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800bf7:	79 ac                	jns    800ba5 <vprintfmt+0x1d8>
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  800bf9:	eb 14                	jmp    800c0f <vprintfmt+0x242>
+                putch(' ', putdat);
+  800bfb:	83 ec 08             	sub    $0x8,%esp
+  800bfe:	ff 75 0c             	pushl  0xc(%ebp)
+  800c01:	6a 20                	push   $0x20
+  800c03:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c06:	ff d0                	call   *%eax
+  800c08:	83 c4 10             	add    $0x10,%esp
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  800c0b:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800c0f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800c13:	7f e6                	jg     800bfb <vprintfmt+0x22e>
+                putch(' ', putdat);
+            }
+            break;
+  800c15:	e9 4e 01 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // (signed) decimal
+        case 'd':
+            num = getint(&ap, lflag);
+  800c1a:	83 ec 08             	sub    $0x8,%esp
+  800c1d:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c20:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c23:	50                   	push   %eax
+  800c24:	e8 39 fd ff ff       	call   800962 <getint>
+  800c29:	83 c4 10             	add    $0x10,%esp
+  800c2c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c2f:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            if ((long long)num < 0) {
+  800c32:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c35:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800c38:	85 d2                	test   %edx,%edx
+  800c3a:	79 23                	jns    800c5f <vprintfmt+0x292>
+                putch('-', putdat);
+  800c3c:	83 ec 08             	sub    $0x8,%esp
+  800c3f:	ff 75 0c             	pushl  0xc(%ebp)
+  800c42:	6a 2d                	push   $0x2d
+  800c44:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c47:	ff d0                	call   *%eax
+  800c49:	83 c4 10             	add    $0x10,%esp
+                num = -(long long)num;
+  800c4c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c4f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800c52:	f7 d8                	neg    %eax
+  800c54:	83 d2 00             	adc    $0x0,%edx
+  800c57:	f7 da                	neg    %edx
+  800c59:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c5c:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            }
+            base = 10;
+  800c5f:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  800c66:	e9 9f 00 00 00       	jmp    800d0a <vprintfmt+0x33d>
+
+        // unsigned decimal
+        case 'u':
+            num = getuint(&ap, lflag);
+  800c6b:	83 ec 08             	sub    $0x8,%esp
+  800c6e:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c71:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c74:	50                   	push   %eax
+  800c75:	e8 99 fc ff ff       	call   800913 <getuint>
+  800c7a:	83 c4 10             	add    $0x10,%esp
+  800c7d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c80:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 10;
+  800c83:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  800c8a:	eb 7e                	jmp    800d0a <vprintfmt+0x33d>
+
+        // (unsigned) octal
+        case 'o':
+            num = getuint(&ap, lflag);
+  800c8c:	83 ec 08             	sub    $0x8,%esp
+  800c8f:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c92:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c95:	50                   	push   %eax
+  800c96:	e8 78 fc ff ff       	call   800913 <getuint>
+  800c9b:	83 c4 10             	add    $0x10,%esp
+  800c9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800ca1:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 8;
+  800ca4:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+            goto number;
+  800cab:	eb 5d                	jmp    800d0a <vprintfmt+0x33d>
+
+        // pointer
+        case 'p':
+            putch('0', putdat);
+  800cad:	83 ec 08             	sub    $0x8,%esp
+  800cb0:	ff 75 0c             	pushl  0xc(%ebp)
+  800cb3:	6a 30                	push   $0x30
+  800cb5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cb8:	ff d0                	call   *%eax
+  800cba:	83 c4 10             	add    $0x10,%esp
+            putch('x', putdat);
+  800cbd:	83 ec 08             	sub    $0x8,%esp
+  800cc0:	ff 75 0c             	pushl  0xc(%ebp)
+  800cc3:	6a 78                	push   $0x78
+  800cc5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cc8:	ff d0                	call   *%eax
+  800cca:	83 c4 10             	add    $0x10,%esp
+            num = (unsigned long long)(uintptr_t)va_arg(ap, void *);
+  800ccd:	8b 45 14             	mov    0x14(%ebp),%eax
+  800cd0:	8d 50 04             	lea    0x4(%eax),%edx
+  800cd3:	89 55 14             	mov    %edx,0x14(%ebp)
+  800cd6:	8b 00                	mov    (%eax),%eax
+  800cd8:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800cdb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+            base = 16;
+  800ce2:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+            goto number;
+  800ce9:	eb 1f                	jmp    800d0a <vprintfmt+0x33d>
+
+        // (unsigned) hexadecimal
+        case 'x':
+            num = getuint(&ap, lflag);
+  800ceb:	83 ec 08             	sub    $0x8,%esp
+  800cee:	ff 75 e0             	pushl  -0x20(%ebp)
+  800cf1:	8d 45 14             	lea    0x14(%ebp),%eax
+  800cf4:	50                   	push   %eax
+  800cf5:	e8 19 fc ff ff       	call   800913 <getuint>
+  800cfa:	83 c4 10             	add    $0x10,%esp
+  800cfd:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800d00:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 16;
+  800d03:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+        number:
+            printnum(putch, putdat, num, base, width, padc);
+  800d0a:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+  800d0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800d11:	83 ec 04             	sub    $0x4,%esp
+  800d14:	52                   	push   %edx
+  800d15:	ff 75 e8             	pushl  -0x18(%ebp)
+  800d18:	50                   	push   %eax
+  800d19:	ff 75 f4             	pushl  -0xc(%ebp)
+  800d1c:	ff 75 f0             	pushl  -0x10(%ebp)
+  800d1f:	ff 75 0c             	pushl  0xc(%ebp)
+  800d22:	ff 75 08             	pushl  0x8(%ebp)
+  800d25:	e8 f8 fa ff ff       	call   800822 <printnum>
+  800d2a:	83 c4 20             	add    $0x20,%esp
+            break;
+  800d2d:	eb 39                	jmp    800d68 <vprintfmt+0x39b>
+
+        // escaped '%' character
+        case '%':
+            putch(ch, putdat);
+  800d2f:	83 ec 08             	sub    $0x8,%esp
+  800d32:	ff 75 0c             	pushl  0xc(%ebp)
+  800d35:	53                   	push   %ebx
+  800d36:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d39:	ff d0                	call   *%eax
+  800d3b:	83 c4 10             	add    $0x10,%esp
+            break;
+  800d3e:	eb 28                	jmp    800d68 <vprintfmt+0x39b>
+
+        // unrecognized escape sequence - just print it literally
+        default:
+            putch('%', putdat);
+  800d40:	83 ec 08             	sub    $0x8,%esp
+  800d43:	ff 75 0c             	pushl  0xc(%ebp)
+  800d46:	6a 25                	push   $0x25
+  800d48:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d4b:	ff d0                	call   *%eax
+  800d4d:	83 c4 10             	add    $0x10,%esp
+            for (fmt --; fmt[-1] != '%'; fmt --)
+  800d50:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800d54:	eb 04                	jmp    800d5a <vprintfmt+0x38d>
+  800d56:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800d5a:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d5d:	83 e8 01             	sub    $0x1,%eax
+  800d60:	0f b6 00             	movzbl (%eax),%eax
+  800d63:	3c 25                	cmp    $0x25,%al
+  800d65:	75 ef                	jne    800d56 <vprintfmt+0x389>
+                /* do nothing */;
+            break;
+  800d67:	90                   	nop
+        }
+    }
+  800d68:	e9 68 fc ff ff       	jmp    8009d5 <vprintfmt+0x8>
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+            if (ch == '\0') {
+                return;
+  800d6d:	90                   	nop
+            for (fmt --; fmt[-1] != '%'; fmt --)
+                /* do nothing */;
+            break;
+        }
+    }
+}
+  800d6e:	8d 65 f8             	lea    -0x8(%ebp),%esp
+  800d71:	5b                   	pop    %ebx
+  800d72:	5e                   	pop    %esi
+  800d73:	5d                   	pop    %ebp
+  800d74:	c3                   	ret    
+
+00800d75 <sprintputch>:
+ * sprintputch - 'print' a single character in a buffer
+ * @ch:         the character will be printed
+ * @b:          the buffer to place the character @ch
+ * */
+static void
+sprintputch(int ch, struct sprintbuf *b) {
+  800d75:	55                   	push   %ebp
+  800d76:	89 e5                	mov    %esp,%ebp
+    b->cnt ++;
+  800d78:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d7b:	8b 40 08             	mov    0x8(%eax),%eax
+  800d7e:	8d 50 01             	lea    0x1(%eax),%edx
+  800d81:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d84:	89 50 08             	mov    %edx,0x8(%eax)
+    if (b->buf < b->ebuf) {
+  800d87:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8a:	8b 10                	mov    (%eax),%edx
+  800d8c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8f:	8b 40 04             	mov    0x4(%eax),%eax
+  800d92:	39 c2                	cmp    %eax,%edx
+  800d94:	73 12                	jae    800da8 <sprintputch+0x33>
+        *b->buf ++ = ch;
+  800d96:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d99:	8b 00                	mov    (%eax),%eax
+  800d9b:	8d 48 01             	lea    0x1(%eax),%ecx
+  800d9e:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800da1:	89 0a                	mov    %ecx,(%edx)
+  800da3:	8b 55 08             	mov    0x8(%ebp),%edx
+  800da6:	88 10                	mov    %dl,(%eax)
+    }
+}
+  800da8:	90                   	nop
+  800da9:	5d                   	pop    %ebp
+  800daa:	c3                   	ret    
+
+00800dab <snprintf>:
+ * @str:        the buffer to place the result into
+ * @size:       the size of buffer, including the trailing null space
+ * @fmt:        the format string to use
+ * */
+int
+snprintf(char *str, size_t size, const char *fmt, ...) {
+  800dab:	55                   	push   %ebp
+  800dac:	89 e5                	mov    %esp,%ebp
+  800dae:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    int cnt;
+    va_start(ap, fmt);
+  800db1:	8d 45 14             	lea    0x14(%ebp),%eax
+  800db4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    cnt = vsnprintf(str, size, fmt, ap);
+  800db7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800dba:	50                   	push   %eax
+  800dbb:	ff 75 10             	pushl  0x10(%ebp)
+  800dbe:	ff 75 0c             	pushl  0xc(%ebp)
+  800dc1:	ff 75 08             	pushl  0x8(%ebp)
+  800dc4:	e8 0b 00 00 00       	call   800dd4 <vsnprintf>
+  800dc9:	83 c4 10             	add    $0x10,%esp
+  800dcc:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+    return cnt;
+  800dcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800dd2:	c9                   	leave  
+  800dd3:	c3                   	ret    
+
+00800dd4 <vsnprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want snprintf() instead.
+ * */
+int
+vsnprintf(char *str, size_t size, const char *fmt, va_list ap) {
+  800dd4:	55                   	push   %ebp
+  800dd5:	89 e5                	mov    %esp,%ebp
+  800dd7:	83 ec 18             	sub    $0x18,%esp
+    struct sprintbuf b = {str, str + size - 1, 0};
+  800dda:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ddd:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800de0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800de3:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800de6:	8b 45 08             	mov    0x8(%ebp),%eax
+  800de9:	01 d0                	add    %edx,%eax
+  800deb:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800dee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    if (str == NULL || b.buf > b.ebuf) {
+  800df5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  800df9:	74 0a                	je     800e05 <vsnprintf+0x31>
+  800dfb:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  800dfe:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800e01:	39 c2                	cmp    %eax,%edx
+  800e03:	76 07                	jbe    800e0c <vsnprintf+0x38>
+        return -E_INVAL;
+  800e05:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+  800e0a:	eb 20                	jmp    800e2c <vsnprintf+0x58>
+    }
+    // print the string to the buffer
+    vprintfmt((void*)sprintputch, &b, fmt, ap);
+  800e0c:	ff 75 14             	pushl  0x14(%ebp)
+  800e0f:	ff 75 10             	pushl  0x10(%ebp)
+  800e12:	8d 45 ec             	lea    -0x14(%ebp),%eax
+  800e15:	50                   	push   %eax
+  800e16:	68 75 0d 80 00       	push   $0x800d75
+  800e1b:	e8 ad fb ff ff       	call   8009cd <vprintfmt>
+  800e20:	83 c4 10             	add    $0x10,%esp
+    // null terminate the buffer
+    *b.buf = '\0';
+  800e23:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e26:	c6 00 00             	movb   $0x0,(%eax)
+    return b.cnt;
+  800e29:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800e2c:	c9                   	leave  
+  800e2d:	c3                   	ret    
+
+00800e2e <hash32>:
+ * @bits:   the number of bits in a return value
+ *
+ * High bits are more random, so we use them.
+ * */
+uint32_t
+hash32(uint32_t val, unsigned int bits) {
+  800e2e:	55                   	push   %ebp
+  800e2f:	89 e5                	mov    %esp,%ebp
+  800e31:	83 ec 10             	sub    $0x10,%esp
+    uint32_t hash = val * GOLDEN_RATIO_PRIME_32;
+  800e34:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e37:	69 c0 01 00 37 9e    	imul   $0x9e370001,%eax,%eax
+  800e3d:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    return (hash >> (32 - bits));
+  800e40:	b8 20 00 00 00       	mov    $0x20,%eax
+  800e45:	2b 45 0c             	sub    0xc(%ebp),%eax
+  800e48:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  800e4b:	89 c1                	mov    %eax,%ecx
+  800e4d:	d3 ea                	shr    %cl,%edx
+  800e4f:	89 d0                	mov    %edx,%eax
+}
+  800e51:	c9                   	leave  
+  800e52:	c3                   	ret    
+
+00800e53 <rand>:
+ * rand - returns a pseudo-random integer
+ *
+ * The rand() function return a value in the range [0, RAND_MAX].
+ * */
+int
+rand(void) {
+  800e53:	55                   	push   %ebp
+  800e54:	89 e5                	mov    %esp,%ebp
+  800e56:	57                   	push   %edi
+  800e57:	56                   	push   %esi
+  800e58:	53                   	push   %ebx
+  800e59:	83 ec 24             	sub    $0x24,%esp
+    next = (next * 0x5DEECE66DLL + 0xBLL) & ((1LL << 48) - 1);
+  800e5c:	a1 00 20 80 00       	mov    0x802000,%eax
+  800e61:	8b 15 04 20 80 00    	mov    0x802004,%edx
+  800e67:	69 fa 6d e6 ec de    	imul   $0xdeece66d,%edx,%edi
+  800e6d:	6b f0 05             	imul   $0x5,%eax,%esi
+  800e70:	01 fe                	add    %edi,%esi
+  800e72:	bf 6d e6 ec de       	mov    $0xdeece66d,%edi
+  800e77:	f7 e7                	mul    %edi
+  800e79:	01 d6                	add    %edx,%esi
+  800e7b:	89 f2                	mov    %esi,%edx
+  800e7d:	83 c0 0b             	add    $0xb,%eax
+  800e80:	83 d2 00             	adc    $0x0,%edx
+  800e83:	89 c7                	mov    %eax,%edi
+  800e85:	83 e7 ff             	and    $0xffffffff,%edi
+  800e88:	89 f9                	mov    %edi,%ecx
+  800e8a:	0f b7 da             	movzwl %dx,%ebx
+  800e8d:	89 0d 00 20 80 00    	mov    %ecx,0x802000
+  800e93:	89 1d 04 20 80 00    	mov    %ebx,0x802004
+    unsigned long long result = (next >> 12);
+  800e99:	a1 00 20 80 00       	mov    0x802000,%eax
+  800e9e:	8b 15 04 20 80 00    	mov    0x802004,%edx
+  800ea4:	0f ac d0 0c          	shrd   $0xc,%edx,%eax
+  800ea8:	c1 ea 0c             	shr    $0xc,%edx
+  800eab:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800eae:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+    return (int)do_div(result, RAND_MAX + 1);
+  800eb1:	c7 45 dc 00 00 00 80 	movl   $0x80000000,-0x24(%ebp)
+  800eb8:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  800ebb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800ebe:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  800ec1:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  800ec4:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ec7:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800eca:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ece:	74 1c                	je     800eec <rand+0x99>
+  800ed0:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ed3:	ba 00 00 00 00       	mov    $0x0,%edx
+  800ed8:	f7 75 dc             	divl   -0x24(%ebp)
+  800edb:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  800ede:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ee1:	ba 00 00 00 00       	mov    $0x0,%edx
+  800ee6:	f7 75 dc             	divl   -0x24(%ebp)
+  800ee9:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800eec:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  800eef:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  800ef2:	f7 75 dc             	divl   -0x24(%ebp)
+  800ef5:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  800ef8:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  800efb:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  800efe:	8b 55 e8             	mov    -0x18(%ebp),%edx
+  800f01:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800f04:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  800f07:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+}
+  800f0a:	83 c4 24             	add    $0x24,%esp
+  800f0d:	5b                   	pop    %ebx
+  800f0e:	5e                   	pop    %esi
+  800f0f:	5f                   	pop    %edi
+  800f10:	5d                   	pop    %ebp
+  800f11:	c3                   	ret    
+
+00800f12 <srand>:
+/* *
+ * srand - seed the random number generator with the given number
+ * @seed:   the required seed number
+ * */
+void
+srand(unsigned int seed) {
+  800f12:	55                   	push   %ebp
+  800f13:	89 e5                	mov    %esp,%ebp
+    next = seed;
+  800f15:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f18:	ba 00 00 00 00       	mov    $0x0,%edx
+  800f1d:	a3 00 20 80 00       	mov    %eax,0x802000
+  800f22:	89 15 04 20 80 00    	mov    %edx,0x802004
+}
+  800f28:	90                   	nop
+  800f29:	5d                   	pop    %ebp
+  800f2a:	c3                   	ret    
+
+00800f2b <main>:
+#include <ulib.h>
+
+int magic = -0x10384;
+
+int
+main(void) {
+  800f2b:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+  800f2f:	83 e4 f0             	and    $0xfffffff0,%esp
+  800f32:	ff 71 fc             	pushl  -0x4(%ecx)
+  800f35:	55                   	push   %ebp
+  800f36:	89 e5                	mov    %esp,%ebp
+  800f38:	51                   	push   %ecx
+  800f39:	83 ec 14             	sub    $0x14,%esp
+    int pid, code;
+    cprintf("I am the parent. Forking the child...\n");
+  800f3c:	83 ec 0c             	sub    $0xc,%esp
+  800f3f:	68 60 13 80 00       	push   $0x801360
+  800f44:	e8 90 f3 ff ff       	call   8002d9 <cprintf>
+  800f49:	83 c4 10             	add    $0x10,%esp
+    if ((pid = fork()) == 0) {
+  800f4c:	e8 8c f2 ff ff       	call   8001dd <fork>
+  800f51:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800f54:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  800f58:	75 41                	jne    800f9b <main+0x70>
+        cprintf("I am the child.\n");
+  800f5a:	83 ec 0c             	sub    $0xc,%esp
+  800f5d:	68 87 13 80 00       	push   $0x801387
+  800f62:	e8 72 f3 ff ff       	call   8002d9 <cprintf>
+  800f67:	83 c4 10             	add    $0x10,%esp
+        yield();
+  800f6a:	e8 ab f2 ff ff       	call   80021a <yield>
+        yield();
+  800f6f:	e8 a6 f2 ff ff       	call   80021a <yield>
+        yield();
+  800f74:	e8 a1 f2 ff ff       	call   80021a <yield>
+        yield();
+  800f79:	e8 9c f2 ff ff       	call   80021a <yield>
+        yield();
+  800f7e:	e8 97 f2 ff ff       	call   80021a <yield>
+        yield();
+  800f83:	e8 92 f2 ff ff       	call   80021a <yield>
+        yield();
+  800f88:	e8 8d f2 ff ff       	call   80021a <yield>
+        exit(magic);
+  800f8d:	a1 08 20 80 00       	mov    0x802008,%eax
+  800f92:	83 ec 0c             	sub    $0xc,%esp
+  800f95:	50                   	push   %eax
+  800f96:	e8 1c f2 ff ff       	call   8001b7 <exit>
+    }
+    else {
+        cprintf("I am parent, fork a child pid %d\n",pid);
+  800f9b:	83 ec 08             	sub    $0x8,%esp
+  800f9e:	ff 75 f4             	pushl  -0xc(%ebp)
+  800fa1:	68 98 13 80 00       	push   $0x801398
+  800fa6:	e8 2e f3 ff ff       	call   8002d9 <cprintf>
+  800fab:	83 c4 10             	add    $0x10,%esp
+    }
+    assert(pid > 0);
+  800fae:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  800fb2:	7f 16                	jg     800fca <main+0x9f>
+  800fb4:	68 ba 13 80 00       	push   $0x8013ba
+  800fb9:	68 c2 13 80 00       	push   $0x8013c2
+  800fbe:	6a 18                	push   $0x18
+  800fc0:	68 d7 13 80 00       	push   $0x8013d7
+  800fc5:	e8 56 f0 ff ff       	call   800020 <__panic>
+    cprintf("I am the parent, waiting now..\n");
+  800fca:	83 ec 0c             	sub    $0xc,%esp
+  800fcd:	68 e4 13 80 00       	push   $0x8013e4
+  800fd2:	e8 02 f3 ff ff       	call   8002d9 <cprintf>
+  800fd7:	83 c4 10             	add    $0x10,%esp
+
+    assert(waitpid(pid, &code) == 0 && code == magic);
+  800fda:	83 ec 08             	sub    $0x8,%esp
+  800fdd:	8d 45 f0             	lea    -0x10(%ebp),%eax
+  800fe0:	50                   	push   %eax
+  800fe1:	ff 75 f4             	pushl  -0xc(%ebp)
+  800fe4:	e8 18 f2 ff ff       	call   800201 <waitpid>
+  800fe9:	83 c4 10             	add    $0x10,%esp
+  800fec:	85 c0                	test   %eax,%eax
+  800fee:	75 0c                	jne    800ffc <main+0xd1>
+  800ff0:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800ff3:	a1 08 20 80 00       	mov    0x802008,%eax
+  800ff8:	39 c2                	cmp    %eax,%edx
+  800ffa:	74 16                	je     801012 <main+0xe7>
+  800ffc:	68 04 14 80 00       	push   $0x801404
+  801001:	68 c2 13 80 00       	push   $0x8013c2
+  801006:	6a 1b                	push   $0x1b
+  801008:	68 d7 13 80 00       	push   $0x8013d7
+  80100d:	e8 0e f0 ff ff       	call   800020 <__panic>
+    assert(waitpid(pid, &code) != 0 && wait() != 0);
+  801012:	83 ec 08             	sub    $0x8,%esp
+  801015:	8d 45 f0             	lea    -0x10(%ebp),%eax
+  801018:	50                   	push   %eax
+  801019:	ff 75 f4             	pushl  -0xc(%ebp)
+  80101c:	e8 e0 f1 ff ff       	call   800201 <waitpid>
+  801021:	83 c4 10             	add    $0x10,%esp
+  801024:	85 c0                	test   %eax,%eax
+  801026:	74 09                	je     801031 <main+0x106>
+  801028:	e8 bd f1 ff ff       	call   8001ea <wait>
+  80102d:	85 c0                	test   %eax,%eax
+  80102f:	75 16                	jne    801047 <main+0x11c>
+  801031:	68 30 14 80 00       	push   $0x801430
+  801036:	68 c2 13 80 00       	push   $0x8013c2
+  80103b:	6a 1c                	push   $0x1c
+  80103d:	68 d7 13 80 00       	push   $0x8013d7
+  801042:	e8 d9 ef ff ff       	call   800020 <__panic>
+    cprintf("waitpid %d ok.\n", pid);
+  801047:	83 ec 08             	sub    $0x8,%esp
+  80104a:	ff 75 f4             	pushl  -0xc(%ebp)
+  80104d:	68 58 14 80 00       	push   $0x801458
+  801052:	e8 82 f2 ff ff       	call   8002d9 <cprintf>
+  801057:	83 c4 10             	add    $0x10,%esp
+
+    cprintf("exit pass.\n");
+  80105a:	83 ec 0c             	sub    $0xc,%esp
+  80105d:	68 68 14 80 00       	push   $0x801468
+  801062:	e8 72 f2 ff ff       	call   8002d9 <cprintf>
+  801067:	83 c4 10             	add    $0x10,%esp
+    return 0;
+  80106a:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  80106f:	8b 4d fc             	mov    -0x4(%ebp),%ecx
+  801072:	c9                   	leave  
+  801073:	8d 61 fc             	lea    -0x4(%ecx),%esp
+  801076:	c3                   	ret    
diff -r -u -P lab6_origin/obj/user/exit.d lab6/obj/user/exit.d
--- lab6_origin/obj/user/exit.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/exit.d	2019-05-13 17:39:38.333072300 +0800
@@ -0,0 +1,2 @@
+obj/user/exit.o obj/user/exit.d: user/exit.c libs/stdio.h libs/defs.h \
+ libs/stdarg.h user/libs/ulib.h
Binary files lab6_origin/obj/user/exit.o and lab6/obj/user/exit.o differ
diff -r -u -P lab6_origin/obj/user/exit.sym lab6/obj/user/exit.sym
--- lab6_origin/obj/user/exit.sym	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/exit.sym	2019-05-13 17:39:43.736969600 +0800
@@ -0,0 +1,77 @@
+00800020 .text
+00801080 .rodata
+00802000 .data
+00200000 .stab_info
+00200010 .stab
+00202ddd .stabstr
+00000000 panic.c
+00000000 syscall.c
+008000b5 syscall
+00000000 ulib.c
+00000000 stdio.c
+0080028c cputch
+00000000 umain.c
+00000000 string.c
+00000000 printfmt.c
+00801180 error_string
+00800822 printnum
+00800913 getuint
+00800962 getint
+00800d75 sprintputch
+00000000 hash.c
+00000000 rand.c
+00802000 next
+00000000 exit.c
+008003be strcpy
+0080021a yield
+00800201 waitpid
+00800141 sys_yield
+008006d7 memmove
+00800dab snprintf
+008009cd vprintfmt
+0080011d sys_fork
+008002d9 cprintf
+0080023e getpid
+0080077a memcpy
+00800266 lab6_set_priority
+00800dd4 vsnprintf
+0080034d umain
+00202ddc __STAB_END__
+00800150 sys_kill
+00202ddd __STABSTR_BEGIN__
+00800020 __panic
+0080053a strtol
+0080038e strnlen
+0080024b print_pgdir
+00800228 kill
+0080050b strfind
+008001ea wait
+0080027d _start
+00800e53 rand
+00800482 strncmp
+00800171 sys_putc
+008003fe strncpy
+008007ca memcmp
+008001dd fork
+00800697 memset
+00800f2b main
+00800f12 srand
+00800e2e hash32
+008009a9 printfmt
+00203bdc __STABSTR_END__
+00800438 strcmp
+00800259 gettime_msec
+00800192 sys_gettime
+00802008 magic
+008002b0 vcprintf
+0080006e __warn
+008002ff cputs
+008001a1 sys_lab6_set_priority
+008001b7 exit
+0080012c sys_wait
+0080010b sys_exit
+00200010 __STAB_BEGIN__
+00800366 strlen
+00800183 sys_pgdir
+008004d8 strchr
+00800162 sys_getpid
diff -r -u -P lab6_origin/obj/user/faultread.asm lab6/obj/user/faultread.asm
--- lab6_origin/obj/user/faultread.asm	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/faultread.asm	2019-05-13 17:39:43.387169900 +0800
@@ -0,0 +1,2584 @@
+
+obj/__user_faultread.out:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00800020 <__panic>:
+#include <stdio.h>
+#include <ulib.h>
+#include <error.h>
+
+void
+__panic(const char *file, int line, const char *fmt, ...) {
+  800020:	55                   	push   %ebp
+  800021:	89 e5                	mov    %esp,%ebp
+  800023:	83 ec 18             	sub    $0x18,%esp
+    // print the 'message'
+    va_list ap;
+    va_start(ap, fmt);
+  800026:	8d 45 14             	lea    0x14(%ebp),%eax
+  800029:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("user panic at %s:%d:\n    ", file, line);
+  80002c:	83 ec 04             	sub    $0x4,%esp
+  80002f:	ff 75 0c             	pushl  0xc(%ebp)
+  800032:	ff 75 08             	pushl  0x8(%ebp)
+  800035:	68 80 0f 80 00       	push   $0x800f80
+  80003a:	e8 9a 02 00 00       	call   8002d9 <cprintf>
+  80003f:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+  800042:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800045:	83 ec 08             	sub    $0x8,%esp
+  800048:	50                   	push   %eax
+  800049:	ff 75 10             	pushl  0x10(%ebp)
+  80004c:	e8 5f 02 00 00       	call   8002b0 <vcprintf>
+  800051:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+  800054:	83 ec 0c             	sub    $0xc,%esp
+  800057:	68 9a 0f 80 00       	push   $0x800f9a
+  80005c:	e8 78 02 00 00       	call   8002d9 <cprintf>
+  800061:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+    exit(-E_PANIC);
+  800064:	83 ec 0c             	sub    $0xc,%esp
+  800067:	6a f6                	push   $0xfffffff6
+  800069:	e8 49 01 00 00       	call   8001b7 <exit>
+
+0080006e <__warn>:
+}
+
+void
+__warn(const char *file, int line, const char *fmt, ...) {
+  80006e:	55                   	push   %ebp
+  80006f:	89 e5                	mov    %esp,%ebp
+  800071:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    va_start(ap, fmt);
+  800074:	8d 45 14             	lea    0x14(%ebp),%eax
+  800077:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("user warning at %s:%d:\n    ", file, line);
+  80007a:	83 ec 04             	sub    $0x4,%esp
+  80007d:	ff 75 0c             	pushl  0xc(%ebp)
+  800080:	ff 75 08             	pushl  0x8(%ebp)
+  800083:	68 9c 0f 80 00       	push   $0x800f9c
+  800088:	e8 4c 02 00 00       	call   8002d9 <cprintf>
+  80008d:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+  800090:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800093:	83 ec 08             	sub    $0x8,%esp
+  800096:	50                   	push   %eax
+  800097:	ff 75 10             	pushl  0x10(%ebp)
+  80009a:	e8 11 02 00 00       	call   8002b0 <vcprintf>
+  80009f:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+  8000a2:	83 ec 0c             	sub    $0xc,%esp
+  8000a5:	68 9a 0f 80 00       	push   $0x800f9a
+  8000aa:	e8 2a 02 00 00       	call   8002d9 <cprintf>
+  8000af:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+  8000b2:	90                   	nop
+  8000b3:	c9                   	leave  
+  8000b4:	c3                   	ret    
+
+008000b5 <syscall>:
+#include <syscall.h>
+
+#define MAX_ARGS            5
+
+static inline int
+syscall(int num, ...) {
+  8000b5:	55                   	push   %ebp
+  8000b6:	89 e5                	mov    %esp,%ebp
+  8000b8:	57                   	push   %edi
+  8000b9:	56                   	push   %esi
+  8000ba:	53                   	push   %ebx
+  8000bb:	83 ec 20             	sub    $0x20,%esp
+    va_list ap;
+    va_start(ap, num);
+  8000be:	8d 45 0c             	lea    0xc(%ebp),%eax
+  8000c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    uint32_t a[MAX_ARGS];
+    int i, ret;
+    for (i = 0; i < MAX_ARGS; i ++) {
+  8000c4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  8000cb:	eb 16                	jmp    8000e3 <syscall+0x2e>
+        a[i] = va_arg(ap, uint32_t);
+  8000cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8000d0:	8d 50 04             	lea    0x4(%eax),%edx
+  8000d3:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  8000d6:	8b 10                	mov    (%eax),%edx
+  8000d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8000db:	89 54 85 d4          	mov    %edx,-0x2c(%ebp,%eax,4)
+syscall(int num, ...) {
+    va_list ap;
+    va_start(ap, num);
+    uint32_t a[MAX_ARGS];
+    int i, ret;
+    for (i = 0; i < MAX_ARGS; i ++) {
+  8000df:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+  8000e3:	83 7d f0 04          	cmpl   $0x4,-0x10(%ebp)
+  8000e7:	7e e4                	jle    8000cd <syscall+0x18>
+    asm volatile (
+        "int %1;"
+        : "=a" (ret)
+        : "i" (T_SYSCALL),
+          "a" (num),
+          "d" (a[0]),
+  8000e9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+          "c" (a[1]),
+  8000ec:	8b 4d d8             	mov    -0x28(%ebp),%ecx
+          "b" (a[2]),
+  8000ef:	8b 5d dc             	mov    -0x24(%ebp),%ebx
+          "D" (a[3]),
+  8000f2:	8b 7d e0             	mov    -0x20(%ebp),%edi
+          "S" (a[4])
+  8000f5:	8b 75 e4             	mov    -0x1c(%ebp),%esi
+    for (i = 0; i < MAX_ARGS; i ++) {
+        a[i] = va_arg(ap, uint32_t);
+    }
+    va_end(ap);
+
+    asm volatile (
+  8000f8:	8b 45 08             	mov    0x8(%ebp),%eax
+  8000fb:	cd 80                	int    $0x80
+  8000fd:	89 45 ec             	mov    %eax,-0x14(%ebp)
+          "c" (a[1]),
+          "b" (a[2]),
+          "D" (a[3]),
+          "S" (a[4])
+        : "cc", "memory");
+    return ret;
+  800100:	8b 45 ec             	mov    -0x14(%ebp),%eax
+}
+  800103:	83 c4 20             	add    $0x20,%esp
+  800106:	5b                   	pop    %ebx
+  800107:	5e                   	pop    %esi
+  800108:	5f                   	pop    %edi
+  800109:	5d                   	pop    %ebp
+  80010a:	c3                   	ret    
+
+0080010b <sys_exit>:
+
+int
+sys_exit(int error_code) {
+  80010b:	55                   	push   %ebp
+  80010c:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_exit, error_code);
+  80010e:	ff 75 08             	pushl  0x8(%ebp)
+  800111:	6a 01                	push   $0x1
+  800113:	e8 9d ff ff ff       	call   8000b5 <syscall>
+  800118:	83 c4 08             	add    $0x8,%esp
+}
+  80011b:	c9                   	leave  
+  80011c:	c3                   	ret    
+
+0080011d <sys_fork>:
+
+int
+sys_fork(void) {
+  80011d:	55                   	push   %ebp
+  80011e:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_fork);
+  800120:	6a 02                	push   $0x2
+  800122:	e8 8e ff ff ff       	call   8000b5 <syscall>
+  800127:	83 c4 04             	add    $0x4,%esp
+}
+  80012a:	c9                   	leave  
+  80012b:	c3                   	ret    
+
+0080012c <sys_wait>:
+
+int
+sys_wait(int pid, int *store) {
+  80012c:	55                   	push   %ebp
+  80012d:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_wait, pid, store);
+  80012f:	ff 75 0c             	pushl  0xc(%ebp)
+  800132:	ff 75 08             	pushl  0x8(%ebp)
+  800135:	6a 03                	push   $0x3
+  800137:	e8 79 ff ff ff       	call   8000b5 <syscall>
+  80013c:	83 c4 0c             	add    $0xc,%esp
+}
+  80013f:	c9                   	leave  
+  800140:	c3                   	ret    
+
+00800141 <sys_yield>:
+
+int
+sys_yield(void) {
+  800141:	55                   	push   %ebp
+  800142:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_yield);
+  800144:	6a 0a                	push   $0xa
+  800146:	e8 6a ff ff ff       	call   8000b5 <syscall>
+  80014b:	83 c4 04             	add    $0x4,%esp
+}
+  80014e:	c9                   	leave  
+  80014f:	c3                   	ret    
+
+00800150 <sys_kill>:
+
+int
+sys_kill(int pid) {
+  800150:	55                   	push   %ebp
+  800151:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_kill, pid);
+  800153:	ff 75 08             	pushl  0x8(%ebp)
+  800156:	6a 0c                	push   $0xc
+  800158:	e8 58 ff ff ff       	call   8000b5 <syscall>
+  80015d:	83 c4 08             	add    $0x8,%esp
+}
+  800160:	c9                   	leave  
+  800161:	c3                   	ret    
+
+00800162 <sys_getpid>:
+
+int
+sys_getpid(void) {
+  800162:	55                   	push   %ebp
+  800163:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_getpid);
+  800165:	6a 12                	push   $0x12
+  800167:	e8 49 ff ff ff       	call   8000b5 <syscall>
+  80016c:	83 c4 04             	add    $0x4,%esp
+}
+  80016f:	c9                   	leave  
+  800170:	c3                   	ret    
+
+00800171 <sys_putc>:
+
+int
+sys_putc(int c) {
+  800171:	55                   	push   %ebp
+  800172:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_putc, c);
+  800174:	ff 75 08             	pushl  0x8(%ebp)
+  800177:	6a 1e                	push   $0x1e
+  800179:	e8 37 ff ff ff       	call   8000b5 <syscall>
+  80017e:	83 c4 08             	add    $0x8,%esp
+}
+  800181:	c9                   	leave  
+  800182:	c3                   	ret    
+
+00800183 <sys_pgdir>:
+
+int
+sys_pgdir(void) {
+  800183:	55                   	push   %ebp
+  800184:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_pgdir);
+  800186:	6a 1f                	push   $0x1f
+  800188:	e8 28 ff ff ff       	call   8000b5 <syscall>
+  80018d:	83 c4 04             	add    $0x4,%esp
+}
+  800190:	c9                   	leave  
+  800191:	c3                   	ret    
+
+00800192 <sys_gettime>:
+
+int
+sys_gettime(void) {
+  800192:	55                   	push   %ebp
+  800193:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_gettime);
+  800195:	6a 11                	push   $0x11
+  800197:	e8 19 ff ff ff       	call   8000b5 <syscall>
+  80019c:	83 c4 04             	add    $0x4,%esp
+}
+  80019f:	c9                   	leave  
+  8001a0:	c3                   	ret    
+
+008001a1 <sys_lab6_set_priority>:
+
+void
+sys_lab6_set_priority(uint32_t priority)
+{
+  8001a1:	55                   	push   %ebp
+  8001a2:	89 e5                	mov    %esp,%ebp
+    syscall(SYS_lab6_set_priority, priority);
+  8001a4:	ff 75 08             	pushl  0x8(%ebp)
+  8001a7:	68 ff 00 00 00       	push   $0xff
+  8001ac:	e8 04 ff ff ff       	call   8000b5 <syscall>
+  8001b1:	83 c4 08             	add    $0x8,%esp
+}
+  8001b4:	90                   	nop
+  8001b5:	c9                   	leave  
+  8001b6:	c3                   	ret    
+
+008001b7 <exit>:
+#include <syscall.h>
+#include <stdio.h>
+#include <ulib.h>
+
+void
+exit(int error_code) {
+  8001b7:	55                   	push   %ebp
+  8001b8:	89 e5                	mov    %esp,%ebp
+  8001ba:	83 ec 08             	sub    $0x8,%esp
+    sys_exit(error_code);
+  8001bd:	83 ec 0c             	sub    $0xc,%esp
+  8001c0:	ff 75 08             	pushl  0x8(%ebp)
+  8001c3:	e8 43 ff ff ff       	call   80010b <sys_exit>
+  8001c8:	83 c4 10             	add    $0x10,%esp
+    cprintf("BUG: exit failed.\n");
+  8001cb:	83 ec 0c             	sub    $0xc,%esp
+  8001ce:	68 b8 0f 80 00       	push   $0x800fb8
+  8001d3:	e8 01 01 00 00       	call   8002d9 <cprintf>
+  8001d8:	83 c4 10             	add    $0x10,%esp
+    while (1);
+  8001db:	eb fe                	jmp    8001db <exit+0x24>
+
+008001dd <fork>:
+}
+
+int
+fork(void) {
+  8001dd:	55                   	push   %ebp
+  8001de:	89 e5                	mov    %esp,%ebp
+  8001e0:	83 ec 08             	sub    $0x8,%esp
+    return sys_fork();
+  8001e3:	e8 35 ff ff ff       	call   80011d <sys_fork>
+}
+  8001e8:	c9                   	leave  
+  8001e9:	c3                   	ret    
+
+008001ea <wait>:
+
+int
+wait(void) {
+  8001ea:	55                   	push   %ebp
+  8001eb:	89 e5                	mov    %esp,%ebp
+  8001ed:	83 ec 08             	sub    $0x8,%esp
+    return sys_wait(0, NULL);
+  8001f0:	83 ec 08             	sub    $0x8,%esp
+  8001f3:	6a 00                	push   $0x0
+  8001f5:	6a 00                	push   $0x0
+  8001f7:	e8 30 ff ff ff       	call   80012c <sys_wait>
+  8001fc:	83 c4 10             	add    $0x10,%esp
+}
+  8001ff:	c9                   	leave  
+  800200:	c3                   	ret    
+
+00800201 <waitpid>:
+
+int
+waitpid(int pid, int *store) {
+  800201:	55                   	push   %ebp
+  800202:	89 e5                	mov    %esp,%ebp
+  800204:	83 ec 08             	sub    $0x8,%esp
+    return sys_wait(pid, store);
+  800207:	83 ec 08             	sub    $0x8,%esp
+  80020a:	ff 75 0c             	pushl  0xc(%ebp)
+  80020d:	ff 75 08             	pushl  0x8(%ebp)
+  800210:	e8 17 ff ff ff       	call   80012c <sys_wait>
+  800215:	83 c4 10             	add    $0x10,%esp
+}
+  800218:	c9                   	leave  
+  800219:	c3                   	ret    
+
+0080021a <yield>:
+
+void
+yield(void) {
+  80021a:	55                   	push   %ebp
+  80021b:	89 e5                	mov    %esp,%ebp
+  80021d:	83 ec 08             	sub    $0x8,%esp
+    sys_yield();
+  800220:	e8 1c ff ff ff       	call   800141 <sys_yield>
+}
+  800225:	90                   	nop
+  800226:	c9                   	leave  
+  800227:	c3                   	ret    
+
+00800228 <kill>:
+
+int
+kill(int pid) {
+  800228:	55                   	push   %ebp
+  800229:	89 e5                	mov    %esp,%ebp
+  80022b:	83 ec 08             	sub    $0x8,%esp
+    return sys_kill(pid);
+  80022e:	83 ec 0c             	sub    $0xc,%esp
+  800231:	ff 75 08             	pushl  0x8(%ebp)
+  800234:	e8 17 ff ff ff       	call   800150 <sys_kill>
+  800239:	83 c4 10             	add    $0x10,%esp
+}
+  80023c:	c9                   	leave  
+  80023d:	c3                   	ret    
+
+0080023e <getpid>:
+
+int
+getpid(void) {
+  80023e:	55                   	push   %ebp
+  80023f:	89 e5                	mov    %esp,%ebp
+  800241:	83 ec 08             	sub    $0x8,%esp
+    return sys_getpid();
+  800244:	e8 19 ff ff ff       	call   800162 <sys_getpid>
+}
+  800249:	c9                   	leave  
+  80024a:	c3                   	ret    
+
+0080024b <print_pgdir>:
+
+//print_pgdir - print the PDT&PT
+void
+print_pgdir(void) {
+  80024b:	55                   	push   %ebp
+  80024c:	89 e5                	mov    %esp,%ebp
+  80024e:	83 ec 08             	sub    $0x8,%esp
+    sys_pgdir();
+  800251:	e8 2d ff ff ff       	call   800183 <sys_pgdir>
+}
+  800256:	90                   	nop
+  800257:	c9                   	leave  
+  800258:	c3                   	ret    
+
+00800259 <gettime_msec>:
+
+unsigned int
+gettime_msec(void) {
+  800259:	55                   	push   %ebp
+  80025a:	89 e5                	mov    %esp,%ebp
+  80025c:	83 ec 08             	sub    $0x8,%esp
+    return (unsigned int)sys_gettime();
+  80025f:	e8 2e ff ff ff       	call   800192 <sys_gettime>
+}
+  800264:	c9                   	leave  
+  800265:	c3                   	ret    
+
+00800266 <lab6_set_priority>:
+
+void
+lab6_set_priority(uint32_t priority)
+{
+  800266:	55                   	push   %ebp
+  800267:	89 e5                	mov    %esp,%ebp
+  800269:	83 ec 08             	sub    $0x8,%esp
+    sys_lab6_set_priority(priority);
+  80026c:	83 ec 0c             	sub    $0xc,%esp
+  80026f:	ff 75 08             	pushl  0x8(%ebp)
+  800272:	e8 2a ff ff ff       	call   8001a1 <sys_lab6_set_priority>
+  800277:	83 c4 10             	add    $0x10,%esp
+}
+  80027a:	90                   	nop
+  80027b:	c9                   	leave  
+  80027c:	c3                   	ret    
+
+0080027d <_start>:
+.text
+.globl _start
+_start:
+    # set ebp for backtrace
+    movl $0x0, %ebp
+  80027d:	bd 00 00 00 00       	mov    $0x0,%ebp
+
+    # move down the esp register
+    # since it may cause page fault in backtrace
+    subl $0x20, %esp
+  800282:	83 ec 20             	sub    $0x20,%esp
+
+    # call user-program function
+    call umain
+  800285:	e8 c3 00 00 00       	call   80034d <umain>
+1:  jmp 1b
+  80028a:	eb fe                	jmp    80028a <_start+0xd>
+
+0080028c <cputch>:
+/* *
+ * cputch - writes a single character @c to stdout, and it will
+ * increace the value of counter pointed by @cnt.
+ * */
+static void
+cputch(int c, int *cnt) {
+  80028c:	55                   	push   %ebp
+  80028d:	89 e5                	mov    %esp,%ebp
+  80028f:	83 ec 08             	sub    $0x8,%esp
+    sys_putc(c);
+  800292:	83 ec 0c             	sub    $0xc,%esp
+  800295:	ff 75 08             	pushl  0x8(%ebp)
+  800298:	e8 d4 fe ff ff       	call   800171 <sys_putc>
+  80029d:	83 c4 10             	add    $0x10,%esp
+    (*cnt) ++;
+  8002a0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002a3:	8b 00                	mov    (%eax),%eax
+  8002a5:	8d 50 01             	lea    0x1(%eax),%edx
+  8002a8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002ab:	89 10                	mov    %edx,(%eax)
+}
+  8002ad:	90                   	nop
+  8002ae:	c9                   	leave  
+  8002af:	c3                   	ret    
+
+008002b0 <vcprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want cprintf() instead.
+ * */
+int
+vcprintf(const char *fmt, va_list ap) {
+  8002b0:	55                   	push   %ebp
+  8002b1:	89 e5                	mov    %esp,%ebp
+  8002b3:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+  8002b6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    vprintfmt((void*)cputch, &cnt, fmt, ap);
+  8002bd:	ff 75 0c             	pushl  0xc(%ebp)
+  8002c0:	ff 75 08             	pushl  0x8(%ebp)
+  8002c3:	8d 45 f4             	lea    -0xc(%ebp),%eax
+  8002c6:	50                   	push   %eax
+  8002c7:	68 8c 02 80 00       	push   $0x80028c
+  8002cc:	e8 fc 06 00 00       	call   8009cd <vprintfmt>
+  8002d1:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+  8002d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8002d7:	c9                   	leave  
+  8002d8:	c3                   	ret    
+
+008002d9 <cprintf>:
+ *
+ * The return value is the number of characters which would be
+ * written to stdout.
+ * */
+int
+cprintf(const char *fmt, ...) {
+  8002d9:	55                   	push   %ebp
+  8002da:	89 e5                	mov    %esp,%ebp
+  8002dc:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  8002df:	8d 45 0c             	lea    0xc(%ebp),%eax
+  8002e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    int cnt = vcprintf(fmt, ap);
+  8002e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8002e8:	83 ec 08             	sub    $0x8,%esp
+  8002eb:	50                   	push   %eax
+  8002ec:	ff 75 08             	pushl  0x8(%ebp)
+  8002ef:	e8 bc ff ff ff       	call   8002b0 <vcprintf>
+  8002f4:	83 c4 10             	add    $0x10,%esp
+  8002f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+
+    return cnt;
+  8002fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8002fd:	c9                   	leave  
+  8002fe:	c3                   	ret    
+
+008002ff <cputs>:
+/* *
+ * cputs- writes the string pointed by @str to stdout and
+ * appends a newline character.
+ * */
+int
+cputs(const char *str) {
+  8002ff:	55                   	push   %ebp
+  800300:	89 e5                	mov    %esp,%ebp
+  800302:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+  800305:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    char c;
+    while ((c = *str ++) != '\0') {
+  80030c:	eb 14                	jmp    800322 <cputs+0x23>
+        cputch(c, &cnt);
+  80030e:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
+  800312:	83 ec 08             	sub    $0x8,%esp
+  800315:	8d 55 f0             	lea    -0x10(%ebp),%edx
+  800318:	52                   	push   %edx
+  800319:	50                   	push   %eax
+  80031a:	e8 6d ff ff ff       	call   80028c <cputch>
+  80031f:	83 c4 10             	add    $0x10,%esp
+ * */
+int
+cputs(const char *str) {
+    int cnt = 0;
+    char c;
+    while ((c = *str ++) != '\0') {
+  800322:	8b 45 08             	mov    0x8(%ebp),%eax
+  800325:	8d 50 01             	lea    0x1(%eax),%edx
+  800328:	89 55 08             	mov    %edx,0x8(%ebp)
+  80032b:	0f b6 00             	movzbl (%eax),%eax
+  80032e:	88 45 f7             	mov    %al,-0x9(%ebp)
+  800331:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
+  800335:	75 d7                	jne    80030e <cputs+0xf>
+        cputch(c, &cnt);
+    }
+    cputch('\n', &cnt);
+  800337:	83 ec 08             	sub    $0x8,%esp
+  80033a:	8d 45 f0             	lea    -0x10(%ebp),%eax
+  80033d:	50                   	push   %eax
+  80033e:	6a 0a                	push   $0xa
+  800340:	e8 47 ff ff ff       	call   80028c <cputch>
+  800345:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+  800348:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+  80034b:	c9                   	leave  
+  80034c:	c3                   	ret    
+
+0080034d <umain>:
+#include <ulib.h>
+
+int main(void);
+
+void
+umain(void) {
+  80034d:	55                   	push   %ebp
+  80034e:	89 e5                	mov    %esp,%ebp
+  800350:	83 ec 18             	sub    $0x18,%esp
+    int ret = main();
+  800353:	e8 d3 0b 00 00       	call   800f2b <main>
+  800358:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    exit(ret);
+  80035b:	83 ec 0c             	sub    $0xc,%esp
+  80035e:	ff 75 f4             	pushl  -0xc(%ebp)
+  800361:	e8 51 fe ff ff       	call   8001b7 <exit>
+
+00800366 <strlen>:
+ * @s:      the input string
+ *
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+  800366:	55                   	push   %ebp
+  800367:	89 e5                	mov    %esp,%ebp
+  800369:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  80036c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (*s ++ != '\0') {
+  800373:	eb 04                	jmp    800379 <strlen+0x13>
+        cnt ++;
+  800375:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+    size_t cnt = 0;
+    while (*s ++ != '\0') {
+  800379:	8b 45 08             	mov    0x8(%ebp),%eax
+  80037c:	8d 50 01             	lea    0x1(%eax),%edx
+  80037f:	89 55 08             	mov    %edx,0x8(%ebp)
+  800382:	0f b6 00             	movzbl (%eax),%eax
+  800385:	84 c0                	test   %al,%al
+  800387:	75 ec                	jne    800375 <strlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  800389:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  80038c:	c9                   	leave  
+  80038d:	c3                   	ret    
+
+0080038e <strnlen>:
+ * The return value is strlen(s), if that is less than @len, or
+ * @len if there is no '\0' character among the first @len characters
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+  80038e:	55                   	push   %ebp
+  80038f:	89 e5                	mov    %esp,%ebp
+  800391:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  800394:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (cnt < len && *s ++ != '\0') {
+  80039b:	eb 04                	jmp    8003a1 <strnlen+0x13>
+        cnt ++;
+  80039d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+    size_t cnt = 0;
+    while (cnt < len && *s ++ != '\0') {
+  8003a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8003a4:	3b 45 0c             	cmp    0xc(%ebp),%eax
+  8003a7:	73 10                	jae    8003b9 <strnlen+0x2b>
+  8003a9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003ac:	8d 50 01             	lea    0x1(%eax),%edx
+  8003af:	89 55 08             	mov    %edx,0x8(%ebp)
+  8003b2:	0f b6 00             	movzbl (%eax),%eax
+  8003b5:	84 c0                	test   %al,%al
+  8003b7:	75 e4                	jne    80039d <strnlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  8003b9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  8003bc:	c9                   	leave  
+  8003bd:	c3                   	ret    
+
+008003be <strcpy>:
+ * To avoid overflows, the size of array pointed by @dst should be long enough to
+ * contain the same string as @src (including the terminating null character), and
+ * should not overlap in memory with @src.
+ * */
+char *
+strcpy(char *dst, const char *src) {
+  8003be:	55                   	push   %ebp
+  8003bf:	89 e5                	mov    %esp,%ebp
+  8003c1:	57                   	push   %edi
+  8003c2:	56                   	push   %esi
+  8003c3:	83 ec 20             	sub    $0x20,%esp
+  8003c6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  8003cc:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8003cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCPY
+#define __HAVE_ARCH_STRCPY
+static inline char *
+__strcpy(char *dst, const char *src) {
+    int d0, d1, d2;
+    asm volatile (
+  8003d2:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  8003d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8003d8:	89 d1                	mov    %edx,%ecx
+  8003da:	89 c2                	mov    %eax,%edx
+  8003dc:	89 ce                	mov    %ecx,%esi
+  8003de:	89 d7                	mov    %edx,%edi
+  8003e0:	ac                   	lods   %ds:(%esi),%al
+  8003e1:	aa                   	stos   %al,%es:(%edi)
+  8003e2:	84 c0                	test   %al,%al
+  8003e4:	75 fa                	jne    8003e0 <strcpy+0x22>
+  8003e6:	89 fa                	mov    %edi,%edx
+  8003e8:	89 f1                	mov    %esi,%ecx
+  8003ea:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  8003ed:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  8003f0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+        "stosb;"
+        "testb %%al, %%al;"
+        "jne 1b;"
+        : "=&S" (d0), "=&D" (d1), "=&a" (d2)
+        : "0" (src), "1" (dst) : "memory");
+    return dst;
+  8003f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCPY
+    return __strcpy(dst, src);
+  8003f6:	90                   	nop
+    char *p = dst;
+    while ((*p ++ = *src ++) != '\0')
+        /* nothing */;
+    return dst;
+#endif /* __HAVE_ARCH_STRCPY */
+}
+  8003f7:	83 c4 20             	add    $0x20,%esp
+  8003fa:	5e                   	pop    %esi
+  8003fb:	5f                   	pop    %edi
+  8003fc:	5d                   	pop    %ebp
+  8003fd:	c3                   	ret    
+
+008003fe <strncpy>:
+ * @len:    maximum number of characters to be copied from @src
+ *
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+  8003fe:	55                   	push   %ebp
+  8003ff:	89 e5                	mov    %esp,%ebp
+  800401:	83 ec 10             	sub    $0x10,%esp
+    char *p = dst;
+  800404:	8b 45 08             	mov    0x8(%ebp),%eax
+  800407:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    while (len > 0) {
+  80040a:	eb 21                	jmp    80042d <strncpy+0x2f>
+        if ((*p = *src) != '\0') {
+  80040c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80040f:	0f b6 10             	movzbl (%eax),%edx
+  800412:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800415:	88 10                	mov    %dl,(%eax)
+  800417:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  80041a:	0f b6 00             	movzbl (%eax),%eax
+  80041d:	84 c0                	test   %al,%al
+  80041f:	74 04                	je     800425 <strncpy+0x27>
+            src ++;
+  800421:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+        }
+        p ++, len --;
+  800425:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800429:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+    char *p = dst;
+    while (len > 0) {
+  80042d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800431:	75 d9                	jne    80040c <strncpy+0xe>
+        if ((*p = *src) != '\0') {
+            src ++;
+        }
+        p ++, len --;
+    }
+    return dst;
+  800433:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800436:	c9                   	leave  
+  800437:	c3                   	ret    
+
+00800438 <strcmp>:
+ * - A value greater than zero indicates that the first character that does
+ *   not match has a greater value in @s1 than in @s2;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+strcmp(const char *s1, const char *s2) {
+  800438:	55                   	push   %ebp
+  800439:	89 e5                	mov    %esp,%ebp
+  80043b:	57                   	push   %edi
+  80043c:	56                   	push   %esi
+  80043d:	83 ec 20             	sub    $0x20,%esp
+  800440:	8b 45 08             	mov    0x8(%ebp),%eax
+  800443:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800446:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800449:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCMP
+#define __HAVE_ARCH_STRCMP
+static inline int
+__strcmp(const char *s1, const char *s2) {
+    int d0, d1, ret;
+    asm volatile (
+  80044c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80044f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800452:	89 d1                	mov    %edx,%ecx
+  800454:	89 c2                	mov    %eax,%edx
+  800456:	89 ce                	mov    %ecx,%esi
+  800458:	89 d7                	mov    %edx,%edi
+  80045a:	ac                   	lods   %ds:(%esi),%al
+  80045b:	ae                   	scas   %es:(%edi),%al
+  80045c:	75 08                	jne    800466 <strcmp+0x2e>
+  80045e:	84 c0                	test   %al,%al
+  800460:	75 f8                	jne    80045a <strcmp+0x22>
+  800462:	31 c0                	xor    %eax,%eax
+  800464:	eb 04                	jmp    80046a <strcmp+0x32>
+  800466:	19 c0                	sbb    %eax,%eax
+  800468:	0c 01                	or     $0x1,%al
+  80046a:	89 fa                	mov    %edi,%edx
+  80046c:	89 f1                	mov    %esi,%ecx
+  80046e:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800471:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  800474:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+        "orb $1, %%al;"
+        "3:"
+        : "=a" (ret), "=&S" (d0), "=&D" (d1)
+        : "1" (s1), "2" (s2)
+        : "memory");
+    return ret;
+  800477:	8b 45 ec             	mov    -0x14(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCMP
+    return __strcmp(s1, s2);
+  80047a:	90                   	nop
+    while (*s1 != '\0' && *s1 == *s2) {
+        s1 ++, s2 ++;
+    }
+    return (int)((unsigned char)*s1 - (unsigned char)*s2);
+#endif /* __HAVE_ARCH_STRCMP */
+}
+  80047b:	83 c4 20             	add    $0x20,%esp
+  80047e:	5e                   	pop    %esi
+  80047f:	5f                   	pop    %edi
+  800480:	5d                   	pop    %ebp
+  800481:	c3                   	ret    
+
+00800482 <strncmp>:
+ * they are equal to each other, it continues with the following pairs until
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+  800482:	55                   	push   %ebp
+  800483:	89 e5                	mov    %esp,%ebp
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  800485:	eb 0c                	jmp    800493 <strncmp+0x11>
+        n --, s1 ++, s2 ++;
+  800487:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  80048b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  80048f:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  800493:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800497:	74 1a                	je     8004b3 <strncmp+0x31>
+  800499:	8b 45 08             	mov    0x8(%ebp),%eax
+  80049c:	0f b6 00             	movzbl (%eax),%eax
+  80049f:	84 c0                	test   %al,%al
+  8004a1:	74 10                	je     8004b3 <strncmp+0x31>
+  8004a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004a6:	0f b6 10             	movzbl (%eax),%edx
+  8004a9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004ac:	0f b6 00             	movzbl (%eax),%eax
+  8004af:	38 c2                	cmp    %al,%dl
+  8004b1:	74 d4                	je     800487 <strncmp+0x5>
+        n --, s1 ++, s2 ++;
+    }
+    return (n == 0) ? 0 : (int)((unsigned char)*s1 - (unsigned char)*s2);
+  8004b3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8004b7:	74 18                	je     8004d1 <strncmp+0x4f>
+  8004b9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004bc:	0f b6 00             	movzbl (%eax),%eax
+  8004bf:	0f b6 d0             	movzbl %al,%edx
+  8004c2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004c5:	0f b6 00             	movzbl (%eax),%eax
+  8004c8:	0f b6 c0             	movzbl %al,%eax
+  8004cb:	29 c2                	sub    %eax,%edx
+  8004cd:	89 d0                	mov    %edx,%eax
+  8004cf:	eb 05                	jmp    8004d6 <strncmp+0x54>
+  8004d1:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  8004d6:	5d                   	pop    %ebp
+  8004d7:	c3                   	ret    
+
+008004d8 <strchr>:
+ *
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+  8004d8:	55                   	push   %ebp
+  8004d9:	89 e5                	mov    %esp,%ebp
+  8004db:	83 ec 04             	sub    $0x4,%esp
+  8004de:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004e1:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  8004e4:	eb 14                	jmp    8004fa <strchr+0x22>
+        if (*s == c) {
+  8004e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004e9:	0f b6 00             	movzbl (%eax),%eax
+  8004ec:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  8004ef:	75 05                	jne    8004f6 <strchr+0x1e>
+            return (char *)s;
+  8004f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004f4:	eb 13                	jmp    800509 <strchr+0x31>
+        }
+        s ++;
+  8004f6:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+    while (*s != '\0') {
+  8004fa:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004fd:	0f b6 00             	movzbl (%eax),%eax
+  800500:	84 c0                	test   %al,%al
+  800502:	75 e2                	jne    8004e6 <strchr+0xe>
+        if (*s == c) {
+            return (char *)s;
+        }
+        s ++;
+    }
+    return NULL;
+  800504:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800509:	c9                   	leave  
+  80050a:	c3                   	ret    
+
+0080050b <strfind>:
+ * The strfind() function is like strchr() except that if @c is
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+  80050b:	55                   	push   %ebp
+  80050c:	89 e5                	mov    %esp,%ebp
+  80050e:	83 ec 04             	sub    $0x4,%esp
+  800511:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800514:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  800517:	eb 0f                	jmp    800528 <strfind+0x1d>
+        if (*s == c) {
+  800519:	8b 45 08             	mov    0x8(%ebp),%eax
+  80051c:	0f b6 00             	movzbl (%eax),%eax
+  80051f:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800522:	74 10                	je     800534 <strfind+0x29>
+            break;
+        }
+        s ++;
+  800524:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+    while (*s != '\0') {
+  800528:	8b 45 08             	mov    0x8(%ebp),%eax
+  80052b:	0f b6 00             	movzbl (%eax),%eax
+  80052e:	84 c0                	test   %al,%al
+  800530:	75 e7                	jne    800519 <strfind+0xe>
+  800532:	eb 01                	jmp    800535 <strfind+0x2a>
+        if (*s == c) {
+            break;
+  800534:	90                   	nop
+        }
+        s ++;
+    }
+    return (char *)s;
+  800535:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800538:	c9                   	leave  
+  800539:	c3                   	ret    
+
+0080053a <strtol>:
+ * an optional "0x" or "0X" prefix.
+ *
+ * The strtol() function returns the converted integral number as a long int value.
+ * */
+long
+strtol(const char *s, char **endptr, int base) {
+  80053a:	55                   	push   %ebp
+  80053b:	89 e5                	mov    %esp,%ebp
+  80053d:	83 ec 10             	sub    $0x10,%esp
+    int neg = 0;
+  800540:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    long val = 0;
+  800547:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  80054e:	eb 04                	jmp    800554 <strtol+0x1a>
+        s ++;
+  800550:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+strtol(const char *s, char **endptr, int base) {
+    int neg = 0;
+    long val = 0;
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  800554:	8b 45 08             	mov    0x8(%ebp),%eax
+  800557:	0f b6 00             	movzbl (%eax),%eax
+  80055a:	3c 20                	cmp    $0x20,%al
+  80055c:	74 f2                	je     800550 <strtol+0x16>
+  80055e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800561:	0f b6 00             	movzbl (%eax),%eax
+  800564:	3c 09                	cmp    $0x9,%al
+  800566:	74 e8                	je     800550 <strtol+0x16>
+        s ++;
+    }
+
+    // plus/minus sign
+    if (*s == '+') {
+  800568:	8b 45 08             	mov    0x8(%ebp),%eax
+  80056b:	0f b6 00             	movzbl (%eax),%eax
+  80056e:	3c 2b                	cmp    $0x2b,%al
+  800570:	75 06                	jne    800578 <strtol+0x3e>
+        s ++;
+  800572:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800576:	eb 15                	jmp    80058d <strtol+0x53>
+    }
+    else if (*s == '-') {
+  800578:	8b 45 08             	mov    0x8(%ebp),%eax
+  80057b:	0f b6 00             	movzbl (%eax),%eax
+  80057e:	3c 2d                	cmp    $0x2d,%al
+  800580:	75 0b                	jne    80058d <strtol+0x53>
+        s ++, neg = 1;
+  800582:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800586:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+    }
+
+    // hex or octal base prefix
+    if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x')) {
+  80058d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800591:	74 06                	je     800599 <strtol+0x5f>
+  800593:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+  800597:	75 24                	jne    8005bd <strtol+0x83>
+  800599:	8b 45 08             	mov    0x8(%ebp),%eax
+  80059c:	0f b6 00             	movzbl (%eax),%eax
+  80059f:	3c 30                	cmp    $0x30,%al
+  8005a1:	75 1a                	jne    8005bd <strtol+0x83>
+  8005a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005a6:	83 c0 01             	add    $0x1,%eax
+  8005a9:	0f b6 00             	movzbl (%eax),%eax
+  8005ac:	3c 78                	cmp    $0x78,%al
+  8005ae:	75 0d                	jne    8005bd <strtol+0x83>
+        s += 2, base = 16;
+  8005b0:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+  8005b4:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+  8005bb:	eb 2a                	jmp    8005e7 <strtol+0xad>
+    }
+    else if (base == 0 && s[0] == '0') {
+  8005bd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8005c1:	75 17                	jne    8005da <strtol+0xa0>
+  8005c3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005c6:	0f b6 00             	movzbl (%eax),%eax
+  8005c9:	3c 30                	cmp    $0x30,%al
+  8005cb:	75 0d                	jne    8005da <strtol+0xa0>
+        s ++, base = 8;
+  8005cd:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  8005d1:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+  8005d8:	eb 0d                	jmp    8005e7 <strtol+0xad>
+    }
+    else if (base == 0) {
+  8005da:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8005de:	75 07                	jne    8005e7 <strtol+0xad>
+        base = 10;
+  8005e0:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+    // digits
+    while (1) {
+        int dig;
+
+        if (*s >= '0' && *s <= '9') {
+  8005e7:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005ea:	0f b6 00             	movzbl (%eax),%eax
+  8005ed:	3c 2f                	cmp    $0x2f,%al
+  8005ef:	7e 1b                	jle    80060c <strtol+0xd2>
+  8005f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005f4:	0f b6 00             	movzbl (%eax),%eax
+  8005f7:	3c 39                	cmp    $0x39,%al
+  8005f9:	7f 11                	jg     80060c <strtol+0xd2>
+            dig = *s - '0';
+  8005fb:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005fe:	0f b6 00             	movzbl (%eax),%eax
+  800601:	0f be c0             	movsbl %al,%eax
+  800604:	83 e8 30             	sub    $0x30,%eax
+  800607:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80060a:	eb 48                	jmp    800654 <strtol+0x11a>
+        }
+        else if (*s >= 'a' && *s <= 'z') {
+  80060c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80060f:	0f b6 00             	movzbl (%eax),%eax
+  800612:	3c 60                	cmp    $0x60,%al
+  800614:	7e 1b                	jle    800631 <strtol+0xf7>
+  800616:	8b 45 08             	mov    0x8(%ebp),%eax
+  800619:	0f b6 00             	movzbl (%eax),%eax
+  80061c:	3c 7a                	cmp    $0x7a,%al
+  80061e:	7f 11                	jg     800631 <strtol+0xf7>
+            dig = *s - 'a' + 10;
+  800620:	8b 45 08             	mov    0x8(%ebp),%eax
+  800623:	0f b6 00             	movzbl (%eax),%eax
+  800626:	0f be c0             	movsbl %al,%eax
+  800629:	83 e8 57             	sub    $0x57,%eax
+  80062c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80062f:	eb 23                	jmp    800654 <strtol+0x11a>
+        }
+        else if (*s >= 'A' && *s <= 'Z') {
+  800631:	8b 45 08             	mov    0x8(%ebp),%eax
+  800634:	0f b6 00             	movzbl (%eax),%eax
+  800637:	3c 40                	cmp    $0x40,%al
+  800639:	7e 3c                	jle    800677 <strtol+0x13d>
+  80063b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80063e:	0f b6 00             	movzbl (%eax),%eax
+  800641:	3c 5a                	cmp    $0x5a,%al
+  800643:	7f 32                	jg     800677 <strtol+0x13d>
+            dig = *s - 'A' + 10;
+  800645:	8b 45 08             	mov    0x8(%ebp),%eax
+  800648:	0f b6 00             	movzbl (%eax),%eax
+  80064b:	0f be c0             	movsbl %al,%eax
+  80064e:	83 e8 37             	sub    $0x37,%eax
+  800651:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+  800654:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800657:	3b 45 10             	cmp    0x10(%ebp),%eax
+  80065a:	7d 1a                	jge    800676 <strtol+0x13c>
+            break;
+        }
+        s ++, val = (val * base) + dig;
+  80065c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800660:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800663:	0f af 45 10          	imul   0x10(%ebp),%eax
+  800667:	89 c2                	mov    %eax,%edx
+  800669:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  80066c:	01 d0                	add    %edx,%eax
+  80066e:	89 45 f8             	mov    %eax,-0x8(%ebp)
+        // we don't properly detect overflow!
+    }
+  800671:	e9 71 ff ff ff       	jmp    8005e7 <strtol+0xad>
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+            break;
+  800676:	90                   	nop
+        }
+        s ++, val = (val * base) + dig;
+        // we don't properly detect overflow!
+    }
+
+    if (endptr) {
+  800677:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  80067b:	74 08                	je     800685 <strtol+0x14b>
+        *endptr = (char *) s;
+  80067d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800680:	8b 55 08             	mov    0x8(%ebp),%edx
+  800683:	89 10                	mov    %edx,(%eax)
+    }
+    return (neg ? -val : val);
+  800685:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+  800689:	74 07                	je     800692 <strtol+0x158>
+  80068b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  80068e:	f7 d8                	neg    %eax
+  800690:	eb 03                	jmp    800695 <strtol+0x15b>
+  800692:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  800695:	c9                   	leave  
+  800696:	c3                   	ret    
+
+00800697 <memset>:
+ * @n:      number of bytes to be set to the value
+ *
+ * The memset() function returns @s.
+ * */
+void *
+memset(void *s, char c, size_t n) {
+  800697:	55                   	push   %ebp
+  800698:	89 e5                	mov    %esp,%ebp
+  80069a:	57                   	push   %edi
+  80069b:	83 ec 24             	sub    $0x24,%esp
+  80069e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006a1:	88 45 d8             	mov    %al,-0x28(%ebp)
+#ifdef __HAVE_ARCH_MEMSET
+    return __memset(s, c, n);
+  8006a4:	0f be 45 d8          	movsbl -0x28(%ebp),%eax
+  8006a8:	8b 55 08             	mov    0x8(%ebp),%edx
+  8006ab:	89 55 f8             	mov    %edx,-0x8(%ebp)
+  8006ae:	88 45 f7             	mov    %al,-0x9(%ebp)
+  8006b1:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_MEMSET
+#define __HAVE_ARCH_MEMSET
+static inline void *
+__memset(void *s, char c, size_t n) {
+    int d0, d1;
+    asm volatile (
+  8006b7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+  8006ba:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
+  8006be:	8b 55 f8             	mov    -0x8(%ebp),%edx
+  8006c1:	89 d7                	mov    %edx,%edi
+  8006c3:	f3 aa                	rep stos %al,%es:(%edi)
+  8006c5:	89 fa                	mov    %edi,%edx
+  8006c7:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  8006ca:	89 55 e8             	mov    %edx,-0x18(%ebp)
+        "rep; stosb;"
+        : "=&c" (d0), "=&D" (d1)
+        : "0" (n), "a" (c), "1" (s)
+        : "memory");
+    return s;
+  8006cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8006d0:	90                   	nop
+    while (n -- > 0) {
+        *p ++ = c;
+    }
+    return s;
+#endif /* __HAVE_ARCH_MEMSET */
+}
+  8006d1:	83 c4 24             	add    $0x24,%esp
+  8006d4:	5f                   	pop    %edi
+  8006d5:	5d                   	pop    %ebp
+  8006d6:	c3                   	ret    
+
+008006d7 <memmove>:
+ * @n:      number of bytes to copy
+ *
+ * The memmove() function returns @dst.
+ * */
+void *
+memmove(void *dst, const void *src, size_t n) {
+  8006d7:	55                   	push   %ebp
+  8006d8:	89 e5                	mov    %esp,%ebp
+  8006da:	57                   	push   %edi
+  8006db:	56                   	push   %esi
+  8006dc:	53                   	push   %ebx
+  8006dd:	83 ec 30             	sub    $0x30,%esp
+  8006e0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8006e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8006e6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  8006ec:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006ef:	89 45 e8             	mov    %eax,-0x18(%ebp)
+
+#ifndef __HAVE_ARCH_MEMMOVE
+#define __HAVE_ARCH_MEMMOVE
+static inline void *
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+  8006f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006f5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  8006f8:	73 42                	jae    80073c <memmove+0x65>
+  8006fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006fd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800700:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800703:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800706:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800709:	89 45 dc             	mov    %eax,-0x24(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  80070c:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  80070f:	c1 e8 02             	shr    $0x2,%eax
+  800712:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  800714:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800717:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80071a:	89 d7                	mov    %edx,%edi
+  80071c:	89 c6                	mov    %eax,%esi
+  80071e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800720:	8b 4d dc             	mov    -0x24(%ebp),%ecx
+  800723:	83 e1 03             	and    $0x3,%ecx
+  800726:	74 02                	je     80072a <memmove+0x53>
+  800728:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  80072a:	89 f0                	mov    %esi,%eax
+  80072c:	89 fa                	mov    %edi,%edx
+  80072e:	89 4d d8             	mov    %ecx,-0x28(%ebp)
+  800731:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  800734:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  800737:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMMOVE
+    return __memmove(dst, src, n);
+  80073a:	eb 36                	jmp    800772 <memmove+0x9b>
+    asm volatile (
+        "std;"
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+  80073c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80073f:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800742:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800745:	01 c2                	add    %eax,%edx
+  800747:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80074a:	8d 48 ff             	lea    -0x1(%eax),%ecx
+  80074d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800750:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+        return __memcpy(dst, src, n);
+    }
+    int d0, d1, d2;
+    asm volatile (
+  800753:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800756:	89 c1                	mov    %eax,%ecx
+  800758:	89 d8                	mov    %ebx,%eax
+  80075a:	89 d6                	mov    %edx,%esi
+  80075c:	89 c7                	mov    %eax,%edi
+  80075e:	fd                   	std    
+  80075f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  800761:	fc                   	cld    
+  800762:	89 f8                	mov    %edi,%eax
+  800764:	89 f2                	mov    %esi,%edx
+  800766:	89 4d cc             	mov    %ecx,-0x34(%ebp)
+  800769:	89 55 c8             	mov    %edx,-0x38(%ebp)
+  80076c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+        : "memory");
+    return dst;
+  80076f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+            *d ++ = *s ++;
+        }
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMMOVE */
+}
+  800772:	83 c4 30             	add    $0x30,%esp
+  800775:	5b                   	pop    %ebx
+  800776:	5e                   	pop    %esi
+  800777:	5f                   	pop    %edi
+  800778:	5d                   	pop    %ebp
+  800779:	c3                   	ret    
+
+0080077a <memcpy>:
+ * it always copies exactly @n bytes. To avoid overflows, the size of arrays pointed
+ * by both @src and @dst, should be at least @n bytes, and should not overlap
+ * (for overlapping memory area, memmove is a safer approach).
+ * */
+void *
+memcpy(void *dst, const void *src, size_t n) {
+  80077a:	55                   	push   %ebp
+  80077b:	89 e5                	mov    %esp,%ebp
+  80077d:	57                   	push   %edi
+  80077e:	56                   	push   %esi
+  80077f:	83 ec 20             	sub    $0x20,%esp
+  800782:	8b 45 08             	mov    0x8(%ebp),%eax
+  800785:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800788:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80078b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80078e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800791:	89 45 ec             	mov    %eax,-0x14(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  800794:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800797:	c1 e8 02             	shr    $0x2,%eax
+  80079a:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  80079c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80079f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8007a2:	89 d7                	mov    %edx,%edi
+  8007a4:	89 c6                	mov    %eax,%esi
+  8007a6:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  8007a8:	8b 4d ec             	mov    -0x14(%ebp),%ecx
+  8007ab:	83 e1 03             	and    $0x3,%ecx
+  8007ae:	74 02                	je     8007b2 <memcpy+0x38>
+  8007b0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  8007b2:	89 f0                	mov    %esi,%eax
+  8007b4:	89 fa                	mov    %edi,%edx
+  8007b6:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  8007b9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  8007bc:	89 45 e0             	mov    %eax,-0x20(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  8007bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMCPY
+    return __memcpy(dst, src, n);
+  8007c2:	90                   	nop
+    while (n -- > 0) {
+        *d ++ = *s ++;
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMCPY */
+}
+  8007c3:	83 c4 20             	add    $0x20,%esp
+  8007c6:	5e                   	pop    %esi
+  8007c7:	5f                   	pop    %edi
+  8007c8:	5d                   	pop    %ebp
+  8007c9:	c3                   	ret    
+
+008007ca <memcmp>:
+ *   match in both memory blocks has a greater value in @v1 than in @v2
+ *   as if evaluated as unsigned char values;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+  8007ca:	55                   	push   %ebp
+  8007cb:	89 e5                	mov    %esp,%ebp
+  8007cd:	83 ec 10             	sub    $0x10,%esp
+    const char *s1 = (const char *)v1;
+  8007d0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8007d3:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    const char *s2 = (const char *)v2;
+  8007d6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8007d9:	89 45 f8             	mov    %eax,-0x8(%ebp)
+    while (n -- > 0) {
+  8007dc:	eb 30                	jmp    80080e <memcmp+0x44>
+        if (*s1 != *s2) {
+  8007de:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8007e1:	0f b6 10             	movzbl (%eax),%edx
+  8007e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8007e7:	0f b6 00             	movzbl (%eax),%eax
+  8007ea:	38 c2                	cmp    %al,%dl
+  8007ec:	74 18                	je     800806 <memcmp+0x3c>
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+  8007ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8007f1:	0f b6 00             	movzbl (%eax),%eax
+  8007f4:	0f b6 d0             	movzbl %al,%edx
+  8007f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8007fa:	0f b6 00             	movzbl (%eax),%eax
+  8007fd:	0f b6 c0             	movzbl %al,%eax
+  800800:	29 c2                	sub    %eax,%edx
+  800802:	89 d0                	mov    %edx,%eax
+  800804:	eb 1a                	jmp    800820 <memcmp+0x56>
+        }
+        s1 ++, s2 ++;
+  800806:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  80080a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+    const char *s1 = (const char *)v1;
+    const char *s2 = (const char *)v2;
+    while (n -- > 0) {
+  80080e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800811:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800814:	89 55 10             	mov    %edx,0x10(%ebp)
+  800817:	85 c0                	test   %eax,%eax
+  800819:	75 c3                	jne    8007de <memcmp+0x14>
+        if (*s1 != *s2) {
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+        }
+        s1 ++, s2 ++;
+    }
+    return 0;
+  80081b:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800820:	c9                   	leave  
+  800821:	c3                   	ret    
+
+00800822 <printnum>:
+ * @width:      maximum number of digits, if the actual width is less than @width, use @padc instead
+ * @padc:       character that padded on the left if the actual width is less than @width
+ * */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+        unsigned long long num, unsigned base, int width, int padc) {
+  800822:	55                   	push   %ebp
+  800823:	89 e5                	mov    %esp,%ebp
+  800825:	83 ec 38             	sub    $0x38,%esp
+  800828:	8b 45 10             	mov    0x10(%ebp),%eax
+  80082b:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  80082e:	8b 45 14             	mov    0x14(%ebp),%eax
+  800831:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+    unsigned long long result = num;
+  800834:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  800837:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  80083a:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  80083d:	89 55 ec             	mov    %edx,-0x14(%ebp)
+    unsigned mod = do_div(result, base);
+  800840:	8b 45 18             	mov    0x18(%ebp),%eax
+  800843:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800846:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800849:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  80084c:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  80084f:	89 55 f0             	mov    %edx,-0x10(%ebp)
+  800852:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800855:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800858:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  80085c:	74 1c                	je     80087a <printnum+0x58>
+  80085e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800861:	ba 00 00 00 00       	mov    $0x0,%edx
+  800866:	f7 75 e4             	divl   -0x1c(%ebp)
+  800869:	89 55 f4             	mov    %edx,-0xc(%ebp)
+  80086c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  80086f:	ba 00 00 00 00       	mov    $0x0,%edx
+  800874:	f7 75 e4             	divl   -0x1c(%ebp)
+  800877:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80087a:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80087d:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800880:	f7 75 e4             	divl   -0x1c(%ebp)
+  800883:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800886:	89 55 dc             	mov    %edx,-0x24(%ebp)
+  800889:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80088c:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  80088f:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800892:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  800895:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  800898:	89 45 d8             	mov    %eax,-0x28(%ebp)
+
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+  80089b:	8b 45 18             	mov    0x18(%ebp),%eax
+  80089e:	ba 00 00 00 00       	mov    $0x0,%edx
+  8008a3:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  8008a6:	77 41                	ja     8008e9 <printnum+0xc7>
+  8008a8:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  8008ab:	72 05                	jb     8008b2 <printnum+0x90>
+  8008ad:	3b 45 d0             	cmp    -0x30(%ebp),%eax
+  8008b0:	77 37                	ja     8008e9 <printnum+0xc7>
+        printnum(putch, putdat, result, base, width - 1, padc);
+  8008b2:	8b 45 1c             	mov    0x1c(%ebp),%eax
+  8008b5:	83 e8 01             	sub    $0x1,%eax
+  8008b8:	83 ec 04             	sub    $0x4,%esp
+  8008bb:	ff 75 20             	pushl  0x20(%ebp)
+  8008be:	50                   	push   %eax
+  8008bf:	ff 75 18             	pushl  0x18(%ebp)
+  8008c2:	ff 75 ec             	pushl  -0x14(%ebp)
+  8008c5:	ff 75 e8             	pushl  -0x18(%ebp)
+  8008c8:	ff 75 0c             	pushl  0xc(%ebp)
+  8008cb:	ff 75 08             	pushl  0x8(%ebp)
+  8008ce:	e8 4f ff ff ff       	call   800822 <printnum>
+  8008d3:	83 c4 20             	add    $0x20,%esp
+  8008d6:	eb 1b                	jmp    8008f3 <printnum+0xd1>
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+            putch(padc, putdat);
+  8008d8:	83 ec 08             	sub    $0x8,%esp
+  8008db:	ff 75 0c             	pushl  0xc(%ebp)
+  8008de:	ff 75 20             	pushl  0x20(%ebp)
+  8008e1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8008e4:	ff d0                	call   *%eax
+  8008e6:	83 c4 10             	add    $0x10,%esp
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+        printnum(putch, putdat, result, base, width - 1, padc);
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+  8008e9:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+  8008ed:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+  8008f1:	7f e5                	jg     8008d8 <printnum+0xb6>
+            putch(padc, putdat);
+    }
+    // then print this (the least significant) digit
+    putch("0123456789abcdef"[mod], putdat);
+  8008f3:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  8008f6:	05 e4 10 80 00       	add    $0x8010e4,%eax
+  8008fb:	0f b6 00             	movzbl (%eax),%eax
+  8008fe:	0f be c0             	movsbl %al,%eax
+  800901:	83 ec 08             	sub    $0x8,%esp
+  800904:	ff 75 0c             	pushl  0xc(%ebp)
+  800907:	50                   	push   %eax
+  800908:	8b 45 08             	mov    0x8(%ebp),%eax
+  80090b:	ff d0                	call   *%eax
+  80090d:	83 c4 10             	add    $0x10,%esp
+}
+  800910:	90                   	nop
+  800911:	c9                   	leave  
+  800912:	c3                   	ret    
+
+00800913 <getuint>:
+ * getuint - get an unsigned int of various possible sizes from a varargs list
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static unsigned long long
+getuint(va_list *ap, int lflag) {
+  800913:	55                   	push   %ebp
+  800914:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  800916:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  80091a:	7e 14                	jle    800930 <getuint+0x1d>
+        return va_arg(*ap, unsigned long long);
+  80091c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80091f:	8b 00                	mov    (%eax),%eax
+  800921:	8d 48 08             	lea    0x8(%eax),%ecx
+  800924:	8b 55 08             	mov    0x8(%ebp),%edx
+  800927:	89 0a                	mov    %ecx,(%edx)
+  800929:	8b 50 04             	mov    0x4(%eax),%edx
+  80092c:	8b 00                	mov    (%eax),%eax
+  80092e:	eb 30                	jmp    800960 <getuint+0x4d>
+    }
+    else if (lflag) {
+  800930:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800934:	74 16                	je     80094c <getuint+0x39>
+        return va_arg(*ap, unsigned long);
+  800936:	8b 45 08             	mov    0x8(%ebp),%eax
+  800939:	8b 00                	mov    (%eax),%eax
+  80093b:	8d 48 04             	lea    0x4(%eax),%ecx
+  80093e:	8b 55 08             	mov    0x8(%ebp),%edx
+  800941:	89 0a                	mov    %ecx,(%edx)
+  800943:	8b 00                	mov    (%eax),%eax
+  800945:	ba 00 00 00 00       	mov    $0x0,%edx
+  80094a:	eb 14                	jmp    800960 <getuint+0x4d>
+    }
+    else {
+        return va_arg(*ap, unsigned int);
+  80094c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80094f:	8b 00                	mov    (%eax),%eax
+  800951:	8d 48 04             	lea    0x4(%eax),%ecx
+  800954:	8b 55 08             	mov    0x8(%ebp),%edx
+  800957:	89 0a                	mov    %ecx,(%edx)
+  800959:	8b 00                	mov    (%eax),%eax
+  80095b:	ba 00 00 00 00       	mov    $0x0,%edx
+    }
+}
+  800960:	5d                   	pop    %ebp
+  800961:	c3                   	ret    
+
+00800962 <getint>:
+ * getint - same as getuint but signed, we can't use getuint because of sign extension
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static long long
+getint(va_list *ap, int lflag) {
+  800962:	55                   	push   %ebp
+  800963:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  800965:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  800969:	7e 14                	jle    80097f <getint+0x1d>
+        return va_arg(*ap, long long);
+  80096b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80096e:	8b 00                	mov    (%eax),%eax
+  800970:	8d 48 08             	lea    0x8(%eax),%ecx
+  800973:	8b 55 08             	mov    0x8(%ebp),%edx
+  800976:	89 0a                	mov    %ecx,(%edx)
+  800978:	8b 50 04             	mov    0x4(%eax),%edx
+  80097b:	8b 00                	mov    (%eax),%eax
+  80097d:	eb 28                	jmp    8009a7 <getint+0x45>
+    }
+    else if (lflag) {
+  80097f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800983:	74 12                	je     800997 <getint+0x35>
+        return va_arg(*ap, long);
+  800985:	8b 45 08             	mov    0x8(%ebp),%eax
+  800988:	8b 00                	mov    (%eax),%eax
+  80098a:	8d 48 04             	lea    0x4(%eax),%ecx
+  80098d:	8b 55 08             	mov    0x8(%ebp),%edx
+  800990:	89 0a                	mov    %ecx,(%edx)
+  800992:	8b 00                	mov    (%eax),%eax
+  800994:	99                   	cltd   
+  800995:	eb 10                	jmp    8009a7 <getint+0x45>
+    }
+    else {
+        return va_arg(*ap, int);
+  800997:	8b 45 08             	mov    0x8(%ebp),%eax
+  80099a:	8b 00                	mov    (%eax),%eax
+  80099c:	8d 48 04             	lea    0x4(%eax),%ecx
+  80099f:	8b 55 08             	mov    0x8(%ebp),%edx
+  8009a2:	89 0a                	mov    %ecx,(%edx)
+  8009a4:	8b 00                	mov    (%eax),%eax
+  8009a6:	99                   	cltd   
+    }
+}
+  8009a7:	5d                   	pop    %ebp
+  8009a8:	c3                   	ret    
+
+008009a9 <printfmt>:
+ * @putch:      specified putch function, print a single character
+ * @putdat:     used by @putch function
+ * @fmt:        the format string to use
+ * */
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...) {
+  8009a9:	55                   	push   %ebp
+  8009aa:	89 e5                	mov    %esp,%ebp
+  8009ac:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  8009af:	8d 45 14             	lea    0x14(%ebp),%eax
+  8009b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    vprintfmt(putch, putdat, fmt, ap);
+  8009b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8009b8:	50                   	push   %eax
+  8009b9:	ff 75 10             	pushl  0x10(%ebp)
+  8009bc:	ff 75 0c             	pushl  0xc(%ebp)
+  8009bf:	ff 75 08             	pushl  0x8(%ebp)
+  8009c2:	e8 06 00 00 00       	call   8009cd <vprintfmt>
+  8009c7:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+  8009ca:	90                   	nop
+  8009cb:	c9                   	leave  
+  8009cc:	c3                   	ret    
+
+008009cd <vprintfmt>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want printfmt() instead.
+ * */
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap) {
+  8009cd:	55                   	push   %ebp
+  8009ce:	89 e5                	mov    %esp,%ebp
+  8009d0:	56                   	push   %esi
+  8009d1:	53                   	push   %ebx
+  8009d2:	83 ec 20             	sub    $0x20,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  8009d5:	eb 17                	jmp    8009ee <vprintfmt+0x21>
+            if (ch == '\0') {
+  8009d7:	85 db                	test   %ebx,%ebx
+  8009d9:	0f 84 8e 03 00 00    	je     800d6d <vprintfmt+0x3a0>
+                return;
+            }
+            putch(ch, putdat);
+  8009df:	83 ec 08             	sub    $0x8,%esp
+  8009e2:	ff 75 0c             	pushl  0xc(%ebp)
+  8009e5:	53                   	push   %ebx
+  8009e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009e9:	ff d0                	call   *%eax
+  8009eb:	83 c4 10             	add    $0x10,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  8009ee:	8b 45 10             	mov    0x10(%ebp),%eax
+  8009f1:	8d 50 01             	lea    0x1(%eax),%edx
+  8009f4:	89 55 10             	mov    %edx,0x10(%ebp)
+  8009f7:	0f b6 00             	movzbl (%eax),%eax
+  8009fa:	0f b6 d8             	movzbl %al,%ebx
+  8009fd:	83 fb 25             	cmp    $0x25,%ebx
+  800a00:	75 d5                	jne    8009d7 <vprintfmt+0xa>
+            }
+            putch(ch, putdat);
+        }
+
+        // Process a %-escape sequence
+        char padc = ' ';
+  800a02:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+        width = precision = -1;
+  800a06:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+  800a0d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800a10:	89 45 e8             	mov    %eax,-0x18(%ebp)
+        lflag = altflag = 0;
+  800a13:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+  800a1a:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  800a1d:	89 45 e0             	mov    %eax,-0x20(%ebp)
+
+    reswitch:
+        switch (ch = *(unsigned char *)fmt ++) {
+  800a20:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a23:	8d 50 01             	lea    0x1(%eax),%edx
+  800a26:	89 55 10             	mov    %edx,0x10(%ebp)
+  800a29:	0f b6 00             	movzbl (%eax),%eax
+  800a2c:	0f b6 d8             	movzbl %al,%ebx
+  800a2f:	8d 43 dd             	lea    -0x23(%ebx),%eax
+  800a32:	83 f8 55             	cmp    $0x55,%eax
+  800a35:	0f 87 05 03 00 00    	ja     800d40 <vprintfmt+0x373>
+  800a3b:	8b 04 85 08 11 80 00 	mov    0x801108(,%eax,4),%eax
+  800a42:	ff e0                	jmp    *%eax
+
+        // flag to pad on the right
+        case '-':
+            padc = '-';
+  800a44:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+            goto reswitch;
+  800a48:	eb d6                	jmp    800a20 <vprintfmt+0x53>
+
+        // flag to pad with 0's instead of spaces
+        case '0':
+            padc = '0';
+  800a4a:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+            goto reswitch;
+  800a4e:	eb d0                	jmp    800a20 <vprintfmt+0x53>
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  800a50:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+                precision = precision * 10 + ch - '0';
+  800a57:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800a5a:	89 d0                	mov    %edx,%eax
+  800a5c:	c1 e0 02             	shl    $0x2,%eax
+  800a5f:	01 d0                	add    %edx,%eax
+  800a61:	01 c0                	add    %eax,%eax
+  800a63:	01 d8                	add    %ebx,%eax
+  800a65:	83 e8 30             	sub    $0x30,%eax
+  800a68:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+                ch = *fmt;
+  800a6b:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a6e:	0f b6 00             	movzbl (%eax),%eax
+  800a71:	0f be d8             	movsbl %al,%ebx
+                if (ch < '0' || ch > '9') {
+  800a74:	83 fb 2f             	cmp    $0x2f,%ebx
+  800a77:	7e 39                	jle    800ab2 <vprintfmt+0xe5>
+  800a79:	83 fb 39             	cmp    $0x39,%ebx
+  800a7c:	7f 34                	jg     800ab2 <vprintfmt+0xe5>
+            padc = '0';
+            goto reswitch;
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  800a7e:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+                precision = precision * 10 + ch - '0';
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+  800a82:	eb d3                	jmp    800a57 <vprintfmt+0x8a>
+            goto process_precision;
+
+        case '*':
+            precision = va_arg(ap, int);
+  800a84:	8b 45 14             	mov    0x14(%ebp),%eax
+  800a87:	8d 50 04             	lea    0x4(%eax),%edx
+  800a8a:	89 55 14             	mov    %edx,0x14(%ebp)
+  800a8d:	8b 00                	mov    (%eax),%eax
+  800a8f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+            goto process_precision;
+  800a92:	eb 1f                	jmp    800ab3 <vprintfmt+0xe6>
+
+        case '.':
+            if (width < 0)
+  800a94:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800a98:	79 86                	jns    800a20 <vprintfmt+0x53>
+                width = 0;
+  800a9a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+            goto reswitch;
+  800aa1:	e9 7a ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        case '#':
+            altflag = 1;
+  800aa6:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+            goto reswitch;
+  800aad:	e9 6e ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+            goto process_precision;
+  800ab2:	90                   	nop
+        case '#':
+            altflag = 1;
+            goto reswitch;
+
+        process_precision:
+            if (width < 0)
+  800ab3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ab7:	0f 89 63 ff ff ff    	jns    800a20 <vprintfmt+0x53>
+                width = precision, precision = -1;
+  800abd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800ac0:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800ac3:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+            goto reswitch;
+  800aca:	e9 51 ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        // long flag (doubled for long long)
+        case 'l':
+            lflag ++;
+  800acf:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
+            goto reswitch;
+  800ad3:	e9 48 ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        // character
+        case 'c':
+            putch(va_arg(ap, int), putdat);
+  800ad8:	8b 45 14             	mov    0x14(%ebp),%eax
+  800adb:	8d 50 04             	lea    0x4(%eax),%edx
+  800ade:	89 55 14             	mov    %edx,0x14(%ebp)
+  800ae1:	8b 00                	mov    (%eax),%eax
+  800ae3:	83 ec 08             	sub    $0x8,%esp
+  800ae6:	ff 75 0c             	pushl  0xc(%ebp)
+  800ae9:	50                   	push   %eax
+  800aea:	8b 45 08             	mov    0x8(%ebp),%eax
+  800aed:	ff d0                	call   *%eax
+  800aef:	83 c4 10             	add    $0x10,%esp
+            break;
+  800af2:	e9 71 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // error message
+        case 'e':
+            err = va_arg(ap, int);
+  800af7:	8b 45 14             	mov    0x14(%ebp),%eax
+  800afa:	8d 50 04             	lea    0x4(%eax),%edx
+  800afd:	89 55 14             	mov    %edx,0x14(%ebp)
+  800b00:	8b 18                	mov    (%eax),%ebx
+            if (err < 0) {
+  800b02:	85 db                	test   %ebx,%ebx
+  800b04:	79 02                	jns    800b08 <vprintfmt+0x13b>
+                err = -err;
+  800b06:	f7 db                	neg    %ebx
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+  800b08:	83 fb 18             	cmp    $0x18,%ebx
+  800b0b:	7f 0b                	jg     800b18 <vprintfmt+0x14b>
+  800b0d:	8b 34 9d 80 10 80 00 	mov    0x801080(,%ebx,4),%esi
+  800b14:	85 f6                	test   %esi,%esi
+  800b16:	75 19                	jne    800b31 <vprintfmt+0x164>
+                printfmt(putch, putdat, "error %d", err);
+  800b18:	53                   	push   %ebx
+  800b19:	68 f5 10 80 00       	push   $0x8010f5
+  800b1e:	ff 75 0c             	pushl  0xc(%ebp)
+  800b21:	ff 75 08             	pushl  0x8(%ebp)
+  800b24:	e8 80 fe ff ff       	call   8009a9 <printfmt>
+  800b29:	83 c4 10             	add    $0x10,%esp
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+            }
+            break;
+  800b2c:	e9 37 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+                printfmt(putch, putdat, "error %d", err);
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+  800b31:	56                   	push   %esi
+  800b32:	68 fe 10 80 00       	push   $0x8010fe
+  800b37:	ff 75 0c             	pushl  0xc(%ebp)
+  800b3a:	ff 75 08             	pushl  0x8(%ebp)
+  800b3d:	e8 67 fe ff ff       	call   8009a9 <printfmt>
+  800b42:	83 c4 10             	add    $0x10,%esp
+            }
+            break;
+  800b45:	e9 1e 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // string
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+  800b4a:	8b 45 14             	mov    0x14(%ebp),%eax
+  800b4d:	8d 50 04             	lea    0x4(%eax),%edx
+  800b50:	89 55 14             	mov    %edx,0x14(%ebp)
+  800b53:	8b 30                	mov    (%eax),%esi
+  800b55:	85 f6                	test   %esi,%esi
+  800b57:	75 05                	jne    800b5e <vprintfmt+0x191>
+                p = "(null)";
+  800b59:	be 01 11 80 00       	mov    $0x801101,%esi
+            }
+            if (width > 0 && padc != '-') {
+  800b5e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800b62:	7e 76                	jle    800bda <vprintfmt+0x20d>
+  800b64:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+  800b68:	74 70                	je     800bda <vprintfmt+0x20d>
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  800b6a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800b6d:	83 ec 08             	sub    $0x8,%esp
+  800b70:	50                   	push   %eax
+  800b71:	56                   	push   %esi
+  800b72:	e8 17 f8 ff ff       	call   80038e <strnlen>
+  800b77:	83 c4 10             	add    $0x10,%esp
+  800b7a:	89 c2                	mov    %eax,%edx
+  800b7c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800b7f:	29 d0                	sub    %edx,%eax
+  800b81:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800b84:	eb 17                	jmp    800b9d <vprintfmt+0x1d0>
+                    putch(padc, putdat);
+  800b86:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+  800b8a:	83 ec 08             	sub    $0x8,%esp
+  800b8d:	ff 75 0c             	pushl  0xc(%ebp)
+  800b90:	50                   	push   %eax
+  800b91:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b94:	ff d0                	call   *%eax
+  800b96:	83 c4 10             	add    $0x10,%esp
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+                p = "(null)";
+            }
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  800b99:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800b9d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ba1:	7f e3                	jg     800b86 <vprintfmt+0x1b9>
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  800ba3:	eb 35                	jmp    800bda <vprintfmt+0x20d>
+                if (altflag && (ch < ' ' || ch > '~')) {
+  800ba5:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+  800ba9:	74 1c                	je     800bc7 <vprintfmt+0x1fa>
+  800bab:	83 fb 1f             	cmp    $0x1f,%ebx
+  800bae:	7e 05                	jle    800bb5 <vprintfmt+0x1e8>
+  800bb0:	83 fb 7e             	cmp    $0x7e,%ebx
+  800bb3:	7e 12                	jle    800bc7 <vprintfmt+0x1fa>
+                    putch('?', putdat);
+  800bb5:	83 ec 08             	sub    $0x8,%esp
+  800bb8:	ff 75 0c             	pushl  0xc(%ebp)
+  800bbb:	6a 3f                	push   $0x3f
+  800bbd:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bc0:	ff d0                	call   *%eax
+  800bc2:	83 c4 10             	add    $0x10,%esp
+  800bc5:	eb 0f                	jmp    800bd6 <vprintfmt+0x209>
+                }
+                else {
+                    putch(ch, putdat);
+  800bc7:	83 ec 08             	sub    $0x8,%esp
+  800bca:	ff 75 0c             	pushl  0xc(%ebp)
+  800bcd:	53                   	push   %ebx
+  800bce:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bd1:	ff d0                	call   *%eax
+  800bd3:	83 c4 10             	add    $0x10,%esp
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  800bd6:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800bda:	89 f0                	mov    %esi,%eax
+  800bdc:	8d 70 01             	lea    0x1(%eax),%esi
+  800bdf:	0f b6 00             	movzbl (%eax),%eax
+  800be2:	0f be d8             	movsbl %al,%ebx
+  800be5:	85 db                	test   %ebx,%ebx
+  800be7:	74 26                	je     800c0f <vprintfmt+0x242>
+  800be9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800bed:	78 b6                	js     800ba5 <vprintfmt+0x1d8>
+  800bef:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800bf3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800bf7:	79 ac                	jns    800ba5 <vprintfmt+0x1d8>
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  800bf9:	eb 14                	jmp    800c0f <vprintfmt+0x242>
+                putch(' ', putdat);
+  800bfb:	83 ec 08             	sub    $0x8,%esp
+  800bfe:	ff 75 0c             	pushl  0xc(%ebp)
+  800c01:	6a 20                	push   $0x20
+  800c03:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c06:	ff d0                	call   *%eax
+  800c08:	83 c4 10             	add    $0x10,%esp
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  800c0b:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800c0f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800c13:	7f e6                	jg     800bfb <vprintfmt+0x22e>
+                putch(' ', putdat);
+            }
+            break;
+  800c15:	e9 4e 01 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // (signed) decimal
+        case 'd':
+            num = getint(&ap, lflag);
+  800c1a:	83 ec 08             	sub    $0x8,%esp
+  800c1d:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c20:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c23:	50                   	push   %eax
+  800c24:	e8 39 fd ff ff       	call   800962 <getint>
+  800c29:	83 c4 10             	add    $0x10,%esp
+  800c2c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c2f:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            if ((long long)num < 0) {
+  800c32:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c35:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800c38:	85 d2                	test   %edx,%edx
+  800c3a:	79 23                	jns    800c5f <vprintfmt+0x292>
+                putch('-', putdat);
+  800c3c:	83 ec 08             	sub    $0x8,%esp
+  800c3f:	ff 75 0c             	pushl  0xc(%ebp)
+  800c42:	6a 2d                	push   $0x2d
+  800c44:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c47:	ff d0                	call   *%eax
+  800c49:	83 c4 10             	add    $0x10,%esp
+                num = -(long long)num;
+  800c4c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c4f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800c52:	f7 d8                	neg    %eax
+  800c54:	83 d2 00             	adc    $0x0,%edx
+  800c57:	f7 da                	neg    %edx
+  800c59:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c5c:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            }
+            base = 10;
+  800c5f:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  800c66:	e9 9f 00 00 00       	jmp    800d0a <vprintfmt+0x33d>
+
+        // unsigned decimal
+        case 'u':
+            num = getuint(&ap, lflag);
+  800c6b:	83 ec 08             	sub    $0x8,%esp
+  800c6e:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c71:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c74:	50                   	push   %eax
+  800c75:	e8 99 fc ff ff       	call   800913 <getuint>
+  800c7a:	83 c4 10             	add    $0x10,%esp
+  800c7d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c80:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 10;
+  800c83:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  800c8a:	eb 7e                	jmp    800d0a <vprintfmt+0x33d>
+
+        // (unsigned) octal
+        case 'o':
+            num = getuint(&ap, lflag);
+  800c8c:	83 ec 08             	sub    $0x8,%esp
+  800c8f:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c92:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c95:	50                   	push   %eax
+  800c96:	e8 78 fc ff ff       	call   800913 <getuint>
+  800c9b:	83 c4 10             	add    $0x10,%esp
+  800c9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800ca1:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 8;
+  800ca4:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+            goto number;
+  800cab:	eb 5d                	jmp    800d0a <vprintfmt+0x33d>
+
+        // pointer
+        case 'p':
+            putch('0', putdat);
+  800cad:	83 ec 08             	sub    $0x8,%esp
+  800cb0:	ff 75 0c             	pushl  0xc(%ebp)
+  800cb3:	6a 30                	push   $0x30
+  800cb5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cb8:	ff d0                	call   *%eax
+  800cba:	83 c4 10             	add    $0x10,%esp
+            putch('x', putdat);
+  800cbd:	83 ec 08             	sub    $0x8,%esp
+  800cc0:	ff 75 0c             	pushl  0xc(%ebp)
+  800cc3:	6a 78                	push   $0x78
+  800cc5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cc8:	ff d0                	call   *%eax
+  800cca:	83 c4 10             	add    $0x10,%esp
+            num = (unsigned long long)(uintptr_t)va_arg(ap, void *);
+  800ccd:	8b 45 14             	mov    0x14(%ebp),%eax
+  800cd0:	8d 50 04             	lea    0x4(%eax),%edx
+  800cd3:	89 55 14             	mov    %edx,0x14(%ebp)
+  800cd6:	8b 00                	mov    (%eax),%eax
+  800cd8:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800cdb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+            base = 16;
+  800ce2:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+            goto number;
+  800ce9:	eb 1f                	jmp    800d0a <vprintfmt+0x33d>
+
+        // (unsigned) hexadecimal
+        case 'x':
+            num = getuint(&ap, lflag);
+  800ceb:	83 ec 08             	sub    $0x8,%esp
+  800cee:	ff 75 e0             	pushl  -0x20(%ebp)
+  800cf1:	8d 45 14             	lea    0x14(%ebp),%eax
+  800cf4:	50                   	push   %eax
+  800cf5:	e8 19 fc ff ff       	call   800913 <getuint>
+  800cfa:	83 c4 10             	add    $0x10,%esp
+  800cfd:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800d00:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 16;
+  800d03:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+        number:
+            printnum(putch, putdat, num, base, width, padc);
+  800d0a:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+  800d0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800d11:	83 ec 04             	sub    $0x4,%esp
+  800d14:	52                   	push   %edx
+  800d15:	ff 75 e8             	pushl  -0x18(%ebp)
+  800d18:	50                   	push   %eax
+  800d19:	ff 75 f4             	pushl  -0xc(%ebp)
+  800d1c:	ff 75 f0             	pushl  -0x10(%ebp)
+  800d1f:	ff 75 0c             	pushl  0xc(%ebp)
+  800d22:	ff 75 08             	pushl  0x8(%ebp)
+  800d25:	e8 f8 fa ff ff       	call   800822 <printnum>
+  800d2a:	83 c4 20             	add    $0x20,%esp
+            break;
+  800d2d:	eb 39                	jmp    800d68 <vprintfmt+0x39b>
+
+        // escaped '%' character
+        case '%':
+            putch(ch, putdat);
+  800d2f:	83 ec 08             	sub    $0x8,%esp
+  800d32:	ff 75 0c             	pushl  0xc(%ebp)
+  800d35:	53                   	push   %ebx
+  800d36:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d39:	ff d0                	call   *%eax
+  800d3b:	83 c4 10             	add    $0x10,%esp
+            break;
+  800d3e:	eb 28                	jmp    800d68 <vprintfmt+0x39b>
+
+        // unrecognized escape sequence - just print it literally
+        default:
+            putch('%', putdat);
+  800d40:	83 ec 08             	sub    $0x8,%esp
+  800d43:	ff 75 0c             	pushl  0xc(%ebp)
+  800d46:	6a 25                	push   $0x25
+  800d48:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d4b:	ff d0                	call   *%eax
+  800d4d:	83 c4 10             	add    $0x10,%esp
+            for (fmt --; fmt[-1] != '%'; fmt --)
+  800d50:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800d54:	eb 04                	jmp    800d5a <vprintfmt+0x38d>
+  800d56:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800d5a:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d5d:	83 e8 01             	sub    $0x1,%eax
+  800d60:	0f b6 00             	movzbl (%eax),%eax
+  800d63:	3c 25                	cmp    $0x25,%al
+  800d65:	75 ef                	jne    800d56 <vprintfmt+0x389>
+                /* do nothing */;
+            break;
+  800d67:	90                   	nop
+        }
+    }
+  800d68:	e9 68 fc ff ff       	jmp    8009d5 <vprintfmt+0x8>
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+            if (ch == '\0') {
+                return;
+  800d6d:	90                   	nop
+            for (fmt --; fmt[-1] != '%'; fmt --)
+                /* do nothing */;
+            break;
+        }
+    }
+}
+  800d6e:	8d 65 f8             	lea    -0x8(%ebp),%esp
+  800d71:	5b                   	pop    %ebx
+  800d72:	5e                   	pop    %esi
+  800d73:	5d                   	pop    %ebp
+  800d74:	c3                   	ret    
+
+00800d75 <sprintputch>:
+ * sprintputch - 'print' a single character in a buffer
+ * @ch:         the character will be printed
+ * @b:          the buffer to place the character @ch
+ * */
+static void
+sprintputch(int ch, struct sprintbuf *b) {
+  800d75:	55                   	push   %ebp
+  800d76:	89 e5                	mov    %esp,%ebp
+    b->cnt ++;
+  800d78:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d7b:	8b 40 08             	mov    0x8(%eax),%eax
+  800d7e:	8d 50 01             	lea    0x1(%eax),%edx
+  800d81:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d84:	89 50 08             	mov    %edx,0x8(%eax)
+    if (b->buf < b->ebuf) {
+  800d87:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8a:	8b 10                	mov    (%eax),%edx
+  800d8c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8f:	8b 40 04             	mov    0x4(%eax),%eax
+  800d92:	39 c2                	cmp    %eax,%edx
+  800d94:	73 12                	jae    800da8 <sprintputch+0x33>
+        *b->buf ++ = ch;
+  800d96:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d99:	8b 00                	mov    (%eax),%eax
+  800d9b:	8d 48 01             	lea    0x1(%eax),%ecx
+  800d9e:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800da1:	89 0a                	mov    %ecx,(%edx)
+  800da3:	8b 55 08             	mov    0x8(%ebp),%edx
+  800da6:	88 10                	mov    %dl,(%eax)
+    }
+}
+  800da8:	90                   	nop
+  800da9:	5d                   	pop    %ebp
+  800daa:	c3                   	ret    
+
+00800dab <snprintf>:
+ * @str:        the buffer to place the result into
+ * @size:       the size of buffer, including the trailing null space
+ * @fmt:        the format string to use
+ * */
+int
+snprintf(char *str, size_t size, const char *fmt, ...) {
+  800dab:	55                   	push   %ebp
+  800dac:	89 e5                	mov    %esp,%ebp
+  800dae:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    int cnt;
+    va_start(ap, fmt);
+  800db1:	8d 45 14             	lea    0x14(%ebp),%eax
+  800db4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    cnt = vsnprintf(str, size, fmt, ap);
+  800db7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800dba:	50                   	push   %eax
+  800dbb:	ff 75 10             	pushl  0x10(%ebp)
+  800dbe:	ff 75 0c             	pushl  0xc(%ebp)
+  800dc1:	ff 75 08             	pushl  0x8(%ebp)
+  800dc4:	e8 0b 00 00 00       	call   800dd4 <vsnprintf>
+  800dc9:	83 c4 10             	add    $0x10,%esp
+  800dcc:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+    return cnt;
+  800dcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800dd2:	c9                   	leave  
+  800dd3:	c3                   	ret    
+
+00800dd4 <vsnprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want snprintf() instead.
+ * */
+int
+vsnprintf(char *str, size_t size, const char *fmt, va_list ap) {
+  800dd4:	55                   	push   %ebp
+  800dd5:	89 e5                	mov    %esp,%ebp
+  800dd7:	83 ec 18             	sub    $0x18,%esp
+    struct sprintbuf b = {str, str + size - 1, 0};
+  800dda:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ddd:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800de0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800de3:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800de6:	8b 45 08             	mov    0x8(%ebp),%eax
+  800de9:	01 d0                	add    %edx,%eax
+  800deb:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800dee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    if (str == NULL || b.buf > b.ebuf) {
+  800df5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  800df9:	74 0a                	je     800e05 <vsnprintf+0x31>
+  800dfb:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  800dfe:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800e01:	39 c2                	cmp    %eax,%edx
+  800e03:	76 07                	jbe    800e0c <vsnprintf+0x38>
+        return -E_INVAL;
+  800e05:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+  800e0a:	eb 20                	jmp    800e2c <vsnprintf+0x58>
+    }
+    // print the string to the buffer
+    vprintfmt((void*)sprintputch, &b, fmt, ap);
+  800e0c:	ff 75 14             	pushl  0x14(%ebp)
+  800e0f:	ff 75 10             	pushl  0x10(%ebp)
+  800e12:	8d 45 ec             	lea    -0x14(%ebp),%eax
+  800e15:	50                   	push   %eax
+  800e16:	68 75 0d 80 00       	push   $0x800d75
+  800e1b:	e8 ad fb ff ff       	call   8009cd <vprintfmt>
+  800e20:	83 c4 10             	add    $0x10,%esp
+    // null terminate the buffer
+    *b.buf = '\0';
+  800e23:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e26:	c6 00 00             	movb   $0x0,(%eax)
+    return b.cnt;
+  800e29:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800e2c:	c9                   	leave  
+  800e2d:	c3                   	ret    
+
+00800e2e <hash32>:
+ * @bits:   the number of bits in a return value
+ *
+ * High bits are more random, so we use them.
+ * */
+uint32_t
+hash32(uint32_t val, unsigned int bits) {
+  800e2e:	55                   	push   %ebp
+  800e2f:	89 e5                	mov    %esp,%ebp
+  800e31:	83 ec 10             	sub    $0x10,%esp
+    uint32_t hash = val * GOLDEN_RATIO_PRIME_32;
+  800e34:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e37:	69 c0 01 00 37 9e    	imul   $0x9e370001,%eax,%eax
+  800e3d:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    return (hash >> (32 - bits));
+  800e40:	b8 20 00 00 00       	mov    $0x20,%eax
+  800e45:	2b 45 0c             	sub    0xc(%ebp),%eax
+  800e48:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  800e4b:	89 c1                	mov    %eax,%ecx
+  800e4d:	d3 ea                	shr    %cl,%edx
+  800e4f:	89 d0                	mov    %edx,%eax
+}
+  800e51:	c9                   	leave  
+  800e52:	c3                   	ret    
+
+00800e53 <rand>:
+ * rand - returns a pseudo-random integer
+ *
+ * The rand() function return a value in the range [0, RAND_MAX].
+ * */
+int
+rand(void) {
+  800e53:	55                   	push   %ebp
+  800e54:	89 e5                	mov    %esp,%ebp
+  800e56:	57                   	push   %edi
+  800e57:	56                   	push   %esi
+  800e58:	53                   	push   %ebx
+  800e59:	83 ec 24             	sub    $0x24,%esp
+    next = (next * 0x5DEECE66DLL + 0xBLL) & ((1LL << 48) - 1);
+  800e5c:	a1 00 20 80 00       	mov    0x802000,%eax
+  800e61:	8b 15 04 20 80 00    	mov    0x802004,%edx
+  800e67:	69 fa 6d e6 ec de    	imul   $0xdeece66d,%edx,%edi
+  800e6d:	6b f0 05             	imul   $0x5,%eax,%esi
+  800e70:	01 fe                	add    %edi,%esi
+  800e72:	bf 6d e6 ec de       	mov    $0xdeece66d,%edi
+  800e77:	f7 e7                	mul    %edi
+  800e79:	01 d6                	add    %edx,%esi
+  800e7b:	89 f2                	mov    %esi,%edx
+  800e7d:	83 c0 0b             	add    $0xb,%eax
+  800e80:	83 d2 00             	adc    $0x0,%edx
+  800e83:	89 c7                	mov    %eax,%edi
+  800e85:	83 e7 ff             	and    $0xffffffff,%edi
+  800e88:	89 f9                	mov    %edi,%ecx
+  800e8a:	0f b7 da             	movzwl %dx,%ebx
+  800e8d:	89 0d 00 20 80 00    	mov    %ecx,0x802000
+  800e93:	89 1d 04 20 80 00    	mov    %ebx,0x802004
+    unsigned long long result = (next >> 12);
+  800e99:	a1 00 20 80 00       	mov    0x802000,%eax
+  800e9e:	8b 15 04 20 80 00    	mov    0x802004,%edx
+  800ea4:	0f ac d0 0c          	shrd   $0xc,%edx,%eax
+  800ea8:	c1 ea 0c             	shr    $0xc,%edx
+  800eab:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800eae:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+    return (int)do_div(result, RAND_MAX + 1);
+  800eb1:	c7 45 dc 00 00 00 80 	movl   $0x80000000,-0x24(%ebp)
+  800eb8:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  800ebb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800ebe:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  800ec1:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  800ec4:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ec7:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800eca:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ece:	74 1c                	je     800eec <rand+0x99>
+  800ed0:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ed3:	ba 00 00 00 00       	mov    $0x0,%edx
+  800ed8:	f7 75 dc             	divl   -0x24(%ebp)
+  800edb:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  800ede:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ee1:	ba 00 00 00 00       	mov    $0x0,%edx
+  800ee6:	f7 75 dc             	divl   -0x24(%ebp)
+  800ee9:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800eec:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  800eef:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  800ef2:	f7 75 dc             	divl   -0x24(%ebp)
+  800ef5:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  800ef8:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  800efb:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  800efe:	8b 55 e8             	mov    -0x18(%ebp),%edx
+  800f01:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800f04:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  800f07:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+}
+  800f0a:	83 c4 24             	add    $0x24,%esp
+  800f0d:	5b                   	pop    %ebx
+  800f0e:	5e                   	pop    %esi
+  800f0f:	5f                   	pop    %edi
+  800f10:	5d                   	pop    %ebp
+  800f11:	c3                   	ret    
+
+00800f12 <srand>:
+/* *
+ * srand - seed the random number generator with the given number
+ * @seed:   the required seed number
+ * */
+void
+srand(unsigned int seed) {
+  800f12:	55                   	push   %ebp
+  800f13:	89 e5                	mov    %esp,%ebp
+    next = seed;
+  800f15:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f18:	ba 00 00 00 00       	mov    $0x0,%edx
+  800f1d:	a3 00 20 80 00       	mov    %eax,0x802000
+  800f22:	89 15 04 20 80 00    	mov    %edx,0x802004
+}
+  800f28:	90                   	nop
+  800f29:	5d                   	pop    %ebp
+  800f2a:	c3                   	ret    
+
+00800f2b <main>:
+#include <stdio.h>
+#include <ulib.h>
+
+int
+main(void) {
+  800f2b:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+  800f2f:	83 e4 f0             	and    $0xfffffff0,%esp
+  800f32:	ff 71 fc             	pushl  -0x4(%ecx)
+  800f35:	55                   	push   %ebp
+  800f36:	89 e5                	mov    %esp,%ebp
+  800f38:	51                   	push   %ecx
+  800f39:	83 ec 04             	sub    $0x4,%esp
+    cprintf("I read %8x from 0.\n", *(unsigned int *)0);
+  800f3c:	b8 00 00 00 00       	mov    $0x0,%eax
+  800f41:	8b 00                	mov    (%eax),%eax
+  800f43:	83 ec 08             	sub    $0x8,%esp
+  800f46:	50                   	push   %eax
+  800f47:	68 60 12 80 00       	push   $0x801260
+  800f4c:	e8 88 f3 ff ff       	call   8002d9 <cprintf>
+  800f51:	83 c4 10             	add    $0x10,%esp
+    panic("FAIL: T.T\n");
+  800f54:	83 ec 04             	sub    $0x4,%esp
+  800f57:	68 74 12 80 00       	push   $0x801274
+  800f5c:	6a 07                	push   $0x7
+  800f5e:	68 7f 12 80 00       	push   $0x80127f
+  800f63:	e8 b8 f0 ff ff       	call   800020 <__panic>
diff -r -u -P lab6_origin/obj/user/faultread.d lab6/obj/user/faultread.d
--- lab6_origin/obj/user/faultread.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/faultread.d	2019-05-13 17:39:38.370051000 +0800
@@ -0,0 +1,2 @@
+obj/user/faultread.o obj/user/faultread.d: user/faultread.c libs/stdio.h \
+ libs/defs.h libs/stdarg.h user/libs/ulib.h
diff -r -u -P lab6_origin/obj/user/faultreadkernel.asm lab6/obj/user/faultreadkernel.asm
--- lab6_origin/obj/user/faultreadkernel.asm	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/faultreadkernel.asm	2019-05-13 17:39:43.729973400 +0800
@@ -0,0 +1,2584 @@
+
+obj/__user_faultreadkernel.out:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00800020 <__panic>:
+#include <stdio.h>
+#include <ulib.h>
+#include <error.h>
+
+void
+__panic(const char *file, int line, const char *fmt, ...) {
+  800020:	55                   	push   %ebp
+  800021:	89 e5                	mov    %esp,%ebp
+  800023:	83 ec 18             	sub    $0x18,%esp
+    // print the 'message'
+    va_list ap;
+    va_start(ap, fmt);
+  800026:	8d 45 14             	lea    0x14(%ebp),%eax
+  800029:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("user panic at %s:%d:\n    ", file, line);
+  80002c:	83 ec 04             	sub    $0x4,%esp
+  80002f:	ff 75 0c             	pushl  0xc(%ebp)
+  800032:	ff 75 08             	pushl  0x8(%ebp)
+  800035:	68 80 0f 80 00       	push   $0x800f80
+  80003a:	e8 9a 02 00 00       	call   8002d9 <cprintf>
+  80003f:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+  800042:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800045:	83 ec 08             	sub    $0x8,%esp
+  800048:	50                   	push   %eax
+  800049:	ff 75 10             	pushl  0x10(%ebp)
+  80004c:	e8 5f 02 00 00       	call   8002b0 <vcprintf>
+  800051:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+  800054:	83 ec 0c             	sub    $0xc,%esp
+  800057:	68 9a 0f 80 00       	push   $0x800f9a
+  80005c:	e8 78 02 00 00       	call   8002d9 <cprintf>
+  800061:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+    exit(-E_PANIC);
+  800064:	83 ec 0c             	sub    $0xc,%esp
+  800067:	6a f6                	push   $0xfffffff6
+  800069:	e8 49 01 00 00       	call   8001b7 <exit>
+
+0080006e <__warn>:
+}
+
+void
+__warn(const char *file, int line, const char *fmt, ...) {
+  80006e:	55                   	push   %ebp
+  80006f:	89 e5                	mov    %esp,%ebp
+  800071:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    va_start(ap, fmt);
+  800074:	8d 45 14             	lea    0x14(%ebp),%eax
+  800077:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("user warning at %s:%d:\n    ", file, line);
+  80007a:	83 ec 04             	sub    $0x4,%esp
+  80007d:	ff 75 0c             	pushl  0xc(%ebp)
+  800080:	ff 75 08             	pushl  0x8(%ebp)
+  800083:	68 9c 0f 80 00       	push   $0x800f9c
+  800088:	e8 4c 02 00 00       	call   8002d9 <cprintf>
+  80008d:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+  800090:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800093:	83 ec 08             	sub    $0x8,%esp
+  800096:	50                   	push   %eax
+  800097:	ff 75 10             	pushl  0x10(%ebp)
+  80009a:	e8 11 02 00 00       	call   8002b0 <vcprintf>
+  80009f:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+  8000a2:	83 ec 0c             	sub    $0xc,%esp
+  8000a5:	68 9a 0f 80 00       	push   $0x800f9a
+  8000aa:	e8 2a 02 00 00       	call   8002d9 <cprintf>
+  8000af:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+  8000b2:	90                   	nop
+  8000b3:	c9                   	leave  
+  8000b4:	c3                   	ret    
+
+008000b5 <syscall>:
+#include <syscall.h>
+
+#define MAX_ARGS            5
+
+static inline int
+syscall(int num, ...) {
+  8000b5:	55                   	push   %ebp
+  8000b6:	89 e5                	mov    %esp,%ebp
+  8000b8:	57                   	push   %edi
+  8000b9:	56                   	push   %esi
+  8000ba:	53                   	push   %ebx
+  8000bb:	83 ec 20             	sub    $0x20,%esp
+    va_list ap;
+    va_start(ap, num);
+  8000be:	8d 45 0c             	lea    0xc(%ebp),%eax
+  8000c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    uint32_t a[MAX_ARGS];
+    int i, ret;
+    for (i = 0; i < MAX_ARGS; i ++) {
+  8000c4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  8000cb:	eb 16                	jmp    8000e3 <syscall+0x2e>
+        a[i] = va_arg(ap, uint32_t);
+  8000cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8000d0:	8d 50 04             	lea    0x4(%eax),%edx
+  8000d3:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  8000d6:	8b 10                	mov    (%eax),%edx
+  8000d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8000db:	89 54 85 d4          	mov    %edx,-0x2c(%ebp,%eax,4)
+syscall(int num, ...) {
+    va_list ap;
+    va_start(ap, num);
+    uint32_t a[MAX_ARGS];
+    int i, ret;
+    for (i = 0; i < MAX_ARGS; i ++) {
+  8000df:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+  8000e3:	83 7d f0 04          	cmpl   $0x4,-0x10(%ebp)
+  8000e7:	7e e4                	jle    8000cd <syscall+0x18>
+    asm volatile (
+        "int %1;"
+        : "=a" (ret)
+        : "i" (T_SYSCALL),
+          "a" (num),
+          "d" (a[0]),
+  8000e9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+          "c" (a[1]),
+  8000ec:	8b 4d d8             	mov    -0x28(%ebp),%ecx
+          "b" (a[2]),
+  8000ef:	8b 5d dc             	mov    -0x24(%ebp),%ebx
+          "D" (a[3]),
+  8000f2:	8b 7d e0             	mov    -0x20(%ebp),%edi
+          "S" (a[4])
+  8000f5:	8b 75 e4             	mov    -0x1c(%ebp),%esi
+    for (i = 0; i < MAX_ARGS; i ++) {
+        a[i] = va_arg(ap, uint32_t);
+    }
+    va_end(ap);
+
+    asm volatile (
+  8000f8:	8b 45 08             	mov    0x8(%ebp),%eax
+  8000fb:	cd 80                	int    $0x80
+  8000fd:	89 45 ec             	mov    %eax,-0x14(%ebp)
+          "c" (a[1]),
+          "b" (a[2]),
+          "D" (a[3]),
+          "S" (a[4])
+        : "cc", "memory");
+    return ret;
+  800100:	8b 45 ec             	mov    -0x14(%ebp),%eax
+}
+  800103:	83 c4 20             	add    $0x20,%esp
+  800106:	5b                   	pop    %ebx
+  800107:	5e                   	pop    %esi
+  800108:	5f                   	pop    %edi
+  800109:	5d                   	pop    %ebp
+  80010a:	c3                   	ret    
+
+0080010b <sys_exit>:
+
+int
+sys_exit(int error_code) {
+  80010b:	55                   	push   %ebp
+  80010c:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_exit, error_code);
+  80010e:	ff 75 08             	pushl  0x8(%ebp)
+  800111:	6a 01                	push   $0x1
+  800113:	e8 9d ff ff ff       	call   8000b5 <syscall>
+  800118:	83 c4 08             	add    $0x8,%esp
+}
+  80011b:	c9                   	leave  
+  80011c:	c3                   	ret    
+
+0080011d <sys_fork>:
+
+int
+sys_fork(void) {
+  80011d:	55                   	push   %ebp
+  80011e:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_fork);
+  800120:	6a 02                	push   $0x2
+  800122:	e8 8e ff ff ff       	call   8000b5 <syscall>
+  800127:	83 c4 04             	add    $0x4,%esp
+}
+  80012a:	c9                   	leave  
+  80012b:	c3                   	ret    
+
+0080012c <sys_wait>:
+
+int
+sys_wait(int pid, int *store) {
+  80012c:	55                   	push   %ebp
+  80012d:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_wait, pid, store);
+  80012f:	ff 75 0c             	pushl  0xc(%ebp)
+  800132:	ff 75 08             	pushl  0x8(%ebp)
+  800135:	6a 03                	push   $0x3
+  800137:	e8 79 ff ff ff       	call   8000b5 <syscall>
+  80013c:	83 c4 0c             	add    $0xc,%esp
+}
+  80013f:	c9                   	leave  
+  800140:	c3                   	ret    
+
+00800141 <sys_yield>:
+
+int
+sys_yield(void) {
+  800141:	55                   	push   %ebp
+  800142:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_yield);
+  800144:	6a 0a                	push   $0xa
+  800146:	e8 6a ff ff ff       	call   8000b5 <syscall>
+  80014b:	83 c4 04             	add    $0x4,%esp
+}
+  80014e:	c9                   	leave  
+  80014f:	c3                   	ret    
+
+00800150 <sys_kill>:
+
+int
+sys_kill(int pid) {
+  800150:	55                   	push   %ebp
+  800151:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_kill, pid);
+  800153:	ff 75 08             	pushl  0x8(%ebp)
+  800156:	6a 0c                	push   $0xc
+  800158:	e8 58 ff ff ff       	call   8000b5 <syscall>
+  80015d:	83 c4 08             	add    $0x8,%esp
+}
+  800160:	c9                   	leave  
+  800161:	c3                   	ret    
+
+00800162 <sys_getpid>:
+
+int
+sys_getpid(void) {
+  800162:	55                   	push   %ebp
+  800163:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_getpid);
+  800165:	6a 12                	push   $0x12
+  800167:	e8 49 ff ff ff       	call   8000b5 <syscall>
+  80016c:	83 c4 04             	add    $0x4,%esp
+}
+  80016f:	c9                   	leave  
+  800170:	c3                   	ret    
+
+00800171 <sys_putc>:
+
+int
+sys_putc(int c) {
+  800171:	55                   	push   %ebp
+  800172:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_putc, c);
+  800174:	ff 75 08             	pushl  0x8(%ebp)
+  800177:	6a 1e                	push   $0x1e
+  800179:	e8 37 ff ff ff       	call   8000b5 <syscall>
+  80017e:	83 c4 08             	add    $0x8,%esp
+}
+  800181:	c9                   	leave  
+  800182:	c3                   	ret    
+
+00800183 <sys_pgdir>:
+
+int
+sys_pgdir(void) {
+  800183:	55                   	push   %ebp
+  800184:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_pgdir);
+  800186:	6a 1f                	push   $0x1f
+  800188:	e8 28 ff ff ff       	call   8000b5 <syscall>
+  80018d:	83 c4 04             	add    $0x4,%esp
+}
+  800190:	c9                   	leave  
+  800191:	c3                   	ret    
+
+00800192 <sys_gettime>:
+
+int
+sys_gettime(void) {
+  800192:	55                   	push   %ebp
+  800193:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_gettime);
+  800195:	6a 11                	push   $0x11
+  800197:	e8 19 ff ff ff       	call   8000b5 <syscall>
+  80019c:	83 c4 04             	add    $0x4,%esp
+}
+  80019f:	c9                   	leave  
+  8001a0:	c3                   	ret    
+
+008001a1 <sys_lab6_set_priority>:
+
+void
+sys_lab6_set_priority(uint32_t priority)
+{
+  8001a1:	55                   	push   %ebp
+  8001a2:	89 e5                	mov    %esp,%ebp
+    syscall(SYS_lab6_set_priority, priority);
+  8001a4:	ff 75 08             	pushl  0x8(%ebp)
+  8001a7:	68 ff 00 00 00       	push   $0xff
+  8001ac:	e8 04 ff ff ff       	call   8000b5 <syscall>
+  8001b1:	83 c4 08             	add    $0x8,%esp
+}
+  8001b4:	90                   	nop
+  8001b5:	c9                   	leave  
+  8001b6:	c3                   	ret    
+
+008001b7 <exit>:
+#include <syscall.h>
+#include <stdio.h>
+#include <ulib.h>
+
+void
+exit(int error_code) {
+  8001b7:	55                   	push   %ebp
+  8001b8:	89 e5                	mov    %esp,%ebp
+  8001ba:	83 ec 08             	sub    $0x8,%esp
+    sys_exit(error_code);
+  8001bd:	83 ec 0c             	sub    $0xc,%esp
+  8001c0:	ff 75 08             	pushl  0x8(%ebp)
+  8001c3:	e8 43 ff ff ff       	call   80010b <sys_exit>
+  8001c8:	83 c4 10             	add    $0x10,%esp
+    cprintf("BUG: exit failed.\n");
+  8001cb:	83 ec 0c             	sub    $0xc,%esp
+  8001ce:	68 b8 0f 80 00       	push   $0x800fb8
+  8001d3:	e8 01 01 00 00       	call   8002d9 <cprintf>
+  8001d8:	83 c4 10             	add    $0x10,%esp
+    while (1);
+  8001db:	eb fe                	jmp    8001db <exit+0x24>
+
+008001dd <fork>:
+}
+
+int
+fork(void) {
+  8001dd:	55                   	push   %ebp
+  8001de:	89 e5                	mov    %esp,%ebp
+  8001e0:	83 ec 08             	sub    $0x8,%esp
+    return sys_fork();
+  8001e3:	e8 35 ff ff ff       	call   80011d <sys_fork>
+}
+  8001e8:	c9                   	leave  
+  8001e9:	c3                   	ret    
+
+008001ea <wait>:
+
+int
+wait(void) {
+  8001ea:	55                   	push   %ebp
+  8001eb:	89 e5                	mov    %esp,%ebp
+  8001ed:	83 ec 08             	sub    $0x8,%esp
+    return sys_wait(0, NULL);
+  8001f0:	83 ec 08             	sub    $0x8,%esp
+  8001f3:	6a 00                	push   $0x0
+  8001f5:	6a 00                	push   $0x0
+  8001f7:	e8 30 ff ff ff       	call   80012c <sys_wait>
+  8001fc:	83 c4 10             	add    $0x10,%esp
+}
+  8001ff:	c9                   	leave  
+  800200:	c3                   	ret    
+
+00800201 <waitpid>:
+
+int
+waitpid(int pid, int *store) {
+  800201:	55                   	push   %ebp
+  800202:	89 e5                	mov    %esp,%ebp
+  800204:	83 ec 08             	sub    $0x8,%esp
+    return sys_wait(pid, store);
+  800207:	83 ec 08             	sub    $0x8,%esp
+  80020a:	ff 75 0c             	pushl  0xc(%ebp)
+  80020d:	ff 75 08             	pushl  0x8(%ebp)
+  800210:	e8 17 ff ff ff       	call   80012c <sys_wait>
+  800215:	83 c4 10             	add    $0x10,%esp
+}
+  800218:	c9                   	leave  
+  800219:	c3                   	ret    
+
+0080021a <yield>:
+
+void
+yield(void) {
+  80021a:	55                   	push   %ebp
+  80021b:	89 e5                	mov    %esp,%ebp
+  80021d:	83 ec 08             	sub    $0x8,%esp
+    sys_yield();
+  800220:	e8 1c ff ff ff       	call   800141 <sys_yield>
+}
+  800225:	90                   	nop
+  800226:	c9                   	leave  
+  800227:	c3                   	ret    
+
+00800228 <kill>:
+
+int
+kill(int pid) {
+  800228:	55                   	push   %ebp
+  800229:	89 e5                	mov    %esp,%ebp
+  80022b:	83 ec 08             	sub    $0x8,%esp
+    return sys_kill(pid);
+  80022e:	83 ec 0c             	sub    $0xc,%esp
+  800231:	ff 75 08             	pushl  0x8(%ebp)
+  800234:	e8 17 ff ff ff       	call   800150 <sys_kill>
+  800239:	83 c4 10             	add    $0x10,%esp
+}
+  80023c:	c9                   	leave  
+  80023d:	c3                   	ret    
+
+0080023e <getpid>:
+
+int
+getpid(void) {
+  80023e:	55                   	push   %ebp
+  80023f:	89 e5                	mov    %esp,%ebp
+  800241:	83 ec 08             	sub    $0x8,%esp
+    return sys_getpid();
+  800244:	e8 19 ff ff ff       	call   800162 <sys_getpid>
+}
+  800249:	c9                   	leave  
+  80024a:	c3                   	ret    
+
+0080024b <print_pgdir>:
+
+//print_pgdir - print the PDT&PT
+void
+print_pgdir(void) {
+  80024b:	55                   	push   %ebp
+  80024c:	89 e5                	mov    %esp,%ebp
+  80024e:	83 ec 08             	sub    $0x8,%esp
+    sys_pgdir();
+  800251:	e8 2d ff ff ff       	call   800183 <sys_pgdir>
+}
+  800256:	90                   	nop
+  800257:	c9                   	leave  
+  800258:	c3                   	ret    
+
+00800259 <gettime_msec>:
+
+unsigned int
+gettime_msec(void) {
+  800259:	55                   	push   %ebp
+  80025a:	89 e5                	mov    %esp,%ebp
+  80025c:	83 ec 08             	sub    $0x8,%esp
+    return (unsigned int)sys_gettime();
+  80025f:	e8 2e ff ff ff       	call   800192 <sys_gettime>
+}
+  800264:	c9                   	leave  
+  800265:	c3                   	ret    
+
+00800266 <lab6_set_priority>:
+
+void
+lab6_set_priority(uint32_t priority)
+{
+  800266:	55                   	push   %ebp
+  800267:	89 e5                	mov    %esp,%ebp
+  800269:	83 ec 08             	sub    $0x8,%esp
+    sys_lab6_set_priority(priority);
+  80026c:	83 ec 0c             	sub    $0xc,%esp
+  80026f:	ff 75 08             	pushl  0x8(%ebp)
+  800272:	e8 2a ff ff ff       	call   8001a1 <sys_lab6_set_priority>
+  800277:	83 c4 10             	add    $0x10,%esp
+}
+  80027a:	90                   	nop
+  80027b:	c9                   	leave  
+  80027c:	c3                   	ret    
+
+0080027d <_start>:
+.text
+.globl _start
+_start:
+    # set ebp for backtrace
+    movl $0x0, %ebp
+  80027d:	bd 00 00 00 00       	mov    $0x0,%ebp
+
+    # move down the esp register
+    # since it may cause page fault in backtrace
+    subl $0x20, %esp
+  800282:	83 ec 20             	sub    $0x20,%esp
+
+    # call user-program function
+    call umain
+  800285:	e8 c3 00 00 00       	call   80034d <umain>
+1:  jmp 1b
+  80028a:	eb fe                	jmp    80028a <_start+0xd>
+
+0080028c <cputch>:
+/* *
+ * cputch - writes a single character @c to stdout, and it will
+ * increace the value of counter pointed by @cnt.
+ * */
+static void
+cputch(int c, int *cnt) {
+  80028c:	55                   	push   %ebp
+  80028d:	89 e5                	mov    %esp,%ebp
+  80028f:	83 ec 08             	sub    $0x8,%esp
+    sys_putc(c);
+  800292:	83 ec 0c             	sub    $0xc,%esp
+  800295:	ff 75 08             	pushl  0x8(%ebp)
+  800298:	e8 d4 fe ff ff       	call   800171 <sys_putc>
+  80029d:	83 c4 10             	add    $0x10,%esp
+    (*cnt) ++;
+  8002a0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002a3:	8b 00                	mov    (%eax),%eax
+  8002a5:	8d 50 01             	lea    0x1(%eax),%edx
+  8002a8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002ab:	89 10                	mov    %edx,(%eax)
+}
+  8002ad:	90                   	nop
+  8002ae:	c9                   	leave  
+  8002af:	c3                   	ret    
+
+008002b0 <vcprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want cprintf() instead.
+ * */
+int
+vcprintf(const char *fmt, va_list ap) {
+  8002b0:	55                   	push   %ebp
+  8002b1:	89 e5                	mov    %esp,%ebp
+  8002b3:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+  8002b6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    vprintfmt((void*)cputch, &cnt, fmt, ap);
+  8002bd:	ff 75 0c             	pushl  0xc(%ebp)
+  8002c0:	ff 75 08             	pushl  0x8(%ebp)
+  8002c3:	8d 45 f4             	lea    -0xc(%ebp),%eax
+  8002c6:	50                   	push   %eax
+  8002c7:	68 8c 02 80 00       	push   $0x80028c
+  8002cc:	e8 fc 06 00 00       	call   8009cd <vprintfmt>
+  8002d1:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+  8002d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8002d7:	c9                   	leave  
+  8002d8:	c3                   	ret    
+
+008002d9 <cprintf>:
+ *
+ * The return value is the number of characters which would be
+ * written to stdout.
+ * */
+int
+cprintf(const char *fmt, ...) {
+  8002d9:	55                   	push   %ebp
+  8002da:	89 e5                	mov    %esp,%ebp
+  8002dc:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  8002df:	8d 45 0c             	lea    0xc(%ebp),%eax
+  8002e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    int cnt = vcprintf(fmt, ap);
+  8002e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8002e8:	83 ec 08             	sub    $0x8,%esp
+  8002eb:	50                   	push   %eax
+  8002ec:	ff 75 08             	pushl  0x8(%ebp)
+  8002ef:	e8 bc ff ff ff       	call   8002b0 <vcprintf>
+  8002f4:	83 c4 10             	add    $0x10,%esp
+  8002f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+
+    return cnt;
+  8002fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8002fd:	c9                   	leave  
+  8002fe:	c3                   	ret    
+
+008002ff <cputs>:
+/* *
+ * cputs- writes the string pointed by @str to stdout and
+ * appends a newline character.
+ * */
+int
+cputs(const char *str) {
+  8002ff:	55                   	push   %ebp
+  800300:	89 e5                	mov    %esp,%ebp
+  800302:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+  800305:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    char c;
+    while ((c = *str ++) != '\0') {
+  80030c:	eb 14                	jmp    800322 <cputs+0x23>
+        cputch(c, &cnt);
+  80030e:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
+  800312:	83 ec 08             	sub    $0x8,%esp
+  800315:	8d 55 f0             	lea    -0x10(%ebp),%edx
+  800318:	52                   	push   %edx
+  800319:	50                   	push   %eax
+  80031a:	e8 6d ff ff ff       	call   80028c <cputch>
+  80031f:	83 c4 10             	add    $0x10,%esp
+ * */
+int
+cputs(const char *str) {
+    int cnt = 0;
+    char c;
+    while ((c = *str ++) != '\0') {
+  800322:	8b 45 08             	mov    0x8(%ebp),%eax
+  800325:	8d 50 01             	lea    0x1(%eax),%edx
+  800328:	89 55 08             	mov    %edx,0x8(%ebp)
+  80032b:	0f b6 00             	movzbl (%eax),%eax
+  80032e:	88 45 f7             	mov    %al,-0x9(%ebp)
+  800331:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
+  800335:	75 d7                	jne    80030e <cputs+0xf>
+        cputch(c, &cnt);
+    }
+    cputch('\n', &cnt);
+  800337:	83 ec 08             	sub    $0x8,%esp
+  80033a:	8d 45 f0             	lea    -0x10(%ebp),%eax
+  80033d:	50                   	push   %eax
+  80033e:	6a 0a                	push   $0xa
+  800340:	e8 47 ff ff ff       	call   80028c <cputch>
+  800345:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+  800348:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+  80034b:	c9                   	leave  
+  80034c:	c3                   	ret    
+
+0080034d <umain>:
+#include <ulib.h>
+
+int main(void);
+
+void
+umain(void) {
+  80034d:	55                   	push   %ebp
+  80034e:	89 e5                	mov    %esp,%ebp
+  800350:	83 ec 18             	sub    $0x18,%esp
+    int ret = main();
+  800353:	e8 d3 0b 00 00       	call   800f2b <main>
+  800358:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    exit(ret);
+  80035b:	83 ec 0c             	sub    $0xc,%esp
+  80035e:	ff 75 f4             	pushl  -0xc(%ebp)
+  800361:	e8 51 fe ff ff       	call   8001b7 <exit>
+
+00800366 <strlen>:
+ * @s:      the input string
+ *
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+  800366:	55                   	push   %ebp
+  800367:	89 e5                	mov    %esp,%ebp
+  800369:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  80036c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (*s ++ != '\0') {
+  800373:	eb 04                	jmp    800379 <strlen+0x13>
+        cnt ++;
+  800375:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+    size_t cnt = 0;
+    while (*s ++ != '\0') {
+  800379:	8b 45 08             	mov    0x8(%ebp),%eax
+  80037c:	8d 50 01             	lea    0x1(%eax),%edx
+  80037f:	89 55 08             	mov    %edx,0x8(%ebp)
+  800382:	0f b6 00             	movzbl (%eax),%eax
+  800385:	84 c0                	test   %al,%al
+  800387:	75 ec                	jne    800375 <strlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  800389:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  80038c:	c9                   	leave  
+  80038d:	c3                   	ret    
+
+0080038e <strnlen>:
+ * The return value is strlen(s), if that is less than @len, or
+ * @len if there is no '\0' character among the first @len characters
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+  80038e:	55                   	push   %ebp
+  80038f:	89 e5                	mov    %esp,%ebp
+  800391:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  800394:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (cnt < len && *s ++ != '\0') {
+  80039b:	eb 04                	jmp    8003a1 <strnlen+0x13>
+        cnt ++;
+  80039d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+    size_t cnt = 0;
+    while (cnt < len && *s ++ != '\0') {
+  8003a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8003a4:	3b 45 0c             	cmp    0xc(%ebp),%eax
+  8003a7:	73 10                	jae    8003b9 <strnlen+0x2b>
+  8003a9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003ac:	8d 50 01             	lea    0x1(%eax),%edx
+  8003af:	89 55 08             	mov    %edx,0x8(%ebp)
+  8003b2:	0f b6 00             	movzbl (%eax),%eax
+  8003b5:	84 c0                	test   %al,%al
+  8003b7:	75 e4                	jne    80039d <strnlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  8003b9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  8003bc:	c9                   	leave  
+  8003bd:	c3                   	ret    
+
+008003be <strcpy>:
+ * To avoid overflows, the size of array pointed by @dst should be long enough to
+ * contain the same string as @src (including the terminating null character), and
+ * should not overlap in memory with @src.
+ * */
+char *
+strcpy(char *dst, const char *src) {
+  8003be:	55                   	push   %ebp
+  8003bf:	89 e5                	mov    %esp,%ebp
+  8003c1:	57                   	push   %edi
+  8003c2:	56                   	push   %esi
+  8003c3:	83 ec 20             	sub    $0x20,%esp
+  8003c6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  8003cc:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8003cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCPY
+#define __HAVE_ARCH_STRCPY
+static inline char *
+__strcpy(char *dst, const char *src) {
+    int d0, d1, d2;
+    asm volatile (
+  8003d2:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  8003d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8003d8:	89 d1                	mov    %edx,%ecx
+  8003da:	89 c2                	mov    %eax,%edx
+  8003dc:	89 ce                	mov    %ecx,%esi
+  8003de:	89 d7                	mov    %edx,%edi
+  8003e0:	ac                   	lods   %ds:(%esi),%al
+  8003e1:	aa                   	stos   %al,%es:(%edi)
+  8003e2:	84 c0                	test   %al,%al
+  8003e4:	75 fa                	jne    8003e0 <strcpy+0x22>
+  8003e6:	89 fa                	mov    %edi,%edx
+  8003e8:	89 f1                	mov    %esi,%ecx
+  8003ea:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  8003ed:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  8003f0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+        "stosb;"
+        "testb %%al, %%al;"
+        "jne 1b;"
+        : "=&S" (d0), "=&D" (d1), "=&a" (d2)
+        : "0" (src), "1" (dst) : "memory");
+    return dst;
+  8003f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCPY
+    return __strcpy(dst, src);
+  8003f6:	90                   	nop
+    char *p = dst;
+    while ((*p ++ = *src ++) != '\0')
+        /* nothing */;
+    return dst;
+#endif /* __HAVE_ARCH_STRCPY */
+}
+  8003f7:	83 c4 20             	add    $0x20,%esp
+  8003fa:	5e                   	pop    %esi
+  8003fb:	5f                   	pop    %edi
+  8003fc:	5d                   	pop    %ebp
+  8003fd:	c3                   	ret    
+
+008003fe <strncpy>:
+ * @len:    maximum number of characters to be copied from @src
+ *
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+  8003fe:	55                   	push   %ebp
+  8003ff:	89 e5                	mov    %esp,%ebp
+  800401:	83 ec 10             	sub    $0x10,%esp
+    char *p = dst;
+  800404:	8b 45 08             	mov    0x8(%ebp),%eax
+  800407:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    while (len > 0) {
+  80040a:	eb 21                	jmp    80042d <strncpy+0x2f>
+        if ((*p = *src) != '\0') {
+  80040c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80040f:	0f b6 10             	movzbl (%eax),%edx
+  800412:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800415:	88 10                	mov    %dl,(%eax)
+  800417:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  80041a:	0f b6 00             	movzbl (%eax),%eax
+  80041d:	84 c0                	test   %al,%al
+  80041f:	74 04                	je     800425 <strncpy+0x27>
+            src ++;
+  800421:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+        }
+        p ++, len --;
+  800425:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800429:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+    char *p = dst;
+    while (len > 0) {
+  80042d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800431:	75 d9                	jne    80040c <strncpy+0xe>
+        if ((*p = *src) != '\0') {
+            src ++;
+        }
+        p ++, len --;
+    }
+    return dst;
+  800433:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800436:	c9                   	leave  
+  800437:	c3                   	ret    
+
+00800438 <strcmp>:
+ * - A value greater than zero indicates that the first character that does
+ *   not match has a greater value in @s1 than in @s2;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+strcmp(const char *s1, const char *s2) {
+  800438:	55                   	push   %ebp
+  800439:	89 e5                	mov    %esp,%ebp
+  80043b:	57                   	push   %edi
+  80043c:	56                   	push   %esi
+  80043d:	83 ec 20             	sub    $0x20,%esp
+  800440:	8b 45 08             	mov    0x8(%ebp),%eax
+  800443:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800446:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800449:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCMP
+#define __HAVE_ARCH_STRCMP
+static inline int
+__strcmp(const char *s1, const char *s2) {
+    int d0, d1, ret;
+    asm volatile (
+  80044c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80044f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800452:	89 d1                	mov    %edx,%ecx
+  800454:	89 c2                	mov    %eax,%edx
+  800456:	89 ce                	mov    %ecx,%esi
+  800458:	89 d7                	mov    %edx,%edi
+  80045a:	ac                   	lods   %ds:(%esi),%al
+  80045b:	ae                   	scas   %es:(%edi),%al
+  80045c:	75 08                	jne    800466 <strcmp+0x2e>
+  80045e:	84 c0                	test   %al,%al
+  800460:	75 f8                	jne    80045a <strcmp+0x22>
+  800462:	31 c0                	xor    %eax,%eax
+  800464:	eb 04                	jmp    80046a <strcmp+0x32>
+  800466:	19 c0                	sbb    %eax,%eax
+  800468:	0c 01                	or     $0x1,%al
+  80046a:	89 fa                	mov    %edi,%edx
+  80046c:	89 f1                	mov    %esi,%ecx
+  80046e:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800471:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  800474:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+        "orb $1, %%al;"
+        "3:"
+        : "=a" (ret), "=&S" (d0), "=&D" (d1)
+        : "1" (s1), "2" (s2)
+        : "memory");
+    return ret;
+  800477:	8b 45 ec             	mov    -0x14(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCMP
+    return __strcmp(s1, s2);
+  80047a:	90                   	nop
+    while (*s1 != '\0' && *s1 == *s2) {
+        s1 ++, s2 ++;
+    }
+    return (int)((unsigned char)*s1 - (unsigned char)*s2);
+#endif /* __HAVE_ARCH_STRCMP */
+}
+  80047b:	83 c4 20             	add    $0x20,%esp
+  80047e:	5e                   	pop    %esi
+  80047f:	5f                   	pop    %edi
+  800480:	5d                   	pop    %ebp
+  800481:	c3                   	ret    
+
+00800482 <strncmp>:
+ * they are equal to each other, it continues with the following pairs until
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+  800482:	55                   	push   %ebp
+  800483:	89 e5                	mov    %esp,%ebp
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  800485:	eb 0c                	jmp    800493 <strncmp+0x11>
+        n --, s1 ++, s2 ++;
+  800487:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  80048b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  80048f:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  800493:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800497:	74 1a                	je     8004b3 <strncmp+0x31>
+  800499:	8b 45 08             	mov    0x8(%ebp),%eax
+  80049c:	0f b6 00             	movzbl (%eax),%eax
+  80049f:	84 c0                	test   %al,%al
+  8004a1:	74 10                	je     8004b3 <strncmp+0x31>
+  8004a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004a6:	0f b6 10             	movzbl (%eax),%edx
+  8004a9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004ac:	0f b6 00             	movzbl (%eax),%eax
+  8004af:	38 c2                	cmp    %al,%dl
+  8004b1:	74 d4                	je     800487 <strncmp+0x5>
+        n --, s1 ++, s2 ++;
+    }
+    return (n == 0) ? 0 : (int)((unsigned char)*s1 - (unsigned char)*s2);
+  8004b3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8004b7:	74 18                	je     8004d1 <strncmp+0x4f>
+  8004b9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004bc:	0f b6 00             	movzbl (%eax),%eax
+  8004bf:	0f b6 d0             	movzbl %al,%edx
+  8004c2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004c5:	0f b6 00             	movzbl (%eax),%eax
+  8004c8:	0f b6 c0             	movzbl %al,%eax
+  8004cb:	29 c2                	sub    %eax,%edx
+  8004cd:	89 d0                	mov    %edx,%eax
+  8004cf:	eb 05                	jmp    8004d6 <strncmp+0x54>
+  8004d1:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  8004d6:	5d                   	pop    %ebp
+  8004d7:	c3                   	ret    
+
+008004d8 <strchr>:
+ *
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+  8004d8:	55                   	push   %ebp
+  8004d9:	89 e5                	mov    %esp,%ebp
+  8004db:	83 ec 04             	sub    $0x4,%esp
+  8004de:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004e1:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  8004e4:	eb 14                	jmp    8004fa <strchr+0x22>
+        if (*s == c) {
+  8004e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004e9:	0f b6 00             	movzbl (%eax),%eax
+  8004ec:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  8004ef:	75 05                	jne    8004f6 <strchr+0x1e>
+            return (char *)s;
+  8004f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004f4:	eb 13                	jmp    800509 <strchr+0x31>
+        }
+        s ++;
+  8004f6:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+    while (*s != '\0') {
+  8004fa:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004fd:	0f b6 00             	movzbl (%eax),%eax
+  800500:	84 c0                	test   %al,%al
+  800502:	75 e2                	jne    8004e6 <strchr+0xe>
+        if (*s == c) {
+            return (char *)s;
+        }
+        s ++;
+    }
+    return NULL;
+  800504:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800509:	c9                   	leave  
+  80050a:	c3                   	ret    
+
+0080050b <strfind>:
+ * The strfind() function is like strchr() except that if @c is
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+  80050b:	55                   	push   %ebp
+  80050c:	89 e5                	mov    %esp,%ebp
+  80050e:	83 ec 04             	sub    $0x4,%esp
+  800511:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800514:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  800517:	eb 0f                	jmp    800528 <strfind+0x1d>
+        if (*s == c) {
+  800519:	8b 45 08             	mov    0x8(%ebp),%eax
+  80051c:	0f b6 00             	movzbl (%eax),%eax
+  80051f:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800522:	74 10                	je     800534 <strfind+0x29>
+            break;
+        }
+        s ++;
+  800524:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+    while (*s != '\0') {
+  800528:	8b 45 08             	mov    0x8(%ebp),%eax
+  80052b:	0f b6 00             	movzbl (%eax),%eax
+  80052e:	84 c0                	test   %al,%al
+  800530:	75 e7                	jne    800519 <strfind+0xe>
+  800532:	eb 01                	jmp    800535 <strfind+0x2a>
+        if (*s == c) {
+            break;
+  800534:	90                   	nop
+        }
+        s ++;
+    }
+    return (char *)s;
+  800535:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800538:	c9                   	leave  
+  800539:	c3                   	ret    
+
+0080053a <strtol>:
+ * an optional "0x" or "0X" prefix.
+ *
+ * The strtol() function returns the converted integral number as a long int value.
+ * */
+long
+strtol(const char *s, char **endptr, int base) {
+  80053a:	55                   	push   %ebp
+  80053b:	89 e5                	mov    %esp,%ebp
+  80053d:	83 ec 10             	sub    $0x10,%esp
+    int neg = 0;
+  800540:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    long val = 0;
+  800547:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  80054e:	eb 04                	jmp    800554 <strtol+0x1a>
+        s ++;
+  800550:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+strtol(const char *s, char **endptr, int base) {
+    int neg = 0;
+    long val = 0;
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  800554:	8b 45 08             	mov    0x8(%ebp),%eax
+  800557:	0f b6 00             	movzbl (%eax),%eax
+  80055a:	3c 20                	cmp    $0x20,%al
+  80055c:	74 f2                	je     800550 <strtol+0x16>
+  80055e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800561:	0f b6 00             	movzbl (%eax),%eax
+  800564:	3c 09                	cmp    $0x9,%al
+  800566:	74 e8                	je     800550 <strtol+0x16>
+        s ++;
+    }
+
+    // plus/minus sign
+    if (*s == '+') {
+  800568:	8b 45 08             	mov    0x8(%ebp),%eax
+  80056b:	0f b6 00             	movzbl (%eax),%eax
+  80056e:	3c 2b                	cmp    $0x2b,%al
+  800570:	75 06                	jne    800578 <strtol+0x3e>
+        s ++;
+  800572:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800576:	eb 15                	jmp    80058d <strtol+0x53>
+    }
+    else if (*s == '-') {
+  800578:	8b 45 08             	mov    0x8(%ebp),%eax
+  80057b:	0f b6 00             	movzbl (%eax),%eax
+  80057e:	3c 2d                	cmp    $0x2d,%al
+  800580:	75 0b                	jne    80058d <strtol+0x53>
+        s ++, neg = 1;
+  800582:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800586:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+    }
+
+    // hex or octal base prefix
+    if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x')) {
+  80058d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800591:	74 06                	je     800599 <strtol+0x5f>
+  800593:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+  800597:	75 24                	jne    8005bd <strtol+0x83>
+  800599:	8b 45 08             	mov    0x8(%ebp),%eax
+  80059c:	0f b6 00             	movzbl (%eax),%eax
+  80059f:	3c 30                	cmp    $0x30,%al
+  8005a1:	75 1a                	jne    8005bd <strtol+0x83>
+  8005a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005a6:	83 c0 01             	add    $0x1,%eax
+  8005a9:	0f b6 00             	movzbl (%eax),%eax
+  8005ac:	3c 78                	cmp    $0x78,%al
+  8005ae:	75 0d                	jne    8005bd <strtol+0x83>
+        s += 2, base = 16;
+  8005b0:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+  8005b4:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+  8005bb:	eb 2a                	jmp    8005e7 <strtol+0xad>
+    }
+    else if (base == 0 && s[0] == '0') {
+  8005bd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8005c1:	75 17                	jne    8005da <strtol+0xa0>
+  8005c3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005c6:	0f b6 00             	movzbl (%eax),%eax
+  8005c9:	3c 30                	cmp    $0x30,%al
+  8005cb:	75 0d                	jne    8005da <strtol+0xa0>
+        s ++, base = 8;
+  8005cd:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  8005d1:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+  8005d8:	eb 0d                	jmp    8005e7 <strtol+0xad>
+    }
+    else if (base == 0) {
+  8005da:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8005de:	75 07                	jne    8005e7 <strtol+0xad>
+        base = 10;
+  8005e0:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+    // digits
+    while (1) {
+        int dig;
+
+        if (*s >= '0' && *s <= '9') {
+  8005e7:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005ea:	0f b6 00             	movzbl (%eax),%eax
+  8005ed:	3c 2f                	cmp    $0x2f,%al
+  8005ef:	7e 1b                	jle    80060c <strtol+0xd2>
+  8005f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005f4:	0f b6 00             	movzbl (%eax),%eax
+  8005f7:	3c 39                	cmp    $0x39,%al
+  8005f9:	7f 11                	jg     80060c <strtol+0xd2>
+            dig = *s - '0';
+  8005fb:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005fe:	0f b6 00             	movzbl (%eax),%eax
+  800601:	0f be c0             	movsbl %al,%eax
+  800604:	83 e8 30             	sub    $0x30,%eax
+  800607:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80060a:	eb 48                	jmp    800654 <strtol+0x11a>
+        }
+        else if (*s >= 'a' && *s <= 'z') {
+  80060c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80060f:	0f b6 00             	movzbl (%eax),%eax
+  800612:	3c 60                	cmp    $0x60,%al
+  800614:	7e 1b                	jle    800631 <strtol+0xf7>
+  800616:	8b 45 08             	mov    0x8(%ebp),%eax
+  800619:	0f b6 00             	movzbl (%eax),%eax
+  80061c:	3c 7a                	cmp    $0x7a,%al
+  80061e:	7f 11                	jg     800631 <strtol+0xf7>
+            dig = *s - 'a' + 10;
+  800620:	8b 45 08             	mov    0x8(%ebp),%eax
+  800623:	0f b6 00             	movzbl (%eax),%eax
+  800626:	0f be c0             	movsbl %al,%eax
+  800629:	83 e8 57             	sub    $0x57,%eax
+  80062c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80062f:	eb 23                	jmp    800654 <strtol+0x11a>
+        }
+        else if (*s >= 'A' && *s <= 'Z') {
+  800631:	8b 45 08             	mov    0x8(%ebp),%eax
+  800634:	0f b6 00             	movzbl (%eax),%eax
+  800637:	3c 40                	cmp    $0x40,%al
+  800639:	7e 3c                	jle    800677 <strtol+0x13d>
+  80063b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80063e:	0f b6 00             	movzbl (%eax),%eax
+  800641:	3c 5a                	cmp    $0x5a,%al
+  800643:	7f 32                	jg     800677 <strtol+0x13d>
+            dig = *s - 'A' + 10;
+  800645:	8b 45 08             	mov    0x8(%ebp),%eax
+  800648:	0f b6 00             	movzbl (%eax),%eax
+  80064b:	0f be c0             	movsbl %al,%eax
+  80064e:	83 e8 37             	sub    $0x37,%eax
+  800651:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+  800654:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800657:	3b 45 10             	cmp    0x10(%ebp),%eax
+  80065a:	7d 1a                	jge    800676 <strtol+0x13c>
+            break;
+        }
+        s ++, val = (val * base) + dig;
+  80065c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800660:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800663:	0f af 45 10          	imul   0x10(%ebp),%eax
+  800667:	89 c2                	mov    %eax,%edx
+  800669:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  80066c:	01 d0                	add    %edx,%eax
+  80066e:	89 45 f8             	mov    %eax,-0x8(%ebp)
+        // we don't properly detect overflow!
+    }
+  800671:	e9 71 ff ff ff       	jmp    8005e7 <strtol+0xad>
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+            break;
+  800676:	90                   	nop
+        }
+        s ++, val = (val * base) + dig;
+        // we don't properly detect overflow!
+    }
+
+    if (endptr) {
+  800677:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  80067b:	74 08                	je     800685 <strtol+0x14b>
+        *endptr = (char *) s;
+  80067d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800680:	8b 55 08             	mov    0x8(%ebp),%edx
+  800683:	89 10                	mov    %edx,(%eax)
+    }
+    return (neg ? -val : val);
+  800685:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+  800689:	74 07                	je     800692 <strtol+0x158>
+  80068b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  80068e:	f7 d8                	neg    %eax
+  800690:	eb 03                	jmp    800695 <strtol+0x15b>
+  800692:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  800695:	c9                   	leave  
+  800696:	c3                   	ret    
+
+00800697 <memset>:
+ * @n:      number of bytes to be set to the value
+ *
+ * The memset() function returns @s.
+ * */
+void *
+memset(void *s, char c, size_t n) {
+  800697:	55                   	push   %ebp
+  800698:	89 e5                	mov    %esp,%ebp
+  80069a:	57                   	push   %edi
+  80069b:	83 ec 24             	sub    $0x24,%esp
+  80069e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006a1:	88 45 d8             	mov    %al,-0x28(%ebp)
+#ifdef __HAVE_ARCH_MEMSET
+    return __memset(s, c, n);
+  8006a4:	0f be 45 d8          	movsbl -0x28(%ebp),%eax
+  8006a8:	8b 55 08             	mov    0x8(%ebp),%edx
+  8006ab:	89 55 f8             	mov    %edx,-0x8(%ebp)
+  8006ae:	88 45 f7             	mov    %al,-0x9(%ebp)
+  8006b1:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_MEMSET
+#define __HAVE_ARCH_MEMSET
+static inline void *
+__memset(void *s, char c, size_t n) {
+    int d0, d1;
+    asm volatile (
+  8006b7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+  8006ba:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
+  8006be:	8b 55 f8             	mov    -0x8(%ebp),%edx
+  8006c1:	89 d7                	mov    %edx,%edi
+  8006c3:	f3 aa                	rep stos %al,%es:(%edi)
+  8006c5:	89 fa                	mov    %edi,%edx
+  8006c7:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  8006ca:	89 55 e8             	mov    %edx,-0x18(%ebp)
+        "rep; stosb;"
+        : "=&c" (d0), "=&D" (d1)
+        : "0" (n), "a" (c), "1" (s)
+        : "memory");
+    return s;
+  8006cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8006d0:	90                   	nop
+    while (n -- > 0) {
+        *p ++ = c;
+    }
+    return s;
+#endif /* __HAVE_ARCH_MEMSET */
+}
+  8006d1:	83 c4 24             	add    $0x24,%esp
+  8006d4:	5f                   	pop    %edi
+  8006d5:	5d                   	pop    %ebp
+  8006d6:	c3                   	ret    
+
+008006d7 <memmove>:
+ * @n:      number of bytes to copy
+ *
+ * The memmove() function returns @dst.
+ * */
+void *
+memmove(void *dst, const void *src, size_t n) {
+  8006d7:	55                   	push   %ebp
+  8006d8:	89 e5                	mov    %esp,%ebp
+  8006da:	57                   	push   %edi
+  8006db:	56                   	push   %esi
+  8006dc:	53                   	push   %ebx
+  8006dd:	83 ec 30             	sub    $0x30,%esp
+  8006e0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8006e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8006e6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  8006ec:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006ef:	89 45 e8             	mov    %eax,-0x18(%ebp)
+
+#ifndef __HAVE_ARCH_MEMMOVE
+#define __HAVE_ARCH_MEMMOVE
+static inline void *
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+  8006f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006f5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  8006f8:	73 42                	jae    80073c <memmove+0x65>
+  8006fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006fd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800700:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800703:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800706:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800709:	89 45 dc             	mov    %eax,-0x24(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  80070c:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  80070f:	c1 e8 02             	shr    $0x2,%eax
+  800712:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  800714:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800717:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80071a:	89 d7                	mov    %edx,%edi
+  80071c:	89 c6                	mov    %eax,%esi
+  80071e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800720:	8b 4d dc             	mov    -0x24(%ebp),%ecx
+  800723:	83 e1 03             	and    $0x3,%ecx
+  800726:	74 02                	je     80072a <memmove+0x53>
+  800728:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  80072a:	89 f0                	mov    %esi,%eax
+  80072c:	89 fa                	mov    %edi,%edx
+  80072e:	89 4d d8             	mov    %ecx,-0x28(%ebp)
+  800731:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  800734:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  800737:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMMOVE
+    return __memmove(dst, src, n);
+  80073a:	eb 36                	jmp    800772 <memmove+0x9b>
+    asm volatile (
+        "std;"
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+  80073c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80073f:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800742:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800745:	01 c2                	add    %eax,%edx
+  800747:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80074a:	8d 48 ff             	lea    -0x1(%eax),%ecx
+  80074d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800750:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+        return __memcpy(dst, src, n);
+    }
+    int d0, d1, d2;
+    asm volatile (
+  800753:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800756:	89 c1                	mov    %eax,%ecx
+  800758:	89 d8                	mov    %ebx,%eax
+  80075a:	89 d6                	mov    %edx,%esi
+  80075c:	89 c7                	mov    %eax,%edi
+  80075e:	fd                   	std    
+  80075f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  800761:	fc                   	cld    
+  800762:	89 f8                	mov    %edi,%eax
+  800764:	89 f2                	mov    %esi,%edx
+  800766:	89 4d cc             	mov    %ecx,-0x34(%ebp)
+  800769:	89 55 c8             	mov    %edx,-0x38(%ebp)
+  80076c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+        : "memory");
+    return dst;
+  80076f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+            *d ++ = *s ++;
+        }
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMMOVE */
+}
+  800772:	83 c4 30             	add    $0x30,%esp
+  800775:	5b                   	pop    %ebx
+  800776:	5e                   	pop    %esi
+  800777:	5f                   	pop    %edi
+  800778:	5d                   	pop    %ebp
+  800779:	c3                   	ret    
+
+0080077a <memcpy>:
+ * it always copies exactly @n bytes. To avoid overflows, the size of arrays pointed
+ * by both @src and @dst, should be at least @n bytes, and should not overlap
+ * (for overlapping memory area, memmove is a safer approach).
+ * */
+void *
+memcpy(void *dst, const void *src, size_t n) {
+  80077a:	55                   	push   %ebp
+  80077b:	89 e5                	mov    %esp,%ebp
+  80077d:	57                   	push   %edi
+  80077e:	56                   	push   %esi
+  80077f:	83 ec 20             	sub    $0x20,%esp
+  800782:	8b 45 08             	mov    0x8(%ebp),%eax
+  800785:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800788:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80078b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80078e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800791:	89 45 ec             	mov    %eax,-0x14(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  800794:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800797:	c1 e8 02             	shr    $0x2,%eax
+  80079a:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  80079c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80079f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8007a2:	89 d7                	mov    %edx,%edi
+  8007a4:	89 c6                	mov    %eax,%esi
+  8007a6:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  8007a8:	8b 4d ec             	mov    -0x14(%ebp),%ecx
+  8007ab:	83 e1 03             	and    $0x3,%ecx
+  8007ae:	74 02                	je     8007b2 <memcpy+0x38>
+  8007b0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  8007b2:	89 f0                	mov    %esi,%eax
+  8007b4:	89 fa                	mov    %edi,%edx
+  8007b6:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  8007b9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  8007bc:	89 45 e0             	mov    %eax,-0x20(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  8007bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMCPY
+    return __memcpy(dst, src, n);
+  8007c2:	90                   	nop
+    while (n -- > 0) {
+        *d ++ = *s ++;
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMCPY */
+}
+  8007c3:	83 c4 20             	add    $0x20,%esp
+  8007c6:	5e                   	pop    %esi
+  8007c7:	5f                   	pop    %edi
+  8007c8:	5d                   	pop    %ebp
+  8007c9:	c3                   	ret    
+
+008007ca <memcmp>:
+ *   match in both memory blocks has a greater value in @v1 than in @v2
+ *   as if evaluated as unsigned char values;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+  8007ca:	55                   	push   %ebp
+  8007cb:	89 e5                	mov    %esp,%ebp
+  8007cd:	83 ec 10             	sub    $0x10,%esp
+    const char *s1 = (const char *)v1;
+  8007d0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8007d3:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    const char *s2 = (const char *)v2;
+  8007d6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8007d9:	89 45 f8             	mov    %eax,-0x8(%ebp)
+    while (n -- > 0) {
+  8007dc:	eb 30                	jmp    80080e <memcmp+0x44>
+        if (*s1 != *s2) {
+  8007de:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8007e1:	0f b6 10             	movzbl (%eax),%edx
+  8007e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8007e7:	0f b6 00             	movzbl (%eax),%eax
+  8007ea:	38 c2                	cmp    %al,%dl
+  8007ec:	74 18                	je     800806 <memcmp+0x3c>
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+  8007ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8007f1:	0f b6 00             	movzbl (%eax),%eax
+  8007f4:	0f b6 d0             	movzbl %al,%edx
+  8007f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8007fa:	0f b6 00             	movzbl (%eax),%eax
+  8007fd:	0f b6 c0             	movzbl %al,%eax
+  800800:	29 c2                	sub    %eax,%edx
+  800802:	89 d0                	mov    %edx,%eax
+  800804:	eb 1a                	jmp    800820 <memcmp+0x56>
+        }
+        s1 ++, s2 ++;
+  800806:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  80080a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+    const char *s1 = (const char *)v1;
+    const char *s2 = (const char *)v2;
+    while (n -- > 0) {
+  80080e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800811:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800814:	89 55 10             	mov    %edx,0x10(%ebp)
+  800817:	85 c0                	test   %eax,%eax
+  800819:	75 c3                	jne    8007de <memcmp+0x14>
+        if (*s1 != *s2) {
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+        }
+        s1 ++, s2 ++;
+    }
+    return 0;
+  80081b:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800820:	c9                   	leave  
+  800821:	c3                   	ret    
+
+00800822 <printnum>:
+ * @width:      maximum number of digits, if the actual width is less than @width, use @padc instead
+ * @padc:       character that padded on the left if the actual width is less than @width
+ * */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+        unsigned long long num, unsigned base, int width, int padc) {
+  800822:	55                   	push   %ebp
+  800823:	89 e5                	mov    %esp,%ebp
+  800825:	83 ec 38             	sub    $0x38,%esp
+  800828:	8b 45 10             	mov    0x10(%ebp),%eax
+  80082b:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  80082e:	8b 45 14             	mov    0x14(%ebp),%eax
+  800831:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+    unsigned long long result = num;
+  800834:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  800837:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  80083a:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  80083d:	89 55 ec             	mov    %edx,-0x14(%ebp)
+    unsigned mod = do_div(result, base);
+  800840:	8b 45 18             	mov    0x18(%ebp),%eax
+  800843:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800846:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800849:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  80084c:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  80084f:	89 55 f0             	mov    %edx,-0x10(%ebp)
+  800852:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800855:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800858:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  80085c:	74 1c                	je     80087a <printnum+0x58>
+  80085e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800861:	ba 00 00 00 00       	mov    $0x0,%edx
+  800866:	f7 75 e4             	divl   -0x1c(%ebp)
+  800869:	89 55 f4             	mov    %edx,-0xc(%ebp)
+  80086c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  80086f:	ba 00 00 00 00       	mov    $0x0,%edx
+  800874:	f7 75 e4             	divl   -0x1c(%ebp)
+  800877:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80087a:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80087d:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800880:	f7 75 e4             	divl   -0x1c(%ebp)
+  800883:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800886:	89 55 dc             	mov    %edx,-0x24(%ebp)
+  800889:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80088c:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  80088f:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800892:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  800895:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  800898:	89 45 d8             	mov    %eax,-0x28(%ebp)
+
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+  80089b:	8b 45 18             	mov    0x18(%ebp),%eax
+  80089e:	ba 00 00 00 00       	mov    $0x0,%edx
+  8008a3:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  8008a6:	77 41                	ja     8008e9 <printnum+0xc7>
+  8008a8:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  8008ab:	72 05                	jb     8008b2 <printnum+0x90>
+  8008ad:	3b 45 d0             	cmp    -0x30(%ebp),%eax
+  8008b0:	77 37                	ja     8008e9 <printnum+0xc7>
+        printnum(putch, putdat, result, base, width - 1, padc);
+  8008b2:	8b 45 1c             	mov    0x1c(%ebp),%eax
+  8008b5:	83 e8 01             	sub    $0x1,%eax
+  8008b8:	83 ec 04             	sub    $0x4,%esp
+  8008bb:	ff 75 20             	pushl  0x20(%ebp)
+  8008be:	50                   	push   %eax
+  8008bf:	ff 75 18             	pushl  0x18(%ebp)
+  8008c2:	ff 75 ec             	pushl  -0x14(%ebp)
+  8008c5:	ff 75 e8             	pushl  -0x18(%ebp)
+  8008c8:	ff 75 0c             	pushl  0xc(%ebp)
+  8008cb:	ff 75 08             	pushl  0x8(%ebp)
+  8008ce:	e8 4f ff ff ff       	call   800822 <printnum>
+  8008d3:	83 c4 20             	add    $0x20,%esp
+  8008d6:	eb 1b                	jmp    8008f3 <printnum+0xd1>
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+            putch(padc, putdat);
+  8008d8:	83 ec 08             	sub    $0x8,%esp
+  8008db:	ff 75 0c             	pushl  0xc(%ebp)
+  8008de:	ff 75 20             	pushl  0x20(%ebp)
+  8008e1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8008e4:	ff d0                	call   *%eax
+  8008e6:	83 c4 10             	add    $0x10,%esp
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+        printnum(putch, putdat, result, base, width - 1, padc);
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+  8008e9:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+  8008ed:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+  8008f1:	7f e5                	jg     8008d8 <printnum+0xb6>
+            putch(padc, putdat);
+    }
+    // then print this (the least significant) digit
+    putch("0123456789abcdef"[mod], putdat);
+  8008f3:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  8008f6:	05 e4 10 80 00       	add    $0x8010e4,%eax
+  8008fb:	0f b6 00             	movzbl (%eax),%eax
+  8008fe:	0f be c0             	movsbl %al,%eax
+  800901:	83 ec 08             	sub    $0x8,%esp
+  800904:	ff 75 0c             	pushl  0xc(%ebp)
+  800907:	50                   	push   %eax
+  800908:	8b 45 08             	mov    0x8(%ebp),%eax
+  80090b:	ff d0                	call   *%eax
+  80090d:	83 c4 10             	add    $0x10,%esp
+}
+  800910:	90                   	nop
+  800911:	c9                   	leave  
+  800912:	c3                   	ret    
+
+00800913 <getuint>:
+ * getuint - get an unsigned int of various possible sizes from a varargs list
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static unsigned long long
+getuint(va_list *ap, int lflag) {
+  800913:	55                   	push   %ebp
+  800914:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  800916:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  80091a:	7e 14                	jle    800930 <getuint+0x1d>
+        return va_arg(*ap, unsigned long long);
+  80091c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80091f:	8b 00                	mov    (%eax),%eax
+  800921:	8d 48 08             	lea    0x8(%eax),%ecx
+  800924:	8b 55 08             	mov    0x8(%ebp),%edx
+  800927:	89 0a                	mov    %ecx,(%edx)
+  800929:	8b 50 04             	mov    0x4(%eax),%edx
+  80092c:	8b 00                	mov    (%eax),%eax
+  80092e:	eb 30                	jmp    800960 <getuint+0x4d>
+    }
+    else if (lflag) {
+  800930:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800934:	74 16                	je     80094c <getuint+0x39>
+        return va_arg(*ap, unsigned long);
+  800936:	8b 45 08             	mov    0x8(%ebp),%eax
+  800939:	8b 00                	mov    (%eax),%eax
+  80093b:	8d 48 04             	lea    0x4(%eax),%ecx
+  80093e:	8b 55 08             	mov    0x8(%ebp),%edx
+  800941:	89 0a                	mov    %ecx,(%edx)
+  800943:	8b 00                	mov    (%eax),%eax
+  800945:	ba 00 00 00 00       	mov    $0x0,%edx
+  80094a:	eb 14                	jmp    800960 <getuint+0x4d>
+    }
+    else {
+        return va_arg(*ap, unsigned int);
+  80094c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80094f:	8b 00                	mov    (%eax),%eax
+  800951:	8d 48 04             	lea    0x4(%eax),%ecx
+  800954:	8b 55 08             	mov    0x8(%ebp),%edx
+  800957:	89 0a                	mov    %ecx,(%edx)
+  800959:	8b 00                	mov    (%eax),%eax
+  80095b:	ba 00 00 00 00       	mov    $0x0,%edx
+    }
+}
+  800960:	5d                   	pop    %ebp
+  800961:	c3                   	ret    
+
+00800962 <getint>:
+ * getint - same as getuint but signed, we can't use getuint because of sign extension
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static long long
+getint(va_list *ap, int lflag) {
+  800962:	55                   	push   %ebp
+  800963:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  800965:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  800969:	7e 14                	jle    80097f <getint+0x1d>
+        return va_arg(*ap, long long);
+  80096b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80096e:	8b 00                	mov    (%eax),%eax
+  800970:	8d 48 08             	lea    0x8(%eax),%ecx
+  800973:	8b 55 08             	mov    0x8(%ebp),%edx
+  800976:	89 0a                	mov    %ecx,(%edx)
+  800978:	8b 50 04             	mov    0x4(%eax),%edx
+  80097b:	8b 00                	mov    (%eax),%eax
+  80097d:	eb 28                	jmp    8009a7 <getint+0x45>
+    }
+    else if (lflag) {
+  80097f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800983:	74 12                	je     800997 <getint+0x35>
+        return va_arg(*ap, long);
+  800985:	8b 45 08             	mov    0x8(%ebp),%eax
+  800988:	8b 00                	mov    (%eax),%eax
+  80098a:	8d 48 04             	lea    0x4(%eax),%ecx
+  80098d:	8b 55 08             	mov    0x8(%ebp),%edx
+  800990:	89 0a                	mov    %ecx,(%edx)
+  800992:	8b 00                	mov    (%eax),%eax
+  800994:	99                   	cltd   
+  800995:	eb 10                	jmp    8009a7 <getint+0x45>
+    }
+    else {
+        return va_arg(*ap, int);
+  800997:	8b 45 08             	mov    0x8(%ebp),%eax
+  80099a:	8b 00                	mov    (%eax),%eax
+  80099c:	8d 48 04             	lea    0x4(%eax),%ecx
+  80099f:	8b 55 08             	mov    0x8(%ebp),%edx
+  8009a2:	89 0a                	mov    %ecx,(%edx)
+  8009a4:	8b 00                	mov    (%eax),%eax
+  8009a6:	99                   	cltd   
+    }
+}
+  8009a7:	5d                   	pop    %ebp
+  8009a8:	c3                   	ret    
+
+008009a9 <printfmt>:
+ * @putch:      specified putch function, print a single character
+ * @putdat:     used by @putch function
+ * @fmt:        the format string to use
+ * */
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...) {
+  8009a9:	55                   	push   %ebp
+  8009aa:	89 e5                	mov    %esp,%ebp
+  8009ac:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  8009af:	8d 45 14             	lea    0x14(%ebp),%eax
+  8009b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    vprintfmt(putch, putdat, fmt, ap);
+  8009b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8009b8:	50                   	push   %eax
+  8009b9:	ff 75 10             	pushl  0x10(%ebp)
+  8009bc:	ff 75 0c             	pushl  0xc(%ebp)
+  8009bf:	ff 75 08             	pushl  0x8(%ebp)
+  8009c2:	e8 06 00 00 00       	call   8009cd <vprintfmt>
+  8009c7:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+  8009ca:	90                   	nop
+  8009cb:	c9                   	leave  
+  8009cc:	c3                   	ret    
+
+008009cd <vprintfmt>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want printfmt() instead.
+ * */
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap) {
+  8009cd:	55                   	push   %ebp
+  8009ce:	89 e5                	mov    %esp,%ebp
+  8009d0:	56                   	push   %esi
+  8009d1:	53                   	push   %ebx
+  8009d2:	83 ec 20             	sub    $0x20,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  8009d5:	eb 17                	jmp    8009ee <vprintfmt+0x21>
+            if (ch == '\0') {
+  8009d7:	85 db                	test   %ebx,%ebx
+  8009d9:	0f 84 8e 03 00 00    	je     800d6d <vprintfmt+0x3a0>
+                return;
+            }
+            putch(ch, putdat);
+  8009df:	83 ec 08             	sub    $0x8,%esp
+  8009e2:	ff 75 0c             	pushl  0xc(%ebp)
+  8009e5:	53                   	push   %ebx
+  8009e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009e9:	ff d0                	call   *%eax
+  8009eb:	83 c4 10             	add    $0x10,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  8009ee:	8b 45 10             	mov    0x10(%ebp),%eax
+  8009f1:	8d 50 01             	lea    0x1(%eax),%edx
+  8009f4:	89 55 10             	mov    %edx,0x10(%ebp)
+  8009f7:	0f b6 00             	movzbl (%eax),%eax
+  8009fa:	0f b6 d8             	movzbl %al,%ebx
+  8009fd:	83 fb 25             	cmp    $0x25,%ebx
+  800a00:	75 d5                	jne    8009d7 <vprintfmt+0xa>
+            }
+            putch(ch, putdat);
+        }
+
+        // Process a %-escape sequence
+        char padc = ' ';
+  800a02:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+        width = precision = -1;
+  800a06:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+  800a0d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800a10:	89 45 e8             	mov    %eax,-0x18(%ebp)
+        lflag = altflag = 0;
+  800a13:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+  800a1a:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  800a1d:	89 45 e0             	mov    %eax,-0x20(%ebp)
+
+    reswitch:
+        switch (ch = *(unsigned char *)fmt ++) {
+  800a20:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a23:	8d 50 01             	lea    0x1(%eax),%edx
+  800a26:	89 55 10             	mov    %edx,0x10(%ebp)
+  800a29:	0f b6 00             	movzbl (%eax),%eax
+  800a2c:	0f b6 d8             	movzbl %al,%ebx
+  800a2f:	8d 43 dd             	lea    -0x23(%ebx),%eax
+  800a32:	83 f8 55             	cmp    $0x55,%eax
+  800a35:	0f 87 05 03 00 00    	ja     800d40 <vprintfmt+0x373>
+  800a3b:	8b 04 85 08 11 80 00 	mov    0x801108(,%eax,4),%eax
+  800a42:	ff e0                	jmp    *%eax
+
+        // flag to pad on the right
+        case '-':
+            padc = '-';
+  800a44:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+            goto reswitch;
+  800a48:	eb d6                	jmp    800a20 <vprintfmt+0x53>
+
+        // flag to pad with 0's instead of spaces
+        case '0':
+            padc = '0';
+  800a4a:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+            goto reswitch;
+  800a4e:	eb d0                	jmp    800a20 <vprintfmt+0x53>
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  800a50:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+                precision = precision * 10 + ch - '0';
+  800a57:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800a5a:	89 d0                	mov    %edx,%eax
+  800a5c:	c1 e0 02             	shl    $0x2,%eax
+  800a5f:	01 d0                	add    %edx,%eax
+  800a61:	01 c0                	add    %eax,%eax
+  800a63:	01 d8                	add    %ebx,%eax
+  800a65:	83 e8 30             	sub    $0x30,%eax
+  800a68:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+                ch = *fmt;
+  800a6b:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a6e:	0f b6 00             	movzbl (%eax),%eax
+  800a71:	0f be d8             	movsbl %al,%ebx
+                if (ch < '0' || ch > '9') {
+  800a74:	83 fb 2f             	cmp    $0x2f,%ebx
+  800a77:	7e 39                	jle    800ab2 <vprintfmt+0xe5>
+  800a79:	83 fb 39             	cmp    $0x39,%ebx
+  800a7c:	7f 34                	jg     800ab2 <vprintfmt+0xe5>
+            padc = '0';
+            goto reswitch;
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  800a7e:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+                precision = precision * 10 + ch - '0';
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+  800a82:	eb d3                	jmp    800a57 <vprintfmt+0x8a>
+            goto process_precision;
+
+        case '*':
+            precision = va_arg(ap, int);
+  800a84:	8b 45 14             	mov    0x14(%ebp),%eax
+  800a87:	8d 50 04             	lea    0x4(%eax),%edx
+  800a8a:	89 55 14             	mov    %edx,0x14(%ebp)
+  800a8d:	8b 00                	mov    (%eax),%eax
+  800a8f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+            goto process_precision;
+  800a92:	eb 1f                	jmp    800ab3 <vprintfmt+0xe6>
+
+        case '.':
+            if (width < 0)
+  800a94:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800a98:	79 86                	jns    800a20 <vprintfmt+0x53>
+                width = 0;
+  800a9a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+            goto reswitch;
+  800aa1:	e9 7a ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        case '#':
+            altflag = 1;
+  800aa6:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+            goto reswitch;
+  800aad:	e9 6e ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+            goto process_precision;
+  800ab2:	90                   	nop
+        case '#':
+            altflag = 1;
+            goto reswitch;
+
+        process_precision:
+            if (width < 0)
+  800ab3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ab7:	0f 89 63 ff ff ff    	jns    800a20 <vprintfmt+0x53>
+                width = precision, precision = -1;
+  800abd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800ac0:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800ac3:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+            goto reswitch;
+  800aca:	e9 51 ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        // long flag (doubled for long long)
+        case 'l':
+            lflag ++;
+  800acf:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
+            goto reswitch;
+  800ad3:	e9 48 ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        // character
+        case 'c':
+            putch(va_arg(ap, int), putdat);
+  800ad8:	8b 45 14             	mov    0x14(%ebp),%eax
+  800adb:	8d 50 04             	lea    0x4(%eax),%edx
+  800ade:	89 55 14             	mov    %edx,0x14(%ebp)
+  800ae1:	8b 00                	mov    (%eax),%eax
+  800ae3:	83 ec 08             	sub    $0x8,%esp
+  800ae6:	ff 75 0c             	pushl  0xc(%ebp)
+  800ae9:	50                   	push   %eax
+  800aea:	8b 45 08             	mov    0x8(%ebp),%eax
+  800aed:	ff d0                	call   *%eax
+  800aef:	83 c4 10             	add    $0x10,%esp
+            break;
+  800af2:	e9 71 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // error message
+        case 'e':
+            err = va_arg(ap, int);
+  800af7:	8b 45 14             	mov    0x14(%ebp),%eax
+  800afa:	8d 50 04             	lea    0x4(%eax),%edx
+  800afd:	89 55 14             	mov    %edx,0x14(%ebp)
+  800b00:	8b 18                	mov    (%eax),%ebx
+            if (err < 0) {
+  800b02:	85 db                	test   %ebx,%ebx
+  800b04:	79 02                	jns    800b08 <vprintfmt+0x13b>
+                err = -err;
+  800b06:	f7 db                	neg    %ebx
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+  800b08:	83 fb 18             	cmp    $0x18,%ebx
+  800b0b:	7f 0b                	jg     800b18 <vprintfmt+0x14b>
+  800b0d:	8b 34 9d 80 10 80 00 	mov    0x801080(,%ebx,4),%esi
+  800b14:	85 f6                	test   %esi,%esi
+  800b16:	75 19                	jne    800b31 <vprintfmt+0x164>
+                printfmt(putch, putdat, "error %d", err);
+  800b18:	53                   	push   %ebx
+  800b19:	68 f5 10 80 00       	push   $0x8010f5
+  800b1e:	ff 75 0c             	pushl  0xc(%ebp)
+  800b21:	ff 75 08             	pushl  0x8(%ebp)
+  800b24:	e8 80 fe ff ff       	call   8009a9 <printfmt>
+  800b29:	83 c4 10             	add    $0x10,%esp
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+            }
+            break;
+  800b2c:	e9 37 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+                printfmt(putch, putdat, "error %d", err);
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+  800b31:	56                   	push   %esi
+  800b32:	68 fe 10 80 00       	push   $0x8010fe
+  800b37:	ff 75 0c             	pushl  0xc(%ebp)
+  800b3a:	ff 75 08             	pushl  0x8(%ebp)
+  800b3d:	e8 67 fe ff ff       	call   8009a9 <printfmt>
+  800b42:	83 c4 10             	add    $0x10,%esp
+            }
+            break;
+  800b45:	e9 1e 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // string
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+  800b4a:	8b 45 14             	mov    0x14(%ebp),%eax
+  800b4d:	8d 50 04             	lea    0x4(%eax),%edx
+  800b50:	89 55 14             	mov    %edx,0x14(%ebp)
+  800b53:	8b 30                	mov    (%eax),%esi
+  800b55:	85 f6                	test   %esi,%esi
+  800b57:	75 05                	jne    800b5e <vprintfmt+0x191>
+                p = "(null)";
+  800b59:	be 01 11 80 00       	mov    $0x801101,%esi
+            }
+            if (width > 0 && padc != '-') {
+  800b5e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800b62:	7e 76                	jle    800bda <vprintfmt+0x20d>
+  800b64:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+  800b68:	74 70                	je     800bda <vprintfmt+0x20d>
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  800b6a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800b6d:	83 ec 08             	sub    $0x8,%esp
+  800b70:	50                   	push   %eax
+  800b71:	56                   	push   %esi
+  800b72:	e8 17 f8 ff ff       	call   80038e <strnlen>
+  800b77:	83 c4 10             	add    $0x10,%esp
+  800b7a:	89 c2                	mov    %eax,%edx
+  800b7c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800b7f:	29 d0                	sub    %edx,%eax
+  800b81:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800b84:	eb 17                	jmp    800b9d <vprintfmt+0x1d0>
+                    putch(padc, putdat);
+  800b86:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+  800b8a:	83 ec 08             	sub    $0x8,%esp
+  800b8d:	ff 75 0c             	pushl  0xc(%ebp)
+  800b90:	50                   	push   %eax
+  800b91:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b94:	ff d0                	call   *%eax
+  800b96:	83 c4 10             	add    $0x10,%esp
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+                p = "(null)";
+            }
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  800b99:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800b9d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ba1:	7f e3                	jg     800b86 <vprintfmt+0x1b9>
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  800ba3:	eb 35                	jmp    800bda <vprintfmt+0x20d>
+                if (altflag && (ch < ' ' || ch > '~')) {
+  800ba5:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+  800ba9:	74 1c                	je     800bc7 <vprintfmt+0x1fa>
+  800bab:	83 fb 1f             	cmp    $0x1f,%ebx
+  800bae:	7e 05                	jle    800bb5 <vprintfmt+0x1e8>
+  800bb0:	83 fb 7e             	cmp    $0x7e,%ebx
+  800bb3:	7e 12                	jle    800bc7 <vprintfmt+0x1fa>
+                    putch('?', putdat);
+  800bb5:	83 ec 08             	sub    $0x8,%esp
+  800bb8:	ff 75 0c             	pushl  0xc(%ebp)
+  800bbb:	6a 3f                	push   $0x3f
+  800bbd:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bc0:	ff d0                	call   *%eax
+  800bc2:	83 c4 10             	add    $0x10,%esp
+  800bc5:	eb 0f                	jmp    800bd6 <vprintfmt+0x209>
+                }
+                else {
+                    putch(ch, putdat);
+  800bc7:	83 ec 08             	sub    $0x8,%esp
+  800bca:	ff 75 0c             	pushl  0xc(%ebp)
+  800bcd:	53                   	push   %ebx
+  800bce:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bd1:	ff d0                	call   *%eax
+  800bd3:	83 c4 10             	add    $0x10,%esp
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  800bd6:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800bda:	89 f0                	mov    %esi,%eax
+  800bdc:	8d 70 01             	lea    0x1(%eax),%esi
+  800bdf:	0f b6 00             	movzbl (%eax),%eax
+  800be2:	0f be d8             	movsbl %al,%ebx
+  800be5:	85 db                	test   %ebx,%ebx
+  800be7:	74 26                	je     800c0f <vprintfmt+0x242>
+  800be9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800bed:	78 b6                	js     800ba5 <vprintfmt+0x1d8>
+  800bef:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800bf3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800bf7:	79 ac                	jns    800ba5 <vprintfmt+0x1d8>
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  800bf9:	eb 14                	jmp    800c0f <vprintfmt+0x242>
+                putch(' ', putdat);
+  800bfb:	83 ec 08             	sub    $0x8,%esp
+  800bfe:	ff 75 0c             	pushl  0xc(%ebp)
+  800c01:	6a 20                	push   $0x20
+  800c03:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c06:	ff d0                	call   *%eax
+  800c08:	83 c4 10             	add    $0x10,%esp
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  800c0b:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800c0f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800c13:	7f e6                	jg     800bfb <vprintfmt+0x22e>
+                putch(' ', putdat);
+            }
+            break;
+  800c15:	e9 4e 01 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // (signed) decimal
+        case 'd':
+            num = getint(&ap, lflag);
+  800c1a:	83 ec 08             	sub    $0x8,%esp
+  800c1d:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c20:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c23:	50                   	push   %eax
+  800c24:	e8 39 fd ff ff       	call   800962 <getint>
+  800c29:	83 c4 10             	add    $0x10,%esp
+  800c2c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c2f:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            if ((long long)num < 0) {
+  800c32:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c35:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800c38:	85 d2                	test   %edx,%edx
+  800c3a:	79 23                	jns    800c5f <vprintfmt+0x292>
+                putch('-', putdat);
+  800c3c:	83 ec 08             	sub    $0x8,%esp
+  800c3f:	ff 75 0c             	pushl  0xc(%ebp)
+  800c42:	6a 2d                	push   $0x2d
+  800c44:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c47:	ff d0                	call   *%eax
+  800c49:	83 c4 10             	add    $0x10,%esp
+                num = -(long long)num;
+  800c4c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c4f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800c52:	f7 d8                	neg    %eax
+  800c54:	83 d2 00             	adc    $0x0,%edx
+  800c57:	f7 da                	neg    %edx
+  800c59:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c5c:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            }
+            base = 10;
+  800c5f:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  800c66:	e9 9f 00 00 00       	jmp    800d0a <vprintfmt+0x33d>
+
+        // unsigned decimal
+        case 'u':
+            num = getuint(&ap, lflag);
+  800c6b:	83 ec 08             	sub    $0x8,%esp
+  800c6e:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c71:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c74:	50                   	push   %eax
+  800c75:	e8 99 fc ff ff       	call   800913 <getuint>
+  800c7a:	83 c4 10             	add    $0x10,%esp
+  800c7d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c80:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 10;
+  800c83:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  800c8a:	eb 7e                	jmp    800d0a <vprintfmt+0x33d>
+
+        // (unsigned) octal
+        case 'o':
+            num = getuint(&ap, lflag);
+  800c8c:	83 ec 08             	sub    $0x8,%esp
+  800c8f:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c92:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c95:	50                   	push   %eax
+  800c96:	e8 78 fc ff ff       	call   800913 <getuint>
+  800c9b:	83 c4 10             	add    $0x10,%esp
+  800c9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800ca1:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 8;
+  800ca4:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+            goto number;
+  800cab:	eb 5d                	jmp    800d0a <vprintfmt+0x33d>
+
+        // pointer
+        case 'p':
+            putch('0', putdat);
+  800cad:	83 ec 08             	sub    $0x8,%esp
+  800cb0:	ff 75 0c             	pushl  0xc(%ebp)
+  800cb3:	6a 30                	push   $0x30
+  800cb5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cb8:	ff d0                	call   *%eax
+  800cba:	83 c4 10             	add    $0x10,%esp
+            putch('x', putdat);
+  800cbd:	83 ec 08             	sub    $0x8,%esp
+  800cc0:	ff 75 0c             	pushl  0xc(%ebp)
+  800cc3:	6a 78                	push   $0x78
+  800cc5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cc8:	ff d0                	call   *%eax
+  800cca:	83 c4 10             	add    $0x10,%esp
+            num = (unsigned long long)(uintptr_t)va_arg(ap, void *);
+  800ccd:	8b 45 14             	mov    0x14(%ebp),%eax
+  800cd0:	8d 50 04             	lea    0x4(%eax),%edx
+  800cd3:	89 55 14             	mov    %edx,0x14(%ebp)
+  800cd6:	8b 00                	mov    (%eax),%eax
+  800cd8:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800cdb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+            base = 16;
+  800ce2:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+            goto number;
+  800ce9:	eb 1f                	jmp    800d0a <vprintfmt+0x33d>
+
+        // (unsigned) hexadecimal
+        case 'x':
+            num = getuint(&ap, lflag);
+  800ceb:	83 ec 08             	sub    $0x8,%esp
+  800cee:	ff 75 e0             	pushl  -0x20(%ebp)
+  800cf1:	8d 45 14             	lea    0x14(%ebp),%eax
+  800cf4:	50                   	push   %eax
+  800cf5:	e8 19 fc ff ff       	call   800913 <getuint>
+  800cfa:	83 c4 10             	add    $0x10,%esp
+  800cfd:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800d00:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 16;
+  800d03:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+        number:
+            printnum(putch, putdat, num, base, width, padc);
+  800d0a:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+  800d0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800d11:	83 ec 04             	sub    $0x4,%esp
+  800d14:	52                   	push   %edx
+  800d15:	ff 75 e8             	pushl  -0x18(%ebp)
+  800d18:	50                   	push   %eax
+  800d19:	ff 75 f4             	pushl  -0xc(%ebp)
+  800d1c:	ff 75 f0             	pushl  -0x10(%ebp)
+  800d1f:	ff 75 0c             	pushl  0xc(%ebp)
+  800d22:	ff 75 08             	pushl  0x8(%ebp)
+  800d25:	e8 f8 fa ff ff       	call   800822 <printnum>
+  800d2a:	83 c4 20             	add    $0x20,%esp
+            break;
+  800d2d:	eb 39                	jmp    800d68 <vprintfmt+0x39b>
+
+        // escaped '%' character
+        case '%':
+            putch(ch, putdat);
+  800d2f:	83 ec 08             	sub    $0x8,%esp
+  800d32:	ff 75 0c             	pushl  0xc(%ebp)
+  800d35:	53                   	push   %ebx
+  800d36:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d39:	ff d0                	call   *%eax
+  800d3b:	83 c4 10             	add    $0x10,%esp
+            break;
+  800d3e:	eb 28                	jmp    800d68 <vprintfmt+0x39b>
+
+        // unrecognized escape sequence - just print it literally
+        default:
+            putch('%', putdat);
+  800d40:	83 ec 08             	sub    $0x8,%esp
+  800d43:	ff 75 0c             	pushl  0xc(%ebp)
+  800d46:	6a 25                	push   $0x25
+  800d48:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d4b:	ff d0                	call   *%eax
+  800d4d:	83 c4 10             	add    $0x10,%esp
+            for (fmt --; fmt[-1] != '%'; fmt --)
+  800d50:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800d54:	eb 04                	jmp    800d5a <vprintfmt+0x38d>
+  800d56:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800d5a:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d5d:	83 e8 01             	sub    $0x1,%eax
+  800d60:	0f b6 00             	movzbl (%eax),%eax
+  800d63:	3c 25                	cmp    $0x25,%al
+  800d65:	75 ef                	jne    800d56 <vprintfmt+0x389>
+                /* do nothing */;
+            break;
+  800d67:	90                   	nop
+        }
+    }
+  800d68:	e9 68 fc ff ff       	jmp    8009d5 <vprintfmt+0x8>
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+            if (ch == '\0') {
+                return;
+  800d6d:	90                   	nop
+            for (fmt --; fmt[-1] != '%'; fmt --)
+                /* do nothing */;
+            break;
+        }
+    }
+}
+  800d6e:	8d 65 f8             	lea    -0x8(%ebp),%esp
+  800d71:	5b                   	pop    %ebx
+  800d72:	5e                   	pop    %esi
+  800d73:	5d                   	pop    %ebp
+  800d74:	c3                   	ret    
+
+00800d75 <sprintputch>:
+ * sprintputch - 'print' a single character in a buffer
+ * @ch:         the character will be printed
+ * @b:          the buffer to place the character @ch
+ * */
+static void
+sprintputch(int ch, struct sprintbuf *b) {
+  800d75:	55                   	push   %ebp
+  800d76:	89 e5                	mov    %esp,%ebp
+    b->cnt ++;
+  800d78:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d7b:	8b 40 08             	mov    0x8(%eax),%eax
+  800d7e:	8d 50 01             	lea    0x1(%eax),%edx
+  800d81:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d84:	89 50 08             	mov    %edx,0x8(%eax)
+    if (b->buf < b->ebuf) {
+  800d87:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8a:	8b 10                	mov    (%eax),%edx
+  800d8c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8f:	8b 40 04             	mov    0x4(%eax),%eax
+  800d92:	39 c2                	cmp    %eax,%edx
+  800d94:	73 12                	jae    800da8 <sprintputch+0x33>
+        *b->buf ++ = ch;
+  800d96:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d99:	8b 00                	mov    (%eax),%eax
+  800d9b:	8d 48 01             	lea    0x1(%eax),%ecx
+  800d9e:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800da1:	89 0a                	mov    %ecx,(%edx)
+  800da3:	8b 55 08             	mov    0x8(%ebp),%edx
+  800da6:	88 10                	mov    %dl,(%eax)
+    }
+}
+  800da8:	90                   	nop
+  800da9:	5d                   	pop    %ebp
+  800daa:	c3                   	ret    
+
+00800dab <snprintf>:
+ * @str:        the buffer to place the result into
+ * @size:       the size of buffer, including the trailing null space
+ * @fmt:        the format string to use
+ * */
+int
+snprintf(char *str, size_t size, const char *fmt, ...) {
+  800dab:	55                   	push   %ebp
+  800dac:	89 e5                	mov    %esp,%ebp
+  800dae:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    int cnt;
+    va_start(ap, fmt);
+  800db1:	8d 45 14             	lea    0x14(%ebp),%eax
+  800db4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    cnt = vsnprintf(str, size, fmt, ap);
+  800db7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800dba:	50                   	push   %eax
+  800dbb:	ff 75 10             	pushl  0x10(%ebp)
+  800dbe:	ff 75 0c             	pushl  0xc(%ebp)
+  800dc1:	ff 75 08             	pushl  0x8(%ebp)
+  800dc4:	e8 0b 00 00 00       	call   800dd4 <vsnprintf>
+  800dc9:	83 c4 10             	add    $0x10,%esp
+  800dcc:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+    return cnt;
+  800dcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800dd2:	c9                   	leave  
+  800dd3:	c3                   	ret    
+
+00800dd4 <vsnprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want snprintf() instead.
+ * */
+int
+vsnprintf(char *str, size_t size, const char *fmt, va_list ap) {
+  800dd4:	55                   	push   %ebp
+  800dd5:	89 e5                	mov    %esp,%ebp
+  800dd7:	83 ec 18             	sub    $0x18,%esp
+    struct sprintbuf b = {str, str + size - 1, 0};
+  800dda:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ddd:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800de0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800de3:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800de6:	8b 45 08             	mov    0x8(%ebp),%eax
+  800de9:	01 d0                	add    %edx,%eax
+  800deb:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800dee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    if (str == NULL || b.buf > b.ebuf) {
+  800df5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  800df9:	74 0a                	je     800e05 <vsnprintf+0x31>
+  800dfb:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  800dfe:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800e01:	39 c2                	cmp    %eax,%edx
+  800e03:	76 07                	jbe    800e0c <vsnprintf+0x38>
+        return -E_INVAL;
+  800e05:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+  800e0a:	eb 20                	jmp    800e2c <vsnprintf+0x58>
+    }
+    // print the string to the buffer
+    vprintfmt((void*)sprintputch, &b, fmt, ap);
+  800e0c:	ff 75 14             	pushl  0x14(%ebp)
+  800e0f:	ff 75 10             	pushl  0x10(%ebp)
+  800e12:	8d 45 ec             	lea    -0x14(%ebp),%eax
+  800e15:	50                   	push   %eax
+  800e16:	68 75 0d 80 00       	push   $0x800d75
+  800e1b:	e8 ad fb ff ff       	call   8009cd <vprintfmt>
+  800e20:	83 c4 10             	add    $0x10,%esp
+    // null terminate the buffer
+    *b.buf = '\0';
+  800e23:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e26:	c6 00 00             	movb   $0x0,(%eax)
+    return b.cnt;
+  800e29:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800e2c:	c9                   	leave  
+  800e2d:	c3                   	ret    
+
+00800e2e <hash32>:
+ * @bits:   the number of bits in a return value
+ *
+ * High bits are more random, so we use them.
+ * */
+uint32_t
+hash32(uint32_t val, unsigned int bits) {
+  800e2e:	55                   	push   %ebp
+  800e2f:	89 e5                	mov    %esp,%ebp
+  800e31:	83 ec 10             	sub    $0x10,%esp
+    uint32_t hash = val * GOLDEN_RATIO_PRIME_32;
+  800e34:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e37:	69 c0 01 00 37 9e    	imul   $0x9e370001,%eax,%eax
+  800e3d:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    return (hash >> (32 - bits));
+  800e40:	b8 20 00 00 00       	mov    $0x20,%eax
+  800e45:	2b 45 0c             	sub    0xc(%ebp),%eax
+  800e48:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  800e4b:	89 c1                	mov    %eax,%ecx
+  800e4d:	d3 ea                	shr    %cl,%edx
+  800e4f:	89 d0                	mov    %edx,%eax
+}
+  800e51:	c9                   	leave  
+  800e52:	c3                   	ret    
+
+00800e53 <rand>:
+ * rand - returns a pseudo-random integer
+ *
+ * The rand() function return a value in the range [0, RAND_MAX].
+ * */
+int
+rand(void) {
+  800e53:	55                   	push   %ebp
+  800e54:	89 e5                	mov    %esp,%ebp
+  800e56:	57                   	push   %edi
+  800e57:	56                   	push   %esi
+  800e58:	53                   	push   %ebx
+  800e59:	83 ec 24             	sub    $0x24,%esp
+    next = (next * 0x5DEECE66DLL + 0xBLL) & ((1LL << 48) - 1);
+  800e5c:	a1 00 20 80 00       	mov    0x802000,%eax
+  800e61:	8b 15 04 20 80 00    	mov    0x802004,%edx
+  800e67:	69 fa 6d e6 ec de    	imul   $0xdeece66d,%edx,%edi
+  800e6d:	6b f0 05             	imul   $0x5,%eax,%esi
+  800e70:	01 fe                	add    %edi,%esi
+  800e72:	bf 6d e6 ec de       	mov    $0xdeece66d,%edi
+  800e77:	f7 e7                	mul    %edi
+  800e79:	01 d6                	add    %edx,%esi
+  800e7b:	89 f2                	mov    %esi,%edx
+  800e7d:	83 c0 0b             	add    $0xb,%eax
+  800e80:	83 d2 00             	adc    $0x0,%edx
+  800e83:	89 c7                	mov    %eax,%edi
+  800e85:	83 e7 ff             	and    $0xffffffff,%edi
+  800e88:	89 f9                	mov    %edi,%ecx
+  800e8a:	0f b7 da             	movzwl %dx,%ebx
+  800e8d:	89 0d 00 20 80 00    	mov    %ecx,0x802000
+  800e93:	89 1d 04 20 80 00    	mov    %ebx,0x802004
+    unsigned long long result = (next >> 12);
+  800e99:	a1 00 20 80 00       	mov    0x802000,%eax
+  800e9e:	8b 15 04 20 80 00    	mov    0x802004,%edx
+  800ea4:	0f ac d0 0c          	shrd   $0xc,%edx,%eax
+  800ea8:	c1 ea 0c             	shr    $0xc,%edx
+  800eab:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800eae:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+    return (int)do_div(result, RAND_MAX + 1);
+  800eb1:	c7 45 dc 00 00 00 80 	movl   $0x80000000,-0x24(%ebp)
+  800eb8:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  800ebb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800ebe:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  800ec1:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  800ec4:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ec7:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800eca:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ece:	74 1c                	je     800eec <rand+0x99>
+  800ed0:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ed3:	ba 00 00 00 00       	mov    $0x0,%edx
+  800ed8:	f7 75 dc             	divl   -0x24(%ebp)
+  800edb:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  800ede:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ee1:	ba 00 00 00 00       	mov    $0x0,%edx
+  800ee6:	f7 75 dc             	divl   -0x24(%ebp)
+  800ee9:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800eec:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  800eef:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  800ef2:	f7 75 dc             	divl   -0x24(%ebp)
+  800ef5:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  800ef8:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  800efb:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  800efe:	8b 55 e8             	mov    -0x18(%ebp),%edx
+  800f01:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800f04:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  800f07:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+}
+  800f0a:	83 c4 24             	add    $0x24,%esp
+  800f0d:	5b                   	pop    %ebx
+  800f0e:	5e                   	pop    %esi
+  800f0f:	5f                   	pop    %edi
+  800f10:	5d                   	pop    %ebp
+  800f11:	c3                   	ret    
+
+00800f12 <srand>:
+/* *
+ * srand - seed the random number generator with the given number
+ * @seed:   the required seed number
+ * */
+void
+srand(unsigned int seed) {
+  800f12:	55                   	push   %ebp
+  800f13:	89 e5                	mov    %esp,%ebp
+    next = seed;
+  800f15:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f18:	ba 00 00 00 00       	mov    $0x0,%edx
+  800f1d:	a3 00 20 80 00       	mov    %eax,0x802000
+  800f22:	89 15 04 20 80 00    	mov    %edx,0x802004
+}
+  800f28:	90                   	nop
+  800f29:	5d                   	pop    %ebp
+  800f2a:	c3                   	ret    
+
+00800f2b <main>:
+#include <stdio.h>
+#include <ulib.h>
+
+int
+main(void) {
+  800f2b:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+  800f2f:	83 e4 f0             	and    $0xfffffff0,%esp
+  800f32:	ff 71 fc             	pushl  -0x4(%ecx)
+  800f35:	55                   	push   %ebp
+  800f36:	89 e5                	mov    %esp,%ebp
+  800f38:	51                   	push   %ecx
+  800f39:	83 ec 04             	sub    $0x4,%esp
+    cprintf("I read %08x from 0xfac00000!\n", *(unsigned *)0xfac00000);
+  800f3c:	b8 00 00 c0 fa       	mov    $0xfac00000,%eax
+  800f41:	8b 00                	mov    (%eax),%eax
+  800f43:	83 ec 08             	sub    $0x8,%esp
+  800f46:	50                   	push   %eax
+  800f47:	68 60 12 80 00       	push   $0x801260
+  800f4c:	e8 88 f3 ff ff       	call   8002d9 <cprintf>
+  800f51:	83 c4 10             	add    $0x10,%esp
+    panic("FAIL: T.T\n");
+  800f54:	83 ec 04             	sub    $0x4,%esp
+  800f57:	68 7e 12 80 00       	push   $0x80127e
+  800f5c:	6a 07                	push   $0x7
+  800f5e:	68 89 12 80 00       	push   $0x801289
+  800f63:	e8 b8 f0 ff ff       	call   800020 <__panic>
diff -r -u -P lab6_origin/obj/user/faultreadkernel.d lab6/obj/user/faultreadkernel.d
--- lab6_origin/obj/user/faultreadkernel.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/faultreadkernel.d	2019-05-13 17:39:38.074220900 +0800
@@ -0,0 +1,3 @@
+obj/user/faultreadkernel.o obj/user/faultreadkernel.d: \
+ user/faultreadkernel.c libs/stdio.h libs/defs.h libs/stdarg.h \
+ user/libs/ulib.h
Binary files lab6_origin/obj/user/faultreadkernel.o and lab6/obj/user/faultreadkernel.o differ
diff -r -u -P lab6_origin/obj/user/faultreadkernel.sym lab6/obj/user/faultreadkernel.sym
--- lab6_origin/obj/user/faultreadkernel.sym	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/faultreadkernel.sym	2019-05-13 17:39:43.886883200 +0800
@@ -0,0 +1,76 @@
+00800020 .text
+00800f80 .rodata
+00802000 .data
+00200000 .stab_info
+00200010 .stab
+00202c8d .stabstr
+00000000 panic.c
+00000000 syscall.c
+008000b5 syscall
+00000000 ulib.c
+00000000 stdio.c
+0080028c cputch
+00000000 umain.c
+00000000 string.c
+00000000 printfmt.c
+00801080 error_string
+00800822 printnum
+00800913 getuint
+00800962 getint
+00800d75 sprintputch
+00000000 hash.c
+00000000 rand.c
+00802000 next
+00000000 faultreadkernel.c
+008003be strcpy
+0080021a yield
+00800201 waitpid
+00800141 sys_yield
+008006d7 memmove
+00800dab snprintf
+008009cd vprintfmt
+0080011d sys_fork
+008002d9 cprintf
+0080023e getpid
+0080077a memcpy
+00800266 lab6_set_priority
+00800dd4 vsnprintf
+0080034d umain
+00202c8c __STAB_END__
+00800150 sys_kill
+00202c8d __STABSTR_BEGIN__
+00800020 __panic
+0080053a strtol
+0080038e strnlen
+0080024b print_pgdir
+00800228 kill
+0080050b strfind
+008001ea wait
+0080027d _start
+00800e53 rand
+00800482 strncmp
+00800171 sys_putc
+008003fe strncpy
+008007ca memcmp
+008001dd fork
+00800697 memset
+00800f2b main
+00800f12 srand
+00800e2e hash32
+008009a9 printfmt
+00203a75 __STABSTR_END__
+00800438 strcmp
+00800259 gettime_msec
+00800192 sys_gettime
+008002b0 vcprintf
+0080006e __warn
+008002ff cputs
+008001a1 sys_lab6_set_priority
+008001b7 exit
+0080012c sys_wait
+0080010b sys_exit
+00200010 __STAB_BEGIN__
+00800366 strlen
+00800183 sys_pgdir
+008004d8 strchr
+00800162 sys_getpid
Binary files lab6_origin/obj/user/faultread.o and lab6/obj/user/faultread.o differ
diff -r -u -P lab6_origin/obj/user/faultread.sym lab6/obj/user/faultread.sym
--- lab6_origin/obj/user/faultread.sym	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/faultread.sym	2019-05-13 17:39:43.759956300 +0800
@@ -0,0 +1,76 @@
+00800020 .text
+00800f80 .rodata
+00802000 .data
+00200000 .stab_info
+00200010 .stab
+00202c8d .stabstr
+00000000 panic.c
+00000000 syscall.c
+008000b5 syscall
+00000000 ulib.c
+00000000 stdio.c
+0080028c cputch
+00000000 umain.c
+00000000 string.c
+00000000 printfmt.c
+00801080 error_string
+00800822 printnum
+00800913 getuint
+00800962 getint
+00800d75 sprintputch
+00000000 hash.c
+00000000 rand.c
+00802000 next
+00000000 faultread.c
+008003be strcpy
+0080021a yield
+00800201 waitpid
+00800141 sys_yield
+008006d7 memmove
+00800dab snprintf
+008009cd vprintfmt
+0080011d sys_fork
+008002d9 cprintf
+0080023e getpid
+0080077a memcpy
+00800266 lab6_set_priority
+00800dd4 vsnprintf
+0080034d umain
+00202c8c __STAB_END__
+00800150 sys_kill
+00202c8d __STABSTR_BEGIN__
+00800020 __panic
+0080053a strtol
+0080038e strnlen
+0080024b print_pgdir
+00800228 kill
+0080050b strfind
+008001ea wait
+0080027d _start
+00800e53 rand
+00800482 strncmp
+00800171 sys_putc
+008003fe strncpy
+008007ca memcmp
+008001dd fork
+00800697 memset
+00800f2b main
+00800f12 srand
+00800e2e hash32
+008009a9 printfmt
+00203a6f __STABSTR_END__
+00800438 strcmp
+00800259 gettime_msec
+00800192 sys_gettime
+008002b0 vcprintf
+0080006e __warn
+008002ff cputs
+008001a1 sys_lab6_set_priority
+008001b7 exit
+0080012c sys_wait
+0080010b sys_exit
+00200010 __STAB_BEGIN__
+00800366 strlen
+00800183 sys_pgdir
+008004d8 strchr
+00800162 sys_getpid
diff -r -u -P lab6_origin/obj/user/forktest.asm lab6/obj/user/forktest.asm
--- lab6_origin/obj/user/forktest.asm	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/forktest.asm	2019-05-13 17:39:43.861897400 +0800
@@ -0,0 +1,2675 @@
+
+obj/__user_forktest.out:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00800020 <__panic>:
+#include <stdio.h>
+#include <ulib.h>
+#include <error.h>
+
+void
+__panic(const char *file, int line, const char *fmt, ...) {
+  800020:	55                   	push   %ebp
+  800021:	89 e5                	mov    %esp,%ebp
+  800023:	83 ec 18             	sub    $0x18,%esp
+    // print the 'message'
+    va_list ap;
+    va_start(ap, fmt);
+  800026:	8d 45 14             	lea    0x14(%ebp),%eax
+  800029:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("user panic at %s:%d:\n    ", file, line);
+  80002c:	83 ec 04             	sub    $0x4,%esp
+  80002f:	ff 75 0c             	pushl  0xc(%ebp)
+  800032:	ff 75 08             	pushl  0x8(%ebp)
+  800035:	68 20 10 80 00       	push   $0x801020
+  80003a:	e8 9a 02 00 00       	call   8002d9 <cprintf>
+  80003f:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+  800042:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800045:	83 ec 08             	sub    $0x8,%esp
+  800048:	50                   	push   %eax
+  800049:	ff 75 10             	pushl  0x10(%ebp)
+  80004c:	e8 5f 02 00 00       	call   8002b0 <vcprintf>
+  800051:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+  800054:	83 ec 0c             	sub    $0xc,%esp
+  800057:	68 3a 10 80 00       	push   $0x80103a
+  80005c:	e8 78 02 00 00       	call   8002d9 <cprintf>
+  800061:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+    exit(-E_PANIC);
+  800064:	83 ec 0c             	sub    $0xc,%esp
+  800067:	6a f6                	push   $0xfffffff6
+  800069:	e8 49 01 00 00       	call   8001b7 <exit>
+
+0080006e <__warn>:
+}
+
+void
+__warn(const char *file, int line, const char *fmt, ...) {
+  80006e:	55                   	push   %ebp
+  80006f:	89 e5                	mov    %esp,%ebp
+  800071:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    va_start(ap, fmt);
+  800074:	8d 45 14             	lea    0x14(%ebp),%eax
+  800077:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("user warning at %s:%d:\n    ", file, line);
+  80007a:	83 ec 04             	sub    $0x4,%esp
+  80007d:	ff 75 0c             	pushl  0xc(%ebp)
+  800080:	ff 75 08             	pushl  0x8(%ebp)
+  800083:	68 3c 10 80 00       	push   $0x80103c
+  800088:	e8 4c 02 00 00       	call   8002d9 <cprintf>
+  80008d:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+  800090:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800093:	83 ec 08             	sub    $0x8,%esp
+  800096:	50                   	push   %eax
+  800097:	ff 75 10             	pushl  0x10(%ebp)
+  80009a:	e8 11 02 00 00       	call   8002b0 <vcprintf>
+  80009f:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+  8000a2:	83 ec 0c             	sub    $0xc,%esp
+  8000a5:	68 3a 10 80 00       	push   $0x80103a
+  8000aa:	e8 2a 02 00 00       	call   8002d9 <cprintf>
+  8000af:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+  8000b2:	90                   	nop
+  8000b3:	c9                   	leave  
+  8000b4:	c3                   	ret    
+
+008000b5 <syscall>:
+#include <syscall.h>
+
+#define MAX_ARGS            5
+
+static inline int
+syscall(int num, ...) {
+  8000b5:	55                   	push   %ebp
+  8000b6:	89 e5                	mov    %esp,%ebp
+  8000b8:	57                   	push   %edi
+  8000b9:	56                   	push   %esi
+  8000ba:	53                   	push   %ebx
+  8000bb:	83 ec 20             	sub    $0x20,%esp
+    va_list ap;
+    va_start(ap, num);
+  8000be:	8d 45 0c             	lea    0xc(%ebp),%eax
+  8000c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    uint32_t a[MAX_ARGS];
+    int i, ret;
+    for (i = 0; i < MAX_ARGS; i ++) {
+  8000c4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  8000cb:	eb 16                	jmp    8000e3 <syscall+0x2e>
+        a[i] = va_arg(ap, uint32_t);
+  8000cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8000d0:	8d 50 04             	lea    0x4(%eax),%edx
+  8000d3:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  8000d6:	8b 10                	mov    (%eax),%edx
+  8000d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8000db:	89 54 85 d4          	mov    %edx,-0x2c(%ebp,%eax,4)
+syscall(int num, ...) {
+    va_list ap;
+    va_start(ap, num);
+    uint32_t a[MAX_ARGS];
+    int i, ret;
+    for (i = 0; i < MAX_ARGS; i ++) {
+  8000df:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+  8000e3:	83 7d f0 04          	cmpl   $0x4,-0x10(%ebp)
+  8000e7:	7e e4                	jle    8000cd <syscall+0x18>
+    asm volatile (
+        "int %1;"
+        : "=a" (ret)
+        : "i" (T_SYSCALL),
+          "a" (num),
+          "d" (a[0]),
+  8000e9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+          "c" (a[1]),
+  8000ec:	8b 4d d8             	mov    -0x28(%ebp),%ecx
+          "b" (a[2]),
+  8000ef:	8b 5d dc             	mov    -0x24(%ebp),%ebx
+          "D" (a[3]),
+  8000f2:	8b 7d e0             	mov    -0x20(%ebp),%edi
+          "S" (a[4])
+  8000f5:	8b 75 e4             	mov    -0x1c(%ebp),%esi
+    for (i = 0; i < MAX_ARGS; i ++) {
+        a[i] = va_arg(ap, uint32_t);
+    }
+    va_end(ap);
+
+    asm volatile (
+  8000f8:	8b 45 08             	mov    0x8(%ebp),%eax
+  8000fb:	cd 80                	int    $0x80
+  8000fd:	89 45 ec             	mov    %eax,-0x14(%ebp)
+          "c" (a[1]),
+          "b" (a[2]),
+          "D" (a[3]),
+          "S" (a[4])
+        : "cc", "memory");
+    return ret;
+  800100:	8b 45 ec             	mov    -0x14(%ebp),%eax
+}
+  800103:	83 c4 20             	add    $0x20,%esp
+  800106:	5b                   	pop    %ebx
+  800107:	5e                   	pop    %esi
+  800108:	5f                   	pop    %edi
+  800109:	5d                   	pop    %ebp
+  80010a:	c3                   	ret    
+
+0080010b <sys_exit>:
+
+int
+sys_exit(int error_code) {
+  80010b:	55                   	push   %ebp
+  80010c:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_exit, error_code);
+  80010e:	ff 75 08             	pushl  0x8(%ebp)
+  800111:	6a 01                	push   $0x1
+  800113:	e8 9d ff ff ff       	call   8000b5 <syscall>
+  800118:	83 c4 08             	add    $0x8,%esp
+}
+  80011b:	c9                   	leave  
+  80011c:	c3                   	ret    
+
+0080011d <sys_fork>:
+
+int
+sys_fork(void) {
+  80011d:	55                   	push   %ebp
+  80011e:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_fork);
+  800120:	6a 02                	push   $0x2
+  800122:	e8 8e ff ff ff       	call   8000b5 <syscall>
+  800127:	83 c4 04             	add    $0x4,%esp
+}
+  80012a:	c9                   	leave  
+  80012b:	c3                   	ret    
+
+0080012c <sys_wait>:
+
+int
+sys_wait(int pid, int *store) {
+  80012c:	55                   	push   %ebp
+  80012d:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_wait, pid, store);
+  80012f:	ff 75 0c             	pushl  0xc(%ebp)
+  800132:	ff 75 08             	pushl  0x8(%ebp)
+  800135:	6a 03                	push   $0x3
+  800137:	e8 79 ff ff ff       	call   8000b5 <syscall>
+  80013c:	83 c4 0c             	add    $0xc,%esp
+}
+  80013f:	c9                   	leave  
+  800140:	c3                   	ret    
+
+00800141 <sys_yield>:
+
+int
+sys_yield(void) {
+  800141:	55                   	push   %ebp
+  800142:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_yield);
+  800144:	6a 0a                	push   $0xa
+  800146:	e8 6a ff ff ff       	call   8000b5 <syscall>
+  80014b:	83 c4 04             	add    $0x4,%esp
+}
+  80014e:	c9                   	leave  
+  80014f:	c3                   	ret    
+
+00800150 <sys_kill>:
+
+int
+sys_kill(int pid) {
+  800150:	55                   	push   %ebp
+  800151:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_kill, pid);
+  800153:	ff 75 08             	pushl  0x8(%ebp)
+  800156:	6a 0c                	push   $0xc
+  800158:	e8 58 ff ff ff       	call   8000b5 <syscall>
+  80015d:	83 c4 08             	add    $0x8,%esp
+}
+  800160:	c9                   	leave  
+  800161:	c3                   	ret    
+
+00800162 <sys_getpid>:
+
+int
+sys_getpid(void) {
+  800162:	55                   	push   %ebp
+  800163:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_getpid);
+  800165:	6a 12                	push   $0x12
+  800167:	e8 49 ff ff ff       	call   8000b5 <syscall>
+  80016c:	83 c4 04             	add    $0x4,%esp
+}
+  80016f:	c9                   	leave  
+  800170:	c3                   	ret    
+
+00800171 <sys_putc>:
+
+int
+sys_putc(int c) {
+  800171:	55                   	push   %ebp
+  800172:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_putc, c);
+  800174:	ff 75 08             	pushl  0x8(%ebp)
+  800177:	6a 1e                	push   $0x1e
+  800179:	e8 37 ff ff ff       	call   8000b5 <syscall>
+  80017e:	83 c4 08             	add    $0x8,%esp
+}
+  800181:	c9                   	leave  
+  800182:	c3                   	ret    
+
+00800183 <sys_pgdir>:
+
+int
+sys_pgdir(void) {
+  800183:	55                   	push   %ebp
+  800184:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_pgdir);
+  800186:	6a 1f                	push   $0x1f
+  800188:	e8 28 ff ff ff       	call   8000b5 <syscall>
+  80018d:	83 c4 04             	add    $0x4,%esp
+}
+  800190:	c9                   	leave  
+  800191:	c3                   	ret    
+
+00800192 <sys_gettime>:
+
+int
+sys_gettime(void) {
+  800192:	55                   	push   %ebp
+  800193:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_gettime);
+  800195:	6a 11                	push   $0x11
+  800197:	e8 19 ff ff ff       	call   8000b5 <syscall>
+  80019c:	83 c4 04             	add    $0x4,%esp
+}
+  80019f:	c9                   	leave  
+  8001a0:	c3                   	ret    
+
+008001a1 <sys_lab6_set_priority>:
+
+void
+sys_lab6_set_priority(uint32_t priority)
+{
+  8001a1:	55                   	push   %ebp
+  8001a2:	89 e5                	mov    %esp,%ebp
+    syscall(SYS_lab6_set_priority, priority);
+  8001a4:	ff 75 08             	pushl  0x8(%ebp)
+  8001a7:	68 ff 00 00 00       	push   $0xff
+  8001ac:	e8 04 ff ff ff       	call   8000b5 <syscall>
+  8001b1:	83 c4 08             	add    $0x8,%esp
+}
+  8001b4:	90                   	nop
+  8001b5:	c9                   	leave  
+  8001b6:	c3                   	ret    
+
+008001b7 <exit>:
+#include <syscall.h>
+#include <stdio.h>
+#include <ulib.h>
+
+void
+exit(int error_code) {
+  8001b7:	55                   	push   %ebp
+  8001b8:	89 e5                	mov    %esp,%ebp
+  8001ba:	83 ec 08             	sub    $0x8,%esp
+    sys_exit(error_code);
+  8001bd:	83 ec 0c             	sub    $0xc,%esp
+  8001c0:	ff 75 08             	pushl  0x8(%ebp)
+  8001c3:	e8 43 ff ff ff       	call   80010b <sys_exit>
+  8001c8:	83 c4 10             	add    $0x10,%esp
+    cprintf("BUG: exit failed.\n");
+  8001cb:	83 ec 0c             	sub    $0xc,%esp
+  8001ce:	68 58 10 80 00       	push   $0x801058
+  8001d3:	e8 01 01 00 00       	call   8002d9 <cprintf>
+  8001d8:	83 c4 10             	add    $0x10,%esp
+    while (1);
+  8001db:	eb fe                	jmp    8001db <exit+0x24>
+
+008001dd <fork>:
+}
+
+int
+fork(void) {
+  8001dd:	55                   	push   %ebp
+  8001de:	89 e5                	mov    %esp,%ebp
+  8001e0:	83 ec 08             	sub    $0x8,%esp
+    return sys_fork();
+  8001e3:	e8 35 ff ff ff       	call   80011d <sys_fork>
+}
+  8001e8:	c9                   	leave  
+  8001e9:	c3                   	ret    
+
+008001ea <wait>:
+
+int
+wait(void) {
+  8001ea:	55                   	push   %ebp
+  8001eb:	89 e5                	mov    %esp,%ebp
+  8001ed:	83 ec 08             	sub    $0x8,%esp
+    return sys_wait(0, NULL);
+  8001f0:	83 ec 08             	sub    $0x8,%esp
+  8001f3:	6a 00                	push   $0x0
+  8001f5:	6a 00                	push   $0x0
+  8001f7:	e8 30 ff ff ff       	call   80012c <sys_wait>
+  8001fc:	83 c4 10             	add    $0x10,%esp
+}
+  8001ff:	c9                   	leave  
+  800200:	c3                   	ret    
+
+00800201 <waitpid>:
+
+int
+waitpid(int pid, int *store) {
+  800201:	55                   	push   %ebp
+  800202:	89 e5                	mov    %esp,%ebp
+  800204:	83 ec 08             	sub    $0x8,%esp
+    return sys_wait(pid, store);
+  800207:	83 ec 08             	sub    $0x8,%esp
+  80020a:	ff 75 0c             	pushl  0xc(%ebp)
+  80020d:	ff 75 08             	pushl  0x8(%ebp)
+  800210:	e8 17 ff ff ff       	call   80012c <sys_wait>
+  800215:	83 c4 10             	add    $0x10,%esp
+}
+  800218:	c9                   	leave  
+  800219:	c3                   	ret    
+
+0080021a <yield>:
+
+void
+yield(void) {
+  80021a:	55                   	push   %ebp
+  80021b:	89 e5                	mov    %esp,%ebp
+  80021d:	83 ec 08             	sub    $0x8,%esp
+    sys_yield();
+  800220:	e8 1c ff ff ff       	call   800141 <sys_yield>
+}
+  800225:	90                   	nop
+  800226:	c9                   	leave  
+  800227:	c3                   	ret    
+
+00800228 <kill>:
+
+int
+kill(int pid) {
+  800228:	55                   	push   %ebp
+  800229:	89 e5                	mov    %esp,%ebp
+  80022b:	83 ec 08             	sub    $0x8,%esp
+    return sys_kill(pid);
+  80022e:	83 ec 0c             	sub    $0xc,%esp
+  800231:	ff 75 08             	pushl  0x8(%ebp)
+  800234:	e8 17 ff ff ff       	call   800150 <sys_kill>
+  800239:	83 c4 10             	add    $0x10,%esp
+}
+  80023c:	c9                   	leave  
+  80023d:	c3                   	ret    
+
+0080023e <getpid>:
+
+int
+getpid(void) {
+  80023e:	55                   	push   %ebp
+  80023f:	89 e5                	mov    %esp,%ebp
+  800241:	83 ec 08             	sub    $0x8,%esp
+    return sys_getpid();
+  800244:	e8 19 ff ff ff       	call   800162 <sys_getpid>
+}
+  800249:	c9                   	leave  
+  80024a:	c3                   	ret    
+
+0080024b <print_pgdir>:
+
+//print_pgdir - print the PDT&PT
+void
+print_pgdir(void) {
+  80024b:	55                   	push   %ebp
+  80024c:	89 e5                	mov    %esp,%ebp
+  80024e:	83 ec 08             	sub    $0x8,%esp
+    sys_pgdir();
+  800251:	e8 2d ff ff ff       	call   800183 <sys_pgdir>
+}
+  800256:	90                   	nop
+  800257:	c9                   	leave  
+  800258:	c3                   	ret    
+
+00800259 <gettime_msec>:
+
+unsigned int
+gettime_msec(void) {
+  800259:	55                   	push   %ebp
+  80025a:	89 e5                	mov    %esp,%ebp
+  80025c:	83 ec 08             	sub    $0x8,%esp
+    return (unsigned int)sys_gettime();
+  80025f:	e8 2e ff ff ff       	call   800192 <sys_gettime>
+}
+  800264:	c9                   	leave  
+  800265:	c3                   	ret    
+
+00800266 <lab6_set_priority>:
+
+void
+lab6_set_priority(uint32_t priority)
+{
+  800266:	55                   	push   %ebp
+  800267:	89 e5                	mov    %esp,%ebp
+  800269:	83 ec 08             	sub    $0x8,%esp
+    sys_lab6_set_priority(priority);
+  80026c:	83 ec 0c             	sub    $0xc,%esp
+  80026f:	ff 75 08             	pushl  0x8(%ebp)
+  800272:	e8 2a ff ff ff       	call   8001a1 <sys_lab6_set_priority>
+  800277:	83 c4 10             	add    $0x10,%esp
+}
+  80027a:	90                   	nop
+  80027b:	c9                   	leave  
+  80027c:	c3                   	ret    
+
+0080027d <_start>:
+.text
+.globl _start
+_start:
+    # set ebp for backtrace
+    movl $0x0, %ebp
+  80027d:	bd 00 00 00 00       	mov    $0x0,%ebp
+
+    # move down the esp register
+    # since it may cause page fault in backtrace
+    subl $0x20, %esp
+  800282:	83 ec 20             	sub    $0x20,%esp
+
+    # call user-program function
+    call umain
+  800285:	e8 c3 00 00 00       	call   80034d <umain>
+1:  jmp 1b
+  80028a:	eb fe                	jmp    80028a <_start+0xd>
+
+0080028c <cputch>:
+/* *
+ * cputch - writes a single character @c to stdout, and it will
+ * increace the value of counter pointed by @cnt.
+ * */
+static void
+cputch(int c, int *cnt) {
+  80028c:	55                   	push   %ebp
+  80028d:	89 e5                	mov    %esp,%ebp
+  80028f:	83 ec 08             	sub    $0x8,%esp
+    sys_putc(c);
+  800292:	83 ec 0c             	sub    $0xc,%esp
+  800295:	ff 75 08             	pushl  0x8(%ebp)
+  800298:	e8 d4 fe ff ff       	call   800171 <sys_putc>
+  80029d:	83 c4 10             	add    $0x10,%esp
+    (*cnt) ++;
+  8002a0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002a3:	8b 00                	mov    (%eax),%eax
+  8002a5:	8d 50 01             	lea    0x1(%eax),%edx
+  8002a8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002ab:	89 10                	mov    %edx,(%eax)
+}
+  8002ad:	90                   	nop
+  8002ae:	c9                   	leave  
+  8002af:	c3                   	ret    
+
+008002b0 <vcprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want cprintf() instead.
+ * */
+int
+vcprintf(const char *fmt, va_list ap) {
+  8002b0:	55                   	push   %ebp
+  8002b1:	89 e5                	mov    %esp,%ebp
+  8002b3:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+  8002b6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    vprintfmt((void*)cputch, &cnt, fmt, ap);
+  8002bd:	ff 75 0c             	pushl  0xc(%ebp)
+  8002c0:	ff 75 08             	pushl  0x8(%ebp)
+  8002c3:	8d 45 f4             	lea    -0xc(%ebp),%eax
+  8002c6:	50                   	push   %eax
+  8002c7:	68 8c 02 80 00       	push   $0x80028c
+  8002cc:	e8 fc 06 00 00       	call   8009cd <vprintfmt>
+  8002d1:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+  8002d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8002d7:	c9                   	leave  
+  8002d8:	c3                   	ret    
+
+008002d9 <cprintf>:
+ *
+ * The return value is the number of characters which would be
+ * written to stdout.
+ * */
+int
+cprintf(const char *fmt, ...) {
+  8002d9:	55                   	push   %ebp
+  8002da:	89 e5                	mov    %esp,%ebp
+  8002dc:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  8002df:	8d 45 0c             	lea    0xc(%ebp),%eax
+  8002e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    int cnt = vcprintf(fmt, ap);
+  8002e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8002e8:	83 ec 08             	sub    $0x8,%esp
+  8002eb:	50                   	push   %eax
+  8002ec:	ff 75 08             	pushl  0x8(%ebp)
+  8002ef:	e8 bc ff ff ff       	call   8002b0 <vcprintf>
+  8002f4:	83 c4 10             	add    $0x10,%esp
+  8002f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+
+    return cnt;
+  8002fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8002fd:	c9                   	leave  
+  8002fe:	c3                   	ret    
+
+008002ff <cputs>:
+/* *
+ * cputs- writes the string pointed by @str to stdout and
+ * appends a newline character.
+ * */
+int
+cputs(const char *str) {
+  8002ff:	55                   	push   %ebp
+  800300:	89 e5                	mov    %esp,%ebp
+  800302:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+  800305:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    char c;
+    while ((c = *str ++) != '\0') {
+  80030c:	eb 14                	jmp    800322 <cputs+0x23>
+        cputch(c, &cnt);
+  80030e:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
+  800312:	83 ec 08             	sub    $0x8,%esp
+  800315:	8d 55 f0             	lea    -0x10(%ebp),%edx
+  800318:	52                   	push   %edx
+  800319:	50                   	push   %eax
+  80031a:	e8 6d ff ff ff       	call   80028c <cputch>
+  80031f:	83 c4 10             	add    $0x10,%esp
+ * */
+int
+cputs(const char *str) {
+    int cnt = 0;
+    char c;
+    while ((c = *str ++) != '\0') {
+  800322:	8b 45 08             	mov    0x8(%ebp),%eax
+  800325:	8d 50 01             	lea    0x1(%eax),%edx
+  800328:	89 55 08             	mov    %edx,0x8(%ebp)
+  80032b:	0f b6 00             	movzbl (%eax),%eax
+  80032e:	88 45 f7             	mov    %al,-0x9(%ebp)
+  800331:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
+  800335:	75 d7                	jne    80030e <cputs+0xf>
+        cputch(c, &cnt);
+    }
+    cputch('\n', &cnt);
+  800337:	83 ec 08             	sub    $0x8,%esp
+  80033a:	8d 45 f0             	lea    -0x10(%ebp),%eax
+  80033d:	50                   	push   %eax
+  80033e:	6a 0a                	push   $0xa
+  800340:	e8 47 ff ff ff       	call   80028c <cputch>
+  800345:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+  800348:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+  80034b:	c9                   	leave  
+  80034c:	c3                   	ret    
+
+0080034d <umain>:
+#include <ulib.h>
+
+int main(void);
+
+void
+umain(void) {
+  80034d:	55                   	push   %ebp
+  80034e:	89 e5                	mov    %esp,%ebp
+  800350:	83 ec 18             	sub    $0x18,%esp
+    int ret = main();
+  800353:	e8 d3 0b 00 00       	call   800f2b <main>
+  800358:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    exit(ret);
+  80035b:	83 ec 0c             	sub    $0xc,%esp
+  80035e:	ff 75 f4             	pushl  -0xc(%ebp)
+  800361:	e8 51 fe ff ff       	call   8001b7 <exit>
+
+00800366 <strlen>:
+ * @s:      the input string
+ *
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+  800366:	55                   	push   %ebp
+  800367:	89 e5                	mov    %esp,%ebp
+  800369:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  80036c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (*s ++ != '\0') {
+  800373:	eb 04                	jmp    800379 <strlen+0x13>
+        cnt ++;
+  800375:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+    size_t cnt = 0;
+    while (*s ++ != '\0') {
+  800379:	8b 45 08             	mov    0x8(%ebp),%eax
+  80037c:	8d 50 01             	lea    0x1(%eax),%edx
+  80037f:	89 55 08             	mov    %edx,0x8(%ebp)
+  800382:	0f b6 00             	movzbl (%eax),%eax
+  800385:	84 c0                	test   %al,%al
+  800387:	75 ec                	jne    800375 <strlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  800389:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  80038c:	c9                   	leave  
+  80038d:	c3                   	ret    
+
+0080038e <strnlen>:
+ * The return value is strlen(s), if that is less than @len, or
+ * @len if there is no '\0' character among the first @len characters
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+  80038e:	55                   	push   %ebp
+  80038f:	89 e5                	mov    %esp,%ebp
+  800391:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  800394:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (cnt < len && *s ++ != '\0') {
+  80039b:	eb 04                	jmp    8003a1 <strnlen+0x13>
+        cnt ++;
+  80039d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+    size_t cnt = 0;
+    while (cnt < len && *s ++ != '\0') {
+  8003a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8003a4:	3b 45 0c             	cmp    0xc(%ebp),%eax
+  8003a7:	73 10                	jae    8003b9 <strnlen+0x2b>
+  8003a9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003ac:	8d 50 01             	lea    0x1(%eax),%edx
+  8003af:	89 55 08             	mov    %edx,0x8(%ebp)
+  8003b2:	0f b6 00             	movzbl (%eax),%eax
+  8003b5:	84 c0                	test   %al,%al
+  8003b7:	75 e4                	jne    80039d <strnlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  8003b9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  8003bc:	c9                   	leave  
+  8003bd:	c3                   	ret    
+
+008003be <strcpy>:
+ * To avoid overflows, the size of array pointed by @dst should be long enough to
+ * contain the same string as @src (including the terminating null character), and
+ * should not overlap in memory with @src.
+ * */
+char *
+strcpy(char *dst, const char *src) {
+  8003be:	55                   	push   %ebp
+  8003bf:	89 e5                	mov    %esp,%ebp
+  8003c1:	57                   	push   %edi
+  8003c2:	56                   	push   %esi
+  8003c3:	83 ec 20             	sub    $0x20,%esp
+  8003c6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  8003cc:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8003cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCPY
+#define __HAVE_ARCH_STRCPY
+static inline char *
+__strcpy(char *dst, const char *src) {
+    int d0, d1, d2;
+    asm volatile (
+  8003d2:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  8003d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8003d8:	89 d1                	mov    %edx,%ecx
+  8003da:	89 c2                	mov    %eax,%edx
+  8003dc:	89 ce                	mov    %ecx,%esi
+  8003de:	89 d7                	mov    %edx,%edi
+  8003e0:	ac                   	lods   %ds:(%esi),%al
+  8003e1:	aa                   	stos   %al,%es:(%edi)
+  8003e2:	84 c0                	test   %al,%al
+  8003e4:	75 fa                	jne    8003e0 <strcpy+0x22>
+  8003e6:	89 fa                	mov    %edi,%edx
+  8003e8:	89 f1                	mov    %esi,%ecx
+  8003ea:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  8003ed:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  8003f0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+        "stosb;"
+        "testb %%al, %%al;"
+        "jne 1b;"
+        : "=&S" (d0), "=&D" (d1), "=&a" (d2)
+        : "0" (src), "1" (dst) : "memory");
+    return dst;
+  8003f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCPY
+    return __strcpy(dst, src);
+  8003f6:	90                   	nop
+    char *p = dst;
+    while ((*p ++ = *src ++) != '\0')
+        /* nothing */;
+    return dst;
+#endif /* __HAVE_ARCH_STRCPY */
+}
+  8003f7:	83 c4 20             	add    $0x20,%esp
+  8003fa:	5e                   	pop    %esi
+  8003fb:	5f                   	pop    %edi
+  8003fc:	5d                   	pop    %ebp
+  8003fd:	c3                   	ret    
+
+008003fe <strncpy>:
+ * @len:    maximum number of characters to be copied from @src
+ *
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+  8003fe:	55                   	push   %ebp
+  8003ff:	89 e5                	mov    %esp,%ebp
+  800401:	83 ec 10             	sub    $0x10,%esp
+    char *p = dst;
+  800404:	8b 45 08             	mov    0x8(%ebp),%eax
+  800407:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    while (len > 0) {
+  80040a:	eb 21                	jmp    80042d <strncpy+0x2f>
+        if ((*p = *src) != '\0') {
+  80040c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80040f:	0f b6 10             	movzbl (%eax),%edx
+  800412:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800415:	88 10                	mov    %dl,(%eax)
+  800417:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  80041a:	0f b6 00             	movzbl (%eax),%eax
+  80041d:	84 c0                	test   %al,%al
+  80041f:	74 04                	je     800425 <strncpy+0x27>
+            src ++;
+  800421:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+        }
+        p ++, len --;
+  800425:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800429:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+    char *p = dst;
+    while (len > 0) {
+  80042d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800431:	75 d9                	jne    80040c <strncpy+0xe>
+        if ((*p = *src) != '\0') {
+            src ++;
+        }
+        p ++, len --;
+    }
+    return dst;
+  800433:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800436:	c9                   	leave  
+  800437:	c3                   	ret    
+
+00800438 <strcmp>:
+ * - A value greater than zero indicates that the first character that does
+ *   not match has a greater value in @s1 than in @s2;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+strcmp(const char *s1, const char *s2) {
+  800438:	55                   	push   %ebp
+  800439:	89 e5                	mov    %esp,%ebp
+  80043b:	57                   	push   %edi
+  80043c:	56                   	push   %esi
+  80043d:	83 ec 20             	sub    $0x20,%esp
+  800440:	8b 45 08             	mov    0x8(%ebp),%eax
+  800443:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800446:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800449:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCMP
+#define __HAVE_ARCH_STRCMP
+static inline int
+__strcmp(const char *s1, const char *s2) {
+    int d0, d1, ret;
+    asm volatile (
+  80044c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80044f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800452:	89 d1                	mov    %edx,%ecx
+  800454:	89 c2                	mov    %eax,%edx
+  800456:	89 ce                	mov    %ecx,%esi
+  800458:	89 d7                	mov    %edx,%edi
+  80045a:	ac                   	lods   %ds:(%esi),%al
+  80045b:	ae                   	scas   %es:(%edi),%al
+  80045c:	75 08                	jne    800466 <strcmp+0x2e>
+  80045e:	84 c0                	test   %al,%al
+  800460:	75 f8                	jne    80045a <strcmp+0x22>
+  800462:	31 c0                	xor    %eax,%eax
+  800464:	eb 04                	jmp    80046a <strcmp+0x32>
+  800466:	19 c0                	sbb    %eax,%eax
+  800468:	0c 01                	or     $0x1,%al
+  80046a:	89 fa                	mov    %edi,%edx
+  80046c:	89 f1                	mov    %esi,%ecx
+  80046e:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800471:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  800474:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+        "orb $1, %%al;"
+        "3:"
+        : "=a" (ret), "=&S" (d0), "=&D" (d1)
+        : "1" (s1), "2" (s2)
+        : "memory");
+    return ret;
+  800477:	8b 45 ec             	mov    -0x14(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCMP
+    return __strcmp(s1, s2);
+  80047a:	90                   	nop
+    while (*s1 != '\0' && *s1 == *s2) {
+        s1 ++, s2 ++;
+    }
+    return (int)((unsigned char)*s1 - (unsigned char)*s2);
+#endif /* __HAVE_ARCH_STRCMP */
+}
+  80047b:	83 c4 20             	add    $0x20,%esp
+  80047e:	5e                   	pop    %esi
+  80047f:	5f                   	pop    %edi
+  800480:	5d                   	pop    %ebp
+  800481:	c3                   	ret    
+
+00800482 <strncmp>:
+ * they are equal to each other, it continues with the following pairs until
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+  800482:	55                   	push   %ebp
+  800483:	89 e5                	mov    %esp,%ebp
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  800485:	eb 0c                	jmp    800493 <strncmp+0x11>
+        n --, s1 ++, s2 ++;
+  800487:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  80048b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  80048f:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  800493:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800497:	74 1a                	je     8004b3 <strncmp+0x31>
+  800499:	8b 45 08             	mov    0x8(%ebp),%eax
+  80049c:	0f b6 00             	movzbl (%eax),%eax
+  80049f:	84 c0                	test   %al,%al
+  8004a1:	74 10                	je     8004b3 <strncmp+0x31>
+  8004a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004a6:	0f b6 10             	movzbl (%eax),%edx
+  8004a9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004ac:	0f b6 00             	movzbl (%eax),%eax
+  8004af:	38 c2                	cmp    %al,%dl
+  8004b1:	74 d4                	je     800487 <strncmp+0x5>
+        n --, s1 ++, s2 ++;
+    }
+    return (n == 0) ? 0 : (int)((unsigned char)*s1 - (unsigned char)*s2);
+  8004b3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8004b7:	74 18                	je     8004d1 <strncmp+0x4f>
+  8004b9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004bc:	0f b6 00             	movzbl (%eax),%eax
+  8004bf:	0f b6 d0             	movzbl %al,%edx
+  8004c2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004c5:	0f b6 00             	movzbl (%eax),%eax
+  8004c8:	0f b6 c0             	movzbl %al,%eax
+  8004cb:	29 c2                	sub    %eax,%edx
+  8004cd:	89 d0                	mov    %edx,%eax
+  8004cf:	eb 05                	jmp    8004d6 <strncmp+0x54>
+  8004d1:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  8004d6:	5d                   	pop    %ebp
+  8004d7:	c3                   	ret    
+
+008004d8 <strchr>:
+ *
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+  8004d8:	55                   	push   %ebp
+  8004d9:	89 e5                	mov    %esp,%ebp
+  8004db:	83 ec 04             	sub    $0x4,%esp
+  8004de:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004e1:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  8004e4:	eb 14                	jmp    8004fa <strchr+0x22>
+        if (*s == c) {
+  8004e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004e9:	0f b6 00             	movzbl (%eax),%eax
+  8004ec:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  8004ef:	75 05                	jne    8004f6 <strchr+0x1e>
+            return (char *)s;
+  8004f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004f4:	eb 13                	jmp    800509 <strchr+0x31>
+        }
+        s ++;
+  8004f6:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+    while (*s != '\0') {
+  8004fa:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004fd:	0f b6 00             	movzbl (%eax),%eax
+  800500:	84 c0                	test   %al,%al
+  800502:	75 e2                	jne    8004e6 <strchr+0xe>
+        if (*s == c) {
+            return (char *)s;
+        }
+        s ++;
+    }
+    return NULL;
+  800504:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800509:	c9                   	leave  
+  80050a:	c3                   	ret    
+
+0080050b <strfind>:
+ * The strfind() function is like strchr() except that if @c is
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+  80050b:	55                   	push   %ebp
+  80050c:	89 e5                	mov    %esp,%ebp
+  80050e:	83 ec 04             	sub    $0x4,%esp
+  800511:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800514:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  800517:	eb 0f                	jmp    800528 <strfind+0x1d>
+        if (*s == c) {
+  800519:	8b 45 08             	mov    0x8(%ebp),%eax
+  80051c:	0f b6 00             	movzbl (%eax),%eax
+  80051f:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800522:	74 10                	je     800534 <strfind+0x29>
+            break;
+        }
+        s ++;
+  800524:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+    while (*s != '\0') {
+  800528:	8b 45 08             	mov    0x8(%ebp),%eax
+  80052b:	0f b6 00             	movzbl (%eax),%eax
+  80052e:	84 c0                	test   %al,%al
+  800530:	75 e7                	jne    800519 <strfind+0xe>
+  800532:	eb 01                	jmp    800535 <strfind+0x2a>
+        if (*s == c) {
+            break;
+  800534:	90                   	nop
+        }
+        s ++;
+    }
+    return (char *)s;
+  800535:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800538:	c9                   	leave  
+  800539:	c3                   	ret    
+
+0080053a <strtol>:
+ * an optional "0x" or "0X" prefix.
+ *
+ * The strtol() function returns the converted integral number as a long int value.
+ * */
+long
+strtol(const char *s, char **endptr, int base) {
+  80053a:	55                   	push   %ebp
+  80053b:	89 e5                	mov    %esp,%ebp
+  80053d:	83 ec 10             	sub    $0x10,%esp
+    int neg = 0;
+  800540:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    long val = 0;
+  800547:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  80054e:	eb 04                	jmp    800554 <strtol+0x1a>
+        s ++;
+  800550:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+strtol(const char *s, char **endptr, int base) {
+    int neg = 0;
+    long val = 0;
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  800554:	8b 45 08             	mov    0x8(%ebp),%eax
+  800557:	0f b6 00             	movzbl (%eax),%eax
+  80055a:	3c 20                	cmp    $0x20,%al
+  80055c:	74 f2                	je     800550 <strtol+0x16>
+  80055e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800561:	0f b6 00             	movzbl (%eax),%eax
+  800564:	3c 09                	cmp    $0x9,%al
+  800566:	74 e8                	je     800550 <strtol+0x16>
+        s ++;
+    }
+
+    // plus/minus sign
+    if (*s == '+') {
+  800568:	8b 45 08             	mov    0x8(%ebp),%eax
+  80056b:	0f b6 00             	movzbl (%eax),%eax
+  80056e:	3c 2b                	cmp    $0x2b,%al
+  800570:	75 06                	jne    800578 <strtol+0x3e>
+        s ++;
+  800572:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800576:	eb 15                	jmp    80058d <strtol+0x53>
+    }
+    else if (*s == '-') {
+  800578:	8b 45 08             	mov    0x8(%ebp),%eax
+  80057b:	0f b6 00             	movzbl (%eax),%eax
+  80057e:	3c 2d                	cmp    $0x2d,%al
+  800580:	75 0b                	jne    80058d <strtol+0x53>
+        s ++, neg = 1;
+  800582:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800586:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+    }
+
+    // hex or octal base prefix
+    if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x')) {
+  80058d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800591:	74 06                	je     800599 <strtol+0x5f>
+  800593:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+  800597:	75 24                	jne    8005bd <strtol+0x83>
+  800599:	8b 45 08             	mov    0x8(%ebp),%eax
+  80059c:	0f b6 00             	movzbl (%eax),%eax
+  80059f:	3c 30                	cmp    $0x30,%al
+  8005a1:	75 1a                	jne    8005bd <strtol+0x83>
+  8005a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005a6:	83 c0 01             	add    $0x1,%eax
+  8005a9:	0f b6 00             	movzbl (%eax),%eax
+  8005ac:	3c 78                	cmp    $0x78,%al
+  8005ae:	75 0d                	jne    8005bd <strtol+0x83>
+        s += 2, base = 16;
+  8005b0:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+  8005b4:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+  8005bb:	eb 2a                	jmp    8005e7 <strtol+0xad>
+    }
+    else if (base == 0 && s[0] == '0') {
+  8005bd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8005c1:	75 17                	jne    8005da <strtol+0xa0>
+  8005c3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005c6:	0f b6 00             	movzbl (%eax),%eax
+  8005c9:	3c 30                	cmp    $0x30,%al
+  8005cb:	75 0d                	jne    8005da <strtol+0xa0>
+        s ++, base = 8;
+  8005cd:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  8005d1:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+  8005d8:	eb 0d                	jmp    8005e7 <strtol+0xad>
+    }
+    else if (base == 0) {
+  8005da:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8005de:	75 07                	jne    8005e7 <strtol+0xad>
+        base = 10;
+  8005e0:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+    // digits
+    while (1) {
+        int dig;
+
+        if (*s >= '0' && *s <= '9') {
+  8005e7:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005ea:	0f b6 00             	movzbl (%eax),%eax
+  8005ed:	3c 2f                	cmp    $0x2f,%al
+  8005ef:	7e 1b                	jle    80060c <strtol+0xd2>
+  8005f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005f4:	0f b6 00             	movzbl (%eax),%eax
+  8005f7:	3c 39                	cmp    $0x39,%al
+  8005f9:	7f 11                	jg     80060c <strtol+0xd2>
+            dig = *s - '0';
+  8005fb:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005fe:	0f b6 00             	movzbl (%eax),%eax
+  800601:	0f be c0             	movsbl %al,%eax
+  800604:	83 e8 30             	sub    $0x30,%eax
+  800607:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80060a:	eb 48                	jmp    800654 <strtol+0x11a>
+        }
+        else if (*s >= 'a' && *s <= 'z') {
+  80060c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80060f:	0f b6 00             	movzbl (%eax),%eax
+  800612:	3c 60                	cmp    $0x60,%al
+  800614:	7e 1b                	jle    800631 <strtol+0xf7>
+  800616:	8b 45 08             	mov    0x8(%ebp),%eax
+  800619:	0f b6 00             	movzbl (%eax),%eax
+  80061c:	3c 7a                	cmp    $0x7a,%al
+  80061e:	7f 11                	jg     800631 <strtol+0xf7>
+            dig = *s - 'a' + 10;
+  800620:	8b 45 08             	mov    0x8(%ebp),%eax
+  800623:	0f b6 00             	movzbl (%eax),%eax
+  800626:	0f be c0             	movsbl %al,%eax
+  800629:	83 e8 57             	sub    $0x57,%eax
+  80062c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80062f:	eb 23                	jmp    800654 <strtol+0x11a>
+        }
+        else if (*s >= 'A' && *s <= 'Z') {
+  800631:	8b 45 08             	mov    0x8(%ebp),%eax
+  800634:	0f b6 00             	movzbl (%eax),%eax
+  800637:	3c 40                	cmp    $0x40,%al
+  800639:	7e 3c                	jle    800677 <strtol+0x13d>
+  80063b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80063e:	0f b6 00             	movzbl (%eax),%eax
+  800641:	3c 5a                	cmp    $0x5a,%al
+  800643:	7f 32                	jg     800677 <strtol+0x13d>
+            dig = *s - 'A' + 10;
+  800645:	8b 45 08             	mov    0x8(%ebp),%eax
+  800648:	0f b6 00             	movzbl (%eax),%eax
+  80064b:	0f be c0             	movsbl %al,%eax
+  80064e:	83 e8 37             	sub    $0x37,%eax
+  800651:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+  800654:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800657:	3b 45 10             	cmp    0x10(%ebp),%eax
+  80065a:	7d 1a                	jge    800676 <strtol+0x13c>
+            break;
+        }
+        s ++, val = (val * base) + dig;
+  80065c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800660:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800663:	0f af 45 10          	imul   0x10(%ebp),%eax
+  800667:	89 c2                	mov    %eax,%edx
+  800669:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  80066c:	01 d0                	add    %edx,%eax
+  80066e:	89 45 f8             	mov    %eax,-0x8(%ebp)
+        // we don't properly detect overflow!
+    }
+  800671:	e9 71 ff ff ff       	jmp    8005e7 <strtol+0xad>
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+            break;
+  800676:	90                   	nop
+        }
+        s ++, val = (val * base) + dig;
+        // we don't properly detect overflow!
+    }
+
+    if (endptr) {
+  800677:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  80067b:	74 08                	je     800685 <strtol+0x14b>
+        *endptr = (char *) s;
+  80067d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800680:	8b 55 08             	mov    0x8(%ebp),%edx
+  800683:	89 10                	mov    %edx,(%eax)
+    }
+    return (neg ? -val : val);
+  800685:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+  800689:	74 07                	je     800692 <strtol+0x158>
+  80068b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  80068e:	f7 d8                	neg    %eax
+  800690:	eb 03                	jmp    800695 <strtol+0x15b>
+  800692:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  800695:	c9                   	leave  
+  800696:	c3                   	ret    
+
+00800697 <memset>:
+ * @n:      number of bytes to be set to the value
+ *
+ * The memset() function returns @s.
+ * */
+void *
+memset(void *s, char c, size_t n) {
+  800697:	55                   	push   %ebp
+  800698:	89 e5                	mov    %esp,%ebp
+  80069a:	57                   	push   %edi
+  80069b:	83 ec 24             	sub    $0x24,%esp
+  80069e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006a1:	88 45 d8             	mov    %al,-0x28(%ebp)
+#ifdef __HAVE_ARCH_MEMSET
+    return __memset(s, c, n);
+  8006a4:	0f be 45 d8          	movsbl -0x28(%ebp),%eax
+  8006a8:	8b 55 08             	mov    0x8(%ebp),%edx
+  8006ab:	89 55 f8             	mov    %edx,-0x8(%ebp)
+  8006ae:	88 45 f7             	mov    %al,-0x9(%ebp)
+  8006b1:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_MEMSET
+#define __HAVE_ARCH_MEMSET
+static inline void *
+__memset(void *s, char c, size_t n) {
+    int d0, d1;
+    asm volatile (
+  8006b7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+  8006ba:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
+  8006be:	8b 55 f8             	mov    -0x8(%ebp),%edx
+  8006c1:	89 d7                	mov    %edx,%edi
+  8006c3:	f3 aa                	rep stos %al,%es:(%edi)
+  8006c5:	89 fa                	mov    %edi,%edx
+  8006c7:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  8006ca:	89 55 e8             	mov    %edx,-0x18(%ebp)
+        "rep; stosb;"
+        : "=&c" (d0), "=&D" (d1)
+        : "0" (n), "a" (c), "1" (s)
+        : "memory");
+    return s;
+  8006cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8006d0:	90                   	nop
+    while (n -- > 0) {
+        *p ++ = c;
+    }
+    return s;
+#endif /* __HAVE_ARCH_MEMSET */
+}
+  8006d1:	83 c4 24             	add    $0x24,%esp
+  8006d4:	5f                   	pop    %edi
+  8006d5:	5d                   	pop    %ebp
+  8006d6:	c3                   	ret    
+
+008006d7 <memmove>:
+ * @n:      number of bytes to copy
+ *
+ * The memmove() function returns @dst.
+ * */
+void *
+memmove(void *dst, const void *src, size_t n) {
+  8006d7:	55                   	push   %ebp
+  8006d8:	89 e5                	mov    %esp,%ebp
+  8006da:	57                   	push   %edi
+  8006db:	56                   	push   %esi
+  8006dc:	53                   	push   %ebx
+  8006dd:	83 ec 30             	sub    $0x30,%esp
+  8006e0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8006e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8006e6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  8006ec:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006ef:	89 45 e8             	mov    %eax,-0x18(%ebp)
+
+#ifndef __HAVE_ARCH_MEMMOVE
+#define __HAVE_ARCH_MEMMOVE
+static inline void *
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+  8006f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006f5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  8006f8:	73 42                	jae    80073c <memmove+0x65>
+  8006fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006fd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800700:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800703:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800706:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800709:	89 45 dc             	mov    %eax,-0x24(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  80070c:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  80070f:	c1 e8 02             	shr    $0x2,%eax
+  800712:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  800714:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800717:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80071a:	89 d7                	mov    %edx,%edi
+  80071c:	89 c6                	mov    %eax,%esi
+  80071e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800720:	8b 4d dc             	mov    -0x24(%ebp),%ecx
+  800723:	83 e1 03             	and    $0x3,%ecx
+  800726:	74 02                	je     80072a <memmove+0x53>
+  800728:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  80072a:	89 f0                	mov    %esi,%eax
+  80072c:	89 fa                	mov    %edi,%edx
+  80072e:	89 4d d8             	mov    %ecx,-0x28(%ebp)
+  800731:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  800734:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  800737:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMMOVE
+    return __memmove(dst, src, n);
+  80073a:	eb 36                	jmp    800772 <memmove+0x9b>
+    asm volatile (
+        "std;"
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+  80073c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80073f:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800742:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800745:	01 c2                	add    %eax,%edx
+  800747:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80074a:	8d 48 ff             	lea    -0x1(%eax),%ecx
+  80074d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800750:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+        return __memcpy(dst, src, n);
+    }
+    int d0, d1, d2;
+    asm volatile (
+  800753:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800756:	89 c1                	mov    %eax,%ecx
+  800758:	89 d8                	mov    %ebx,%eax
+  80075a:	89 d6                	mov    %edx,%esi
+  80075c:	89 c7                	mov    %eax,%edi
+  80075e:	fd                   	std    
+  80075f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  800761:	fc                   	cld    
+  800762:	89 f8                	mov    %edi,%eax
+  800764:	89 f2                	mov    %esi,%edx
+  800766:	89 4d cc             	mov    %ecx,-0x34(%ebp)
+  800769:	89 55 c8             	mov    %edx,-0x38(%ebp)
+  80076c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+        : "memory");
+    return dst;
+  80076f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+            *d ++ = *s ++;
+        }
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMMOVE */
+}
+  800772:	83 c4 30             	add    $0x30,%esp
+  800775:	5b                   	pop    %ebx
+  800776:	5e                   	pop    %esi
+  800777:	5f                   	pop    %edi
+  800778:	5d                   	pop    %ebp
+  800779:	c3                   	ret    
+
+0080077a <memcpy>:
+ * it always copies exactly @n bytes. To avoid overflows, the size of arrays pointed
+ * by both @src and @dst, should be at least @n bytes, and should not overlap
+ * (for overlapping memory area, memmove is a safer approach).
+ * */
+void *
+memcpy(void *dst, const void *src, size_t n) {
+  80077a:	55                   	push   %ebp
+  80077b:	89 e5                	mov    %esp,%ebp
+  80077d:	57                   	push   %edi
+  80077e:	56                   	push   %esi
+  80077f:	83 ec 20             	sub    $0x20,%esp
+  800782:	8b 45 08             	mov    0x8(%ebp),%eax
+  800785:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800788:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80078b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80078e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800791:	89 45 ec             	mov    %eax,-0x14(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  800794:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800797:	c1 e8 02             	shr    $0x2,%eax
+  80079a:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  80079c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80079f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8007a2:	89 d7                	mov    %edx,%edi
+  8007a4:	89 c6                	mov    %eax,%esi
+  8007a6:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  8007a8:	8b 4d ec             	mov    -0x14(%ebp),%ecx
+  8007ab:	83 e1 03             	and    $0x3,%ecx
+  8007ae:	74 02                	je     8007b2 <memcpy+0x38>
+  8007b0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  8007b2:	89 f0                	mov    %esi,%eax
+  8007b4:	89 fa                	mov    %edi,%edx
+  8007b6:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  8007b9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  8007bc:	89 45 e0             	mov    %eax,-0x20(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  8007bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMCPY
+    return __memcpy(dst, src, n);
+  8007c2:	90                   	nop
+    while (n -- > 0) {
+        *d ++ = *s ++;
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMCPY */
+}
+  8007c3:	83 c4 20             	add    $0x20,%esp
+  8007c6:	5e                   	pop    %esi
+  8007c7:	5f                   	pop    %edi
+  8007c8:	5d                   	pop    %ebp
+  8007c9:	c3                   	ret    
+
+008007ca <memcmp>:
+ *   match in both memory blocks has a greater value in @v1 than in @v2
+ *   as if evaluated as unsigned char values;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+  8007ca:	55                   	push   %ebp
+  8007cb:	89 e5                	mov    %esp,%ebp
+  8007cd:	83 ec 10             	sub    $0x10,%esp
+    const char *s1 = (const char *)v1;
+  8007d0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8007d3:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    const char *s2 = (const char *)v2;
+  8007d6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8007d9:	89 45 f8             	mov    %eax,-0x8(%ebp)
+    while (n -- > 0) {
+  8007dc:	eb 30                	jmp    80080e <memcmp+0x44>
+        if (*s1 != *s2) {
+  8007de:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8007e1:	0f b6 10             	movzbl (%eax),%edx
+  8007e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8007e7:	0f b6 00             	movzbl (%eax),%eax
+  8007ea:	38 c2                	cmp    %al,%dl
+  8007ec:	74 18                	je     800806 <memcmp+0x3c>
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+  8007ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8007f1:	0f b6 00             	movzbl (%eax),%eax
+  8007f4:	0f b6 d0             	movzbl %al,%edx
+  8007f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8007fa:	0f b6 00             	movzbl (%eax),%eax
+  8007fd:	0f b6 c0             	movzbl %al,%eax
+  800800:	29 c2                	sub    %eax,%edx
+  800802:	89 d0                	mov    %edx,%eax
+  800804:	eb 1a                	jmp    800820 <memcmp+0x56>
+        }
+        s1 ++, s2 ++;
+  800806:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  80080a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+    const char *s1 = (const char *)v1;
+    const char *s2 = (const char *)v2;
+    while (n -- > 0) {
+  80080e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800811:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800814:	89 55 10             	mov    %edx,0x10(%ebp)
+  800817:	85 c0                	test   %eax,%eax
+  800819:	75 c3                	jne    8007de <memcmp+0x14>
+        if (*s1 != *s2) {
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+        }
+        s1 ++, s2 ++;
+    }
+    return 0;
+  80081b:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800820:	c9                   	leave  
+  800821:	c3                   	ret    
+
+00800822 <printnum>:
+ * @width:      maximum number of digits, if the actual width is less than @width, use @padc instead
+ * @padc:       character that padded on the left if the actual width is less than @width
+ * */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+        unsigned long long num, unsigned base, int width, int padc) {
+  800822:	55                   	push   %ebp
+  800823:	89 e5                	mov    %esp,%ebp
+  800825:	83 ec 38             	sub    $0x38,%esp
+  800828:	8b 45 10             	mov    0x10(%ebp),%eax
+  80082b:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  80082e:	8b 45 14             	mov    0x14(%ebp),%eax
+  800831:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+    unsigned long long result = num;
+  800834:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  800837:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  80083a:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  80083d:	89 55 ec             	mov    %edx,-0x14(%ebp)
+    unsigned mod = do_div(result, base);
+  800840:	8b 45 18             	mov    0x18(%ebp),%eax
+  800843:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800846:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800849:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  80084c:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  80084f:	89 55 f0             	mov    %edx,-0x10(%ebp)
+  800852:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800855:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800858:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  80085c:	74 1c                	je     80087a <printnum+0x58>
+  80085e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800861:	ba 00 00 00 00       	mov    $0x0,%edx
+  800866:	f7 75 e4             	divl   -0x1c(%ebp)
+  800869:	89 55 f4             	mov    %edx,-0xc(%ebp)
+  80086c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  80086f:	ba 00 00 00 00       	mov    $0x0,%edx
+  800874:	f7 75 e4             	divl   -0x1c(%ebp)
+  800877:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80087a:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80087d:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800880:	f7 75 e4             	divl   -0x1c(%ebp)
+  800883:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800886:	89 55 dc             	mov    %edx,-0x24(%ebp)
+  800889:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80088c:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  80088f:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800892:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  800895:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  800898:	89 45 d8             	mov    %eax,-0x28(%ebp)
+
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+  80089b:	8b 45 18             	mov    0x18(%ebp),%eax
+  80089e:	ba 00 00 00 00       	mov    $0x0,%edx
+  8008a3:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  8008a6:	77 41                	ja     8008e9 <printnum+0xc7>
+  8008a8:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  8008ab:	72 05                	jb     8008b2 <printnum+0x90>
+  8008ad:	3b 45 d0             	cmp    -0x30(%ebp),%eax
+  8008b0:	77 37                	ja     8008e9 <printnum+0xc7>
+        printnum(putch, putdat, result, base, width - 1, padc);
+  8008b2:	8b 45 1c             	mov    0x1c(%ebp),%eax
+  8008b5:	83 e8 01             	sub    $0x1,%eax
+  8008b8:	83 ec 04             	sub    $0x4,%esp
+  8008bb:	ff 75 20             	pushl  0x20(%ebp)
+  8008be:	50                   	push   %eax
+  8008bf:	ff 75 18             	pushl  0x18(%ebp)
+  8008c2:	ff 75 ec             	pushl  -0x14(%ebp)
+  8008c5:	ff 75 e8             	pushl  -0x18(%ebp)
+  8008c8:	ff 75 0c             	pushl  0xc(%ebp)
+  8008cb:	ff 75 08             	pushl  0x8(%ebp)
+  8008ce:	e8 4f ff ff ff       	call   800822 <printnum>
+  8008d3:	83 c4 20             	add    $0x20,%esp
+  8008d6:	eb 1b                	jmp    8008f3 <printnum+0xd1>
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+            putch(padc, putdat);
+  8008d8:	83 ec 08             	sub    $0x8,%esp
+  8008db:	ff 75 0c             	pushl  0xc(%ebp)
+  8008de:	ff 75 20             	pushl  0x20(%ebp)
+  8008e1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8008e4:	ff d0                	call   *%eax
+  8008e6:	83 c4 10             	add    $0x10,%esp
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+        printnum(putch, putdat, result, base, width - 1, padc);
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+  8008e9:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+  8008ed:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+  8008f1:	7f e5                	jg     8008d8 <printnum+0xb6>
+            putch(padc, putdat);
+    }
+    // then print this (the least significant) digit
+    putch("0123456789abcdef"[mod], putdat);
+  8008f3:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  8008f6:	05 84 11 80 00       	add    $0x801184,%eax
+  8008fb:	0f b6 00             	movzbl (%eax),%eax
+  8008fe:	0f be c0             	movsbl %al,%eax
+  800901:	83 ec 08             	sub    $0x8,%esp
+  800904:	ff 75 0c             	pushl  0xc(%ebp)
+  800907:	50                   	push   %eax
+  800908:	8b 45 08             	mov    0x8(%ebp),%eax
+  80090b:	ff d0                	call   *%eax
+  80090d:	83 c4 10             	add    $0x10,%esp
+}
+  800910:	90                   	nop
+  800911:	c9                   	leave  
+  800912:	c3                   	ret    
+
+00800913 <getuint>:
+ * getuint - get an unsigned int of various possible sizes from a varargs list
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static unsigned long long
+getuint(va_list *ap, int lflag) {
+  800913:	55                   	push   %ebp
+  800914:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  800916:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  80091a:	7e 14                	jle    800930 <getuint+0x1d>
+        return va_arg(*ap, unsigned long long);
+  80091c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80091f:	8b 00                	mov    (%eax),%eax
+  800921:	8d 48 08             	lea    0x8(%eax),%ecx
+  800924:	8b 55 08             	mov    0x8(%ebp),%edx
+  800927:	89 0a                	mov    %ecx,(%edx)
+  800929:	8b 50 04             	mov    0x4(%eax),%edx
+  80092c:	8b 00                	mov    (%eax),%eax
+  80092e:	eb 30                	jmp    800960 <getuint+0x4d>
+    }
+    else if (lflag) {
+  800930:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800934:	74 16                	je     80094c <getuint+0x39>
+        return va_arg(*ap, unsigned long);
+  800936:	8b 45 08             	mov    0x8(%ebp),%eax
+  800939:	8b 00                	mov    (%eax),%eax
+  80093b:	8d 48 04             	lea    0x4(%eax),%ecx
+  80093e:	8b 55 08             	mov    0x8(%ebp),%edx
+  800941:	89 0a                	mov    %ecx,(%edx)
+  800943:	8b 00                	mov    (%eax),%eax
+  800945:	ba 00 00 00 00       	mov    $0x0,%edx
+  80094a:	eb 14                	jmp    800960 <getuint+0x4d>
+    }
+    else {
+        return va_arg(*ap, unsigned int);
+  80094c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80094f:	8b 00                	mov    (%eax),%eax
+  800951:	8d 48 04             	lea    0x4(%eax),%ecx
+  800954:	8b 55 08             	mov    0x8(%ebp),%edx
+  800957:	89 0a                	mov    %ecx,(%edx)
+  800959:	8b 00                	mov    (%eax),%eax
+  80095b:	ba 00 00 00 00       	mov    $0x0,%edx
+    }
+}
+  800960:	5d                   	pop    %ebp
+  800961:	c3                   	ret    
+
+00800962 <getint>:
+ * getint - same as getuint but signed, we can't use getuint because of sign extension
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static long long
+getint(va_list *ap, int lflag) {
+  800962:	55                   	push   %ebp
+  800963:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  800965:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  800969:	7e 14                	jle    80097f <getint+0x1d>
+        return va_arg(*ap, long long);
+  80096b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80096e:	8b 00                	mov    (%eax),%eax
+  800970:	8d 48 08             	lea    0x8(%eax),%ecx
+  800973:	8b 55 08             	mov    0x8(%ebp),%edx
+  800976:	89 0a                	mov    %ecx,(%edx)
+  800978:	8b 50 04             	mov    0x4(%eax),%edx
+  80097b:	8b 00                	mov    (%eax),%eax
+  80097d:	eb 28                	jmp    8009a7 <getint+0x45>
+    }
+    else if (lflag) {
+  80097f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800983:	74 12                	je     800997 <getint+0x35>
+        return va_arg(*ap, long);
+  800985:	8b 45 08             	mov    0x8(%ebp),%eax
+  800988:	8b 00                	mov    (%eax),%eax
+  80098a:	8d 48 04             	lea    0x4(%eax),%ecx
+  80098d:	8b 55 08             	mov    0x8(%ebp),%edx
+  800990:	89 0a                	mov    %ecx,(%edx)
+  800992:	8b 00                	mov    (%eax),%eax
+  800994:	99                   	cltd   
+  800995:	eb 10                	jmp    8009a7 <getint+0x45>
+    }
+    else {
+        return va_arg(*ap, int);
+  800997:	8b 45 08             	mov    0x8(%ebp),%eax
+  80099a:	8b 00                	mov    (%eax),%eax
+  80099c:	8d 48 04             	lea    0x4(%eax),%ecx
+  80099f:	8b 55 08             	mov    0x8(%ebp),%edx
+  8009a2:	89 0a                	mov    %ecx,(%edx)
+  8009a4:	8b 00                	mov    (%eax),%eax
+  8009a6:	99                   	cltd   
+    }
+}
+  8009a7:	5d                   	pop    %ebp
+  8009a8:	c3                   	ret    
+
+008009a9 <printfmt>:
+ * @putch:      specified putch function, print a single character
+ * @putdat:     used by @putch function
+ * @fmt:        the format string to use
+ * */
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...) {
+  8009a9:	55                   	push   %ebp
+  8009aa:	89 e5                	mov    %esp,%ebp
+  8009ac:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  8009af:	8d 45 14             	lea    0x14(%ebp),%eax
+  8009b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    vprintfmt(putch, putdat, fmt, ap);
+  8009b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8009b8:	50                   	push   %eax
+  8009b9:	ff 75 10             	pushl  0x10(%ebp)
+  8009bc:	ff 75 0c             	pushl  0xc(%ebp)
+  8009bf:	ff 75 08             	pushl  0x8(%ebp)
+  8009c2:	e8 06 00 00 00       	call   8009cd <vprintfmt>
+  8009c7:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+  8009ca:	90                   	nop
+  8009cb:	c9                   	leave  
+  8009cc:	c3                   	ret    
+
+008009cd <vprintfmt>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want printfmt() instead.
+ * */
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap) {
+  8009cd:	55                   	push   %ebp
+  8009ce:	89 e5                	mov    %esp,%ebp
+  8009d0:	56                   	push   %esi
+  8009d1:	53                   	push   %ebx
+  8009d2:	83 ec 20             	sub    $0x20,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  8009d5:	eb 17                	jmp    8009ee <vprintfmt+0x21>
+            if (ch == '\0') {
+  8009d7:	85 db                	test   %ebx,%ebx
+  8009d9:	0f 84 8e 03 00 00    	je     800d6d <vprintfmt+0x3a0>
+                return;
+            }
+            putch(ch, putdat);
+  8009df:	83 ec 08             	sub    $0x8,%esp
+  8009e2:	ff 75 0c             	pushl  0xc(%ebp)
+  8009e5:	53                   	push   %ebx
+  8009e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009e9:	ff d0                	call   *%eax
+  8009eb:	83 c4 10             	add    $0x10,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  8009ee:	8b 45 10             	mov    0x10(%ebp),%eax
+  8009f1:	8d 50 01             	lea    0x1(%eax),%edx
+  8009f4:	89 55 10             	mov    %edx,0x10(%ebp)
+  8009f7:	0f b6 00             	movzbl (%eax),%eax
+  8009fa:	0f b6 d8             	movzbl %al,%ebx
+  8009fd:	83 fb 25             	cmp    $0x25,%ebx
+  800a00:	75 d5                	jne    8009d7 <vprintfmt+0xa>
+            }
+            putch(ch, putdat);
+        }
+
+        // Process a %-escape sequence
+        char padc = ' ';
+  800a02:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+        width = precision = -1;
+  800a06:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+  800a0d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800a10:	89 45 e8             	mov    %eax,-0x18(%ebp)
+        lflag = altflag = 0;
+  800a13:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+  800a1a:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  800a1d:	89 45 e0             	mov    %eax,-0x20(%ebp)
+
+    reswitch:
+        switch (ch = *(unsigned char *)fmt ++) {
+  800a20:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a23:	8d 50 01             	lea    0x1(%eax),%edx
+  800a26:	89 55 10             	mov    %edx,0x10(%ebp)
+  800a29:	0f b6 00             	movzbl (%eax),%eax
+  800a2c:	0f b6 d8             	movzbl %al,%ebx
+  800a2f:	8d 43 dd             	lea    -0x23(%ebx),%eax
+  800a32:	83 f8 55             	cmp    $0x55,%eax
+  800a35:	0f 87 05 03 00 00    	ja     800d40 <vprintfmt+0x373>
+  800a3b:	8b 04 85 a8 11 80 00 	mov    0x8011a8(,%eax,4),%eax
+  800a42:	ff e0                	jmp    *%eax
+
+        // flag to pad on the right
+        case '-':
+            padc = '-';
+  800a44:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+            goto reswitch;
+  800a48:	eb d6                	jmp    800a20 <vprintfmt+0x53>
+
+        // flag to pad with 0's instead of spaces
+        case '0':
+            padc = '0';
+  800a4a:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+            goto reswitch;
+  800a4e:	eb d0                	jmp    800a20 <vprintfmt+0x53>
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  800a50:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+                precision = precision * 10 + ch - '0';
+  800a57:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800a5a:	89 d0                	mov    %edx,%eax
+  800a5c:	c1 e0 02             	shl    $0x2,%eax
+  800a5f:	01 d0                	add    %edx,%eax
+  800a61:	01 c0                	add    %eax,%eax
+  800a63:	01 d8                	add    %ebx,%eax
+  800a65:	83 e8 30             	sub    $0x30,%eax
+  800a68:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+                ch = *fmt;
+  800a6b:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a6e:	0f b6 00             	movzbl (%eax),%eax
+  800a71:	0f be d8             	movsbl %al,%ebx
+                if (ch < '0' || ch > '9') {
+  800a74:	83 fb 2f             	cmp    $0x2f,%ebx
+  800a77:	7e 39                	jle    800ab2 <vprintfmt+0xe5>
+  800a79:	83 fb 39             	cmp    $0x39,%ebx
+  800a7c:	7f 34                	jg     800ab2 <vprintfmt+0xe5>
+            padc = '0';
+            goto reswitch;
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  800a7e:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+                precision = precision * 10 + ch - '0';
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+  800a82:	eb d3                	jmp    800a57 <vprintfmt+0x8a>
+            goto process_precision;
+
+        case '*':
+            precision = va_arg(ap, int);
+  800a84:	8b 45 14             	mov    0x14(%ebp),%eax
+  800a87:	8d 50 04             	lea    0x4(%eax),%edx
+  800a8a:	89 55 14             	mov    %edx,0x14(%ebp)
+  800a8d:	8b 00                	mov    (%eax),%eax
+  800a8f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+            goto process_precision;
+  800a92:	eb 1f                	jmp    800ab3 <vprintfmt+0xe6>
+
+        case '.':
+            if (width < 0)
+  800a94:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800a98:	79 86                	jns    800a20 <vprintfmt+0x53>
+                width = 0;
+  800a9a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+            goto reswitch;
+  800aa1:	e9 7a ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        case '#':
+            altflag = 1;
+  800aa6:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+            goto reswitch;
+  800aad:	e9 6e ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+            goto process_precision;
+  800ab2:	90                   	nop
+        case '#':
+            altflag = 1;
+            goto reswitch;
+
+        process_precision:
+            if (width < 0)
+  800ab3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ab7:	0f 89 63 ff ff ff    	jns    800a20 <vprintfmt+0x53>
+                width = precision, precision = -1;
+  800abd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800ac0:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800ac3:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+            goto reswitch;
+  800aca:	e9 51 ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        // long flag (doubled for long long)
+        case 'l':
+            lflag ++;
+  800acf:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
+            goto reswitch;
+  800ad3:	e9 48 ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        // character
+        case 'c':
+            putch(va_arg(ap, int), putdat);
+  800ad8:	8b 45 14             	mov    0x14(%ebp),%eax
+  800adb:	8d 50 04             	lea    0x4(%eax),%edx
+  800ade:	89 55 14             	mov    %edx,0x14(%ebp)
+  800ae1:	8b 00                	mov    (%eax),%eax
+  800ae3:	83 ec 08             	sub    $0x8,%esp
+  800ae6:	ff 75 0c             	pushl  0xc(%ebp)
+  800ae9:	50                   	push   %eax
+  800aea:	8b 45 08             	mov    0x8(%ebp),%eax
+  800aed:	ff d0                	call   *%eax
+  800aef:	83 c4 10             	add    $0x10,%esp
+            break;
+  800af2:	e9 71 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // error message
+        case 'e':
+            err = va_arg(ap, int);
+  800af7:	8b 45 14             	mov    0x14(%ebp),%eax
+  800afa:	8d 50 04             	lea    0x4(%eax),%edx
+  800afd:	89 55 14             	mov    %edx,0x14(%ebp)
+  800b00:	8b 18                	mov    (%eax),%ebx
+            if (err < 0) {
+  800b02:	85 db                	test   %ebx,%ebx
+  800b04:	79 02                	jns    800b08 <vprintfmt+0x13b>
+                err = -err;
+  800b06:	f7 db                	neg    %ebx
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+  800b08:	83 fb 18             	cmp    $0x18,%ebx
+  800b0b:	7f 0b                	jg     800b18 <vprintfmt+0x14b>
+  800b0d:	8b 34 9d 20 11 80 00 	mov    0x801120(,%ebx,4),%esi
+  800b14:	85 f6                	test   %esi,%esi
+  800b16:	75 19                	jne    800b31 <vprintfmt+0x164>
+                printfmt(putch, putdat, "error %d", err);
+  800b18:	53                   	push   %ebx
+  800b19:	68 95 11 80 00       	push   $0x801195
+  800b1e:	ff 75 0c             	pushl  0xc(%ebp)
+  800b21:	ff 75 08             	pushl  0x8(%ebp)
+  800b24:	e8 80 fe ff ff       	call   8009a9 <printfmt>
+  800b29:	83 c4 10             	add    $0x10,%esp
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+            }
+            break;
+  800b2c:	e9 37 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+                printfmt(putch, putdat, "error %d", err);
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+  800b31:	56                   	push   %esi
+  800b32:	68 9e 11 80 00       	push   $0x80119e
+  800b37:	ff 75 0c             	pushl  0xc(%ebp)
+  800b3a:	ff 75 08             	pushl  0x8(%ebp)
+  800b3d:	e8 67 fe ff ff       	call   8009a9 <printfmt>
+  800b42:	83 c4 10             	add    $0x10,%esp
+            }
+            break;
+  800b45:	e9 1e 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // string
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+  800b4a:	8b 45 14             	mov    0x14(%ebp),%eax
+  800b4d:	8d 50 04             	lea    0x4(%eax),%edx
+  800b50:	89 55 14             	mov    %edx,0x14(%ebp)
+  800b53:	8b 30                	mov    (%eax),%esi
+  800b55:	85 f6                	test   %esi,%esi
+  800b57:	75 05                	jne    800b5e <vprintfmt+0x191>
+                p = "(null)";
+  800b59:	be a1 11 80 00       	mov    $0x8011a1,%esi
+            }
+            if (width > 0 && padc != '-') {
+  800b5e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800b62:	7e 76                	jle    800bda <vprintfmt+0x20d>
+  800b64:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+  800b68:	74 70                	je     800bda <vprintfmt+0x20d>
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  800b6a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800b6d:	83 ec 08             	sub    $0x8,%esp
+  800b70:	50                   	push   %eax
+  800b71:	56                   	push   %esi
+  800b72:	e8 17 f8 ff ff       	call   80038e <strnlen>
+  800b77:	83 c4 10             	add    $0x10,%esp
+  800b7a:	89 c2                	mov    %eax,%edx
+  800b7c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800b7f:	29 d0                	sub    %edx,%eax
+  800b81:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800b84:	eb 17                	jmp    800b9d <vprintfmt+0x1d0>
+                    putch(padc, putdat);
+  800b86:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+  800b8a:	83 ec 08             	sub    $0x8,%esp
+  800b8d:	ff 75 0c             	pushl  0xc(%ebp)
+  800b90:	50                   	push   %eax
+  800b91:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b94:	ff d0                	call   *%eax
+  800b96:	83 c4 10             	add    $0x10,%esp
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+                p = "(null)";
+            }
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  800b99:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800b9d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ba1:	7f e3                	jg     800b86 <vprintfmt+0x1b9>
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  800ba3:	eb 35                	jmp    800bda <vprintfmt+0x20d>
+                if (altflag && (ch < ' ' || ch > '~')) {
+  800ba5:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+  800ba9:	74 1c                	je     800bc7 <vprintfmt+0x1fa>
+  800bab:	83 fb 1f             	cmp    $0x1f,%ebx
+  800bae:	7e 05                	jle    800bb5 <vprintfmt+0x1e8>
+  800bb0:	83 fb 7e             	cmp    $0x7e,%ebx
+  800bb3:	7e 12                	jle    800bc7 <vprintfmt+0x1fa>
+                    putch('?', putdat);
+  800bb5:	83 ec 08             	sub    $0x8,%esp
+  800bb8:	ff 75 0c             	pushl  0xc(%ebp)
+  800bbb:	6a 3f                	push   $0x3f
+  800bbd:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bc0:	ff d0                	call   *%eax
+  800bc2:	83 c4 10             	add    $0x10,%esp
+  800bc5:	eb 0f                	jmp    800bd6 <vprintfmt+0x209>
+                }
+                else {
+                    putch(ch, putdat);
+  800bc7:	83 ec 08             	sub    $0x8,%esp
+  800bca:	ff 75 0c             	pushl  0xc(%ebp)
+  800bcd:	53                   	push   %ebx
+  800bce:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bd1:	ff d0                	call   *%eax
+  800bd3:	83 c4 10             	add    $0x10,%esp
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  800bd6:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800bda:	89 f0                	mov    %esi,%eax
+  800bdc:	8d 70 01             	lea    0x1(%eax),%esi
+  800bdf:	0f b6 00             	movzbl (%eax),%eax
+  800be2:	0f be d8             	movsbl %al,%ebx
+  800be5:	85 db                	test   %ebx,%ebx
+  800be7:	74 26                	je     800c0f <vprintfmt+0x242>
+  800be9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800bed:	78 b6                	js     800ba5 <vprintfmt+0x1d8>
+  800bef:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800bf3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800bf7:	79 ac                	jns    800ba5 <vprintfmt+0x1d8>
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  800bf9:	eb 14                	jmp    800c0f <vprintfmt+0x242>
+                putch(' ', putdat);
+  800bfb:	83 ec 08             	sub    $0x8,%esp
+  800bfe:	ff 75 0c             	pushl  0xc(%ebp)
+  800c01:	6a 20                	push   $0x20
+  800c03:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c06:	ff d0                	call   *%eax
+  800c08:	83 c4 10             	add    $0x10,%esp
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  800c0b:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800c0f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800c13:	7f e6                	jg     800bfb <vprintfmt+0x22e>
+                putch(' ', putdat);
+            }
+            break;
+  800c15:	e9 4e 01 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // (signed) decimal
+        case 'd':
+            num = getint(&ap, lflag);
+  800c1a:	83 ec 08             	sub    $0x8,%esp
+  800c1d:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c20:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c23:	50                   	push   %eax
+  800c24:	e8 39 fd ff ff       	call   800962 <getint>
+  800c29:	83 c4 10             	add    $0x10,%esp
+  800c2c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c2f:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            if ((long long)num < 0) {
+  800c32:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c35:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800c38:	85 d2                	test   %edx,%edx
+  800c3a:	79 23                	jns    800c5f <vprintfmt+0x292>
+                putch('-', putdat);
+  800c3c:	83 ec 08             	sub    $0x8,%esp
+  800c3f:	ff 75 0c             	pushl  0xc(%ebp)
+  800c42:	6a 2d                	push   $0x2d
+  800c44:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c47:	ff d0                	call   *%eax
+  800c49:	83 c4 10             	add    $0x10,%esp
+                num = -(long long)num;
+  800c4c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c4f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800c52:	f7 d8                	neg    %eax
+  800c54:	83 d2 00             	adc    $0x0,%edx
+  800c57:	f7 da                	neg    %edx
+  800c59:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c5c:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            }
+            base = 10;
+  800c5f:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  800c66:	e9 9f 00 00 00       	jmp    800d0a <vprintfmt+0x33d>
+
+        // unsigned decimal
+        case 'u':
+            num = getuint(&ap, lflag);
+  800c6b:	83 ec 08             	sub    $0x8,%esp
+  800c6e:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c71:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c74:	50                   	push   %eax
+  800c75:	e8 99 fc ff ff       	call   800913 <getuint>
+  800c7a:	83 c4 10             	add    $0x10,%esp
+  800c7d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c80:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 10;
+  800c83:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  800c8a:	eb 7e                	jmp    800d0a <vprintfmt+0x33d>
+
+        // (unsigned) octal
+        case 'o':
+            num = getuint(&ap, lflag);
+  800c8c:	83 ec 08             	sub    $0x8,%esp
+  800c8f:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c92:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c95:	50                   	push   %eax
+  800c96:	e8 78 fc ff ff       	call   800913 <getuint>
+  800c9b:	83 c4 10             	add    $0x10,%esp
+  800c9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800ca1:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 8;
+  800ca4:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+            goto number;
+  800cab:	eb 5d                	jmp    800d0a <vprintfmt+0x33d>
+
+        // pointer
+        case 'p':
+            putch('0', putdat);
+  800cad:	83 ec 08             	sub    $0x8,%esp
+  800cb0:	ff 75 0c             	pushl  0xc(%ebp)
+  800cb3:	6a 30                	push   $0x30
+  800cb5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cb8:	ff d0                	call   *%eax
+  800cba:	83 c4 10             	add    $0x10,%esp
+            putch('x', putdat);
+  800cbd:	83 ec 08             	sub    $0x8,%esp
+  800cc0:	ff 75 0c             	pushl  0xc(%ebp)
+  800cc3:	6a 78                	push   $0x78
+  800cc5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cc8:	ff d0                	call   *%eax
+  800cca:	83 c4 10             	add    $0x10,%esp
+            num = (unsigned long long)(uintptr_t)va_arg(ap, void *);
+  800ccd:	8b 45 14             	mov    0x14(%ebp),%eax
+  800cd0:	8d 50 04             	lea    0x4(%eax),%edx
+  800cd3:	89 55 14             	mov    %edx,0x14(%ebp)
+  800cd6:	8b 00                	mov    (%eax),%eax
+  800cd8:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800cdb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+            base = 16;
+  800ce2:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+            goto number;
+  800ce9:	eb 1f                	jmp    800d0a <vprintfmt+0x33d>
+
+        // (unsigned) hexadecimal
+        case 'x':
+            num = getuint(&ap, lflag);
+  800ceb:	83 ec 08             	sub    $0x8,%esp
+  800cee:	ff 75 e0             	pushl  -0x20(%ebp)
+  800cf1:	8d 45 14             	lea    0x14(%ebp),%eax
+  800cf4:	50                   	push   %eax
+  800cf5:	e8 19 fc ff ff       	call   800913 <getuint>
+  800cfa:	83 c4 10             	add    $0x10,%esp
+  800cfd:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800d00:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 16;
+  800d03:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+        number:
+            printnum(putch, putdat, num, base, width, padc);
+  800d0a:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+  800d0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800d11:	83 ec 04             	sub    $0x4,%esp
+  800d14:	52                   	push   %edx
+  800d15:	ff 75 e8             	pushl  -0x18(%ebp)
+  800d18:	50                   	push   %eax
+  800d19:	ff 75 f4             	pushl  -0xc(%ebp)
+  800d1c:	ff 75 f0             	pushl  -0x10(%ebp)
+  800d1f:	ff 75 0c             	pushl  0xc(%ebp)
+  800d22:	ff 75 08             	pushl  0x8(%ebp)
+  800d25:	e8 f8 fa ff ff       	call   800822 <printnum>
+  800d2a:	83 c4 20             	add    $0x20,%esp
+            break;
+  800d2d:	eb 39                	jmp    800d68 <vprintfmt+0x39b>
+
+        // escaped '%' character
+        case '%':
+            putch(ch, putdat);
+  800d2f:	83 ec 08             	sub    $0x8,%esp
+  800d32:	ff 75 0c             	pushl  0xc(%ebp)
+  800d35:	53                   	push   %ebx
+  800d36:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d39:	ff d0                	call   *%eax
+  800d3b:	83 c4 10             	add    $0x10,%esp
+            break;
+  800d3e:	eb 28                	jmp    800d68 <vprintfmt+0x39b>
+
+        // unrecognized escape sequence - just print it literally
+        default:
+            putch('%', putdat);
+  800d40:	83 ec 08             	sub    $0x8,%esp
+  800d43:	ff 75 0c             	pushl  0xc(%ebp)
+  800d46:	6a 25                	push   $0x25
+  800d48:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d4b:	ff d0                	call   *%eax
+  800d4d:	83 c4 10             	add    $0x10,%esp
+            for (fmt --; fmt[-1] != '%'; fmt --)
+  800d50:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800d54:	eb 04                	jmp    800d5a <vprintfmt+0x38d>
+  800d56:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800d5a:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d5d:	83 e8 01             	sub    $0x1,%eax
+  800d60:	0f b6 00             	movzbl (%eax),%eax
+  800d63:	3c 25                	cmp    $0x25,%al
+  800d65:	75 ef                	jne    800d56 <vprintfmt+0x389>
+                /* do nothing */;
+            break;
+  800d67:	90                   	nop
+        }
+    }
+  800d68:	e9 68 fc ff ff       	jmp    8009d5 <vprintfmt+0x8>
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+            if (ch == '\0') {
+                return;
+  800d6d:	90                   	nop
+            for (fmt --; fmt[-1] != '%'; fmt --)
+                /* do nothing */;
+            break;
+        }
+    }
+}
+  800d6e:	8d 65 f8             	lea    -0x8(%ebp),%esp
+  800d71:	5b                   	pop    %ebx
+  800d72:	5e                   	pop    %esi
+  800d73:	5d                   	pop    %ebp
+  800d74:	c3                   	ret    
+
+00800d75 <sprintputch>:
+ * sprintputch - 'print' a single character in a buffer
+ * @ch:         the character will be printed
+ * @b:          the buffer to place the character @ch
+ * */
+static void
+sprintputch(int ch, struct sprintbuf *b) {
+  800d75:	55                   	push   %ebp
+  800d76:	89 e5                	mov    %esp,%ebp
+    b->cnt ++;
+  800d78:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d7b:	8b 40 08             	mov    0x8(%eax),%eax
+  800d7e:	8d 50 01             	lea    0x1(%eax),%edx
+  800d81:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d84:	89 50 08             	mov    %edx,0x8(%eax)
+    if (b->buf < b->ebuf) {
+  800d87:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8a:	8b 10                	mov    (%eax),%edx
+  800d8c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8f:	8b 40 04             	mov    0x4(%eax),%eax
+  800d92:	39 c2                	cmp    %eax,%edx
+  800d94:	73 12                	jae    800da8 <sprintputch+0x33>
+        *b->buf ++ = ch;
+  800d96:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d99:	8b 00                	mov    (%eax),%eax
+  800d9b:	8d 48 01             	lea    0x1(%eax),%ecx
+  800d9e:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800da1:	89 0a                	mov    %ecx,(%edx)
+  800da3:	8b 55 08             	mov    0x8(%ebp),%edx
+  800da6:	88 10                	mov    %dl,(%eax)
+    }
+}
+  800da8:	90                   	nop
+  800da9:	5d                   	pop    %ebp
+  800daa:	c3                   	ret    
+
+00800dab <snprintf>:
+ * @str:        the buffer to place the result into
+ * @size:       the size of buffer, including the trailing null space
+ * @fmt:        the format string to use
+ * */
+int
+snprintf(char *str, size_t size, const char *fmt, ...) {
+  800dab:	55                   	push   %ebp
+  800dac:	89 e5                	mov    %esp,%ebp
+  800dae:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    int cnt;
+    va_start(ap, fmt);
+  800db1:	8d 45 14             	lea    0x14(%ebp),%eax
+  800db4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    cnt = vsnprintf(str, size, fmt, ap);
+  800db7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800dba:	50                   	push   %eax
+  800dbb:	ff 75 10             	pushl  0x10(%ebp)
+  800dbe:	ff 75 0c             	pushl  0xc(%ebp)
+  800dc1:	ff 75 08             	pushl  0x8(%ebp)
+  800dc4:	e8 0b 00 00 00       	call   800dd4 <vsnprintf>
+  800dc9:	83 c4 10             	add    $0x10,%esp
+  800dcc:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+    return cnt;
+  800dcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800dd2:	c9                   	leave  
+  800dd3:	c3                   	ret    
+
+00800dd4 <vsnprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want snprintf() instead.
+ * */
+int
+vsnprintf(char *str, size_t size, const char *fmt, va_list ap) {
+  800dd4:	55                   	push   %ebp
+  800dd5:	89 e5                	mov    %esp,%ebp
+  800dd7:	83 ec 18             	sub    $0x18,%esp
+    struct sprintbuf b = {str, str + size - 1, 0};
+  800dda:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ddd:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800de0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800de3:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800de6:	8b 45 08             	mov    0x8(%ebp),%eax
+  800de9:	01 d0                	add    %edx,%eax
+  800deb:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800dee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    if (str == NULL || b.buf > b.ebuf) {
+  800df5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  800df9:	74 0a                	je     800e05 <vsnprintf+0x31>
+  800dfb:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  800dfe:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800e01:	39 c2                	cmp    %eax,%edx
+  800e03:	76 07                	jbe    800e0c <vsnprintf+0x38>
+        return -E_INVAL;
+  800e05:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+  800e0a:	eb 20                	jmp    800e2c <vsnprintf+0x58>
+    }
+    // print the string to the buffer
+    vprintfmt((void*)sprintputch, &b, fmt, ap);
+  800e0c:	ff 75 14             	pushl  0x14(%ebp)
+  800e0f:	ff 75 10             	pushl  0x10(%ebp)
+  800e12:	8d 45 ec             	lea    -0x14(%ebp),%eax
+  800e15:	50                   	push   %eax
+  800e16:	68 75 0d 80 00       	push   $0x800d75
+  800e1b:	e8 ad fb ff ff       	call   8009cd <vprintfmt>
+  800e20:	83 c4 10             	add    $0x10,%esp
+    // null terminate the buffer
+    *b.buf = '\0';
+  800e23:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e26:	c6 00 00             	movb   $0x0,(%eax)
+    return b.cnt;
+  800e29:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800e2c:	c9                   	leave  
+  800e2d:	c3                   	ret    
+
+00800e2e <hash32>:
+ * @bits:   the number of bits in a return value
+ *
+ * High bits are more random, so we use them.
+ * */
+uint32_t
+hash32(uint32_t val, unsigned int bits) {
+  800e2e:	55                   	push   %ebp
+  800e2f:	89 e5                	mov    %esp,%ebp
+  800e31:	83 ec 10             	sub    $0x10,%esp
+    uint32_t hash = val * GOLDEN_RATIO_PRIME_32;
+  800e34:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e37:	69 c0 01 00 37 9e    	imul   $0x9e370001,%eax,%eax
+  800e3d:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    return (hash >> (32 - bits));
+  800e40:	b8 20 00 00 00       	mov    $0x20,%eax
+  800e45:	2b 45 0c             	sub    0xc(%ebp),%eax
+  800e48:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  800e4b:	89 c1                	mov    %eax,%ecx
+  800e4d:	d3 ea                	shr    %cl,%edx
+  800e4f:	89 d0                	mov    %edx,%eax
+}
+  800e51:	c9                   	leave  
+  800e52:	c3                   	ret    
+
+00800e53 <rand>:
+ * rand - returns a pseudo-random integer
+ *
+ * The rand() function return a value in the range [0, RAND_MAX].
+ * */
+int
+rand(void) {
+  800e53:	55                   	push   %ebp
+  800e54:	89 e5                	mov    %esp,%ebp
+  800e56:	57                   	push   %edi
+  800e57:	56                   	push   %esi
+  800e58:	53                   	push   %ebx
+  800e59:	83 ec 24             	sub    $0x24,%esp
+    next = (next * 0x5DEECE66DLL + 0xBLL) & ((1LL << 48) - 1);
+  800e5c:	a1 00 20 80 00       	mov    0x802000,%eax
+  800e61:	8b 15 04 20 80 00    	mov    0x802004,%edx
+  800e67:	69 fa 6d e6 ec de    	imul   $0xdeece66d,%edx,%edi
+  800e6d:	6b f0 05             	imul   $0x5,%eax,%esi
+  800e70:	01 fe                	add    %edi,%esi
+  800e72:	bf 6d e6 ec de       	mov    $0xdeece66d,%edi
+  800e77:	f7 e7                	mul    %edi
+  800e79:	01 d6                	add    %edx,%esi
+  800e7b:	89 f2                	mov    %esi,%edx
+  800e7d:	83 c0 0b             	add    $0xb,%eax
+  800e80:	83 d2 00             	adc    $0x0,%edx
+  800e83:	89 c7                	mov    %eax,%edi
+  800e85:	83 e7 ff             	and    $0xffffffff,%edi
+  800e88:	89 f9                	mov    %edi,%ecx
+  800e8a:	0f b7 da             	movzwl %dx,%ebx
+  800e8d:	89 0d 00 20 80 00    	mov    %ecx,0x802000
+  800e93:	89 1d 04 20 80 00    	mov    %ebx,0x802004
+    unsigned long long result = (next >> 12);
+  800e99:	a1 00 20 80 00       	mov    0x802000,%eax
+  800e9e:	8b 15 04 20 80 00    	mov    0x802004,%edx
+  800ea4:	0f ac d0 0c          	shrd   $0xc,%edx,%eax
+  800ea8:	c1 ea 0c             	shr    $0xc,%edx
+  800eab:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800eae:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+    return (int)do_div(result, RAND_MAX + 1);
+  800eb1:	c7 45 dc 00 00 00 80 	movl   $0x80000000,-0x24(%ebp)
+  800eb8:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  800ebb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800ebe:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  800ec1:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  800ec4:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ec7:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800eca:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ece:	74 1c                	je     800eec <rand+0x99>
+  800ed0:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ed3:	ba 00 00 00 00       	mov    $0x0,%edx
+  800ed8:	f7 75 dc             	divl   -0x24(%ebp)
+  800edb:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  800ede:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ee1:	ba 00 00 00 00       	mov    $0x0,%edx
+  800ee6:	f7 75 dc             	divl   -0x24(%ebp)
+  800ee9:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800eec:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  800eef:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  800ef2:	f7 75 dc             	divl   -0x24(%ebp)
+  800ef5:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  800ef8:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  800efb:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  800efe:	8b 55 e8             	mov    -0x18(%ebp),%edx
+  800f01:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800f04:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  800f07:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+}
+  800f0a:	83 c4 24             	add    $0x24,%esp
+  800f0d:	5b                   	pop    %ebx
+  800f0e:	5e                   	pop    %esi
+  800f0f:	5f                   	pop    %edi
+  800f10:	5d                   	pop    %ebp
+  800f11:	c3                   	ret    
+
+00800f12 <srand>:
+/* *
+ * srand - seed the random number generator with the given number
+ * @seed:   the required seed number
+ * */
+void
+srand(unsigned int seed) {
+  800f12:	55                   	push   %ebp
+  800f13:	89 e5                	mov    %esp,%ebp
+    next = seed;
+  800f15:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f18:	ba 00 00 00 00       	mov    $0x0,%edx
+  800f1d:	a3 00 20 80 00       	mov    %eax,0x802000
+  800f22:	89 15 04 20 80 00    	mov    %edx,0x802004
+}
+  800f28:	90                   	nop
+  800f29:	5d                   	pop    %ebp
+  800f2a:	c3                   	ret    
+
+00800f2b <main>:
+#include <stdio.h>
+
+const int max_child = 32;
+
+int
+main(void) {
+  800f2b:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+  800f2f:	83 e4 f0             	and    $0xfffffff0,%esp
+  800f32:	ff 71 fc             	pushl  -0x4(%ecx)
+  800f35:	55                   	push   %ebp
+  800f36:	89 e5                	mov    %esp,%ebp
+  800f38:	51                   	push   %ecx
+  800f39:	83 ec 14             	sub    $0x14,%esp
+    int n, pid;
+    for (n = 0; n < max_child; n ++) {
+  800f3c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  800f43:	eb 4b                	jmp    800f90 <main+0x65>
+        if ((pid = fork()) == 0) {
+  800f45:	e8 93 f2 ff ff       	call   8001dd <fork>
+  800f4a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800f4d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  800f51:	75 1d                	jne    800f70 <main+0x45>
+            cprintf("I am child %d\n", n);
+  800f53:	83 ec 08             	sub    $0x8,%esp
+  800f56:	ff 75 f4             	pushl  -0xc(%ebp)
+  800f59:	68 04 13 80 00       	push   $0x801304
+  800f5e:	e8 76 f3 ff ff       	call   8002d9 <cprintf>
+  800f63:	83 c4 10             	add    $0x10,%esp
+            exit(0);
+  800f66:	83 ec 0c             	sub    $0xc,%esp
+  800f69:	6a 00                	push   $0x0
+  800f6b:	e8 47 f2 ff ff       	call   8001b7 <exit>
+        }
+        assert(pid > 0);
+  800f70:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  800f74:	7f 16                	jg     800f8c <main+0x61>
+  800f76:	68 13 13 80 00       	push   $0x801313
+  800f7b:	68 1b 13 80 00       	push   $0x80131b
+  800f80:	6a 0e                	push   $0xe
+  800f82:	68 30 13 80 00       	push   $0x801330
+  800f87:	e8 94 f0 ff ff       	call   800020 <__panic>
+const int max_child = 32;
+
+int
+main(void) {
+    int n, pid;
+    for (n = 0; n < max_child; n ++) {
+  800f8c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  800f90:	b8 20 00 00 00       	mov    $0x20,%eax
+  800f95:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+  800f98:	7c ab                	jl     800f45 <main+0x1a>
+            exit(0);
+        }
+        assert(pid > 0);
+    }
+
+    if (n > max_child) {
+  800f9a:	b8 20 00 00 00       	mov    $0x20,%eax
+  800f9f:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+  800fa2:	7e 35                	jle    800fd9 <main+0xae>
+        panic("fork claimed to work %d times!\n", n);
+  800fa4:	ff 75 f4             	pushl  -0xc(%ebp)
+  800fa7:	68 40 13 80 00       	push   $0x801340
+  800fac:	6a 12                	push   $0x12
+  800fae:	68 30 13 80 00       	push   $0x801330
+  800fb3:	e8 68 f0 ff ff       	call   800020 <__panic>
+    }
+
+    for (; n > 0; n --) {
+        if (wait() != 0) {
+  800fb8:	e8 2d f2 ff ff       	call   8001ea <wait>
+  800fbd:	85 c0                	test   %eax,%eax
+  800fbf:	74 14                	je     800fd5 <main+0xaa>
+            panic("wait stopped early\n");
+  800fc1:	83 ec 04             	sub    $0x4,%esp
+  800fc4:	68 60 13 80 00       	push   $0x801360
+  800fc9:	6a 17                	push   $0x17
+  800fcb:	68 30 13 80 00       	push   $0x801330
+  800fd0:	e8 4b f0 ff ff       	call   800020 <__panic>
+
+    if (n > max_child) {
+        panic("fork claimed to work %d times!\n", n);
+    }
+
+    for (; n > 0; n --) {
+  800fd5:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+  800fd9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  800fdd:	7f d9                	jg     800fb8 <main+0x8d>
+        if (wait() != 0) {
+            panic("wait stopped early\n");
+        }
+    }
+
+    if (wait() == 0) {
+  800fdf:	e8 06 f2 ff ff       	call   8001ea <wait>
+  800fe4:	85 c0                	test   %eax,%eax
+  800fe6:	75 14                	jne    800ffc <main+0xd1>
+        panic("wait got too many\n");
+  800fe8:	83 ec 04             	sub    $0x4,%esp
+  800feb:	68 74 13 80 00       	push   $0x801374
+  800ff0:	6a 1c                	push   $0x1c
+  800ff2:	68 30 13 80 00       	push   $0x801330
+  800ff7:	e8 24 f0 ff ff       	call   800020 <__panic>
+    }
+
+    cprintf("forktest pass.\n");
+  800ffc:	83 ec 0c             	sub    $0xc,%esp
+  800fff:	68 87 13 80 00       	push   $0x801387
+  801004:	e8 d0 f2 ff ff       	call   8002d9 <cprintf>
+  801009:	83 c4 10             	add    $0x10,%esp
+    return 0;
+  80100c:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  801011:	8b 4d fc             	mov    -0x4(%ebp),%ecx
+  801014:	c9                   	leave  
+  801015:	8d 61 fc             	lea    -0x4(%ecx),%esp
+  801018:	c3                   	ret    
diff -r -u -P lab6_origin/obj/user/forktest.d lab6/obj/user/forktest.d
--- lab6_origin/obj/user/forktest.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/forktest.d	2019-05-13 17:39:38.257115700 +0800
@@ -0,0 +1,2 @@
+obj/user/forktest.o obj/user/forktest.d: user/forktest.c user/libs/ulib.h \
+ libs/defs.h libs/stdio.h libs/stdarg.h
Binary files lab6_origin/obj/user/forktest.o and lab6/obj/user/forktest.o differ
diff -r -u -P lab6_origin/obj/user/forktest.sym lab6/obj/user/forktest.sym
--- lab6_origin/obj/user/forktest.sym	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/forktest.sym	2019-05-13 17:39:43.934855700 +0800
@@ -0,0 +1,77 @@
+00800020 .text
+00801020 .rodata
+00802000 .data
+00200000 .stab_info
+00200010 .stab
+00202da1 .stabstr
+00000000 panic.c
+00000000 syscall.c
+008000b5 syscall
+00000000 ulib.c
+00000000 stdio.c
+0080028c cputch
+00000000 umain.c
+00000000 string.c
+00000000 printfmt.c
+00801120 error_string
+00800822 printnum
+00800913 getuint
+00800962 getint
+00800d75 sprintputch
+00000000 hash.c
+00000000 rand.c
+00802000 next
+00000000 forktest.c
+008003be strcpy
+0080021a yield
+00800201 waitpid
+00800141 sys_yield
+008006d7 memmove
+00800dab snprintf
+008009cd vprintfmt
+0080011d sys_fork
+008002d9 cprintf
+0080023e getpid
+0080077a memcpy
+00800266 lab6_set_priority
+00800dd4 vsnprintf
+0080034d umain
+00202da0 __STAB_END__
+00800150 sys_kill
+00202da1 __STABSTR_BEGIN__
+00800020 __panic
+00801300 max_child
+0080053a strtol
+0080038e strnlen
+0080024b print_pgdir
+00800228 kill
+0080050b strfind
+008001ea wait
+0080027d _start
+00800e53 rand
+00800482 strncmp
+00800171 sys_putc
+008003fe strncpy
+008007ca memcmp
+008001dd fork
+00800697 memset
+00800f2b main
+00800f12 srand
+00800e2e hash32
+008009a9 printfmt
+00203ba5 __STABSTR_END__
+00800438 strcmp
+00800259 gettime_msec
+00800192 sys_gettime
+008002b0 vcprintf
+0080006e __warn
+008002ff cputs
+008001a1 sys_lab6_set_priority
+008001b7 exit
+0080012c sys_wait
+0080010b sys_exit
+00200010 __STAB_BEGIN__
+00800366 strlen
+00800183 sys_pgdir
+008004d8 strchr
+00800162 sys_getpid
diff -r -u -P lab6_origin/obj/user/forktree.asm lab6/obj/user/forktree.asm
--- lab6_origin/obj/user/forktree.asm	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/forktree.asm	2019-05-13 17:39:43.702988800 +0800
@@ -0,0 +1,2679 @@
+
+obj/__user_forktree.out:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00800020 <__panic>:
+#include <stdio.h>
+#include <ulib.h>
+#include <error.h>
+
+void
+__panic(const char *file, int line, const char *fmt, ...) {
+  800020:	55                   	push   %ebp
+  800021:	89 e5                	mov    %esp,%ebp
+  800023:	83 ec 18             	sub    $0x18,%esp
+    // print the 'message'
+    va_list ap;
+    va_start(ap, fmt);
+  800026:	8d 45 14             	lea    0x14(%ebp),%eax
+  800029:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("user panic at %s:%d:\n    ", file, line);
+  80002c:	83 ec 04             	sub    $0x4,%esp
+  80002f:	ff 75 0c             	pushl  0xc(%ebp)
+  800032:	ff 75 08             	pushl  0x8(%ebp)
+  800035:	68 20 10 80 00       	push   $0x801020
+  80003a:	e8 9a 02 00 00       	call   8002d9 <cprintf>
+  80003f:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+  800042:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800045:	83 ec 08             	sub    $0x8,%esp
+  800048:	50                   	push   %eax
+  800049:	ff 75 10             	pushl  0x10(%ebp)
+  80004c:	e8 5f 02 00 00       	call   8002b0 <vcprintf>
+  800051:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+  800054:	83 ec 0c             	sub    $0xc,%esp
+  800057:	68 3a 10 80 00       	push   $0x80103a
+  80005c:	e8 78 02 00 00       	call   8002d9 <cprintf>
+  800061:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+    exit(-E_PANIC);
+  800064:	83 ec 0c             	sub    $0xc,%esp
+  800067:	6a f6                	push   $0xfffffff6
+  800069:	e8 49 01 00 00       	call   8001b7 <exit>
+
+0080006e <__warn>:
+}
+
+void
+__warn(const char *file, int line, const char *fmt, ...) {
+  80006e:	55                   	push   %ebp
+  80006f:	89 e5                	mov    %esp,%ebp
+  800071:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    va_start(ap, fmt);
+  800074:	8d 45 14             	lea    0x14(%ebp),%eax
+  800077:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("user warning at %s:%d:\n    ", file, line);
+  80007a:	83 ec 04             	sub    $0x4,%esp
+  80007d:	ff 75 0c             	pushl  0xc(%ebp)
+  800080:	ff 75 08             	pushl  0x8(%ebp)
+  800083:	68 3c 10 80 00       	push   $0x80103c
+  800088:	e8 4c 02 00 00       	call   8002d9 <cprintf>
+  80008d:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+  800090:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800093:	83 ec 08             	sub    $0x8,%esp
+  800096:	50                   	push   %eax
+  800097:	ff 75 10             	pushl  0x10(%ebp)
+  80009a:	e8 11 02 00 00       	call   8002b0 <vcprintf>
+  80009f:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+  8000a2:	83 ec 0c             	sub    $0xc,%esp
+  8000a5:	68 3a 10 80 00       	push   $0x80103a
+  8000aa:	e8 2a 02 00 00       	call   8002d9 <cprintf>
+  8000af:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+  8000b2:	90                   	nop
+  8000b3:	c9                   	leave  
+  8000b4:	c3                   	ret    
+
+008000b5 <syscall>:
+#include <syscall.h>
+
+#define MAX_ARGS            5
+
+static inline int
+syscall(int num, ...) {
+  8000b5:	55                   	push   %ebp
+  8000b6:	89 e5                	mov    %esp,%ebp
+  8000b8:	57                   	push   %edi
+  8000b9:	56                   	push   %esi
+  8000ba:	53                   	push   %ebx
+  8000bb:	83 ec 20             	sub    $0x20,%esp
+    va_list ap;
+    va_start(ap, num);
+  8000be:	8d 45 0c             	lea    0xc(%ebp),%eax
+  8000c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    uint32_t a[MAX_ARGS];
+    int i, ret;
+    for (i = 0; i < MAX_ARGS; i ++) {
+  8000c4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  8000cb:	eb 16                	jmp    8000e3 <syscall+0x2e>
+        a[i] = va_arg(ap, uint32_t);
+  8000cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8000d0:	8d 50 04             	lea    0x4(%eax),%edx
+  8000d3:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  8000d6:	8b 10                	mov    (%eax),%edx
+  8000d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8000db:	89 54 85 d4          	mov    %edx,-0x2c(%ebp,%eax,4)
+syscall(int num, ...) {
+    va_list ap;
+    va_start(ap, num);
+    uint32_t a[MAX_ARGS];
+    int i, ret;
+    for (i = 0; i < MAX_ARGS; i ++) {
+  8000df:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+  8000e3:	83 7d f0 04          	cmpl   $0x4,-0x10(%ebp)
+  8000e7:	7e e4                	jle    8000cd <syscall+0x18>
+    asm volatile (
+        "int %1;"
+        : "=a" (ret)
+        : "i" (T_SYSCALL),
+          "a" (num),
+          "d" (a[0]),
+  8000e9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+          "c" (a[1]),
+  8000ec:	8b 4d d8             	mov    -0x28(%ebp),%ecx
+          "b" (a[2]),
+  8000ef:	8b 5d dc             	mov    -0x24(%ebp),%ebx
+          "D" (a[3]),
+  8000f2:	8b 7d e0             	mov    -0x20(%ebp),%edi
+          "S" (a[4])
+  8000f5:	8b 75 e4             	mov    -0x1c(%ebp),%esi
+    for (i = 0; i < MAX_ARGS; i ++) {
+        a[i] = va_arg(ap, uint32_t);
+    }
+    va_end(ap);
+
+    asm volatile (
+  8000f8:	8b 45 08             	mov    0x8(%ebp),%eax
+  8000fb:	cd 80                	int    $0x80
+  8000fd:	89 45 ec             	mov    %eax,-0x14(%ebp)
+          "c" (a[1]),
+          "b" (a[2]),
+          "D" (a[3]),
+          "S" (a[4])
+        : "cc", "memory");
+    return ret;
+  800100:	8b 45 ec             	mov    -0x14(%ebp),%eax
+}
+  800103:	83 c4 20             	add    $0x20,%esp
+  800106:	5b                   	pop    %ebx
+  800107:	5e                   	pop    %esi
+  800108:	5f                   	pop    %edi
+  800109:	5d                   	pop    %ebp
+  80010a:	c3                   	ret    
+
+0080010b <sys_exit>:
+
+int
+sys_exit(int error_code) {
+  80010b:	55                   	push   %ebp
+  80010c:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_exit, error_code);
+  80010e:	ff 75 08             	pushl  0x8(%ebp)
+  800111:	6a 01                	push   $0x1
+  800113:	e8 9d ff ff ff       	call   8000b5 <syscall>
+  800118:	83 c4 08             	add    $0x8,%esp
+}
+  80011b:	c9                   	leave  
+  80011c:	c3                   	ret    
+
+0080011d <sys_fork>:
+
+int
+sys_fork(void) {
+  80011d:	55                   	push   %ebp
+  80011e:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_fork);
+  800120:	6a 02                	push   $0x2
+  800122:	e8 8e ff ff ff       	call   8000b5 <syscall>
+  800127:	83 c4 04             	add    $0x4,%esp
+}
+  80012a:	c9                   	leave  
+  80012b:	c3                   	ret    
+
+0080012c <sys_wait>:
+
+int
+sys_wait(int pid, int *store) {
+  80012c:	55                   	push   %ebp
+  80012d:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_wait, pid, store);
+  80012f:	ff 75 0c             	pushl  0xc(%ebp)
+  800132:	ff 75 08             	pushl  0x8(%ebp)
+  800135:	6a 03                	push   $0x3
+  800137:	e8 79 ff ff ff       	call   8000b5 <syscall>
+  80013c:	83 c4 0c             	add    $0xc,%esp
+}
+  80013f:	c9                   	leave  
+  800140:	c3                   	ret    
+
+00800141 <sys_yield>:
+
+int
+sys_yield(void) {
+  800141:	55                   	push   %ebp
+  800142:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_yield);
+  800144:	6a 0a                	push   $0xa
+  800146:	e8 6a ff ff ff       	call   8000b5 <syscall>
+  80014b:	83 c4 04             	add    $0x4,%esp
+}
+  80014e:	c9                   	leave  
+  80014f:	c3                   	ret    
+
+00800150 <sys_kill>:
+
+int
+sys_kill(int pid) {
+  800150:	55                   	push   %ebp
+  800151:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_kill, pid);
+  800153:	ff 75 08             	pushl  0x8(%ebp)
+  800156:	6a 0c                	push   $0xc
+  800158:	e8 58 ff ff ff       	call   8000b5 <syscall>
+  80015d:	83 c4 08             	add    $0x8,%esp
+}
+  800160:	c9                   	leave  
+  800161:	c3                   	ret    
+
+00800162 <sys_getpid>:
+
+int
+sys_getpid(void) {
+  800162:	55                   	push   %ebp
+  800163:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_getpid);
+  800165:	6a 12                	push   $0x12
+  800167:	e8 49 ff ff ff       	call   8000b5 <syscall>
+  80016c:	83 c4 04             	add    $0x4,%esp
+}
+  80016f:	c9                   	leave  
+  800170:	c3                   	ret    
+
+00800171 <sys_putc>:
+
+int
+sys_putc(int c) {
+  800171:	55                   	push   %ebp
+  800172:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_putc, c);
+  800174:	ff 75 08             	pushl  0x8(%ebp)
+  800177:	6a 1e                	push   $0x1e
+  800179:	e8 37 ff ff ff       	call   8000b5 <syscall>
+  80017e:	83 c4 08             	add    $0x8,%esp
+}
+  800181:	c9                   	leave  
+  800182:	c3                   	ret    
+
+00800183 <sys_pgdir>:
+
+int
+sys_pgdir(void) {
+  800183:	55                   	push   %ebp
+  800184:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_pgdir);
+  800186:	6a 1f                	push   $0x1f
+  800188:	e8 28 ff ff ff       	call   8000b5 <syscall>
+  80018d:	83 c4 04             	add    $0x4,%esp
+}
+  800190:	c9                   	leave  
+  800191:	c3                   	ret    
+
+00800192 <sys_gettime>:
+
+int
+sys_gettime(void) {
+  800192:	55                   	push   %ebp
+  800193:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_gettime);
+  800195:	6a 11                	push   $0x11
+  800197:	e8 19 ff ff ff       	call   8000b5 <syscall>
+  80019c:	83 c4 04             	add    $0x4,%esp
+}
+  80019f:	c9                   	leave  
+  8001a0:	c3                   	ret    
+
+008001a1 <sys_lab6_set_priority>:
+
+void
+sys_lab6_set_priority(uint32_t priority)
+{
+  8001a1:	55                   	push   %ebp
+  8001a2:	89 e5                	mov    %esp,%ebp
+    syscall(SYS_lab6_set_priority, priority);
+  8001a4:	ff 75 08             	pushl  0x8(%ebp)
+  8001a7:	68 ff 00 00 00       	push   $0xff
+  8001ac:	e8 04 ff ff ff       	call   8000b5 <syscall>
+  8001b1:	83 c4 08             	add    $0x8,%esp
+}
+  8001b4:	90                   	nop
+  8001b5:	c9                   	leave  
+  8001b6:	c3                   	ret    
+
+008001b7 <exit>:
+#include <syscall.h>
+#include <stdio.h>
+#include <ulib.h>
+
+void
+exit(int error_code) {
+  8001b7:	55                   	push   %ebp
+  8001b8:	89 e5                	mov    %esp,%ebp
+  8001ba:	83 ec 08             	sub    $0x8,%esp
+    sys_exit(error_code);
+  8001bd:	83 ec 0c             	sub    $0xc,%esp
+  8001c0:	ff 75 08             	pushl  0x8(%ebp)
+  8001c3:	e8 43 ff ff ff       	call   80010b <sys_exit>
+  8001c8:	83 c4 10             	add    $0x10,%esp
+    cprintf("BUG: exit failed.\n");
+  8001cb:	83 ec 0c             	sub    $0xc,%esp
+  8001ce:	68 58 10 80 00       	push   $0x801058
+  8001d3:	e8 01 01 00 00       	call   8002d9 <cprintf>
+  8001d8:	83 c4 10             	add    $0x10,%esp
+    while (1);
+  8001db:	eb fe                	jmp    8001db <exit+0x24>
+
+008001dd <fork>:
+}
+
+int
+fork(void) {
+  8001dd:	55                   	push   %ebp
+  8001de:	89 e5                	mov    %esp,%ebp
+  8001e0:	83 ec 08             	sub    $0x8,%esp
+    return sys_fork();
+  8001e3:	e8 35 ff ff ff       	call   80011d <sys_fork>
+}
+  8001e8:	c9                   	leave  
+  8001e9:	c3                   	ret    
+
+008001ea <wait>:
+
+int
+wait(void) {
+  8001ea:	55                   	push   %ebp
+  8001eb:	89 e5                	mov    %esp,%ebp
+  8001ed:	83 ec 08             	sub    $0x8,%esp
+    return sys_wait(0, NULL);
+  8001f0:	83 ec 08             	sub    $0x8,%esp
+  8001f3:	6a 00                	push   $0x0
+  8001f5:	6a 00                	push   $0x0
+  8001f7:	e8 30 ff ff ff       	call   80012c <sys_wait>
+  8001fc:	83 c4 10             	add    $0x10,%esp
+}
+  8001ff:	c9                   	leave  
+  800200:	c3                   	ret    
+
+00800201 <waitpid>:
+
+int
+waitpid(int pid, int *store) {
+  800201:	55                   	push   %ebp
+  800202:	89 e5                	mov    %esp,%ebp
+  800204:	83 ec 08             	sub    $0x8,%esp
+    return sys_wait(pid, store);
+  800207:	83 ec 08             	sub    $0x8,%esp
+  80020a:	ff 75 0c             	pushl  0xc(%ebp)
+  80020d:	ff 75 08             	pushl  0x8(%ebp)
+  800210:	e8 17 ff ff ff       	call   80012c <sys_wait>
+  800215:	83 c4 10             	add    $0x10,%esp
+}
+  800218:	c9                   	leave  
+  800219:	c3                   	ret    
+
+0080021a <yield>:
+
+void
+yield(void) {
+  80021a:	55                   	push   %ebp
+  80021b:	89 e5                	mov    %esp,%ebp
+  80021d:	83 ec 08             	sub    $0x8,%esp
+    sys_yield();
+  800220:	e8 1c ff ff ff       	call   800141 <sys_yield>
+}
+  800225:	90                   	nop
+  800226:	c9                   	leave  
+  800227:	c3                   	ret    
+
+00800228 <kill>:
+
+int
+kill(int pid) {
+  800228:	55                   	push   %ebp
+  800229:	89 e5                	mov    %esp,%ebp
+  80022b:	83 ec 08             	sub    $0x8,%esp
+    return sys_kill(pid);
+  80022e:	83 ec 0c             	sub    $0xc,%esp
+  800231:	ff 75 08             	pushl  0x8(%ebp)
+  800234:	e8 17 ff ff ff       	call   800150 <sys_kill>
+  800239:	83 c4 10             	add    $0x10,%esp
+}
+  80023c:	c9                   	leave  
+  80023d:	c3                   	ret    
+
+0080023e <getpid>:
+
+int
+getpid(void) {
+  80023e:	55                   	push   %ebp
+  80023f:	89 e5                	mov    %esp,%ebp
+  800241:	83 ec 08             	sub    $0x8,%esp
+    return sys_getpid();
+  800244:	e8 19 ff ff ff       	call   800162 <sys_getpid>
+}
+  800249:	c9                   	leave  
+  80024a:	c3                   	ret    
+
+0080024b <print_pgdir>:
+
+//print_pgdir - print the PDT&PT
+void
+print_pgdir(void) {
+  80024b:	55                   	push   %ebp
+  80024c:	89 e5                	mov    %esp,%ebp
+  80024e:	83 ec 08             	sub    $0x8,%esp
+    sys_pgdir();
+  800251:	e8 2d ff ff ff       	call   800183 <sys_pgdir>
+}
+  800256:	90                   	nop
+  800257:	c9                   	leave  
+  800258:	c3                   	ret    
+
+00800259 <gettime_msec>:
+
+unsigned int
+gettime_msec(void) {
+  800259:	55                   	push   %ebp
+  80025a:	89 e5                	mov    %esp,%ebp
+  80025c:	83 ec 08             	sub    $0x8,%esp
+    return (unsigned int)sys_gettime();
+  80025f:	e8 2e ff ff ff       	call   800192 <sys_gettime>
+}
+  800264:	c9                   	leave  
+  800265:	c3                   	ret    
+
+00800266 <lab6_set_priority>:
+
+void
+lab6_set_priority(uint32_t priority)
+{
+  800266:	55                   	push   %ebp
+  800267:	89 e5                	mov    %esp,%ebp
+  800269:	83 ec 08             	sub    $0x8,%esp
+    sys_lab6_set_priority(priority);
+  80026c:	83 ec 0c             	sub    $0xc,%esp
+  80026f:	ff 75 08             	pushl  0x8(%ebp)
+  800272:	e8 2a ff ff ff       	call   8001a1 <sys_lab6_set_priority>
+  800277:	83 c4 10             	add    $0x10,%esp
+}
+  80027a:	90                   	nop
+  80027b:	c9                   	leave  
+  80027c:	c3                   	ret    
+
+0080027d <_start>:
+.text
+.globl _start
+_start:
+    # set ebp for backtrace
+    movl $0x0, %ebp
+  80027d:	bd 00 00 00 00       	mov    $0x0,%ebp
+
+    # move down the esp register
+    # since it may cause page fault in backtrace
+    subl $0x20, %esp
+  800282:	83 ec 20             	sub    $0x20,%esp
+
+    # call user-program function
+    call umain
+  800285:	e8 c3 00 00 00       	call   80034d <umain>
+1:  jmp 1b
+  80028a:	eb fe                	jmp    80028a <_start+0xd>
+
+0080028c <cputch>:
+/* *
+ * cputch - writes a single character @c to stdout, and it will
+ * increace the value of counter pointed by @cnt.
+ * */
+static void
+cputch(int c, int *cnt) {
+  80028c:	55                   	push   %ebp
+  80028d:	89 e5                	mov    %esp,%ebp
+  80028f:	83 ec 08             	sub    $0x8,%esp
+    sys_putc(c);
+  800292:	83 ec 0c             	sub    $0xc,%esp
+  800295:	ff 75 08             	pushl  0x8(%ebp)
+  800298:	e8 d4 fe ff ff       	call   800171 <sys_putc>
+  80029d:	83 c4 10             	add    $0x10,%esp
+    (*cnt) ++;
+  8002a0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002a3:	8b 00                	mov    (%eax),%eax
+  8002a5:	8d 50 01             	lea    0x1(%eax),%edx
+  8002a8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002ab:	89 10                	mov    %edx,(%eax)
+}
+  8002ad:	90                   	nop
+  8002ae:	c9                   	leave  
+  8002af:	c3                   	ret    
+
+008002b0 <vcprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want cprintf() instead.
+ * */
+int
+vcprintf(const char *fmt, va_list ap) {
+  8002b0:	55                   	push   %ebp
+  8002b1:	89 e5                	mov    %esp,%ebp
+  8002b3:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+  8002b6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    vprintfmt((void*)cputch, &cnt, fmt, ap);
+  8002bd:	ff 75 0c             	pushl  0xc(%ebp)
+  8002c0:	ff 75 08             	pushl  0x8(%ebp)
+  8002c3:	8d 45 f4             	lea    -0xc(%ebp),%eax
+  8002c6:	50                   	push   %eax
+  8002c7:	68 8c 02 80 00       	push   $0x80028c
+  8002cc:	e8 fc 06 00 00       	call   8009cd <vprintfmt>
+  8002d1:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+  8002d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8002d7:	c9                   	leave  
+  8002d8:	c3                   	ret    
+
+008002d9 <cprintf>:
+ *
+ * The return value is the number of characters which would be
+ * written to stdout.
+ * */
+int
+cprintf(const char *fmt, ...) {
+  8002d9:	55                   	push   %ebp
+  8002da:	89 e5                	mov    %esp,%ebp
+  8002dc:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  8002df:	8d 45 0c             	lea    0xc(%ebp),%eax
+  8002e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    int cnt = vcprintf(fmt, ap);
+  8002e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8002e8:	83 ec 08             	sub    $0x8,%esp
+  8002eb:	50                   	push   %eax
+  8002ec:	ff 75 08             	pushl  0x8(%ebp)
+  8002ef:	e8 bc ff ff ff       	call   8002b0 <vcprintf>
+  8002f4:	83 c4 10             	add    $0x10,%esp
+  8002f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+
+    return cnt;
+  8002fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8002fd:	c9                   	leave  
+  8002fe:	c3                   	ret    
+
+008002ff <cputs>:
+/* *
+ * cputs- writes the string pointed by @str to stdout and
+ * appends a newline character.
+ * */
+int
+cputs(const char *str) {
+  8002ff:	55                   	push   %ebp
+  800300:	89 e5                	mov    %esp,%ebp
+  800302:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+  800305:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    char c;
+    while ((c = *str ++) != '\0') {
+  80030c:	eb 14                	jmp    800322 <cputs+0x23>
+        cputch(c, &cnt);
+  80030e:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
+  800312:	83 ec 08             	sub    $0x8,%esp
+  800315:	8d 55 f0             	lea    -0x10(%ebp),%edx
+  800318:	52                   	push   %edx
+  800319:	50                   	push   %eax
+  80031a:	e8 6d ff ff ff       	call   80028c <cputch>
+  80031f:	83 c4 10             	add    $0x10,%esp
+ * */
+int
+cputs(const char *str) {
+    int cnt = 0;
+    char c;
+    while ((c = *str ++) != '\0') {
+  800322:	8b 45 08             	mov    0x8(%ebp),%eax
+  800325:	8d 50 01             	lea    0x1(%eax),%edx
+  800328:	89 55 08             	mov    %edx,0x8(%ebp)
+  80032b:	0f b6 00             	movzbl (%eax),%eax
+  80032e:	88 45 f7             	mov    %al,-0x9(%ebp)
+  800331:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
+  800335:	75 d7                	jne    80030e <cputs+0xf>
+        cputch(c, &cnt);
+    }
+    cputch('\n', &cnt);
+  800337:	83 ec 08             	sub    $0x8,%esp
+  80033a:	8d 45 f0             	lea    -0x10(%ebp),%eax
+  80033d:	50                   	push   %eax
+  80033e:	6a 0a                	push   $0xa
+  800340:	e8 47 ff ff ff       	call   80028c <cputch>
+  800345:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+  800348:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+  80034b:	c9                   	leave  
+  80034c:	c3                   	ret    
+
+0080034d <umain>:
+#include <ulib.h>
+
+int main(void);
+
+void
+umain(void) {
+  80034d:	55                   	push   %ebp
+  80034e:	89 e5                	mov    %esp,%ebp
+  800350:	83 ec 18             	sub    $0x18,%esp
+    int ret = main();
+  800353:	e8 7c 0c 00 00       	call   800fd4 <main>
+  800358:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    exit(ret);
+  80035b:	83 ec 0c             	sub    $0xc,%esp
+  80035e:	ff 75 f4             	pushl  -0xc(%ebp)
+  800361:	e8 51 fe ff ff       	call   8001b7 <exit>
+
+00800366 <strlen>:
+ * @s:      the input string
+ *
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+  800366:	55                   	push   %ebp
+  800367:	89 e5                	mov    %esp,%ebp
+  800369:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  80036c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (*s ++ != '\0') {
+  800373:	eb 04                	jmp    800379 <strlen+0x13>
+        cnt ++;
+  800375:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+    size_t cnt = 0;
+    while (*s ++ != '\0') {
+  800379:	8b 45 08             	mov    0x8(%ebp),%eax
+  80037c:	8d 50 01             	lea    0x1(%eax),%edx
+  80037f:	89 55 08             	mov    %edx,0x8(%ebp)
+  800382:	0f b6 00             	movzbl (%eax),%eax
+  800385:	84 c0                	test   %al,%al
+  800387:	75 ec                	jne    800375 <strlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  800389:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  80038c:	c9                   	leave  
+  80038d:	c3                   	ret    
+
+0080038e <strnlen>:
+ * The return value is strlen(s), if that is less than @len, or
+ * @len if there is no '\0' character among the first @len characters
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+  80038e:	55                   	push   %ebp
+  80038f:	89 e5                	mov    %esp,%ebp
+  800391:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  800394:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (cnt < len && *s ++ != '\0') {
+  80039b:	eb 04                	jmp    8003a1 <strnlen+0x13>
+        cnt ++;
+  80039d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+    size_t cnt = 0;
+    while (cnt < len && *s ++ != '\0') {
+  8003a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8003a4:	3b 45 0c             	cmp    0xc(%ebp),%eax
+  8003a7:	73 10                	jae    8003b9 <strnlen+0x2b>
+  8003a9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003ac:	8d 50 01             	lea    0x1(%eax),%edx
+  8003af:	89 55 08             	mov    %edx,0x8(%ebp)
+  8003b2:	0f b6 00             	movzbl (%eax),%eax
+  8003b5:	84 c0                	test   %al,%al
+  8003b7:	75 e4                	jne    80039d <strnlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  8003b9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  8003bc:	c9                   	leave  
+  8003bd:	c3                   	ret    
+
+008003be <strcpy>:
+ * To avoid overflows, the size of array pointed by @dst should be long enough to
+ * contain the same string as @src (including the terminating null character), and
+ * should not overlap in memory with @src.
+ * */
+char *
+strcpy(char *dst, const char *src) {
+  8003be:	55                   	push   %ebp
+  8003bf:	89 e5                	mov    %esp,%ebp
+  8003c1:	57                   	push   %edi
+  8003c2:	56                   	push   %esi
+  8003c3:	83 ec 20             	sub    $0x20,%esp
+  8003c6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  8003cc:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8003cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCPY
+#define __HAVE_ARCH_STRCPY
+static inline char *
+__strcpy(char *dst, const char *src) {
+    int d0, d1, d2;
+    asm volatile (
+  8003d2:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  8003d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8003d8:	89 d1                	mov    %edx,%ecx
+  8003da:	89 c2                	mov    %eax,%edx
+  8003dc:	89 ce                	mov    %ecx,%esi
+  8003de:	89 d7                	mov    %edx,%edi
+  8003e0:	ac                   	lods   %ds:(%esi),%al
+  8003e1:	aa                   	stos   %al,%es:(%edi)
+  8003e2:	84 c0                	test   %al,%al
+  8003e4:	75 fa                	jne    8003e0 <strcpy+0x22>
+  8003e6:	89 fa                	mov    %edi,%edx
+  8003e8:	89 f1                	mov    %esi,%ecx
+  8003ea:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  8003ed:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  8003f0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+        "stosb;"
+        "testb %%al, %%al;"
+        "jne 1b;"
+        : "=&S" (d0), "=&D" (d1), "=&a" (d2)
+        : "0" (src), "1" (dst) : "memory");
+    return dst;
+  8003f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCPY
+    return __strcpy(dst, src);
+  8003f6:	90                   	nop
+    char *p = dst;
+    while ((*p ++ = *src ++) != '\0')
+        /* nothing */;
+    return dst;
+#endif /* __HAVE_ARCH_STRCPY */
+}
+  8003f7:	83 c4 20             	add    $0x20,%esp
+  8003fa:	5e                   	pop    %esi
+  8003fb:	5f                   	pop    %edi
+  8003fc:	5d                   	pop    %ebp
+  8003fd:	c3                   	ret    
+
+008003fe <strncpy>:
+ * @len:    maximum number of characters to be copied from @src
+ *
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+  8003fe:	55                   	push   %ebp
+  8003ff:	89 e5                	mov    %esp,%ebp
+  800401:	83 ec 10             	sub    $0x10,%esp
+    char *p = dst;
+  800404:	8b 45 08             	mov    0x8(%ebp),%eax
+  800407:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    while (len > 0) {
+  80040a:	eb 21                	jmp    80042d <strncpy+0x2f>
+        if ((*p = *src) != '\0') {
+  80040c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80040f:	0f b6 10             	movzbl (%eax),%edx
+  800412:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800415:	88 10                	mov    %dl,(%eax)
+  800417:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  80041a:	0f b6 00             	movzbl (%eax),%eax
+  80041d:	84 c0                	test   %al,%al
+  80041f:	74 04                	je     800425 <strncpy+0x27>
+            src ++;
+  800421:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+        }
+        p ++, len --;
+  800425:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800429:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+    char *p = dst;
+    while (len > 0) {
+  80042d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800431:	75 d9                	jne    80040c <strncpy+0xe>
+        if ((*p = *src) != '\0') {
+            src ++;
+        }
+        p ++, len --;
+    }
+    return dst;
+  800433:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800436:	c9                   	leave  
+  800437:	c3                   	ret    
+
+00800438 <strcmp>:
+ * - A value greater than zero indicates that the first character that does
+ *   not match has a greater value in @s1 than in @s2;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+strcmp(const char *s1, const char *s2) {
+  800438:	55                   	push   %ebp
+  800439:	89 e5                	mov    %esp,%ebp
+  80043b:	57                   	push   %edi
+  80043c:	56                   	push   %esi
+  80043d:	83 ec 20             	sub    $0x20,%esp
+  800440:	8b 45 08             	mov    0x8(%ebp),%eax
+  800443:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800446:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800449:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCMP
+#define __HAVE_ARCH_STRCMP
+static inline int
+__strcmp(const char *s1, const char *s2) {
+    int d0, d1, ret;
+    asm volatile (
+  80044c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80044f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800452:	89 d1                	mov    %edx,%ecx
+  800454:	89 c2                	mov    %eax,%edx
+  800456:	89 ce                	mov    %ecx,%esi
+  800458:	89 d7                	mov    %edx,%edi
+  80045a:	ac                   	lods   %ds:(%esi),%al
+  80045b:	ae                   	scas   %es:(%edi),%al
+  80045c:	75 08                	jne    800466 <strcmp+0x2e>
+  80045e:	84 c0                	test   %al,%al
+  800460:	75 f8                	jne    80045a <strcmp+0x22>
+  800462:	31 c0                	xor    %eax,%eax
+  800464:	eb 04                	jmp    80046a <strcmp+0x32>
+  800466:	19 c0                	sbb    %eax,%eax
+  800468:	0c 01                	or     $0x1,%al
+  80046a:	89 fa                	mov    %edi,%edx
+  80046c:	89 f1                	mov    %esi,%ecx
+  80046e:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800471:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  800474:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+        "orb $1, %%al;"
+        "3:"
+        : "=a" (ret), "=&S" (d0), "=&D" (d1)
+        : "1" (s1), "2" (s2)
+        : "memory");
+    return ret;
+  800477:	8b 45 ec             	mov    -0x14(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCMP
+    return __strcmp(s1, s2);
+  80047a:	90                   	nop
+    while (*s1 != '\0' && *s1 == *s2) {
+        s1 ++, s2 ++;
+    }
+    return (int)((unsigned char)*s1 - (unsigned char)*s2);
+#endif /* __HAVE_ARCH_STRCMP */
+}
+  80047b:	83 c4 20             	add    $0x20,%esp
+  80047e:	5e                   	pop    %esi
+  80047f:	5f                   	pop    %edi
+  800480:	5d                   	pop    %ebp
+  800481:	c3                   	ret    
+
+00800482 <strncmp>:
+ * they are equal to each other, it continues with the following pairs until
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+  800482:	55                   	push   %ebp
+  800483:	89 e5                	mov    %esp,%ebp
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  800485:	eb 0c                	jmp    800493 <strncmp+0x11>
+        n --, s1 ++, s2 ++;
+  800487:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  80048b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  80048f:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  800493:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800497:	74 1a                	je     8004b3 <strncmp+0x31>
+  800499:	8b 45 08             	mov    0x8(%ebp),%eax
+  80049c:	0f b6 00             	movzbl (%eax),%eax
+  80049f:	84 c0                	test   %al,%al
+  8004a1:	74 10                	je     8004b3 <strncmp+0x31>
+  8004a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004a6:	0f b6 10             	movzbl (%eax),%edx
+  8004a9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004ac:	0f b6 00             	movzbl (%eax),%eax
+  8004af:	38 c2                	cmp    %al,%dl
+  8004b1:	74 d4                	je     800487 <strncmp+0x5>
+        n --, s1 ++, s2 ++;
+    }
+    return (n == 0) ? 0 : (int)((unsigned char)*s1 - (unsigned char)*s2);
+  8004b3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8004b7:	74 18                	je     8004d1 <strncmp+0x4f>
+  8004b9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004bc:	0f b6 00             	movzbl (%eax),%eax
+  8004bf:	0f b6 d0             	movzbl %al,%edx
+  8004c2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004c5:	0f b6 00             	movzbl (%eax),%eax
+  8004c8:	0f b6 c0             	movzbl %al,%eax
+  8004cb:	29 c2                	sub    %eax,%edx
+  8004cd:	89 d0                	mov    %edx,%eax
+  8004cf:	eb 05                	jmp    8004d6 <strncmp+0x54>
+  8004d1:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  8004d6:	5d                   	pop    %ebp
+  8004d7:	c3                   	ret    
+
+008004d8 <strchr>:
+ *
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+  8004d8:	55                   	push   %ebp
+  8004d9:	89 e5                	mov    %esp,%ebp
+  8004db:	83 ec 04             	sub    $0x4,%esp
+  8004de:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004e1:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  8004e4:	eb 14                	jmp    8004fa <strchr+0x22>
+        if (*s == c) {
+  8004e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004e9:	0f b6 00             	movzbl (%eax),%eax
+  8004ec:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  8004ef:	75 05                	jne    8004f6 <strchr+0x1e>
+            return (char *)s;
+  8004f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004f4:	eb 13                	jmp    800509 <strchr+0x31>
+        }
+        s ++;
+  8004f6:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+    while (*s != '\0') {
+  8004fa:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004fd:	0f b6 00             	movzbl (%eax),%eax
+  800500:	84 c0                	test   %al,%al
+  800502:	75 e2                	jne    8004e6 <strchr+0xe>
+        if (*s == c) {
+            return (char *)s;
+        }
+        s ++;
+    }
+    return NULL;
+  800504:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800509:	c9                   	leave  
+  80050a:	c3                   	ret    
+
+0080050b <strfind>:
+ * The strfind() function is like strchr() except that if @c is
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+  80050b:	55                   	push   %ebp
+  80050c:	89 e5                	mov    %esp,%ebp
+  80050e:	83 ec 04             	sub    $0x4,%esp
+  800511:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800514:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  800517:	eb 0f                	jmp    800528 <strfind+0x1d>
+        if (*s == c) {
+  800519:	8b 45 08             	mov    0x8(%ebp),%eax
+  80051c:	0f b6 00             	movzbl (%eax),%eax
+  80051f:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800522:	74 10                	je     800534 <strfind+0x29>
+            break;
+        }
+        s ++;
+  800524:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+    while (*s != '\0') {
+  800528:	8b 45 08             	mov    0x8(%ebp),%eax
+  80052b:	0f b6 00             	movzbl (%eax),%eax
+  80052e:	84 c0                	test   %al,%al
+  800530:	75 e7                	jne    800519 <strfind+0xe>
+  800532:	eb 01                	jmp    800535 <strfind+0x2a>
+        if (*s == c) {
+            break;
+  800534:	90                   	nop
+        }
+        s ++;
+    }
+    return (char *)s;
+  800535:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800538:	c9                   	leave  
+  800539:	c3                   	ret    
+
+0080053a <strtol>:
+ * an optional "0x" or "0X" prefix.
+ *
+ * The strtol() function returns the converted integral number as a long int value.
+ * */
+long
+strtol(const char *s, char **endptr, int base) {
+  80053a:	55                   	push   %ebp
+  80053b:	89 e5                	mov    %esp,%ebp
+  80053d:	83 ec 10             	sub    $0x10,%esp
+    int neg = 0;
+  800540:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    long val = 0;
+  800547:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  80054e:	eb 04                	jmp    800554 <strtol+0x1a>
+        s ++;
+  800550:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+strtol(const char *s, char **endptr, int base) {
+    int neg = 0;
+    long val = 0;
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  800554:	8b 45 08             	mov    0x8(%ebp),%eax
+  800557:	0f b6 00             	movzbl (%eax),%eax
+  80055a:	3c 20                	cmp    $0x20,%al
+  80055c:	74 f2                	je     800550 <strtol+0x16>
+  80055e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800561:	0f b6 00             	movzbl (%eax),%eax
+  800564:	3c 09                	cmp    $0x9,%al
+  800566:	74 e8                	je     800550 <strtol+0x16>
+        s ++;
+    }
+
+    // plus/minus sign
+    if (*s == '+') {
+  800568:	8b 45 08             	mov    0x8(%ebp),%eax
+  80056b:	0f b6 00             	movzbl (%eax),%eax
+  80056e:	3c 2b                	cmp    $0x2b,%al
+  800570:	75 06                	jne    800578 <strtol+0x3e>
+        s ++;
+  800572:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800576:	eb 15                	jmp    80058d <strtol+0x53>
+    }
+    else if (*s == '-') {
+  800578:	8b 45 08             	mov    0x8(%ebp),%eax
+  80057b:	0f b6 00             	movzbl (%eax),%eax
+  80057e:	3c 2d                	cmp    $0x2d,%al
+  800580:	75 0b                	jne    80058d <strtol+0x53>
+        s ++, neg = 1;
+  800582:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800586:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+    }
+
+    // hex or octal base prefix
+    if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x')) {
+  80058d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800591:	74 06                	je     800599 <strtol+0x5f>
+  800593:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+  800597:	75 24                	jne    8005bd <strtol+0x83>
+  800599:	8b 45 08             	mov    0x8(%ebp),%eax
+  80059c:	0f b6 00             	movzbl (%eax),%eax
+  80059f:	3c 30                	cmp    $0x30,%al
+  8005a1:	75 1a                	jne    8005bd <strtol+0x83>
+  8005a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005a6:	83 c0 01             	add    $0x1,%eax
+  8005a9:	0f b6 00             	movzbl (%eax),%eax
+  8005ac:	3c 78                	cmp    $0x78,%al
+  8005ae:	75 0d                	jne    8005bd <strtol+0x83>
+        s += 2, base = 16;
+  8005b0:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+  8005b4:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+  8005bb:	eb 2a                	jmp    8005e7 <strtol+0xad>
+    }
+    else if (base == 0 && s[0] == '0') {
+  8005bd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8005c1:	75 17                	jne    8005da <strtol+0xa0>
+  8005c3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005c6:	0f b6 00             	movzbl (%eax),%eax
+  8005c9:	3c 30                	cmp    $0x30,%al
+  8005cb:	75 0d                	jne    8005da <strtol+0xa0>
+        s ++, base = 8;
+  8005cd:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  8005d1:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+  8005d8:	eb 0d                	jmp    8005e7 <strtol+0xad>
+    }
+    else if (base == 0) {
+  8005da:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8005de:	75 07                	jne    8005e7 <strtol+0xad>
+        base = 10;
+  8005e0:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+    // digits
+    while (1) {
+        int dig;
+
+        if (*s >= '0' && *s <= '9') {
+  8005e7:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005ea:	0f b6 00             	movzbl (%eax),%eax
+  8005ed:	3c 2f                	cmp    $0x2f,%al
+  8005ef:	7e 1b                	jle    80060c <strtol+0xd2>
+  8005f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005f4:	0f b6 00             	movzbl (%eax),%eax
+  8005f7:	3c 39                	cmp    $0x39,%al
+  8005f9:	7f 11                	jg     80060c <strtol+0xd2>
+            dig = *s - '0';
+  8005fb:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005fe:	0f b6 00             	movzbl (%eax),%eax
+  800601:	0f be c0             	movsbl %al,%eax
+  800604:	83 e8 30             	sub    $0x30,%eax
+  800607:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80060a:	eb 48                	jmp    800654 <strtol+0x11a>
+        }
+        else if (*s >= 'a' && *s <= 'z') {
+  80060c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80060f:	0f b6 00             	movzbl (%eax),%eax
+  800612:	3c 60                	cmp    $0x60,%al
+  800614:	7e 1b                	jle    800631 <strtol+0xf7>
+  800616:	8b 45 08             	mov    0x8(%ebp),%eax
+  800619:	0f b6 00             	movzbl (%eax),%eax
+  80061c:	3c 7a                	cmp    $0x7a,%al
+  80061e:	7f 11                	jg     800631 <strtol+0xf7>
+            dig = *s - 'a' + 10;
+  800620:	8b 45 08             	mov    0x8(%ebp),%eax
+  800623:	0f b6 00             	movzbl (%eax),%eax
+  800626:	0f be c0             	movsbl %al,%eax
+  800629:	83 e8 57             	sub    $0x57,%eax
+  80062c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80062f:	eb 23                	jmp    800654 <strtol+0x11a>
+        }
+        else if (*s >= 'A' && *s <= 'Z') {
+  800631:	8b 45 08             	mov    0x8(%ebp),%eax
+  800634:	0f b6 00             	movzbl (%eax),%eax
+  800637:	3c 40                	cmp    $0x40,%al
+  800639:	7e 3c                	jle    800677 <strtol+0x13d>
+  80063b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80063e:	0f b6 00             	movzbl (%eax),%eax
+  800641:	3c 5a                	cmp    $0x5a,%al
+  800643:	7f 32                	jg     800677 <strtol+0x13d>
+            dig = *s - 'A' + 10;
+  800645:	8b 45 08             	mov    0x8(%ebp),%eax
+  800648:	0f b6 00             	movzbl (%eax),%eax
+  80064b:	0f be c0             	movsbl %al,%eax
+  80064e:	83 e8 37             	sub    $0x37,%eax
+  800651:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+  800654:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800657:	3b 45 10             	cmp    0x10(%ebp),%eax
+  80065a:	7d 1a                	jge    800676 <strtol+0x13c>
+            break;
+        }
+        s ++, val = (val * base) + dig;
+  80065c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800660:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800663:	0f af 45 10          	imul   0x10(%ebp),%eax
+  800667:	89 c2                	mov    %eax,%edx
+  800669:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  80066c:	01 d0                	add    %edx,%eax
+  80066e:	89 45 f8             	mov    %eax,-0x8(%ebp)
+        // we don't properly detect overflow!
+    }
+  800671:	e9 71 ff ff ff       	jmp    8005e7 <strtol+0xad>
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+            break;
+  800676:	90                   	nop
+        }
+        s ++, val = (val * base) + dig;
+        // we don't properly detect overflow!
+    }
+
+    if (endptr) {
+  800677:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  80067b:	74 08                	je     800685 <strtol+0x14b>
+        *endptr = (char *) s;
+  80067d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800680:	8b 55 08             	mov    0x8(%ebp),%edx
+  800683:	89 10                	mov    %edx,(%eax)
+    }
+    return (neg ? -val : val);
+  800685:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+  800689:	74 07                	je     800692 <strtol+0x158>
+  80068b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  80068e:	f7 d8                	neg    %eax
+  800690:	eb 03                	jmp    800695 <strtol+0x15b>
+  800692:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  800695:	c9                   	leave  
+  800696:	c3                   	ret    
+
+00800697 <memset>:
+ * @n:      number of bytes to be set to the value
+ *
+ * The memset() function returns @s.
+ * */
+void *
+memset(void *s, char c, size_t n) {
+  800697:	55                   	push   %ebp
+  800698:	89 e5                	mov    %esp,%ebp
+  80069a:	57                   	push   %edi
+  80069b:	83 ec 24             	sub    $0x24,%esp
+  80069e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006a1:	88 45 d8             	mov    %al,-0x28(%ebp)
+#ifdef __HAVE_ARCH_MEMSET
+    return __memset(s, c, n);
+  8006a4:	0f be 45 d8          	movsbl -0x28(%ebp),%eax
+  8006a8:	8b 55 08             	mov    0x8(%ebp),%edx
+  8006ab:	89 55 f8             	mov    %edx,-0x8(%ebp)
+  8006ae:	88 45 f7             	mov    %al,-0x9(%ebp)
+  8006b1:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_MEMSET
+#define __HAVE_ARCH_MEMSET
+static inline void *
+__memset(void *s, char c, size_t n) {
+    int d0, d1;
+    asm volatile (
+  8006b7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+  8006ba:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
+  8006be:	8b 55 f8             	mov    -0x8(%ebp),%edx
+  8006c1:	89 d7                	mov    %edx,%edi
+  8006c3:	f3 aa                	rep stos %al,%es:(%edi)
+  8006c5:	89 fa                	mov    %edi,%edx
+  8006c7:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  8006ca:	89 55 e8             	mov    %edx,-0x18(%ebp)
+        "rep; stosb;"
+        : "=&c" (d0), "=&D" (d1)
+        : "0" (n), "a" (c), "1" (s)
+        : "memory");
+    return s;
+  8006cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8006d0:	90                   	nop
+    while (n -- > 0) {
+        *p ++ = c;
+    }
+    return s;
+#endif /* __HAVE_ARCH_MEMSET */
+}
+  8006d1:	83 c4 24             	add    $0x24,%esp
+  8006d4:	5f                   	pop    %edi
+  8006d5:	5d                   	pop    %ebp
+  8006d6:	c3                   	ret    
+
+008006d7 <memmove>:
+ * @n:      number of bytes to copy
+ *
+ * The memmove() function returns @dst.
+ * */
+void *
+memmove(void *dst, const void *src, size_t n) {
+  8006d7:	55                   	push   %ebp
+  8006d8:	89 e5                	mov    %esp,%ebp
+  8006da:	57                   	push   %edi
+  8006db:	56                   	push   %esi
+  8006dc:	53                   	push   %ebx
+  8006dd:	83 ec 30             	sub    $0x30,%esp
+  8006e0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8006e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8006e6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  8006ec:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006ef:	89 45 e8             	mov    %eax,-0x18(%ebp)
+
+#ifndef __HAVE_ARCH_MEMMOVE
+#define __HAVE_ARCH_MEMMOVE
+static inline void *
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+  8006f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006f5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  8006f8:	73 42                	jae    80073c <memmove+0x65>
+  8006fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006fd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800700:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800703:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800706:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800709:	89 45 dc             	mov    %eax,-0x24(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  80070c:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  80070f:	c1 e8 02             	shr    $0x2,%eax
+  800712:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  800714:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800717:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80071a:	89 d7                	mov    %edx,%edi
+  80071c:	89 c6                	mov    %eax,%esi
+  80071e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800720:	8b 4d dc             	mov    -0x24(%ebp),%ecx
+  800723:	83 e1 03             	and    $0x3,%ecx
+  800726:	74 02                	je     80072a <memmove+0x53>
+  800728:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  80072a:	89 f0                	mov    %esi,%eax
+  80072c:	89 fa                	mov    %edi,%edx
+  80072e:	89 4d d8             	mov    %ecx,-0x28(%ebp)
+  800731:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  800734:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  800737:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMMOVE
+    return __memmove(dst, src, n);
+  80073a:	eb 36                	jmp    800772 <memmove+0x9b>
+    asm volatile (
+        "std;"
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+  80073c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80073f:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800742:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800745:	01 c2                	add    %eax,%edx
+  800747:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80074a:	8d 48 ff             	lea    -0x1(%eax),%ecx
+  80074d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800750:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+        return __memcpy(dst, src, n);
+    }
+    int d0, d1, d2;
+    asm volatile (
+  800753:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800756:	89 c1                	mov    %eax,%ecx
+  800758:	89 d8                	mov    %ebx,%eax
+  80075a:	89 d6                	mov    %edx,%esi
+  80075c:	89 c7                	mov    %eax,%edi
+  80075e:	fd                   	std    
+  80075f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  800761:	fc                   	cld    
+  800762:	89 f8                	mov    %edi,%eax
+  800764:	89 f2                	mov    %esi,%edx
+  800766:	89 4d cc             	mov    %ecx,-0x34(%ebp)
+  800769:	89 55 c8             	mov    %edx,-0x38(%ebp)
+  80076c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+        : "memory");
+    return dst;
+  80076f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+            *d ++ = *s ++;
+        }
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMMOVE */
+}
+  800772:	83 c4 30             	add    $0x30,%esp
+  800775:	5b                   	pop    %ebx
+  800776:	5e                   	pop    %esi
+  800777:	5f                   	pop    %edi
+  800778:	5d                   	pop    %ebp
+  800779:	c3                   	ret    
+
+0080077a <memcpy>:
+ * it always copies exactly @n bytes. To avoid overflows, the size of arrays pointed
+ * by both @src and @dst, should be at least @n bytes, and should not overlap
+ * (for overlapping memory area, memmove is a safer approach).
+ * */
+void *
+memcpy(void *dst, const void *src, size_t n) {
+  80077a:	55                   	push   %ebp
+  80077b:	89 e5                	mov    %esp,%ebp
+  80077d:	57                   	push   %edi
+  80077e:	56                   	push   %esi
+  80077f:	83 ec 20             	sub    $0x20,%esp
+  800782:	8b 45 08             	mov    0x8(%ebp),%eax
+  800785:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800788:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80078b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80078e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800791:	89 45 ec             	mov    %eax,-0x14(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  800794:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800797:	c1 e8 02             	shr    $0x2,%eax
+  80079a:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  80079c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80079f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8007a2:	89 d7                	mov    %edx,%edi
+  8007a4:	89 c6                	mov    %eax,%esi
+  8007a6:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  8007a8:	8b 4d ec             	mov    -0x14(%ebp),%ecx
+  8007ab:	83 e1 03             	and    $0x3,%ecx
+  8007ae:	74 02                	je     8007b2 <memcpy+0x38>
+  8007b0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  8007b2:	89 f0                	mov    %esi,%eax
+  8007b4:	89 fa                	mov    %edi,%edx
+  8007b6:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  8007b9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  8007bc:	89 45 e0             	mov    %eax,-0x20(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  8007bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMCPY
+    return __memcpy(dst, src, n);
+  8007c2:	90                   	nop
+    while (n -- > 0) {
+        *d ++ = *s ++;
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMCPY */
+}
+  8007c3:	83 c4 20             	add    $0x20,%esp
+  8007c6:	5e                   	pop    %esi
+  8007c7:	5f                   	pop    %edi
+  8007c8:	5d                   	pop    %ebp
+  8007c9:	c3                   	ret    
+
+008007ca <memcmp>:
+ *   match in both memory blocks has a greater value in @v1 than in @v2
+ *   as if evaluated as unsigned char values;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+  8007ca:	55                   	push   %ebp
+  8007cb:	89 e5                	mov    %esp,%ebp
+  8007cd:	83 ec 10             	sub    $0x10,%esp
+    const char *s1 = (const char *)v1;
+  8007d0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8007d3:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    const char *s2 = (const char *)v2;
+  8007d6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8007d9:	89 45 f8             	mov    %eax,-0x8(%ebp)
+    while (n -- > 0) {
+  8007dc:	eb 30                	jmp    80080e <memcmp+0x44>
+        if (*s1 != *s2) {
+  8007de:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8007e1:	0f b6 10             	movzbl (%eax),%edx
+  8007e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8007e7:	0f b6 00             	movzbl (%eax),%eax
+  8007ea:	38 c2                	cmp    %al,%dl
+  8007ec:	74 18                	je     800806 <memcmp+0x3c>
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+  8007ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8007f1:	0f b6 00             	movzbl (%eax),%eax
+  8007f4:	0f b6 d0             	movzbl %al,%edx
+  8007f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8007fa:	0f b6 00             	movzbl (%eax),%eax
+  8007fd:	0f b6 c0             	movzbl %al,%eax
+  800800:	29 c2                	sub    %eax,%edx
+  800802:	89 d0                	mov    %edx,%eax
+  800804:	eb 1a                	jmp    800820 <memcmp+0x56>
+        }
+        s1 ++, s2 ++;
+  800806:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  80080a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+    const char *s1 = (const char *)v1;
+    const char *s2 = (const char *)v2;
+    while (n -- > 0) {
+  80080e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800811:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800814:	89 55 10             	mov    %edx,0x10(%ebp)
+  800817:	85 c0                	test   %eax,%eax
+  800819:	75 c3                	jne    8007de <memcmp+0x14>
+        if (*s1 != *s2) {
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+        }
+        s1 ++, s2 ++;
+    }
+    return 0;
+  80081b:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800820:	c9                   	leave  
+  800821:	c3                   	ret    
+
+00800822 <printnum>:
+ * @width:      maximum number of digits, if the actual width is less than @width, use @padc instead
+ * @padc:       character that padded on the left if the actual width is less than @width
+ * */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+        unsigned long long num, unsigned base, int width, int padc) {
+  800822:	55                   	push   %ebp
+  800823:	89 e5                	mov    %esp,%ebp
+  800825:	83 ec 38             	sub    $0x38,%esp
+  800828:	8b 45 10             	mov    0x10(%ebp),%eax
+  80082b:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  80082e:	8b 45 14             	mov    0x14(%ebp),%eax
+  800831:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+    unsigned long long result = num;
+  800834:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  800837:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  80083a:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  80083d:	89 55 ec             	mov    %edx,-0x14(%ebp)
+    unsigned mod = do_div(result, base);
+  800840:	8b 45 18             	mov    0x18(%ebp),%eax
+  800843:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800846:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800849:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  80084c:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  80084f:	89 55 f0             	mov    %edx,-0x10(%ebp)
+  800852:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800855:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800858:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  80085c:	74 1c                	je     80087a <printnum+0x58>
+  80085e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800861:	ba 00 00 00 00       	mov    $0x0,%edx
+  800866:	f7 75 e4             	divl   -0x1c(%ebp)
+  800869:	89 55 f4             	mov    %edx,-0xc(%ebp)
+  80086c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  80086f:	ba 00 00 00 00       	mov    $0x0,%edx
+  800874:	f7 75 e4             	divl   -0x1c(%ebp)
+  800877:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80087a:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80087d:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800880:	f7 75 e4             	divl   -0x1c(%ebp)
+  800883:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800886:	89 55 dc             	mov    %edx,-0x24(%ebp)
+  800889:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80088c:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  80088f:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800892:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  800895:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  800898:	89 45 d8             	mov    %eax,-0x28(%ebp)
+
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+  80089b:	8b 45 18             	mov    0x18(%ebp),%eax
+  80089e:	ba 00 00 00 00       	mov    $0x0,%edx
+  8008a3:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  8008a6:	77 41                	ja     8008e9 <printnum+0xc7>
+  8008a8:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  8008ab:	72 05                	jb     8008b2 <printnum+0x90>
+  8008ad:	3b 45 d0             	cmp    -0x30(%ebp),%eax
+  8008b0:	77 37                	ja     8008e9 <printnum+0xc7>
+        printnum(putch, putdat, result, base, width - 1, padc);
+  8008b2:	8b 45 1c             	mov    0x1c(%ebp),%eax
+  8008b5:	83 e8 01             	sub    $0x1,%eax
+  8008b8:	83 ec 04             	sub    $0x4,%esp
+  8008bb:	ff 75 20             	pushl  0x20(%ebp)
+  8008be:	50                   	push   %eax
+  8008bf:	ff 75 18             	pushl  0x18(%ebp)
+  8008c2:	ff 75 ec             	pushl  -0x14(%ebp)
+  8008c5:	ff 75 e8             	pushl  -0x18(%ebp)
+  8008c8:	ff 75 0c             	pushl  0xc(%ebp)
+  8008cb:	ff 75 08             	pushl  0x8(%ebp)
+  8008ce:	e8 4f ff ff ff       	call   800822 <printnum>
+  8008d3:	83 c4 20             	add    $0x20,%esp
+  8008d6:	eb 1b                	jmp    8008f3 <printnum+0xd1>
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+            putch(padc, putdat);
+  8008d8:	83 ec 08             	sub    $0x8,%esp
+  8008db:	ff 75 0c             	pushl  0xc(%ebp)
+  8008de:	ff 75 20             	pushl  0x20(%ebp)
+  8008e1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8008e4:	ff d0                	call   *%eax
+  8008e6:	83 c4 10             	add    $0x10,%esp
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+        printnum(putch, putdat, result, base, width - 1, padc);
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+  8008e9:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+  8008ed:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+  8008f1:	7f e5                	jg     8008d8 <printnum+0xb6>
+            putch(padc, putdat);
+    }
+    // then print this (the least significant) digit
+    putch("0123456789abcdef"[mod], putdat);
+  8008f3:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  8008f6:	05 84 11 80 00       	add    $0x801184,%eax
+  8008fb:	0f b6 00             	movzbl (%eax),%eax
+  8008fe:	0f be c0             	movsbl %al,%eax
+  800901:	83 ec 08             	sub    $0x8,%esp
+  800904:	ff 75 0c             	pushl  0xc(%ebp)
+  800907:	50                   	push   %eax
+  800908:	8b 45 08             	mov    0x8(%ebp),%eax
+  80090b:	ff d0                	call   *%eax
+  80090d:	83 c4 10             	add    $0x10,%esp
+}
+  800910:	90                   	nop
+  800911:	c9                   	leave  
+  800912:	c3                   	ret    
+
+00800913 <getuint>:
+ * getuint - get an unsigned int of various possible sizes from a varargs list
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static unsigned long long
+getuint(va_list *ap, int lflag) {
+  800913:	55                   	push   %ebp
+  800914:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  800916:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  80091a:	7e 14                	jle    800930 <getuint+0x1d>
+        return va_arg(*ap, unsigned long long);
+  80091c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80091f:	8b 00                	mov    (%eax),%eax
+  800921:	8d 48 08             	lea    0x8(%eax),%ecx
+  800924:	8b 55 08             	mov    0x8(%ebp),%edx
+  800927:	89 0a                	mov    %ecx,(%edx)
+  800929:	8b 50 04             	mov    0x4(%eax),%edx
+  80092c:	8b 00                	mov    (%eax),%eax
+  80092e:	eb 30                	jmp    800960 <getuint+0x4d>
+    }
+    else if (lflag) {
+  800930:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800934:	74 16                	je     80094c <getuint+0x39>
+        return va_arg(*ap, unsigned long);
+  800936:	8b 45 08             	mov    0x8(%ebp),%eax
+  800939:	8b 00                	mov    (%eax),%eax
+  80093b:	8d 48 04             	lea    0x4(%eax),%ecx
+  80093e:	8b 55 08             	mov    0x8(%ebp),%edx
+  800941:	89 0a                	mov    %ecx,(%edx)
+  800943:	8b 00                	mov    (%eax),%eax
+  800945:	ba 00 00 00 00       	mov    $0x0,%edx
+  80094a:	eb 14                	jmp    800960 <getuint+0x4d>
+    }
+    else {
+        return va_arg(*ap, unsigned int);
+  80094c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80094f:	8b 00                	mov    (%eax),%eax
+  800951:	8d 48 04             	lea    0x4(%eax),%ecx
+  800954:	8b 55 08             	mov    0x8(%ebp),%edx
+  800957:	89 0a                	mov    %ecx,(%edx)
+  800959:	8b 00                	mov    (%eax),%eax
+  80095b:	ba 00 00 00 00       	mov    $0x0,%edx
+    }
+}
+  800960:	5d                   	pop    %ebp
+  800961:	c3                   	ret    
+
+00800962 <getint>:
+ * getint - same as getuint but signed, we can't use getuint because of sign extension
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static long long
+getint(va_list *ap, int lflag) {
+  800962:	55                   	push   %ebp
+  800963:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  800965:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  800969:	7e 14                	jle    80097f <getint+0x1d>
+        return va_arg(*ap, long long);
+  80096b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80096e:	8b 00                	mov    (%eax),%eax
+  800970:	8d 48 08             	lea    0x8(%eax),%ecx
+  800973:	8b 55 08             	mov    0x8(%ebp),%edx
+  800976:	89 0a                	mov    %ecx,(%edx)
+  800978:	8b 50 04             	mov    0x4(%eax),%edx
+  80097b:	8b 00                	mov    (%eax),%eax
+  80097d:	eb 28                	jmp    8009a7 <getint+0x45>
+    }
+    else if (lflag) {
+  80097f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800983:	74 12                	je     800997 <getint+0x35>
+        return va_arg(*ap, long);
+  800985:	8b 45 08             	mov    0x8(%ebp),%eax
+  800988:	8b 00                	mov    (%eax),%eax
+  80098a:	8d 48 04             	lea    0x4(%eax),%ecx
+  80098d:	8b 55 08             	mov    0x8(%ebp),%edx
+  800990:	89 0a                	mov    %ecx,(%edx)
+  800992:	8b 00                	mov    (%eax),%eax
+  800994:	99                   	cltd   
+  800995:	eb 10                	jmp    8009a7 <getint+0x45>
+    }
+    else {
+        return va_arg(*ap, int);
+  800997:	8b 45 08             	mov    0x8(%ebp),%eax
+  80099a:	8b 00                	mov    (%eax),%eax
+  80099c:	8d 48 04             	lea    0x4(%eax),%ecx
+  80099f:	8b 55 08             	mov    0x8(%ebp),%edx
+  8009a2:	89 0a                	mov    %ecx,(%edx)
+  8009a4:	8b 00                	mov    (%eax),%eax
+  8009a6:	99                   	cltd   
+    }
+}
+  8009a7:	5d                   	pop    %ebp
+  8009a8:	c3                   	ret    
+
+008009a9 <printfmt>:
+ * @putch:      specified putch function, print a single character
+ * @putdat:     used by @putch function
+ * @fmt:        the format string to use
+ * */
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...) {
+  8009a9:	55                   	push   %ebp
+  8009aa:	89 e5                	mov    %esp,%ebp
+  8009ac:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  8009af:	8d 45 14             	lea    0x14(%ebp),%eax
+  8009b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    vprintfmt(putch, putdat, fmt, ap);
+  8009b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8009b8:	50                   	push   %eax
+  8009b9:	ff 75 10             	pushl  0x10(%ebp)
+  8009bc:	ff 75 0c             	pushl  0xc(%ebp)
+  8009bf:	ff 75 08             	pushl  0x8(%ebp)
+  8009c2:	e8 06 00 00 00       	call   8009cd <vprintfmt>
+  8009c7:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+  8009ca:	90                   	nop
+  8009cb:	c9                   	leave  
+  8009cc:	c3                   	ret    
+
+008009cd <vprintfmt>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want printfmt() instead.
+ * */
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap) {
+  8009cd:	55                   	push   %ebp
+  8009ce:	89 e5                	mov    %esp,%ebp
+  8009d0:	56                   	push   %esi
+  8009d1:	53                   	push   %ebx
+  8009d2:	83 ec 20             	sub    $0x20,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  8009d5:	eb 17                	jmp    8009ee <vprintfmt+0x21>
+            if (ch == '\0') {
+  8009d7:	85 db                	test   %ebx,%ebx
+  8009d9:	0f 84 8e 03 00 00    	je     800d6d <vprintfmt+0x3a0>
+                return;
+            }
+            putch(ch, putdat);
+  8009df:	83 ec 08             	sub    $0x8,%esp
+  8009e2:	ff 75 0c             	pushl  0xc(%ebp)
+  8009e5:	53                   	push   %ebx
+  8009e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009e9:	ff d0                	call   *%eax
+  8009eb:	83 c4 10             	add    $0x10,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  8009ee:	8b 45 10             	mov    0x10(%ebp),%eax
+  8009f1:	8d 50 01             	lea    0x1(%eax),%edx
+  8009f4:	89 55 10             	mov    %edx,0x10(%ebp)
+  8009f7:	0f b6 00             	movzbl (%eax),%eax
+  8009fa:	0f b6 d8             	movzbl %al,%ebx
+  8009fd:	83 fb 25             	cmp    $0x25,%ebx
+  800a00:	75 d5                	jne    8009d7 <vprintfmt+0xa>
+            }
+            putch(ch, putdat);
+        }
+
+        // Process a %-escape sequence
+        char padc = ' ';
+  800a02:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+        width = precision = -1;
+  800a06:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+  800a0d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800a10:	89 45 e8             	mov    %eax,-0x18(%ebp)
+        lflag = altflag = 0;
+  800a13:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+  800a1a:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  800a1d:	89 45 e0             	mov    %eax,-0x20(%ebp)
+
+    reswitch:
+        switch (ch = *(unsigned char *)fmt ++) {
+  800a20:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a23:	8d 50 01             	lea    0x1(%eax),%edx
+  800a26:	89 55 10             	mov    %edx,0x10(%ebp)
+  800a29:	0f b6 00             	movzbl (%eax),%eax
+  800a2c:	0f b6 d8             	movzbl %al,%ebx
+  800a2f:	8d 43 dd             	lea    -0x23(%ebx),%eax
+  800a32:	83 f8 55             	cmp    $0x55,%eax
+  800a35:	0f 87 05 03 00 00    	ja     800d40 <vprintfmt+0x373>
+  800a3b:	8b 04 85 a8 11 80 00 	mov    0x8011a8(,%eax,4),%eax
+  800a42:	ff e0                	jmp    *%eax
+
+        // flag to pad on the right
+        case '-':
+            padc = '-';
+  800a44:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+            goto reswitch;
+  800a48:	eb d6                	jmp    800a20 <vprintfmt+0x53>
+
+        // flag to pad with 0's instead of spaces
+        case '0':
+            padc = '0';
+  800a4a:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+            goto reswitch;
+  800a4e:	eb d0                	jmp    800a20 <vprintfmt+0x53>
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  800a50:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+                precision = precision * 10 + ch - '0';
+  800a57:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800a5a:	89 d0                	mov    %edx,%eax
+  800a5c:	c1 e0 02             	shl    $0x2,%eax
+  800a5f:	01 d0                	add    %edx,%eax
+  800a61:	01 c0                	add    %eax,%eax
+  800a63:	01 d8                	add    %ebx,%eax
+  800a65:	83 e8 30             	sub    $0x30,%eax
+  800a68:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+                ch = *fmt;
+  800a6b:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a6e:	0f b6 00             	movzbl (%eax),%eax
+  800a71:	0f be d8             	movsbl %al,%ebx
+                if (ch < '0' || ch > '9') {
+  800a74:	83 fb 2f             	cmp    $0x2f,%ebx
+  800a77:	7e 39                	jle    800ab2 <vprintfmt+0xe5>
+  800a79:	83 fb 39             	cmp    $0x39,%ebx
+  800a7c:	7f 34                	jg     800ab2 <vprintfmt+0xe5>
+            padc = '0';
+            goto reswitch;
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  800a7e:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+                precision = precision * 10 + ch - '0';
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+  800a82:	eb d3                	jmp    800a57 <vprintfmt+0x8a>
+            goto process_precision;
+
+        case '*':
+            precision = va_arg(ap, int);
+  800a84:	8b 45 14             	mov    0x14(%ebp),%eax
+  800a87:	8d 50 04             	lea    0x4(%eax),%edx
+  800a8a:	89 55 14             	mov    %edx,0x14(%ebp)
+  800a8d:	8b 00                	mov    (%eax),%eax
+  800a8f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+            goto process_precision;
+  800a92:	eb 1f                	jmp    800ab3 <vprintfmt+0xe6>
+
+        case '.':
+            if (width < 0)
+  800a94:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800a98:	79 86                	jns    800a20 <vprintfmt+0x53>
+                width = 0;
+  800a9a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+            goto reswitch;
+  800aa1:	e9 7a ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        case '#':
+            altflag = 1;
+  800aa6:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+            goto reswitch;
+  800aad:	e9 6e ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+            goto process_precision;
+  800ab2:	90                   	nop
+        case '#':
+            altflag = 1;
+            goto reswitch;
+
+        process_precision:
+            if (width < 0)
+  800ab3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ab7:	0f 89 63 ff ff ff    	jns    800a20 <vprintfmt+0x53>
+                width = precision, precision = -1;
+  800abd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800ac0:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800ac3:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+            goto reswitch;
+  800aca:	e9 51 ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        // long flag (doubled for long long)
+        case 'l':
+            lflag ++;
+  800acf:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
+            goto reswitch;
+  800ad3:	e9 48 ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        // character
+        case 'c':
+            putch(va_arg(ap, int), putdat);
+  800ad8:	8b 45 14             	mov    0x14(%ebp),%eax
+  800adb:	8d 50 04             	lea    0x4(%eax),%edx
+  800ade:	89 55 14             	mov    %edx,0x14(%ebp)
+  800ae1:	8b 00                	mov    (%eax),%eax
+  800ae3:	83 ec 08             	sub    $0x8,%esp
+  800ae6:	ff 75 0c             	pushl  0xc(%ebp)
+  800ae9:	50                   	push   %eax
+  800aea:	8b 45 08             	mov    0x8(%ebp),%eax
+  800aed:	ff d0                	call   *%eax
+  800aef:	83 c4 10             	add    $0x10,%esp
+            break;
+  800af2:	e9 71 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // error message
+        case 'e':
+            err = va_arg(ap, int);
+  800af7:	8b 45 14             	mov    0x14(%ebp),%eax
+  800afa:	8d 50 04             	lea    0x4(%eax),%edx
+  800afd:	89 55 14             	mov    %edx,0x14(%ebp)
+  800b00:	8b 18                	mov    (%eax),%ebx
+            if (err < 0) {
+  800b02:	85 db                	test   %ebx,%ebx
+  800b04:	79 02                	jns    800b08 <vprintfmt+0x13b>
+                err = -err;
+  800b06:	f7 db                	neg    %ebx
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+  800b08:	83 fb 18             	cmp    $0x18,%ebx
+  800b0b:	7f 0b                	jg     800b18 <vprintfmt+0x14b>
+  800b0d:	8b 34 9d 20 11 80 00 	mov    0x801120(,%ebx,4),%esi
+  800b14:	85 f6                	test   %esi,%esi
+  800b16:	75 19                	jne    800b31 <vprintfmt+0x164>
+                printfmt(putch, putdat, "error %d", err);
+  800b18:	53                   	push   %ebx
+  800b19:	68 95 11 80 00       	push   $0x801195
+  800b1e:	ff 75 0c             	pushl  0xc(%ebp)
+  800b21:	ff 75 08             	pushl  0x8(%ebp)
+  800b24:	e8 80 fe ff ff       	call   8009a9 <printfmt>
+  800b29:	83 c4 10             	add    $0x10,%esp
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+            }
+            break;
+  800b2c:	e9 37 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+                printfmt(putch, putdat, "error %d", err);
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+  800b31:	56                   	push   %esi
+  800b32:	68 9e 11 80 00       	push   $0x80119e
+  800b37:	ff 75 0c             	pushl  0xc(%ebp)
+  800b3a:	ff 75 08             	pushl  0x8(%ebp)
+  800b3d:	e8 67 fe ff ff       	call   8009a9 <printfmt>
+  800b42:	83 c4 10             	add    $0x10,%esp
+            }
+            break;
+  800b45:	e9 1e 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // string
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+  800b4a:	8b 45 14             	mov    0x14(%ebp),%eax
+  800b4d:	8d 50 04             	lea    0x4(%eax),%edx
+  800b50:	89 55 14             	mov    %edx,0x14(%ebp)
+  800b53:	8b 30                	mov    (%eax),%esi
+  800b55:	85 f6                	test   %esi,%esi
+  800b57:	75 05                	jne    800b5e <vprintfmt+0x191>
+                p = "(null)";
+  800b59:	be a1 11 80 00       	mov    $0x8011a1,%esi
+            }
+            if (width > 0 && padc != '-') {
+  800b5e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800b62:	7e 76                	jle    800bda <vprintfmt+0x20d>
+  800b64:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+  800b68:	74 70                	je     800bda <vprintfmt+0x20d>
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  800b6a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800b6d:	83 ec 08             	sub    $0x8,%esp
+  800b70:	50                   	push   %eax
+  800b71:	56                   	push   %esi
+  800b72:	e8 17 f8 ff ff       	call   80038e <strnlen>
+  800b77:	83 c4 10             	add    $0x10,%esp
+  800b7a:	89 c2                	mov    %eax,%edx
+  800b7c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800b7f:	29 d0                	sub    %edx,%eax
+  800b81:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800b84:	eb 17                	jmp    800b9d <vprintfmt+0x1d0>
+                    putch(padc, putdat);
+  800b86:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+  800b8a:	83 ec 08             	sub    $0x8,%esp
+  800b8d:	ff 75 0c             	pushl  0xc(%ebp)
+  800b90:	50                   	push   %eax
+  800b91:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b94:	ff d0                	call   *%eax
+  800b96:	83 c4 10             	add    $0x10,%esp
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+                p = "(null)";
+            }
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  800b99:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800b9d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ba1:	7f e3                	jg     800b86 <vprintfmt+0x1b9>
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  800ba3:	eb 35                	jmp    800bda <vprintfmt+0x20d>
+                if (altflag && (ch < ' ' || ch > '~')) {
+  800ba5:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+  800ba9:	74 1c                	je     800bc7 <vprintfmt+0x1fa>
+  800bab:	83 fb 1f             	cmp    $0x1f,%ebx
+  800bae:	7e 05                	jle    800bb5 <vprintfmt+0x1e8>
+  800bb0:	83 fb 7e             	cmp    $0x7e,%ebx
+  800bb3:	7e 12                	jle    800bc7 <vprintfmt+0x1fa>
+                    putch('?', putdat);
+  800bb5:	83 ec 08             	sub    $0x8,%esp
+  800bb8:	ff 75 0c             	pushl  0xc(%ebp)
+  800bbb:	6a 3f                	push   $0x3f
+  800bbd:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bc0:	ff d0                	call   *%eax
+  800bc2:	83 c4 10             	add    $0x10,%esp
+  800bc5:	eb 0f                	jmp    800bd6 <vprintfmt+0x209>
+                }
+                else {
+                    putch(ch, putdat);
+  800bc7:	83 ec 08             	sub    $0x8,%esp
+  800bca:	ff 75 0c             	pushl  0xc(%ebp)
+  800bcd:	53                   	push   %ebx
+  800bce:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bd1:	ff d0                	call   *%eax
+  800bd3:	83 c4 10             	add    $0x10,%esp
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  800bd6:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800bda:	89 f0                	mov    %esi,%eax
+  800bdc:	8d 70 01             	lea    0x1(%eax),%esi
+  800bdf:	0f b6 00             	movzbl (%eax),%eax
+  800be2:	0f be d8             	movsbl %al,%ebx
+  800be5:	85 db                	test   %ebx,%ebx
+  800be7:	74 26                	je     800c0f <vprintfmt+0x242>
+  800be9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800bed:	78 b6                	js     800ba5 <vprintfmt+0x1d8>
+  800bef:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800bf3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800bf7:	79 ac                	jns    800ba5 <vprintfmt+0x1d8>
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  800bf9:	eb 14                	jmp    800c0f <vprintfmt+0x242>
+                putch(' ', putdat);
+  800bfb:	83 ec 08             	sub    $0x8,%esp
+  800bfe:	ff 75 0c             	pushl  0xc(%ebp)
+  800c01:	6a 20                	push   $0x20
+  800c03:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c06:	ff d0                	call   *%eax
+  800c08:	83 c4 10             	add    $0x10,%esp
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  800c0b:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800c0f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800c13:	7f e6                	jg     800bfb <vprintfmt+0x22e>
+                putch(' ', putdat);
+            }
+            break;
+  800c15:	e9 4e 01 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // (signed) decimal
+        case 'd':
+            num = getint(&ap, lflag);
+  800c1a:	83 ec 08             	sub    $0x8,%esp
+  800c1d:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c20:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c23:	50                   	push   %eax
+  800c24:	e8 39 fd ff ff       	call   800962 <getint>
+  800c29:	83 c4 10             	add    $0x10,%esp
+  800c2c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c2f:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            if ((long long)num < 0) {
+  800c32:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c35:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800c38:	85 d2                	test   %edx,%edx
+  800c3a:	79 23                	jns    800c5f <vprintfmt+0x292>
+                putch('-', putdat);
+  800c3c:	83 ec 08             	sub    $0x8,%esp
+  800c3f:	ff 75 0c             	pushl  0xc(%ebp)
+  800c42:	6a 2d                	push   $0x2d
+  800c44:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c47:	ff d0                	call   *%eax
+  800c49:	83 c4 10             	add    $0x10,%esp
+                num = -(long long)num;
+  800c4c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c4f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800c52:	f7 d8                	neg    %eax
+  800c54:	83 d2 00             	adc    $0x0,%edx
+  800c57:	f7 da                	neg    %edx
+  800c59:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c5c:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            }
+            base = 10;
+  800c5f:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  800c66:	e9 9f 00 00 00       	jmp    800d0a <vprintfmt+0x33d>
+
+        // unsigned decimal
+        case 'u':
+            num = getuint(&ap, lflag);
+  800c6b:	83 ec 08             	sub    $0x8,%esp
+  800c6e:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c71:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c74:	50                   	push   %eax
+  800c75:	e8 99 fc ff ff       	call   800913 <getuint>
+  800c7a:	83 c4 10             	add    $0x10,%esp
+  800c7d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c80:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 10;
+  800c83:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  800c8a:	eb 7e                	jmp    800d0a <vprintfmt+0x33d>
+
+        // (unsigned) octal
+        case 'o':
+            num = getuint(&ap, lflag);
+  800c8c:	83 ec 08             	sub    $0x8,%esp
+  800c8f:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c92:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c95:	50                   	push   %eax
+  800c96:	e8 78 fc ff ff       	call   800913 <getuint>
+  800c9b:	83 c4 10             	add    $0x10,%esp
+  800c9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800ca1:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 8;
+  800ca4:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+            goto number;
+  800cab:	eb 5d                	jmp    800d0a <vprintfmt+0x33d>
+
+        // pointer
+        case 'p':
+            putch('0', putdat);
+  800cad:	83 ec 08             	sub    $0x8,%esp
+  800cb0:	ff 75 0c             	pushl  0xc(%ebp)
+  800cb3:	6a 30                	push   $0x30
+  800cb5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cb8:	ff d0                	call   *%eax
+  800cba:	83 c4 10             	add    $0x10,%esp
+            putch('x', putdat);
+  800cbd:	83 ec 08             	sub    $0x8,%esp
+  800cc0:	ff 75 0c             	pushl  0xc(%ebp)
+  800cc3:	6a 78                	push   $0x78
+  800cc5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cc8:	ff d0                	call   *%eax
+  800cca:	83 c4 10             	add    $0x10,%esp
+            num = (unsigned long long)(uintptr_t)va_arg(ap, void *);
+  800ccd:	8b 45 14             	mov    0x14(%ebp),%eax
+  800cd0:	8d 50 04             	lea    0x4(%eax),%edx
+  800cd3:	89 55 14             	mov    %edx,0x14(%ebp)
+  800cd6:	8b 00                	mov    (%eax),%eax
+  800cd8:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800cdb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+            base = 16;
+  800ce2:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+            goto number;
+  800ce9:	eb 1f                	jmp    800d0a <vprintfmt+0x33d>
+
+        // (unsigned) hexadecimal
+        case 'x':
+            num = getuint(&ap, lflag);
+  800ceb:	83 ec 08             	sub    $0x8,%esp
+  800cee:	ff 75 e0             	pushl  -0x20(%ebp)
+  800cf1:	8d 45 14             	lea    0x14(%ebp),%eax
+  800cf4:	50                   	push   %eax
+  800cf5:	e8 19 fc ff ff       	call   800913 <getuint>
+  800cfa:	83 c4 10             	add    $0x10,%esp
+  800cfd:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800d00:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 16;
+  800d03:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+        number:
+            printnum(putch, putdat, num, base, width, padc);
+  800d0a:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+  800d0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800d11:	83 ec 04             	sub    $0x4,%esp
+  800d14:	52                   	push   %edx
+  800d15:	ff 75 e8             	pushl  -0x18(%ebp)
+  800d18:	50                   	push   %eax
+  800d19:	ff 75 f4             	pushl  -0xc(%ebp)
+  800d1c:	ff 75 f0             	pushl  -0x10(%ebp)
+  800d1f:	ff 75 0c             	pushl  0xc(%ebp)
+  800d22:	ff 75 08             	pushl  0x8(%ebp)
+  800d25:	e8 f8 fa ff ff       	call   800822 <printnum>
+  800d2a:	83 c4 20             	add    $0x20,%esp
+            break;
+  800d2d:	eb 39                	jmp    800d68 <vprintfmt+0x39b>
+
+        // escaped '%' character
+        case '%':
+            putch(ch, putdat);
+  800d2f:	83 ec 08             	sub    $0x8,%esp
+  800d32:	ff 75 0c             	pushl  0xc(%ebp)
+  800d35:	53                   	push   %ebx
+  800d36:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d39:	ff d0                	call   *%eax
+  800d3b:	83 c4 10             	add    $0x10,%esp
+            break;
+  800d3e:	eb 28                	jmp    800d68 <vprintfmt+0x39b>
+
+        // unrecognized escape sequence - just print it literally
+        default:
+            putch('%', putdat);
+  800d40:	83 ec 08             	sub    $0x8,%esp
+  800d43:	ff 75 0c             	pushl  0xc(%ebp)
+  800d46:	6a 25                	push   $0x25
+  800d48:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d4b:	ff d0                	call   *%eax
+  800d4d:	83 c4 10             	add    $0x10,%esp
+            for (fmt --; fmt[-1] != '%'; fmt --)
+  800d50:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800d54:	eb 04                	jmp    800d5a <vprintfmt+0x38d>
+  800d56:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800d5a:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d5d:	83 e8 01             	sub    $0x1,%eax
+  800d60:	0f b6 00             	movzbl (%eax),%eax
+  800d63:	3c 25                	cmp    $0x25,%al
+  800d65:	75 ef                	jne    800d56 <vprintfmt+0x389>
+                /* do nothing */;
+            break;
+  800d67:	90                   	nop
+        }
+    }
+  800d68:	e9 68 fc ff ff       	jmp    8009d5 <vprintfmt+0x8>
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+            if (ch == '\0') {
+                return;
+  800d6d:	90                   	nop
+            for (fmt --; fmt[-1] != '%'; fmt --)
+                /* do nothing */;
+            break;
+        }
+    }
+}
+  800d6e:	8d 65 f8             	lea    -0x8(%ebp),%esp
+  800d71:	5b                   	pop    %ebx
+  800d72:	5e                   	pop    %esi
+  800d73:	5d                   	pop    %ebp
+  800d74:	c3                   	ret    
+
+00800d75 <sprintputch>:
+ * sprintputch - 'print' a single character in a buffer
+ * @ch:         the character will be printed
+ * @b:          the buffer to place the character @ch
+ * */
+static void
+sprintputch(int ch, struct sprintbuf *b) {
+  800d75:	55                   	push   %ebp
+  800d76:	89 e5                	mov    %esp,%ebp
+    b->cnt ++;
+  800d78:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d7b:	8b 40 08             	mov    0x8(%eax),%eax
+  800d7e:	8d 50 01             	lea    0x1(%eax),%edx
+  800d81:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d84:	89 50 08             	mov    %edx,0x8(%eax)
+    if (b->buf < b->ebuf) {
+  800d87:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8a:	8b 10                	mov    (%eax),%edx
+  800d8c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8f:	8b 40 04             	mov    0x4(%eax),%eax
+  800d92:	39 c2                	cmp    %eax,%edx
+  800d94:	73 12                	jae    800da8 <sprintputch+0x33>
+        *b->buf ++ = ch;
+  800d96:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d99:	8b 00                	mov    (%eax),%eax
+  800d9b:	8d 48 01             	lea    0x1(%eax),%ecx
+  800d9e:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800da1:	89 0a                	mov    %ecx,(%edx)
+  800da3:	8b 55 08             	mov    0x8(%ebp),%edx
+  800da6:	88 10                	mov    %dl,(%eax)
+    }
+}
+  800da8:	90                   	nop
+  800da9:	5d                   	pop    %ebp
+  800daa:	c3                   	ret    
+
+00800dab <snprintf>:
+ * @str:        the buffer to place the result into
+ * @size:       the size of buffer, including the trailing null space
+ * @fmt:        the format string to use
+ * */
+int
+snprintf(char *str, size_t size, const char *fmt, ...) {
+  800dab:	55                   	push   %ebp
+  800dac:	89 e5                	mov    %esp,%ebp
+  800dae:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    int cnt;
+    va_start(ap, fmt);
+  800db1:	8d 45 14             	lea    0x14(%ebp),%eax
+  800db4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    cnt = vsnprintf(str, size, fmt, ap);
+  800db7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800dba:	50                   	push   %eax
+  800dbb:	ff 75 10             	pushl  0x10(%ebp)
+  800dbe:	ff 75 0c             	pushl  0xc(%ebp)
+  800dc1:	ff 75 08             	pushl  0x8(%ebp)
+  800dc4:	e8 0b 00 00 00       	call   800dd4 <vsnprintf>
+  800dc9:	83 c4 10             	add    $0x10,%esp
+  800dcc:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+    return cnt;
+  800dcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800dd2:	c9                   	leave  
+  800dd3:	c3                   	ret    
+
+00800dd4 <vsnprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want snprintf() instead.
+ * */
+int
+vsnprintf(char *str, size_t size, const char *fmt, va_list ap) {
+  800dd4:	55                   	push   %ebp
+  800dd5:	89 e5                	mov    %esp,%ebp
+  800dd7:	83 ec 18             	sub    $0x18,%esp
+    struct sprintbuf b = {str, str + size - 1, 0};
+  800dda:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ddd:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800de0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800de3:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800de6:	8b 45 08             	mov    0x8(%ebp),%eax
+  800de9:	01 d0                	add    %edx,%eax
+  800deb:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800dee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    if (str == NULL || b.buf > b.ebuf) {
+  800df5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  800df9:	74 0a                	je     800e05 <vsnprintf+0x31>
+  800dfb:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  800dfe:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800e01:	39 c2                	cmp    %eax,%edx
+  800e03:	76 07                	jbe    800e0c <vsnprintf+0x38>
+        return -E_INVAL;
+  800e05:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+  800e0a:	eb 20                	jmp    800e2c <vsnprintf+0x58>
+    }
+    // print the string to the buffer
+    vprintfmt((void*)sprintputch, &b, fmt, ap);
+  800e0c:	ff 75 14             	pushl  0x14(%ebp)
+  800e0f:	ff 75 10             	pushl  0x10(%ebp)
+  800e12:	8d 45 ec             	lea    -0x14(%ebp),%eax
+  800e15:	50                   	push   %eax
+  800e16:	68 75 0d 80 00       	push   $0x800d75
+  800e1b:	e8 ad fb ff ff       	call   8009cd <vprintfmt>
+  800e20:	83 c4 10             	add    $0x10,%esp
+    // null terminate the buffer
+    *b.buf = '\0';
+  800e23:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e26:	c6 00 00             	movb   $0x0,(%eax)
+    return b.cnt;
+  800e29:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800e2c:	c9                   	leave  
+  800e2d:	c3                   	ret    
+
+00800e2e <hash32>:
+ * @bits:   the number of bits in a return value
+ *
+ * High bits are more random, so we use them.
+ * */
+uint32_t
+hash32(uint32_t val, unsigned int bits) {
+  800e2e:	55                   	push   %ebp
+  800e2f:	89 e5                	mov    %esp,%ebp
+  800e31:	83 ec 10             	sub    $0x10,%esp
+    uint32_t hash = val * GOLDEN_RATIO_PRIME_32;
+  800e34:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e37:	69 c0 01 00 37 9e    	imul   $0x9e370001,%eax,%eax
+  800e3d:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    return (hash >> (32 - bits));
+  800e40:	b8 20 00 00 00       	mov    $0x20,%eax
+  800e45:	2b 45 0c             	sub    0xc(%ebp),%eax
+  800e48:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  800e4b:	89 c1                	mov    %eax,%ecx
+  800e4d:	d3 ea                	shr    %cl,%edx
+  800e4f:	89 d0                	mov    %edx,%eax
+}
+  800e51:	c9                   	leave  
+  800e52:	c3                   	ret    
+
+00800e53 <rand>:
+ * rand - returns a pseudo-random integer
+ *
+ * The rand() function return a value in the range [0, RAND_MAX].
+ * */
+int
+rand(void) {
+  800e53:	55                   	push   %ebp
+  800e54:	89 e5                	mov    %esp,%ebp
+  800e56:	57                   	push   %edi
+  800e57:	56                   	push   %esi
+  800e58:	53                   	push   %ebx
+  800e59:	83 ec 24             	sub    $0x24,%esp
+    next = (next * 0x5DEECE66DLL + 0xBLL) & ((1LL << 48) - 1);
+  800e5c:	a1 00 20 80 00       	mov    0x802000,%eax
+  800e61:	8b 15 04 20 80 00    	mov    0x802004,%edx
+  800e67:	69 fa 6d e6 ec de    	imul   $0xdeece66d,%edx,%edi
+  800e6d:	6b f0 05             	imul   $0x5,%eax,%esi
+  800e70:	01 fe                	add    %edi,%esi
+  800e72:	bf 6d e6 ec de       	mov    $0xdeece66d,%edi
+  800e77:	f7 e7                	mul    %edi
+  800e79:	01 d6                	add    %edx,%esi
+  800e7b:	89 f2                	mov    %esi,%edx
+  800e7d:	83 c0 0b             	add    $0xb,%eax
+  800e80:	83 d2 00             	adc    $0x0,%edx
+  800e83:	89 c7                	mov    %eax,%edi
+  800e85:	83 e7 ff             	and    $0xffffffff,%edi
+  800e88:	89 f9                	mov    %edi,%ecx
+  800e8a:	0f b7 da             	movzwl %dx,%ebx
+  800e8d:	89 0d 00 20 80 00    	mov    %ecx,0x802000
+  800e93:	89 1d 04 20 80 00    	mov    %ebx,0x802004
+    unsigned long long result = (next >> 12);
+  800e99:	a1 00 20 80 00       	mov    0x802000,%eax
+  800e9e:	8b 15 04 20 80 00    	mov    0x802004,%edx
+  800ea4:	0f ac d0 0c          	shrd   $0xc,%edx,%eax
+  800ea8:	c1 ea 0c             	shr    $0xc,%edx
+  800eab:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800eae:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+    return (int)do_div(result, RAND_MAX + 1);
+  800eb1:	c7 45 dc 00 00 00 80 	movl   $0x80000000,-0x24(%ebp)
+  800eb8:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  800ebb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800ebe:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  800ec1:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  800ec4:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ec7:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800eca:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ece:	74 1c                	je     800eec <rand+0x99>
+  800ed0:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ed3:	ba 00 00 00 00       	mov    $0x0,%edx
+  800ed8:	f7 75 dc             	divl   -0x24(%ebp)
+  800edb:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  800ede:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ee1:	ba 00 00 00 00       	mov    $0x0,%edx
+  800ee6:	f7 75 dc             	divl   -0x24(%ebp)
+  800ee9:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800eec:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  800eef:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  800ef2:	f7 75 dc             	divl   -0x24(%ebp)
+  800ef5:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  800ef8:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  800efb:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  800efe:	8b 55 e8             	mov    -0x18(%ebp),%edx
+  800f01:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800f04:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  800f07:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+}
+  800f0a:	83 c4 24             	add    $0x24,%esp
+  800f0d:	5b                   	pop    %ebx
+  800f0e:	5e                   	pop    %esi
+  800f0f:	5f                   	pop    %edi
+  800f10:	5d                   	pop    %ebp
+  800f11:	c3                   	ret    
+
+00800f12 <srand>:
+/* *
+ * srand - seed the random number generator with the given number
+ * @seed:   the required seed number
+ * */
+void
+srand(unsigned int seed) {
+  800f12:	55                   	push   %ebp
+  800f13:	89 e5                	mov    %esp,%ebp
+    next = seed;
+  800f15:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f18:	ba 00 00 00 00       	mov    $0x0,%edx
+  800f1d:	a3 00 20 80 00       	mov    %eax,0x802000
+  800f22:	89 15 04 20 80 00    	mov    %edx,0x802004
+}
+  800f28:	90                   	nop
+  800f29:	5d                   	pop    %ebp
+  800f2a:	c3                   	ret    
+
+00800f2b <forkchild>:
+#define DEPTH 4
+
+void forktree(const char *cur);
+
+void
+forkchild(const char *cur, char branch) {
+  800f2b:	55                   	push   %ebp
+  800f2c:	89 e5                	mov    %esp,%ebp
+  800f2e:	83 ec 28             	sub    $0x28,%esp
+  800f31:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800f34:	88 45 e4             	mov    %al,-0x1c(%ebp)
+    char nxt[DEPTH + 1];
+
+    if (strlen(cur) >= DEPTH)
+  800f37:	83 ec 0c             	sub    $0xc,%esp
+  800f3a:	ff 75 08             	pushl  0x8(%ebp)
+  800f3d:	e8 24 f4 ff ff       	call   800366 <strlen>
+  800f42:	83 c4 10             	add    $0x10,%esp
+  800f45:	83 f8 03             	cmp    $0x3,%eax
+  800f48:	77 45                	ja     800f8f <forkchild+0x64>
+        return;
+
+    snprintf(nxt, DEPTH + 1, "%s%c", cur, branch);
+  800f4a:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
+  800f4e:	83 ec 0c             	sub    $0xc,%esp
+  800f51:	50                   	push   %eax
+  800f52:	ff 75 08             	pushl  0x8(%ebp)
+  800f55:	68 00 13 80 00       	push   $0x801300
+  800f5a:	6a 05                	push   $0x5
+  800f5c:	8d 45 f3             	lea    -0xd(%ebp),%eax
+  800f5f:	50                   	push   %eax
+  800f60:	e8 46 fe ff ff       	call   800dab <snprintf>
+  800f65:	83 c4 20             	add    $0x20,%esp
+    if (fork() == 0) {
+  800f68:	e8 70 f2 ff ff       	call   8001dd <fork>
+  800f6d:	85 c0                	test   %eax,%eax
+  800f6f:	75 1f                	jne    800f90 <forkchild+0x65>
+        forktree(nxt);
+  800f71:	83 ec 0c             	sub    $0xc,%esp
+  800f74:	8d 45 f3             	lea    -0xd(%ebp),%eax
+  800f77:	50                   	push   %eax
+  800f78:	e8 15 00 00 00       	call   800f92 <forktree>
+  800f7d:	83 c4 10             	add    $0x10,%esp
+        yield();
+  800f80:	e8 95 f2 ff ff       	call   80021a <yield>
+        exit(0);
+  800f85:	83 ec 0c             	sub    $0xc,%esp
+  800f88:	6a 00                	push   $0x0
+  800f8a:	e8 28 f2 ff ff       	call   8001b7 <exit>
+void
+forkchild(const char *cur, char branch) {
+    char nxt[DEPTH + 1];
+
+    if (strlen(cur) >= DEPTH)
+        return;
+  800f8f:	90                   	nop
+    if (fork() == 0) {
+        forktree(nxt);
+        yield();
+        exit(0);
+    }
+}
+  800f90:	c9                   	leave  
+  800f91:	c3                   	ret    
+
+00800f92 <forktree>:
+
+void
+forktree(const char *cur) {
+  800f92:	55                   	push   %ebp
+  800f93:	89 e5                	mov    %esp,%ebp
+  800f95:	83 ec 08             	sub    $0x8,%esp
+    cprintf("%04x: I am '%s'\n", getpid(), cur);
+  800f98:	e8 a1 f2 ff ff       	call   80023e <getpid>
+  800f9d:	83 ec 04             	sub    $0x4,%esp
+  800fa0:	ff 75 08             	pushl  0x8(%ebp)
+  800fa3:	50                   	push   %eax
+  800fa4:	68 05 13 80 00       	push   $0x801305
+  800fa9:	e8 2b f3 ff ff       	call   8002d9 <cprintf>
+  800fae:	83 c4 10             	add    $0x10,%esp
+
+    forkchild(cur, '0');
+  800fb1:	83 ec 08             	sub    $0x8,%esp
+  800fb4:	6a 30                	push   $0x30
+  800fb6:	ff 75 08             	pushl  0x8(%ebp)
+  800fb9:	e8 6d ff ff ff       	call   800f2b <forkchild>
+  800fbe:	83 c4 10             	add    $0x10,%esp
+    forkchild(cur, '1');
+  800fc1:	83 ec 08             	sub    $0x8,%esp
+  800fc4:	6a 31                	push   $0x31
+  800fc6:	ff 75 08             	pushl  0x8(%ebp)
+  800fc9:	e8 5d ff ff ff       	call   800f2b <forkchild>
+  800fce:	83 c4 10             	add    $0x10,%esp
+}
+  800fd1:	90                   	nop
+  800fd2:	c9                   	leave  
+  800fd3:	c3                   	ret    
+
+00800fd4 <main>:
+
+int
+main(void) {
+  800fd4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+  800fd8:	83 e4 f0             	and    $0xfffffff0,%esp
+  800fdb:	ff 71 fc             	pushl  -0x4(%ecx)
+  800fde:	55                   	push   %ebp
+  800fdf:	89 e5                	mov    %esp,%ebp
+  800fe1:	51                   	push   %ecx
+  800fe2:	83 ec 04             	sub    $0x4,%esp
+    forktree("");
+  800fe5:	83 ec 0c             	sub    $0xc,%esp
+  800fe8:	68 16 13 80 00       	push   $0x801316
+  800fed:	e8 a0 ff ff ff       	call   800f92 <forktree>
+  800ff2:	83 c4 10             	add    $0x10,%esp
+    return 0;
+  800ff5:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800ffa:	8b 4d fc             	mov    -0x4(%ebp),%ecx
+  800ffd:	c9                   	leave  
+  800ffe:	8d 61 fc             	lea    -0x4(%ecx),%esp
+  801001:	c3                   	ret    
diff -r -u -P lab6_origin/obj/user/forktree.d lab6/obj/user/forktree.d
--- lab6_origin/obj/user/forktree.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/forktree.d	2019-05-13 17:39:38.548948300 +0800
@@ -0,0 +1,2 @@
+obj/user/forktree.o obj/user/forktree.d: user/forktree.c user/libs/ulib.h \
+ libs/defs.h libs/stdio.h libs/stdarg.h libs/string.h
Binary files lab6_origin/obj/user/forktree.o and lab6/obj/user/forktree.o differ
diff -r -u -P lab6_origin/obj/user/forktree.sym lab6/obj/user/forktree.sym
--- lab6_origin/obj/user/forktree.sym	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/forktree.sym	2019-05-13 17:39:43.897877000 +0800
@@ -0,0 +1,78 @@
+00800020 .text
+00801020 .rodata
+00802000 .data
+00200000 .stab_info
+00200010 .stab
+00202db9 .stabstr
+00000000 panic.c
+00000000 syscall.c
+008000b5 syscall
+00000000 ulib.c
+00000000 stdio.c
+0080028c cputch
+00000000 umain.c
+00000000 string.c
+00000000 printfmt.c
+00801120 error_string
+00800822 printnum
+00800913 getuint
+00800962 getint
+00800d75 sprintputch
+00000000 hash.c
+00000000 rand.c
+00802000 next
+00000000 forktree.c
+008003be strcpy
+0080021a yield
+00800201 waitpid
+00800141 sys_yield
+008006d7 memmove
+00800dab snprintf
+008009cd vprintfmt
+0080011d sys_fork
+008002d9 cprintf
+0080023e getpid
+0080077a memcpy
+00800266 lab6_set_priority
+00800dd4 vsnprintf
+0080034d umain
+00202db8 __STAB_END__
+00800150 sys_kill
+00202db9 __STABSTR_BEGIN__
+00800020 __panic
+0080053a strtol
+0080038e strnlen
+00800f92 forktree
+0080024b print_pgdir
+00800228 kill
+0080050b strfind
+008001ea wait
+0080027d _start
+00800e53 rand
+00800482 strncmp
+00800171 sys_putc
+008003fe strncpy
+008007ca memcmp
+008001dd fork
+00800697 memset
+00800fd4 main
+00800f12 srand
+00800e2e hash32
+008009a9 printfmt
+00203c2b __STABSTR_END__
+00800438 strcmp
+00800259 gettime_msec
+00800192 sys_gettime
+008002b0 vcprintf
+0080006e __warn
+008002ff cputs
+008001a1 sys_lab6_set_priority
+008001b7 exit
+0080012c sys_wait
+0080010b sys_exit
+00200010 __STAB_BEGIN__
+00800366 strlen
+00800183 sys_pgdir
+008004d8 strchr
+00800162 sys_getpid
+00800f2b forkchild
diff -r -u -P lab6_origin/obj/user/hello.asm lab6/obj/user/hello.asm
--- lab6_origin/obj/user/hello.asm	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/hello.asm	2019-05-13 17:39:43.262241700 +0800
@@ -0,0 +1,2594 @@
+
+obj/__user_hello.out:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00800020 <__panic>:
+#include <stdio.h>
+#include <ulib.h>
+#include <error.h>
+
+void
+__panic(const char *file, int line, const char *fmt, ...) {
+  800020:	55                   	push   %ebp
+  800021:	89 e5                	mov    %esp,%ebp
+  800023:	83 ec 18             	sub    $0x18,%esp
+    // print the 'message'
+    va_list ap;
+    va_start(ap, fmt);
+  800026:	8d 45 14             	lea    0x14(%ebp),%eax
+  800029:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("user panic at %s:%d:\n    ", file, line);
+  80002c:	83 ec 04             	sub    $0x4,%esp
+  80002f:	ff 75 0c             	pushl  0xc(%ebp)
+  800032:	ff 75 08             	pushl  0x8(%ebp)
+  800035:	68 80 0f 80 00       	push   $0x800f80
+  80003a:	e8 9a 02 00 00       	call   8002d9 <cprintf>
+  80003f:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+  800042:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800045:	83 ec 08             	sub    $0x8,%esp
+  800048:	50                   	push   %eax
+  800049:	ff 75 10             	pushl  0x10(%ebp)
+  80004c:	e8 5f 02 00 00       	call   8002b0 <vcprintf>
+  800051:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+  800054:	83 ec 0c             	sub    $0xc,%esp
+  800057:	68 9a 0f 80 00       	push   $0x800f9a
+  80005c:	e8 78 02 00 00       	call   8002d9 <cprintf>
+  800061:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+    exit(-E_PANIC);
+  800064:	83 ec 0c             	sub    $0xc,%esp
+  800067:	6a f6                	push   $0xfffffff6
+  800069:	e8 49 01 00 00       	call   8001b7 <exit>
+
+0080006e <__warn>:
+}
+
+void
+__warn(const char *file, int line, const char *fmt, ...) {
+  80006e:	55                   	push   %ebp
+  80006f:	89 e5                	mov    %esp,%ebp
+  800071:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    va_start(ap, fmt);
+  800074:	8d 45 14             	lea    0x14(%ebp),%eax
+  800077:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("user warning at %s:%d:\n    ", file, line);
+  80007a:	83 ec 04             	sub    $0x4,%esp
+  80007d:	ff 75 0c             	pushl  0xc(%ebp)
+  800080:	ff 75 08             	pushl  0x8(%ebp)
+  800083:	68 9c 0f 80 00       	push   $0x800f9c
+  800088:	e8 4c 02 00 00       	call   8002d9 <cprintf>
+  80008d:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+  800090:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800093:	83 ec 08             	sub    $0x8,%esp
+  800096:	50                   	push   %eax
+  800097:	ff 75 10             	pushl  0x10(%ebp)
+  80009a:	e8 11 02 00 00       	call   8002b0 <vcprintf>
+  80009f:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+  8000a2:	83 ec 0c             	sub    $0xc,%esp
+  8000a5:	68 9a 0f 80 00       	push   $0x800f9a
+  8000aa:	e8 2a 02 00 00       	call   8002d9 <cprintf>
+  8000af:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+  8000b2:	90                   	nop
+  8000b3:	c9                   	leave  
+  8000b4:	c3                   	ret    
+
+008000b5 <syscall>:
+#include <syscall.h>
+
+#define MAX_ARGS            5
+
+static inline int
+syscall(int num, ...) {
+  8000b5:	55                   	push   %ebp
+  8000b6:	89 e5                	mov    %esp,%ebp
+  8000b8:	57                   	push   %edi
+  8000b9:	56                   	push   %esi
+  8000ba:	53                   	push   %ebx
+  8000bb:	83 ec 20             	sub    $0x20,%esp
+    va_list ap;
+    va_start(ap, num);
+  8000be:	8d 45 0c             	lea    0xc(%ebp),%eax
+  8000c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    uint32_t a[MAX_ARGS];
+    int i, ret;
+    for (i = 0; i < MAX_ARGS; i ++) {
+  8000c4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  8000cb:	eb 16                	jmp    8000e3 <syscall+0x2e>
+        a[i] = va_arg(ap, uint32_t);
+  8000cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8000d0:	8d 50 04             	lea    0x4(%eax),%edx
+  8000d3:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  8000d6:	8b 10                	mov    (%eax),%edx
+  8000d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8000db:	89 54 85 d4          	mov    %edx,-0x2c(%ebp,%eax,4)
+syscall(int num, ...) {
+    va_list ap;
+    va_start(ap, num);
+    uint32_t a[MAX_ARGS];
+    int i, ret;
+    for (i = 0; i < MAX_ARGS; i ++) {
+  8000df:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+  8000e3:	83 7d f0 04          	cmpl   $0x4,-0x10(%ebp)
+  8000e7:	7e e4                	jle    8000cd <syscall+0x18>
+    asm volatile (
+        "int %1;"
+        : "=a" (ret)
+        : "i" (T_SYSCALL),
+          "a" (num),
+          "d" (a[0]),
+  8000e9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+          "c" (a[1]),
+  8000ec:	8b 4d d8             	mov    -0x28(%ebp),%ecx
+          "b" (a[2]),
+  8000ef:	8b 5d dc             	mov    -0x24(%ebp),%ebx
+          "D" (a[3]),
+  8000f2:	8b 7d e0             	mov    -0x20(%ebp),%edi
+          "S" (a[4])
+  8000f5:	8b 75 e4             	mov    -0x1c(%ebp),%esi
+    for (i = 0; i < MAX_ARGS; i ++) {
+        a[i] = va_arg(ap, uint32_t);
+    }
+    va_end(ap);
+
+    asm volatile (
+  8000f8:	8b 45 08             	mov    0x8(%ebp),%eax
+  8000fb:	cd 80                	int    $0x80
+  8000fd:	89 45 ec             	mov    %eax,-0x14(%ebp)
+          "c" (a[1]),
+          "b" (a[2]),
+          "D" (a[3]),
+          "S" (a[4])
+        : "cc", "memory");
+    return ret;
+  800100:	8b 45 ec             	mov    -0x14(%ebp),%eax
+}
+  800103:	83 c4 20             	add    $0x20,%esp
+  800106:	5b                   	pop    %ebx
+  800107:	5e                   	pop    %esi
+  800108:	5f                   	pop    %edi
+  800109:	5d                   	pop    %ebp
+  80010a:	c3                   	ret    
+
+0080010b <sys_exit>:
+
+int
+sys_exit(int error_code) {
+  80010b:	55                   	push   %ebp
+  80010c:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_exit, error_code);
+  80010e:	ff 75 08             	pushl  0x8(%ebp)
+  800111:	6a 01                	push   $0x1
+  800113:	e8 9d ff ff ff       	call   8000b5 <syscall>
+  800118:	83 c4 08             	add    $0x8,%esp
+}
+  80011b:	c9                   	leave  
+  80011c:	c3                   	ret    
+
+0080011d <sys_fork>:
+
+int
+sys_fork(void) {
+  80011d:	55                   	push   %ebp
+  80011e:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_fork);
+  800120:	6a 02                	push   $0x2
+  800122:	e8 8e ff ff ff       	call   8000b5 <syscall>
+  800127:	83 c4 04             	add    $0x4,%esp
+}
+  80012a:	c9                   	leave  
+  80012b:	c3                   	ret    
+
+0080012c <sys_wait>:
+
+int
+sys_wait(int pid, int *store) {
+  80012c:	55                   	push   %ebp
+  80012d:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_wait, pid, store);
+  80012f:	ff 75 0c             	pushl  0xc(%ebp)
+  800132:	ff 75 08             	pushl  0x8(%ebp)
+  800135:	6a 03                	push   $0x3
+  800137:	e8 79 ff ff ff       	call   8000b5 <syscall>
+  80013c:	83 c4 0c             	add    $0xc,%esp
+}
+  80013f:	c9                   	leave  
+  800140:	c3                   	ret    
+
+00800141 <sys_yield>:
+
+int
+sys_yield(void) {
+  800141:	55                   	push   %ebp
+  800142:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_yield);
+  800144:	6a 0a                	push   $0xa
+  800146:	e8 6a ff ff ff       	call   8000b5 <syscall>
+  80014b:	83 c4 04             	add    $0x4,%esp
+}
+  80014e:	c9                   	leave  
+  80014f:	c3                   	ret    
+
+00800150 <sys_kill>:
+
+int
+sys_kill(int pid) {
+  800150:	55                   	push   %ebp
+  800151:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_kill, pid);
+  800153:	ff 75 08             	pushl  0x8(%ebp)
+  800156:	6a 0c                	push   $0xc
+  800158:	e8 58 ff ff ff       	call   8000b5 <syscall>
+  80015d:	83 c4 08             	add    $0x8,%esp
+}
+  800160:	c9                   	leave  
+  800161:	c3                   	ret    
+
+00800162 <sys_getpid>:
+
+int
+sys_getpid(void) {
+  800162:	55                   	push   %ebp
+  800163:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_getpid);
+  800165:	6a 12                	push   $0x12
+  800167:	e8 49 ff ff ff       	call   8000b5 <syscall>
+  80016c:	83 c4 04             	add    $0x4,%esp
+}
+  80016f:	c9                   	leave  
+  800170:	c3                   	ret    
+
+00800171 <sys_putc>:
+
+int
+sys_putc(int c) {
+  800171:	55                   	push   %ebp
+  800172:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_putc, c);
+  800174:	ff 75 08             	pushl  0x8(%ebp)
+  800177:	6a 1e                	push   $0x1e
+  800179:	e8 37 ff ff ff       	call   8000b5 <syscall>
+  80017e:	83 c4 08             	add    $0x8,%esp
+}
+  800181:	c9                   	leave  
+  800182:	c3                   	ret    
+
+00800183 <sys_pgdir>:
+
+int
+sys_pgdir(void) {
+  800183:	55                   	push   %ebp
+  800184:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_pgdir);
+  800186:	6a 1f                	push   $0x1f
+  800188:	e8 28 ff ff ff       	call   8000b5 <syscall>
+  80018d:	83 c4 04             	add    $0x4,%esp
+}
+  800190:	c9                   	leave  
+  800191:	c3                   	ret    
+
+00800192 <sys_gettime>:
+
+int
+sys_gettime(void) {
+  800192:	55                   	push   %ebp
+  800193:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_gettime);
+  800195:	6a 11                	push   $0x11
+  800197:	e8 19 ff ff ff       	call   8000b5 <syscall>
+  80019c:	83 c4 04             	add    $0x4,%esp
+}
+  80019f:	c9                   	leave  
+  8001a0:	c3                   	ret    
+
+008001a1 <sys_lab6_set_priority>:
+
+void
+sys_lab6_set_priority(uint32_t priority)
+{
+  8001a1:	55                   	push   %ebp
+  8001a2:	89 e5                	mov    %esp,%ebp
+    syscall(SYS_lab6_set_priority, priority);
+  8001a4:	ff 75 08             	pushl  0x8(%ebp)
+  8001a7:	68 ff 00 00 00       	push   $0xff
+  8001ac:	e8 04 ff ff ff       	call   8000b5 <syscall>
+  8001b1:	83 c4 08             	add    $0x8,%esp
+}
+  8001b4:	90                   	nop
+  8001b5:	c9                   	leave  
+  8001b6:	c3                   	ret    
+
+008001b7 <exit>:
+#include <syscall.h>
+#include <stdio.h>
+#include <ulib.h>
+
+void
+exit(int error_code) {
+  8001b7:	55                   	push   %ebp
+  8001b8:	89 e5                	mov    %esp,%ebp
+  8001ba:	83 ec 08             	sub    $0x8,%esp
+    sys_exit(error_code);
+  8001bd:	83 ec 0c             	sub    $0xc,%esp
+  8001c0:	ff 75 08             	pushl  0x8(%ebp)
+  8001c3:	e8 43 ff ff ff       	call   80010b <sys_exit>
+  8001c8:	83 c4 10             	add    $0x10,%esp
+    cprintf("BUG: exit failed.\n");
+  8001cb:	83 ec 0c             	sub    $0xc,%esp
+  8001ce:	68 b8 0f 80 00       	push   $0x800fb8
+  8001d3:	e8 01 01 00 00       	call   8002d9 <cprintf>
+  8001d8:	83 c4 10             	add    $0x10,%esp
+    while (1);
+  8001db:	eb fe                	jmp    8001db <exit+0x24>
+
+008001dd <fork>:
+}
+
+int
+fork(void) {
+  8001dd:	55                   	push   %ebp
+  8001de:	89 e5                	mov    %esp,%ebp
+  8001e0:	83 ec 08             	sub    $0x8,%esp
+    return sys_fork();
+  8001e3:	e8 35 ff ff ff       	call   80011d <sys_fork>
+}
+  8001e8:	c9                   	leave  
+  8001e9:	c3                   	ret    
+
+008001ea <wait>:
+
+int
+wait(void) {
+  8001ea:	55                   	push   %ebp
+  8001eb:	89 e5                	mov    %esp,%ebp
+  8001ed:	83 ec 08             	sub    $0x8,%esp
+    return sys_wait(0, NULL);
+  8001f0:	83 ec 08             	sub    $0x8,%esp
+  8001f3:	6a 00                	push   $0x0
+  8001f5:	6a 00                	push   $0x0
+  8001f7:	e8 30 ff ff ff       	call   80012c <sys_wait>
+  8001fc:	83 c4 10             	add    $0x10,%esp
+}
+  8001ff:	c9                   	leave  
+  800200:	c3                   	ret    
+
+00800201 <waitpid>:
+
+int
+waitpid(int pid, int *store) {
+  800201:	55                   	push   %ebp
+  800202:	89 e5                	mov    %esp,%ebp
+  800204:	83 ec 08             	sub    $0x8,%esp
+    return sys_wait(pid, store);
+  800207:	83 ec 08             	sub    $0x8,%esp
+  80020a:	ff 75 0c             	pushl  0xc(%ebp)
+  80020d:	ff 75 08             	pushl  0x8(%ebp)
+  800210:	e8 17 ff ff ff       	call   80012c <sys_wait>
+  800215:	83 c4 10             	add    $0x10,%esp
+}
+  800218:	c9                   	leave  
+  800219:	c3                   	ret    
+
+0080021a <yield>:
+
+void
+yield(void) {
+  80021a:	55                   	push   %ebp
+  80021b:	89 e5                	mov    %esp,%ebp
+  80021d:	83 ec 08             	sub    $0x8,%esp
+    sys_yield();
+  800220:	e8 1c ff ff ff       	call   800141 <sys_yield>
+}
+  800225:	90                   	nop
+  800226:	c9                   	leave  
+  800227:	c3                   	ret    
+
+00800228 <kill>:
+
+int
+kill(int pid) {
+  800228:	55                   	push   %ebp
+  800229:	89 e5                	mov    %esp,%ebp
+  80022b:	83 ec 08             	sub    $0x8,%esp
+    return sys_kill(pid);
+  80022e:	83 ec 0c             	sub    $0xc,%esp
+  800231:	ff 75 08             	pushl  0x8(%ebp)
+  800234:	e8 17 ff ff ff       	call   800150 <sys_kill>
+  800239:	83 c4 10             	add    $0x10,%esp
+}
+  80023c:	c9                   	leave  
+  80023d:	c3                   	ret    
+
+0080023e <getpid>:
+
+int
+getpid(void) {
+  80023e:	55                   	push   %ebp
+  80023f:	89 e5                	mov    %esp,%ebp
+  800241:	83 ec 08             	sub    $0x8,%esp
+    return sys_getpid();
+  800244:	e8 19 ff ff ff       	call   800162 <sys_getpid>
+}
+  800249:	c9                   	leave  
+  80024a:	c3                   	ret    
+
+0080024b <print_pgdir>:
+
+//print_pgdir - print the PDT&PT
+void
+print_pgdir(void) {
+  80024b:	55                   	push   %ebp
+  80024c:	89 e5                	mov    %esp,%ebp
+  80024e:	83 ec 08             	sub    $0x8,%esp
+    sys_pgdir();
+  800251:	e8 2d ff ff ff       	call   800183 <sys_pgdir>
+}
+  800256:	90                   	nop
+  800257:	c9                   	leave  
+  800258:	c3                   	ret    
+
+00800259 <gettime_msec>:
+
+unsigned int
+gettime_msec(void) {
+  800259:	55                   	push   %ebp
+  80025a:	89 e5                	mov    %esp,%ebp
+  80025c:	83 ec 08             	sub    $0x8,%esp
+    return (unsigned int)sys_gettime();
+  80025f:	e8 2e ff ff ff       	call   800192 <sys_gettime>
+}
+  800264:	c9                   	leave  
+  800265:	c3                   	ret    
+
+00800266 <lab6_set_priority>:
+
+void
+lab6_set_priority(uint32_t priority)
+{
+  800266:	55                   	push   %ebp
+  800267:	89 e5                	mov    %esp,%ebp
+  800269:	83 ec 08             	sub    $0x8,%esp
+    sys_lab6_set_priority(priority);
+  80026c:	83 ec 0c             	sub    $0xc,%esp
+  80026f:	ff 75 08             	pushl  0x8(%ebp)
+  800272:	e8 2a ff ff ff       	call   8001a1 <sys_lab6_set_priority>
+  800277:	83 c4 10             	add    $0x10,%esp
+}
+  80027a:	90                   	nop
+  80027b:	c9                   	leave  
+  80027c:	c3                   	ret    
+
+0080027d <_start>:
+.text
+.globl _start
+_start:
+    # set ebp for backtrace
+    movl $0x0, %ebp
+  80027d:	bd 00 00 00 00       	mov    $0x0,%ebp
+
+    # move down the esp register
+    # since it may cause page fault in backtrace
+    subl $0x20, %esp
+  800282:	83 ec 20             	sub    $0x20,%esp
+
+    # call user-program function
+    call umain
+  800285:	e8 c3 00 00 00       	call   80034d <umain>
+1:  jmp 1b
+  80028a:	eb fe                	jmp    80028a <_start+0xd>
+
+0080028c <cputch>:
+/* *
+ * cputch - writes a single character @c to stdout, and it will
+ * increace the value of counter pointed by @cnt.
+ * */
+static void
+cputch(int c, int *cnt) {
+  80028c:	55                   	push   %ebp
+  80028d:	89 e5                	mov    %esp,%ebp
+  80028f:	83 ec 08             	sub    $0x8,%esp
+    sys_putc(c);
+  800292:	83 ec 0c             	sub    $0xc,%esp
+  800295:	ff 75 08             	pushl  0x8(%ebp)
+  800298:	e8 d4 fe ff ff       	call   800171 <sys_putc>
+  80029d:	83 c4 10             	add    $0x10,%esp
+    (*cnt) ++;
+  8002a0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002a3:	8b 00                	mov    (%eax),%eax
+  8002a5:	8d 50 01             	lea    0x1(%eax),%edx
+  8002a8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002ab:	89 10                	mov    %edx,(%eax)
+}
+  8002ad:	90                   	nop
+  8002ae:	c9                   	leave  
+  8002af:	c3                   	ret    
+
+008002b0 <vcprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want cprintf() instead.
+ * */
+int
+vcprintf(const char *fmt, va_list ap) {
+  8002b0:	55                   	push   %ebp
+  8002b1:	89 e5                	mov    %esp,%ebp
+  8002b3:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+  8002b6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    vprintfmt((void*)cputch, &cnt, fmt, ap);
+  8002bd:	ff 75 0c             	pushl  0xc(%ebp)
+  8002c0:	ff 75 08             	pushl  0x8(%ebp)
+  8002c3:	8d 45 f4             	lea    -0xc(%ebp),%eax
+  8002c6:	50                   	push   %eax
+  8002c7:	68 8c 02 80 00       	push   $0x80028c
+  8002cc:	e8 fc 06 00 00       	call   8009cd <vprintfmt>
+  8002d1:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+  8002d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8002d7:	c9                   	leave  
+  8002d8:	c3                   	ret    
+
+008002d9 <cprintf>:
+ *
+ * The return value is the number of characters which would be
+ * written to stdout.
+ * */
+int
+cprintf(const char *fmt, ...) {
+  8002d9:	55                   	push   %ebp
+  8002da:	89 e5                	mov    %esp,%ebp
+  8002dc:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  8002df:	8d 45 0c             	lea    0xc(%ebp),%eax
+  8002e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    int cnt = vcprintf(fmt, ap);
+  8002e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8002e8:	83 ec 08             	sub    $0x8,%esp
+  8002eb:	50                   	push   %eax
+  8002ec:	ff 75 08             	pushl  0x8(%ebp)
+  8002ef:	e8 bc ff ff ff       	call   8002b0 <vcprintf>
+  8002f4:	83 c4 10             	add    $0x10,%esp
+  8002f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+
+    return cnt;
+  8002fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8002fd:	c9                   	leave  
+  8002fe:	c3                   	ret    
+
+008002ff <cputs>:
+/* *
+ * cputs- writes the string pointed by @str to stdout and
+ * appends a newline character.
+ * */
+int
+cputs(const char *str) {
+  8002ff:	55                   	push   %ebp
+  800300:	89 e5                	mov    %esp,%ebp
+  800302:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+  800305:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    char c;
+    while ((c = *str ++) != '\0') {
+  80030c:	eb 14                	jmp    800322 <cputs+0x23>
+        cputch(c, &cnt);
+  80030e:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
+  800312:	83 ec 08             	sub    $0x8,%esp
+  800315:	8d 55 f0             	lea    -0x10(%ebp),%edx
+  800318:	52                   	push   %edx
+  800319:	50                   	push   %eax
+  80031a:	e8 6d ff ff ff       	call   80028c <cputch>
+  80031f:	83 c4 10             	add    $0x10,%esp
+ * */
+int
+cputs(const char *str) {
+    int cnt = 0;
+    char c;
+    while ((c = *str ++) != '\0') {
+  800322:	8b 45 08             	mov    0x8(%ebp),%eax
+  800325:	8d 50 01             	lea    0x1(%eax),%edx
+  800328:	89 55 08             	mov    %edx,0x8(%ebp)
+  80032b:	0f b6 00             	movzbl (%eax),%eax
+  80032e:	88 45 f7             	mov    %al,-0x9(%ebp)
+  800331:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
+  800335:	75 d7                	jne    80030e <cputs+0xf>
+        cputch(c, &cnt);
+    }
+    cputch('\n', &cnt);
+  800337:	83 ec 08             	sub    $0x8,%esp
+  80033a:	8d 45 f0             	lea    -0x10(%ebp),%eax
+  80033d:	50                   	push   %eax
+  80033e:	6a 0a                	push   $0xa
+  800340:	e8 47 ff ff ff       	call   80028c <cputch>
+  800345:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+  800348:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+  80034b:	c9                   	leave  
+  80034c:	c3                   	ret    
+
+0080034d <umain>:
+#include <ulib.h>
+
+int main(void);
+
+void
+umain(void) {
+  80034d:	55                   	push   %ebp
+  80034e:	89 e5                	mov    %esp,%ebp
+  800350:	83 ec 18             	sub    $0x18,%esp
+    int ret = main();
+  800353:	e8 d3 0b 00 00       	call   800f2b <main>
+  800358:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    exit(ret);
+  80035b:	83 ec 0c             	sub    $0xc,%esp
+  80035e:	ff 75 f4             	pushl  -0xc(%ebp)
+  800361:	e8 51 fe ff ff       	call   8001b7 <exit>
+
+00800366 <strlen>:
+ * @s:      the input string
+ *
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+  800366:	55                   	push   %ebp
+  800367:	89 e5                	mov    %esp,%ebp
+  800369:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  80036c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (*s ++ != '\0') {
+  800373:	eb 04                	jmp    800379 <strlen+0x13>
+        cnt ++;
+  800375:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+    size_t cnt = 0;
+    while (*s ++ != '\0') {
+  800379:	8b 45 08             	mov    0x8(%ebp),%eax
+  80037c:	8d 50 01             	lea    0x1(%eax),%edx
+  80037f:	89 55 08             	mov    %edx,0x8(%ebp)
+  800382:	0f b6 00             	movzbl (%eax),%eax
+  800385:	84 c0                	test   %al,%al
+  800387:	75 ec                	jne    800375 <strlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  800389:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  80038c:	c9                   	leave  
+  80038d:	c3                   	ret    
+
+0080038e <strnlen>:
+ * The return value is strlen(s), if that is less than @len, or
+ * @len if there is no '\0' character among the first @len characters
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+  80038e:	55                   	push   %ebp
+  80038f:	89 e5                	mov    %esp,%ebp
+  800391:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  800394:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (cnt < len && *s ++ != '\0') {
+  80039b:	eb 04                	jmp    8003a1 <strnlen+0x13>
+        cnt ++;
+  80039d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+    size_t cnt = 0;
+    while (cnt < len && *s ++ != '\0') {
+  8003a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8003a4:	3b 45 0c             	cmp    0xc(%ebp),%eax
+  8003a7:	73 10                	jae    8003b9 <strnlen+0x2b>
+  8003a9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003ac:	8d 50 01             	lea    0x1(%eax),%edx
+  8003af:	89 55 08             	mov    %edx,0x8(%ebp)
+  8003b2:	0f b6 00             	movzbl (%eax),%eax
+  8003b5:	84 c0                	test   %al,%al
+  8003b7:	75 e4                	jne    80039d <strnlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  8003b9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  8003bc:	c9                   	leave  
+  8003bd:	c3                   	ret    
+
+008003be <strcpy>:
+ * To avoid overflows, the size of array pointed by @dst should be long enough to
+ * contain the same string as @src (including the terminating null character), and
+ * should not overlap in memory with @src.
+ * */
+char *
+strcpy(char *dst, const char *src) {
+  8003be:	55                   	push   %ebp
+  8003bf:	89 e5                	mov    %esp,%ebp
+  8003c1:	57                   	push   %edi
+  8003c2:	56                   	push   %esi
+  8003c3:	83 ec 20             	sub    $0x20,%esp
+  8003c6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  8003cc:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8003cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCPY
+#define __HAVE_ARCH_STRCPY
+static inline char *
+__strcpy(char *dst, const char *src) {
+    int d0, d1, d2;
+    asm volatile (
+  8003d2:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  8003d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8003d8:	89 d1                	mov    %edx,%ecx
+  8003da:	89 c2                	mov    %eax,%edx
+  8003dc:	89 ce                	mov    %ecx,%esi
+  8003de:	89 d7                	mov    %edx,%edi
+  8003e0:	ac                   	lods   %ds:(%esi),%al
+  8003e1:	aa                   	stos   %al,%es:(%edi)
+  8003e2:	84 c0                	test   %al,%al
+  8003e4:	75 fa                	jne    8003e0 <strcpy+0x22>
+  8003e6:	89 fa                	mov    %edi,%edx
+  8003e8:	89 f1                	mov    %esi,%ecx
+  8003ea:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  8003ed:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  8003f0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+        "stosb;"
+        "testb %%al, %%al;"
+        "jne 1b;"
+        : "=&S" (d0), "=&D" (d1), "=&a" (d2)
+        : "0" (src), "1" (dst) : "memory");
+    return dst;
+  8003f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCPY
+    return __strcpy(dst, src);
+  8003f6:	90                   	nop
+    char *p = dst;
+    while ((*p ++ = *src ++) != '\0')
+        /* nothing */;
+    return dst;
+#endif /* __HAVE_ARCH_STRCPY */
+}
+  8003f7:	83 c4 20             	add    $0x20,%esp
+  8003fa:	5e                   	pop    %esi
+  8003fb:	5f                   	pop    %edi
+  8003fc:	5d                   	pop    %ebp
+  8003fd:	c3                   	ret    
+
+008003fe <strncpy>:
+ * @len:    maximum number of characters to be copied from @src
+ *
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+  8003fe:	55                   	push   %ebp
+  8003ff:	89 e5                	mov    %esp,%ebp
+  800401:	83 ec 10             	sub    $0x10,%esp
+    char *p = dst;
+  800404:	8b 45 08             	mov    0x8(%ebp),%eax
+  800407:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    while (len > 0) {
+  80040a:	eb 21                	jmp    80042d <strncpy+0x2f>
+        if ((*p = *src) != '\0') {
+  80040c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80040f:	0f b6 10             	movzbl (%eax),%edx
+  800412:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800415:	88 10                	mov    %dl,(%eax)
+  800417:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  80041a:	0f b6 00             	movzbl (%eax),%eax
+  80041d:	84 c0                	test   %al,%al
+  80041f:	74 04                	je     800425 <strncpy+0x27>
+            src ++;
+  800421:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+        }
+        p ++, len --;
+  800425:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800429:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+    char *p = dst;
+    while (len > 0) {
+  80042d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800431:	75 d9                	jne    80040c <strncpy+0xe>
+        if ((*p = *src) != '\0') {
+            src ++;
+        }
+        p ++, len --;
+    }
+    return dst;
+  800433:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800436:	c9                   	leave  
+  800437:	c3                   	ret    
+
+00800438 <strcmp>:
+ * - A value greater than zero indicates that the first character that does
+ *   not match has a greater value in @s1 than in @s2;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+strcmp(const char *s1, const char *s2) {
+  800438:	55                   	push   %ebp
+  800439:	89 e5                	mov    %esp,%ebp
+  80043b:	57                   	push   %edi
+  80043c:	56                   	push   %esi
+  80043d:	83 ec 20             	sub    $0x20,%esp
+  800440:	8b 45 08             	mov    0x8(%ebp),%eax
+  800443:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800446:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800449:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCMP
+#define __HAVE_ARCH_STRCMP
+static inline int
+__strcmp(const char *s1, const char *s2) {
+    int d0, d1, ret;
+    asm volatile (
+  80044c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80044f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800452:	89 d1                	mov    %edx,%ecx
+  800454:	89 c2                	mov    %eax,%edx
+  800456:	89 ce                	mov    %ecx,%esi
+  800458:	89 d7                	mov    %edx,%edi
+  80045a:	ac                   	lods   %ds:(%esi),%al
+  80045b:	ae                   	scas   %es:(%edi),%al
+  80045c:	75 08                	jne    800466 <strcmp+0x2e>
+  80045e:	84 c0                	test   %al,%al
+  800460:	75 f8                	jne    80045a <strcmp+0x22>
+  800462:	31 c0                	xor    %eax,%eax
+  800464:	eb 04                	jmp    80046a <strcmp+0x32>
+  800466:	19 c0                	sbb    %eax,%eax
+  800468:	0c 01                	or     $0x1,%al
+  80046a:	89 fa                	mov    %edi,%edx
+  80046c:	89 f1                	mov    %esi,%ecx
+  80046e:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800471:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  800474:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+        "orb $1, %%al;"
+        "3:"
+        : "=a" (ret), "=&S" (d0), "=&D" (d1)
+        : "1" (s1), "2" (s2)
+        : "memory");
+    return ret;
+  800477:	8b 45 ec             	mov    -0x14(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCMP
+    return __strcmp(s1, s2);
+  80047a:	90                   	nop
+    while (*s1 != '\0' && *s1 == *s2) {
+        s1 ++, s2 ++;
+    }
+    return (int)((unsigned char)*s1 - (unsigned char)*s2);
+#endif /* __HAVE_ARCH_STRCMP */
+}
+  80047b:	83 c4 20             	add    $0x20,%esp
+  80047e:	5e                   	pop    %esi
+  80047f:	5f                   	pop    %edi
+  800480:	5d                   	pop    %ebp
+  800481:	c3                   	ret    
+
+00800482 <strncmp>:
+ * they are equal to each other, it continues with the following pairs until
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+  800482:	55                   	push   %ebp
+  800483:	89 e5                	mov    %esp,%ebp
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  800485:	eb 0c                	jmp    800493 <strncmp+0x11>
+        n --, s1 ++, s2 ++;
+  800487:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  80048b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  80048f:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  800493:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800497:	74 1a                	je     8004b3 <strncmp+0x31>
+  800499:	8b 45 08             	mov    0x8(%ebp),%eax
+  80049c:	0f b6 00             	movzbl (%eax),%eax
+  80049f:	84 c0                	test   %al,%al
+  8004a1:	74 10                	je     8004b3 <strncmp+0x31>
+  8004a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004a6:	0f b6 10             	movzbl (%eax),%edx
+  8004a9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004ac:	0f b6 00             	movzbl (%eax),%eax
+  8004af:	38 c2                	cmp    %al,%dl
+  8004b1:	74 d4                	je     800487 <strncmp+0x5>
+        n --, s1 ++, s2 ++;
+    }
+    return (n == 0) ? 0 : (int)((unsigned char)*s1 - (unsigned char)*s2);
+  8004b3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8004b7:	74 18                	je     8004d1 <strncmp+0x4f>
+  8004b9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004bc:	0f b6 00             	movzbl (%eax),%eax
+  8004bf:	0f b6 d0             	movzbl %al,%edx
+  8004c2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004c5:	0f b6 00             	movzbl (%eax),%eax
+  8004c8:	0f b6 c0             	movzbl %al,%eax
+  8004cb:	29 c2                	sub    %eax,%edx
+  8004cd:	89 d0                	mov    %edx,%eax
+  8004cf:	eb 05                	jmp    8004d6 <strncmp+0x54>
+  8004d1:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  8004d6:	5d                   	pop    %ebp
+  8004d7:	c3                   	ret    
+
+008004d8 <strchr>:
+ *
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+  8004d8:	55                   	push   %ebp
+  8004d9:	89 e5                	mov    %esp,%ebp
+  8004db:	83 ec 04             	sub    $0x4,%esp
+  8004de:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004e1:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  8004e4:	eb 14                	jmp    8004fa <strchr+0x22>
+        if (*s == c) {
+  8004e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004e9:	0f b6 00             	movzbl (%eax),%eax
+  8004ec:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  8004ef:	75 05                	jne    8004f6 <strchr+0x1e>
+            return (char *)s;
+  8004f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004f4:	eb 13                	jmp    800509 <strchr+0x31>
+        }
+        s ++;
+  8004f6:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+    while (*s != '\0') {
+  8004fa:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004fd:	0f b6 00             	movzbl (%eax),%eax
+  800500:	84 c0                	test   %al,%al
+  800502:	75 e2                	jne    8004e6 <strchr+0xe>
+        if (*s == c) {
+            return (char *)s;
+        }
+        s ++;
+    }
+    return NULL;
+  800504:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800509:	c9                   	leave  
+  80050a:	c3                   	ret    
+
+0080050b <strfind>:
+ * The strfind() function is like strchr() except that if @c is
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+  80050b:	55                   	push   %ebp
+  80050c:	89 e5                	mov    %esp,%ebp
+  80050e:	83 ec 04             	sub    $0x4,%esp
+  800511:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800514:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  800517:	eb 0f                	jmp    800528 <strfind+0x1d>
+        if (*s == c) {
+  800519:	8b 45 08             	mov    0x8(%ebp),%eax
+  80051c:	0f b6 00             	movzbl (%eax),%eax
+  80051f:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800522:	74 10                	je     800534 <strfind+0x29>
+            break;
+        }
+        s ++;
+  800524:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+    while (*s != '\0') {
+  800528:	8b 45 08             	mov    0x8(%ebp),%eax
+  80052b:	0f b6 00             	movzbl (%eax),%eax
+  80052e:	84 c0                	test   %al,%al
+  800530:	75 e7                	jne    800519 <strfind+0xe>
+  800532:	eb 01                	jmp    800535 <strfind+0x2a>
+        if (*s == c) {
+            break;
+  800534:	90                   	nop
+        }
+        s ++;
+    }
+    return (char *)s;
+  800535:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800538:	c9                   	leave  
+  800539:	c3                   	ret    
+
+0080053a <strtol>:
+ * an optional "0x" or "0X" prefix.
+ *
+ * The strtol() function returns the converted integral number as a long int value.
+ * */
+long
+strtol(const char *s, char **endptr, int base) {
+  80053a:	55                   	push   %ebp
+  80053b:	89 e5                	mov    %esp,%ebp
+  80053d:	83 ec 10             	sub    $0x10,%esp
+    int neg = 0;
+  800540:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    long val = 0;
+  800547:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  80054e:	eb 04                	jmp    800554 <strtol+0x1a>
+        s ++;
+  800550:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+strtol(const char *s, char **endptr, int base) {
+    int neg = 0;
+    long val = 0;
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  800554:	8b 45 08             	mov    0x8(%ebp),%eax
+  800557:	0f b6 00             	movzbl (%eax),%eax
+  80055a:	3c 20                	cmp    $0x20,%al
+  80055c:	74 f2                	je     800550 <strtol+0x16>
+  80055e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800561:	0f b6 00             	movzbl (%eax),%eax
+  800564:	3c 09                	cmp    $0x9,%al
+  800566:	74 e8                	je     800550 <strtol+0x16>
+        s ++;
+    }
+
+    // plus/minus sign
+    if (*s == '+') {
+  800568:	8b 45 08             	mov    0x8(%ebp),%eax
+  80056b:	0f b6 00             	movzbl (%eax),%eax
+  80056e:	3c 2b                	cmp    $0x2b,%al
+  800570:	75 06                	jne    800578 <strtol+0x3e>
+        s ++;
+  800572:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800576:	eb 15                	jmp    80058d <strtol+0x53>
+    }
+    else if (*s == '-') {
+  800578:	8b 45 08             	mov    0x8(%ebp),%eax
+  80057b:	0f b6 00             	movzbl (%eax),%eax
+  80057e:	3c 2d                	cmp    $0x2d,%al
+  800580:	75 0b                	jne    80058d <strtol+0x53>
+        s ++, neg = 1;
+  800582:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800586:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+    }
+
+    // hex or octal base prefix
+    if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x')) {
+  80058d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800591:	74 06                	je     800599 <strtol+0x5f>
+  800593:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+  800597:	75 24                	jne    8005bd <strtol+0x83>
+  800599:	8b 45 08             	mov    0x8(%ebp),%eax
+  80059c:	0f b6 00             	movzbl (%eax),%eax
+  80059f:	3c 30                	cmp    $0x30,%al
+  8005a1:	75 1a                	jne    8005bd <strtol+0x83>
+  8005a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005a6:	83 c0 01             	add    $0x1,%eax
+  8005a9:	0f b6 00             	movzbl (%eax),%eax
+  8005ac:	3c 78                	cmp    $0x78,%al
+  8005ae:	75 0d                	jne    8005bd <strtol+0x83>
+        s += 2, base = 16;
+  8005b0:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+  8005b4:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+  8005bb:	eb 2a                	jmp    8005e7 <strtol+0xad>
+    }
+    else if (base == 0 && s[0] == '0') {
+  8005bd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8005c1:	75 17                	jne    8005da <strtol+0xa0>
+  8005c3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005c6:	0f b6 00             	movzbl (%eax),%eax
+  8005c9:	3c 30                	cmp    $0x30,%al
+  8005cb:	75 0d                	jne    8005da <strtol+0xa0>
+        s ++, base = 8;
+  8005cd:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  8005d1:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+  8005d8:	eb 0d                	jmp    8005e7 <strtol+0xad>
+    }
+    else if (base == 0) {
+  8005da:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8005de:	75 07                	jne    8005e7 <strtol+0xad>
+        base = 10;
+  8005e0:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+    // digits
+    while (1) {
+        int dig;
+
+        if (*s >= '0' && *s <= '9') {
+  8005e7:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005ea:	0f b6 00             	movzbl (%eax),%eax
+  8005ed:	3c 2f                	cmp    $0x2f,%al
+  8005ef:	7e 1b                	jle    80060c <strtol+0xd2>
+  8005f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005f4:	0f b6 00             	movzbl (%eax),%eax
+  8005f7:	3c 39                	cmp    $0x39,%al
+  8005f9:	7f 11                	jg     80060c <strtol+0xd2>
+            dig = *s - '0';
+  8005fb:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005fe:	0f b6 00             	movzbl (%eax),%eax
+  800601:	0f be c0             	movsbl %al,%eax
+  800604:	83 e8 30             	sub    $0x30,%eax
+  800607:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80060a:	eb 48                	jmp    800654 <strtol+0x11a>
+        }
+        else if (*s >= 'a' && *s <= 'z') {
+  80060c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80060f:	0f b6 00             	movzbl (%eax),%eax
+  800612:	3c 60                	cmp    $0x60,%al
+  800614:	7e 1b                	jle    800631 <strtol+0xf7>
+  800616:	8b 45 08             	mov    0x8(%ebp),%eax
+  800619:	0f b6 00             	movzbl (%eax),%eax
+  80061c:	3c 7a                	cmp    $0x7a,%al
+  80061e:	7f 11                	jg     800631 <strtol+0xf7>
+            dig = *s - 'a' + 10;
+  800620:	8b 45 08             	mov    0x8(%ebp),%eax
+  800623:	0f b6 00             	movzbl (%eax),%eax
+  800626:	0f be c0             	movsbl %al,%eax
+  800629:	83 e8 57             	sub    $0x57,%eax
+  80062c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80062f:	eb 23                	jmp    800654 <strtol+0x11a>
+        }
+        else if (*s >= 'A' && *s <= 'Z') {
+  800631:	8b 45 08             	mov    0x8(%ebp),%eax
+  800634:	0f b6 00             	movzbl (%eax),%eax
+  800637:	3c 40                	cmp    $0x40,%al
+  800639:	7e 3c                	jle    800677 <strtol+0x13d>
+  80063b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80063e:	0f b6 00             	movzbl (%eax),%eax
+  800641:	3c 5a                	cmp    $0x5a,%al
+  800643:	7f 32                	jg     800677 <strtol+0x13d>
+            dig = *s - 'A' + 10;
+  800645:	8b 45 08             	mov    0x8(%ebp),%eax
+  800648:	0f b6 00             	movzbl (%eax),%eax
+  80064b:	0f be c0             	movsbl %al,%eax
+  80064e:	83 e8 37             	sub    $0x37,%eax
+  800651:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+  800654:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800657:	3b 45 10             	cmp    0x10(%ebp),%eax
+  80065a:	7d 1a                	jge    800676 <strtol+0x13c>
+            break;
+        }
+        s ++, val = (val * base) + dig;
+  80065c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800660:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800663:	0f af 45 10          	imul   0x10(%ebp),%eax
+  800667:	89 c2                	mov    %eax,%edx
+  800669:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  80066c:	01 d0                	add    %edx,%eax
+  80066e:	89 45 f8             	mov    %eax,-0x8(%ebp)
+        // we don't properly detect overflow!
+    }
+  800671:	e9 71 ff ff ff       	jmp    8005e7 <strtol+0xad>
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+            break;
+  800676:	90                   	nop
+        }
+        s ++, val = (val * base) + dig;
+        // we don't properly detect overflow!
+    }
+
+    if (endptr) {
+  800677:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  80067b:	74 08                	je     800685 <strtol+0x14b>
+        *endptr = (char *) s;
+  80067d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800680:	8b 55 08             	mov    0x8(%ebp),%edx
+  800683:	89 10                	mov    %edx,(%eax)
+    }
+    return (neg ? -val : val);
+  800685:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+  800689:	74 07                	je     800692 <strtol+0x158>
+  80068b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  80068e:	f7 d8                	neg    %eax
+  800690:	eb 03                	jmp    800695 <strtol+0x15b>
+  800692:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  800695:	c9                   	leave  
+  800696:	c3                   	ret    
+
+00800697 <memset>:
+ * @n:      number of bytes to be set to the value
+ *
+ * The memset() function returns @s.
+ * */
+void *
+memset(void *s, char c, size_t n) {
+  800697:	55                   	push   %ebp
+  800698:	89 e5                	mov    %esp,%ebp
+  80069a:	57                   	push   %edi
+  80069b:	83 ec 24             	sub    $0x24,%esp
+  80069e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006a1:	88 45 d8             	mov    %al,-0x28(%ebp)
+#ifdef __HAVE_ARCH_MEMSET
+    return __memset(s, c, n);
+  8006a4:	0f be 45 d8          	movsbl -0x28(%ebp),%eax
+  8006a8:	8b 55 08             	mov    0x8(%ebp),%edx
+  8006ab:	89 55 f8             	mov    %edx,-0x8(%ebp)
+  8006ae:	88 45 f7             	mov    %al,-0x9(%ebp)
+  8006b1:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_MEMSET
+#define __HAVE_ARCH_MEMSET
+static inline void *
+__memset(void *s, char c, size_t n) {
+    int d0, d1;
+    asm volatile (
+  8006b7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+  8006ba:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
+  8006be:	8b 55 f8             	mov    -0x8(%ebp),%edx
+  8006c1:	89 d7                	mov    %edx,%edi
+  8006c3:	f3 aa                	rep stos %al,%es:(%edi)
+  8006c5:	89 fa                	mov    %edi,%edx
+  8006c7:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  8006ca:	89 55 e8             	mov    %edx,-0x18(%ebp)
+        "rep; stosb;"
+        : "=&c" (d0), "=&D" (d1)
+        : "0" (n), "a" (c), "1" (s)
+        : "memory");
+    return s;
+  8006cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8006d0:	90                   	nop
+    while (n -- > 0) {
+        *p ++ = c;
+    }
+    return s;
+#endif /* __HAVE_ARCH_MEMSET */
+}
+  8006d1:	83 c4 24             	add    $0x24,%esp
+  8006d4:	5f                   	pop    %edi
+  8006d5:	5d                   	pop    %ebp
+  8006d6:	c3                   	ret    
+
+008006d7 <memmove>:
+ * @n:      number of bytes to copy
+ *
+ * The memmove() function returns @dst.
+ * */
+void *
+memmove(void *dst, const void *src, size_t n) {
+  8006d7:	55                   	push   %ebp
+  8006d8:	89 e5                	mov    %esp,%ebp
+  8006da:	57                   	push   %edi
+  8006db:	56                   	push   %esi
+  8006dc:	53                   	push   %ebx
+  8006dd:	83 ec 30             	sub    $0x30,%esp
+  8006e0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8006e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8006e6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  8006ec:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006ef:	89 45 e8             	mov    %eax,-0x18(%ebp)
+
+#ifndef __HAVE_ARCH_MEMMOVE
+#define __HAVE_ARCH_MEMMOVE
+static inline void *
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+  8006f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006f5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  8006f8:	73 42                	jae    80073c <memmove+0x65>
+  8006fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006fd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800700:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800703:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800706:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800709:	89 45 dc             	mov    %eax,-0x24(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  80070c:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  80070f:	c1 e8 02             	shr    $0x2,%eax
+  800712:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  800714:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800717:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80071a:	89 d7                	mov    %edx,%edi
+  80071c:	89 c6                	mov    %eax,%esi
+  80071e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800720:	8b 4d dc             	mov    -0x24(%ebp),%ecx
+  800723:	83 e1 03             	and    $0x3,%ecx
+  800726:	74 02                	je     80072a <memmove+0x53>
+  800728:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  80072a:	89 f0                	mov    %esi,%eax
+  80072c:	89 fa                	mov    %edi,%edx
+  80072e:	89 4d d8             	mov    %ecx,-0x28(%ebp)
+  800731:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  800734:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  800737:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMMOVE
+    return __memmove(dst, src, n);
+  80073a:	eb 36                	jmp    800772 <memmove+0x9b>
+    asm volatile (
+        "std;"
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+  80073c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80073f:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800742:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800745:	01 c2                	add    %eax,%edx
+  800747:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80074a:	8d 48 ff             	lea    -0x1(%eax),%ecx
+  80074d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800750:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+        return __memcpy(dst, src, n);
+    }
+    int d0, d1, d2;
+    asm volatile (
+  800753:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800756:	89 c1                	mov    %eax,%ecx
+  800758:	89 d8                	mov    %ebx,%eax
+  80075a:	89 d6                	mov    %edx,%esi
+  80075c:	89 c7                	mov    %eax,%edi
+  80075e:	fd                   	std    
+  80075f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  800761:	fc                   	cld    
+  800762:	89 f8                	mov    %edi,%eax
+  800764:	89 f2                	mov    %esi,%edx
+  800766:	89 4d cc             	mov    %ecx,-0x34(%ebp)
+  800769:	89 55 c8             	mov    %edx,-0x38(%ebp)
+  80076c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+        : "memory");
+    return dst;
+  80076f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+            *d ++ = *s ++;
+        }
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMMOVE */
+}
+  800772:	83 c4 30             	add    $0x30,%esp
+  800775:	5b                   	pop    %ebx
+  800776:	5e                   	pop    %esi
+  800777:	5f                   	pop    %edi
+  800778:	5d                   	pop    %ebp
+  800779:	c3                   	ret    
+
+0080077a <memcpy>:
+ * it always copies exactly @n bytes. To avoid overflows, the size of arrays pointed
+ * by both @src and @dst, should be at least @n bytes, and should not overlap
+ * (for overlapping memory area, memmove is a safer approach).
+ * */
+void *
+memcpy(void *dst, const void *src, size_t n) {
+  80077a:	55                   	push   %ebp
+  80077b:	89 e5                	mov    %esp,%ebp
+  80077d:	57                   	push   %edi
+  80077e:	56                   	push   %esi
+  80077f:	83 ec 20             	sub    $0x20,%esp
+  800782:	8b 45 08             	mov    0x8(%ebp),%eax
+  800785:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800788:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80078b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80078e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800791:	89 45 ec             	mov    %eax,-0x14(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  800794:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800797:	c1 e8 02             	shr    $0x2,%eax
+  80079a:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  80079c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80079f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8007a2:	89 d7                	mov    %edx,%edi
+  8007a4:	89 c6                	mov    %eax,%esi
+  8007a6:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  8007a8:	8b 4d ec             	mov    -0x14(%ebp),%ecx
+  8007ab:	83 e1 03             	and    $0x3,%ecx
+  8007ae:	74 02                	je     8007b2 <memcpy+0x38>
+  8007b0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  8007b2:	89 f0                	mov    %esi,%eax
+  8007b4:	89 fa                	mov    %edi,%edx
+  8007b6:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  8007b9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  8007bc:	89 45 e0             	mov    %eax,-0x20(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  8007bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMCPY
+    return __memcpy(dst, src, n);
+  8007c2:	90                   	nop
+    while (n -- > 0) {
+        *d ++ = *s ++;
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMCPY */
+}
+  8007c3:	83 c4 20             	add    $0x20,%esp
+  8007c6:	5e                   	pop    %esi
+  8007c7:	5f                   	pop    %edi
+  8007c8:	5d                   	pop    %ebp
+  8007c9:	c3                   	ret    
+
+008007ca <memcmp>:
+ *   match in both memory blocks has a greater value in @v1 than in @v2
+ *   as if evaluated as unsigned char values;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+  8007ca:	55                   	push   %ebp
+  8007cb:	89 e5                	mov    %esp,%ebp
+  8007cd:	83 ec 10             	sub    $0x10,%esp
+    const char *s1 = (const char *)v1;
+  8007d0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8007d3:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    const char *s2 = (const char *)v2;
+  8007d6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8007d9:	89 45 f8             	mov    %eax,-0x8(%ebp)
+    while (n -- > 0) {
+  8007dc:	eb 30                	jmp    80080e <memcmp+0x44>
+        if (*s1 != *s2) {
+  8007de:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8007e1:	0f b6 10             	movzbl (%eax),%edx
+  8007e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8007e7:	0f b6 00             	movzbl (%eax),%eax
+  8007ea:	38 c2                	cmp    %al,%dl
+  8007ec:	74 18                	je     800806 <memcmp+0x3c>
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+  8007ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8007f1:	0f b6 00             	movzbl (%eax),%eax
+  8007f4:	0f b6 d0             	movzbl %al,%edx
+  8007f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8007fa:	0f b6 00             	movzbl (%eax),%eax
+  8007fd:	0f b6 c0             	movzbl %al,%eax
+  800800:	29 c2                	sub    %eax,%edx
+  800802:	89 d0                	mov    %edx,%eax
+  800804:	eb 1a                	jmp    800820 <memcmp+0x56>
+        }
+        s1 ++, s2 ++;
+  800806:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  80080a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+    const char *s1 = (const char *)v1;
+    const char *s2 = (const char *)v2;
+    while (n -- > 0) {
+  80080e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800811:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800814:	89 55 10             	mov    %edx,0x10(%ebp)
+  800817:	85 c0                	test   %eax,%eax
+  800819:	75 c3                	jne    8007de <memcmp+0x14>
+        if (*s1 != *s2) {
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+        }
+        s1 ++, s2 ++;
+    }
+    return 0;
+  80081b:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800820:	c9                   	leave  
+  800821:	c3                   	ret    
+
+00800822 <printnum>:
+ * @width:      maximum number of digits, if the actual width is less than @width, use @padc instead
+ * @padc:       character that padded on the left if the actual width is less than @width
+ * */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+        unsigned long long num, unsigned base, int width, int padc) {
+  800822:	55                   	push   %ebp
+  800823:	89 e5                	mov    %esp,%ebp
+  800825:	83 ec 38             	sub    $0x38,%esp
+  800828:	8b 45 10             	mov    0x10(%ebp),%eax
+  80082b:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  80082e:	8b 45 14             	mov    0x14(%ebp),%eax
+  800831:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+    unsigned long long result = num;
+  800834:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  800837:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  80083a:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  80083d:	89 55 ec             	mov    %edx,-0x14(%ebp)
+    unsigned mod = do_div(result, base);
+  800840:	8b 45 18             	mov    0x18(%ebp),%eax
+  800843:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800846:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800849:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  80084c:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  80084f:	89 55 f0             	mov    %edx,-0x10(%ebp)
+  800852:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800855:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800858:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  80085c:	74 1c                	je     80087a <printnum+0x58>
+  80085e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800861:	ba 00 00 00 00       	mov    $0x0,%edx
+  800866:	f7 75 e4             	divl   -0x1c(%ebp)
+  800869:	89 55 f4             	mov    %edx,-0xc(%ebp)
+  80086c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  80086f:	ba 00 00 00 00       	mov    $0x0,%edx
+  800874:	f7 75 e4             	divl   -0x1c(%ebp)
+  800877:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80087a:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80087d:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800880:	f7 75 e4             	divl   -0x1c(%ebp)
+  800883:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800886:	89 55 dc             	mov    %edx,-0x24(%ebp)
+  800889:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80088c:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  80088f:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800892:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  800895:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  800898:	89 45 d8             	mov    %eax,-0x28(%ebp)
+
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+  80089b:	8b 45 18             	mov    0x18(%ebp),%eax
+  80089e:	ba 00 00 00 00       	mov    $0x0,%edx
+  8008a3:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  8008a6:	77 41                	ja     8008e9 <printnum+0xc7>
+  8008a8:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  8008ab:	72 05                	jb     8008b2 <printnum+0x90>
+  8008ad:	3b 45 d0             	cmp    -0x30(%ebp),%eax
+  8008b0:	77 37                	ja     8008e9 <printnum+0xc7>
+        printnum(putch, putdat, result, base, width - 1, padc);
+  8008b2:	8b 45 1c             	mov    0x1c(%ebp),%eax
+  8008b5:	83 e8 01             	sub    $0x1,%eax
+  8008b8:	83 ec 04             	sub    $0x4,%esp
+  8008bb:	ff 75 20             	pushl  0x20(%ebp)
+  8008be:	50                   	push   %eax
+  8008bf:	ff 75 18             	pushl  0x18(%ebp)
+  8008c2:	ff 75 ec             	pushl  -0x14(%ebp)
+  8008c5:	ff 75 e8             	pushl  -0x18(%ebp)
+  8008c8:	ff 75 0c             	pushl  0xc(%ebp)
+  8008cb:	ff 75 08             	pushl  0x8(%ebp)
+  8008ce:	e8 4f ff ff ff       	call   800822 <printnum>
+  8008d3:	83 c4 20             	add    $0x20,%esp
+  8008d6:	eb 1b                	jmp    8008f3 <printnum+0xd1>
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+            putch(padc, putdat);
+  8008d8:	83 ec 08             	sub    $0x8,%esp
+  8008db:	ff 75 0c             	pushl  0xc(%ebp)
+  8008de:	ff 75 20             	pushl  0x20(%ebp)
+  8008e1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8008e4:	ff d0                	call   *%eax
+  8008e6:	83 c4 10             	add    $0x10,%esp
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+        printnum(putch, putdat, result, base, width - 1, padc);
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+  8008e9:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+  8008ed:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+  8008f1:	7f e5                	jg     8008d8 <printnum+0xb6>
+            putch(padc, putdat);
+    }
+    // then print this (the least significant) digit
+    putch("0123456789abcdef"[mod], putdat);
+  8008f3:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  8008f6:	05 e4 10 80 00       	add    $0x8010e4,%eax
+  8008fb:	0f b6 00             	movzbl (%eax),%eax
+  8008fe:	0f be c0             	movsbl %al,%eax
+  800901:	83 ec 08             	sub    $0x8,%esp
+  800904:	ff 75 0c             	pushl  0xc(%ebp)
+  800907:	50                   	push   %eax
+  800908:	8b 45 08             	mov    0x8(%ebp),%eax
+  80090b:	ff d0                	call   *%eax
+  80090d:	83 c4 10             	add    $0x10,%esp
+}
+  800910:	90                   	nop
+  800911:	c9                   	leave  
+  800912:	c3                   	ret    
+
+00800913 <getuint>:
+ * getuint - get an unsigned int of various possible sizes from a varargs list
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static unsigned long long
+getuint(va_list *ap, int lflag) {
+  800913:	55                   	push   %ebp
+  800914:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  800916:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  80091a:	7e 14                	jle    800930 <getuint+0x1d>
+        return va_arg(*ap, unsigned long long);
+  80091c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80091f:	8b 00                	mov    (%eax),%eax
+  800921:	8d 48 08             	lea    0x8(%eax),%ecx
+  800924:	8b 55 08             	mov    0x8(%ebp),%edx
+  800927:	89 0a                	mov    %ecx,(%edx)
+  800929:	8b 50 04             	mov    0x4(%eax),%edx
+  80092c:	8b 00                	mov    (%eax),%eax
+  80092e:	eb 30                	jmp    800960 <getuint+0x4d>
+    }
+    else if (lflag) {
+  800930:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800934:	74 16                	je     80094c <getuint+0x39>
+        return va_arg(*ap, unsigned long);
+  800936:	8b 45 08             	mov    0x8(%ebp),%eax
+  800939:	8b 00                	mov    (%eax),%eax
+  80093b:	8d 48 04             	lea    0x4(%eax),%ecx
+  80093e:	8b 55 08             	mov    0x8(%ebp),%edx
+  800941:	89 0a                	mov    %ecx,(%edx)
+  800943:	8b 00                	mov    (%eax),%eax
+  800945:	ba 00 00 00 00       	mov    $0x0,%edx
+  80094a:	eb 14                	jmp    800960 <getuint+0x4d>
+    }
+    else {
+        return va_arg(*ap, unsigned int);
+  80094c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80094f:	8b 00                	mov    (%eax),%eax
+  800951:	8d 48 04             	lea    0x4(%eax),%ecx
+  800954:	8b 55 08             	mov    0x8(%ebp),%edx
+  800957:	89 0a                	mov    %ecx,(%edx)
+  800959:	8b 00                	mov    (%eax),%eax
+  80095b:	ba 00 00 00 00       	mov    $0x0,%edx
+    }
+}
+  800960:	5d                   	pop    %ebp
+  800961:	c3                   	ret    
+
+00800962 <getint>:
+ * getint - same as getuint but signed, we can't use getuint because of sign extension
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static long long
+getint(va_list *ap, int lflag) {
+  800962:	55                   	push   %ebp
+  800963:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  800965:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  800969:	7e 14                	jle    80097f <getint+0x1d>
+        return va_arg(*ap, long long);
+  80096b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80096e:	8b 00                	mov    (%eax),%eax
+  800970:	8d 48 08             	lea    0x8(%eax),%ecx
+  800973:	8b 55 08             	mov    0x8(%ebp),%edx
+  800976:	89 0a                	mov    %ecx,(%edx)
+  800978:	8b 50 04             	mov    0x4(%eax),%edx
+  80097b:	8b 00                	mov    (%eax),%eax
+  80097d:	eb 28                	jmp    8009a7 <getint+0x45>
+    }
+    else if (lflag) {
+  80097f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800983:	74 12                	je     800997 <getint+0x35>
+        return va_arg(*ap, long);
+  800985:	8b 45 08             	mov    0x8(%ebp),%eax
+  800988:	8b 00                	mov    (%eax),%eax
+  80098a:	8d 48 04             	lea    0x4(%eax),%ecx
+  80098d:	8b 55 08             	mov    0x8(%ebp),%edx
+  800990:	89 0a                	mov    %ecx,(%edx)
+  800992:	8b 00                	mov    (%eax),%eax
+  800994:	99                   	cltd   
+  800995:	eb 10                	jmp    8009a7 <getint+0x45>
+    }
+    else {
+        return va_arg(*ap, int);
+  800997:	8b 45 08             	mov    0x8(%ebp),%eax
+  80099a:	8b 00                	mov    (%eax),%eax
+  80099c:	8d 48 04             	lea    0x4(%eax),%ecx
+  80099f:	8b 55 08             	mov    0x8(%ebp),%edx
+  8009a2:	89 0a                	mov    %ecx,(%edx)
+  8009a4:	8b 00                	mov    (%eax),%eax
+  8009a6:	99                   	cltd   
+    }
+}
+  8009a7:	5d                   	pop    %ebp
+  8009a8:	c3                   	ret    
+
+008009a9 <printfmt>:
+ * @putch:      specified putch function, print a single character
+ * @putdat:     used by @putch function
+ * @fmt:        the format string to use
+ * */
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...) {
+  8009a9:	55                   	push   %ebp
+  8009aa:	89 e5                	mov    %esp,%ebp
+  8009ac:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  8009af:	8d 45 14             	lea    0x14(%ebp),%eax
+  8009b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    vprintfmt(putch, putdat, fmt, ap);
+  8009b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8009b8:	50                   	push   %eax
+  8009b9:	ff 75 10             	pushl  0x10(%ebp)
+  8009bc:	ff 75 0c             	pushl  0xc(%ebp)
+  8009bf:	ff 75 08             	pushl  0x8(%ebp)
+  8009c2:	e8 06 00 00 00       	call   8009cd <vprintfmt>
+  8009c7:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+  8009ca:	90                   	nop
+  8009cb:	c9                   	leave  
+  8009cc:	c3                   	ret    
+
+008009cd <vprintfmt>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want printfmt() instead.
+ * */
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap) {
+  8009cd:	55                   	push   %ebp
+  8009ce:	89 e5                	mov    %esp,%ebp
+  8009d0:	56                   	push   %esi
+  8009d1:	53                   	push   %ebx
+  8009d2:	83 ec 20             	sub    $0x20,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  8009d5:	eb 17                	jmp    8009ee <vprintfmt+0x21>
+            if (ch == '\0') {
+  8009d7:	85 db                	test   %ebx,%ebx
+  8009d9:	0f 84 8e 03 00 00    	je     800d6d <vprintfmt+0x3a0>
+                return;
+            }
+            putch(ch, putdat);
+  8009df:	83 ec 08             	sub    $0x8,%esp
+  8009e2:	ff 75 0c             	pushl  0xc(%ebp)
+  8009e5:	53                   	push   %ebx
+  8009e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009e9:	ff d0                	call   *%eax
+  8009eb:	83 c4 10             	add    $0x10,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  8009ee:	8b 45 10             	mov    0x10(%ebp),%eax
+  8009f1:	8d 50 01             	lea    0x1(%eax),%edx
+  8009f4:	89 55 10             	mov    %edx,0x10(%ebp)
+  8009f7:	0f b6 00             	movzbl (%eax),%eax
+  8009fa:	0f b6 d8             	movzbl %al,%ebx
+  8009fd:	83 fb 25             	cmp    $0x25,%ebx
+  800a00:	75 d5                	jne    8009d7 <vprintfmt+0xa>
+            }
+            putch(ch, putdat);
+        }
+
+        // Process a %-escape sequence
+        char padc = ' ';
+  800a02:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+        width = precision = -1;
+  800a06:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+  800a0d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800a10:	89 45 e8             	mov    %eax,-0x18(%ebp)
+        lflag = altflag = 0;
+  800a13:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+  800a1a:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  800a1d:	89 45 e0             	mov    %eax,-0x20(%ebp)
+
+    reswitch:
+        switch (ch = *(unsigned char *)fmt ++) {
+  800a20:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a23:	8d 50 01             	lea    0x1(%eax),%edx
+  800a26:	89 55 10             	mov    %edx,0x10(%ebp)
+  800a29:	0f b6 00             	movzbl (%eax),%eax
+  800a2c:	0f b6 d8             	movzbl %al,%ebx
+  800a2f:	8d 43 dd             	lea    -0x23(%ebx),%eax
+  800a32:	83 f8 55             	cmp    $0x55,%eax
+  800a35:	0f 87 05 03 00 00    	ja     800d40 <vprintfmt+0x373>
+  800a3b:	8b 04 85 08 11 80 00 	mov    0x801108(,%eax,4),%eax
+  800a42:	ff e0                	jmp    *%eax
+
+        // flag to pad on the right
+        case '-':
+            padc = '-';
+  800a44:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+            goto reswitch;
+  800a48:	eb d6                	jmp    800a20 <vprintfmt+0x53>
+
+        // flag to pad with 0's instead of spaces
+        case '0':
+            padc = '0';
+  800a4a:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+            goto reswitch;
+  800a4e:	eb d0                	jmp    800a20 <vprintfmt+0x53>
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  800a50:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+                precision = precision * 10 + ch - '0';
+  800a57:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800a5a:	89 d0                	mov    %edx,%eax
+  800a5c:	c1 e0 02             	shl    $0x2,%eax
+  800a5f:	01 d0                	add    %edx,%eax
+  800a61:	01 c0                	add    %eax,%eax
+  800a63:	01 d8                	add    %ebx,%eax
+  800a65:	83 e8 30             	sub    $0x30,%eax
+  800a68:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+                ch = *fmt;
+  800a6b:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a6e:	0f b6 00             	movzbl (%eax),%eax
+  800a71:	0f be d8             	movsbl %al,%ebx
+                if (ch < '0' || ch > '9') {
+  800a74:	83 fb 2f             	cmp    $0x2f,%ebx
+  800a77:	7e 39                	jle    800ab2 <vprintfmt+0xe5>
+  800a79:	83 fb 39             	cmp    $0x39,%ebx
+  800a7c:	7f 34                	jg     800ab2 <vprintfmt+0xe5>
+            padc = '0';
+            goto reswitch;
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  800a7e:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+                precision = precision * 10 + ch - '0';
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+  800a82:	eb d3                	jmp    800a57 <vprintfmt+0x8a>
+            goto process_precision;
+
+        case '*':
+            precision = va_arg(ap, int);
+  800a84:	8b 45 14             	mov    0x14(%ebp),%eax
+  800a87:	8d 50 04             	lea    0x4(%eax),%edx
+  800a8a:	89 55 14             	mov    %edx,0x14(%ebp)
+  800a8d:	8b 00                	mov    (%eax),%eax
+  800a8f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+            goto process_precision;
+  800a92:	eb 1f                	jmp    800ab3 <vprintfmt+0xe6>
+
+        case '.':
+            if (width < 0)
+  800a94:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800a98:	79 86                	jns    800a20 <vprintfmt+0x53>
+                width = 0;
+  800a9a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+            goto reswitch;
+  800aa1:	e9 7a ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        case '#':
+            altflag = 1;
+  800aa6:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+            goto reswitch;
+  800aad:	e9 6e ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+            goto process_precision;
+  800ab2:	90                   	nop
+        case '#':
+            altflag = 1;
+            goto reswitch;
+
+        process_precision:
+            if (width < 0)
+  800ab3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ab7:	0f 89 63 ff ff ff    	jns    800a20 <vprintfmt+0x53>
+                width = precision, precision = -1;
+  800abd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800ac0:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800ac3:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+            goto reswitch;
+  800aca:	e9 51 ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        // long flag (doubled for long long)
+        case 'l':
+            lflag ++;
+  800acf:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
+            goto reswitch;
+  800ad3:	e9 48 ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        // character
+        case 'c':
+            putch(va_arg(ap, int), putdat);
+  800ad8:	8b 45 14             	mov    0x14(%ebp),%eax
+  800adb:	8d 50 04             	lea    0x4(%eax),%edx
+  800ade:	89 55 14             	mov    %edx,0x14(%ebp)
+  800ae1:	8b 00                	mov    (%eax),%eax
+  800ae3:	83 ec 08             	sub    $0x8,%esp
+  800ae6:	ff 75 0c             	pushl  0xc(%ebp)
+  800ae9:	50                   	push   %eax
+  800aea:	8b 45 08             	mov    0x8(%ebp),%eax
+  800aed:	ff d0                	call   *%eax
+  800aef:	83 c4 10             	add    $0x10,%esp
+            break;
+  800af2:	e9 71 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // error message
+        case 'e':
+            err = va_arg(ap, int);
+  800af7:	8b 45 14             	mov    0x14(%ebp),%eax
+  800afa:	8d 50 04             	lea    0x4(%eax),%edx
+  800afd:	89 55 14             	mov    %edx,0x14(%ebp)
+  800b00:	8b 18                	mov    (%eax),%ebx
+            if (err < 0) {
+  800b02:	85 db                	test   %ebx,%ebx
+  800b04:	79 02                	jns    800b08 <vprintfmt+0x13b>
+                err = -err;
+  800b06:	f7 db                	neg    %ebx
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+  800b08:	83 fb 18             	cmp    $0x18,%ebx
+  800b0b:	7f 0b                	jg     800b18 <vprintfmt+0x14b>
+  800b0d:	8b 34 9d 80 10 80 00 	mov    0x801080(,%ebx,4),%esi
+  800b14:	85 f6                	test   %esi,%esi
+  800b16:	75 19                	jne    800b31 <vprintfmt+0x164>
+                printfmt(putch, putdat, "error %d", err);
+  800b18:	53                   	push   %ebx
+  800b19:	68 f5 10 80 00       	push   $0x8010f5
+  800b1e:	ff 75 0c             	pushl  0xc(%ebp)
+  800b21:	ff 75 08             	pushl  0x8(%ebp)
+  800b24:	e8 80 fe ff ff       	call   8009a9 <printfmt>
+  800b29:	83 c4 10             	add    $0x10,%esp
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+            }
+            break;
+  800b2c:	e9 37 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+                printfmt(putch, putdat, "error %d", err);
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+  800b31:	56                   	push   %esi
+  800b32:	68 fe 10 80 00       	push   $0x8010fe
+  800b37:	ff 75 0c             	pushl  0xc(%ebp)
+  800b3a:	ff 75 08             	pushl  0x8(%ebp)
+  800b3d:	e8 67 fe ff ff       	call   8009a9 <printfmt>
+  800b42:	83 c4 10             	add    $0x10,%esp
+            }
+            break;
+  800b45:	e9 1e 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // string
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+  800b4a:	8b 45 14             	mov    0x14(%ebp),%eax
+  800b4d:	8d 50 04             	lea    0x4(%eax),%edx
+  800b50:	89 55 14             	mov    %edx,0x14(%ebp)
+  800b53:	8b 30                	mov    (%eax),%esi
+  800b55:	85 f6                	test   %esi,%esi
+  800b57:	75 05                	jne    800b5e <vprintfmt+0x191>
+                p = "(null)";
+  800b59:	be 01 11 80 00       	mov    $0x801101,%esi
+            }
+            if (width > 0 && padc != '-') {
+  800b5e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800b62:	7e 76                	jle    800bda <vprintfmt+0x20d>
+  800b64:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+  800b68:	74 70                	je     800bda <vprintfmt+0x20d>
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  800b6a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800b6d:	83 ec 08             	sub    $0x8,%esp
+  800b70:	50                   	push   %eax
+  800b71:	56                   	push   %esi
+  800b72:	e8 17 f8 ff ff       	call   80038e <strnlen>
+  800b77:	83 c4 10             	add    $0x10,%esp
+  800b7a:	89 c2                	mov    %eax,%edx
+  800b7c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800b7f:	29 d0                	sub    %edx,%eax
+  800b81:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800b84:	eb 17                	jmp    800b9d <vprintfmt+0x1d0>
+                    putch(padc, putdat);
+  800b86:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+  800b8a:	83 ec 08             	sub    $0x8,%esp
+  800b8d:	ff 75 0c             	pushl  0xc(%ebp)
+  800b90:	50                   	push   %eax
+  800b91:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b94:	ff d0                	call   *%eax
+  800b96:	83 c4 10             	add    $0x10,%esp
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+                p = "(null)";
+            }
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  800b99:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800b9d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ba1:	7f e3                	jg     800b86 <vprintfmt+0x1b9>
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  800ba3:	eb 35                	jmp    800bda <vprintfmt+0x20d>
+                if (altflag && (ch < ' ' || ch > '~')) {
+  800ba5:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+  800ba9:	74 1c                	je     800bc7 <vprintfmt+0x1fa>
+  800bab:	83 fb 1f             	cmp    $0x1f,%ebx
+  800bae:	7e 05                	jle    800bb5 <vprintfmt+0x1e8>
+  800bb0:	83 fb 7e             	cmp    $0x7e,%ebx
+  800bb3:	7e 12                	jle    800bc7 <vprintfmt+0x1fa>
+                    putch('?', putdat);
+  800bb5:	83 ec 08             	sub    $0x8,%esp
+  800bb8:	ff 75 0c             	pushl  0xc(%ebp)
+  800bbb:	6a 3f                	push   $0x3f
+  800bbd:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bc0:	ff d0                	call   *%eax
+  800bc2:	83 c4 10             	add    $0x10,%esp
+  800bc5:	eb 0f                	jmp    800bd6 <vprintfmt+0x209>
+                }
+                else {
+                    putch(ch, putdat);
+  800bc7:	83 ec 08             	sub    $0x8,%esp
+  800bca:	ff 75 0c             	pushl  0xc(%ebp)
+  800bcd:	53                   	push   %ebx
+  800bce:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bd1:	ff d0                	call   *%eax
+  800bd3:	83 c4 10             	add    $0x10,%esp
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  800bd6:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800bda:	89 f0                	mov    %esi,%eax
+  800bdc:	8d 70 01             	lea    0x1(%eax),%esi
+  800bdf:	0f b6 00             	movzbl (%eax),%eax
+  800be2:	0f be d8             	movsbl %al,%ebx
+  800be5:	85 db                	test   %ebx,%ebx
+  800be7:	74 26                	je     800c0f <vprintfmt+0x242>
+  800be9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800bed:	78 b6                	js     800ba5 <vprintfmt+0x1d8>
+  800bef:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800bf3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800bf7:	79 ac                	jns    800ba5 <vprintfmt+0x1d8>
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  800bf9:	eb 14                	jmp    800c0f <vprintfmt+0x242>
+                putch(' ', putdat);
+  800bfb:	83 ec 08             	sub    $0x8,%esp
+  800bfe:	ff 75 0c             	pushl  0xc(%ebp)
+  800c01:	6a 20                	push   $0x20
+  800c03:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c06:	ff d0                	call   *%eax
+  800c08:	83 c4 10             	add    $0x10,%esp
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  800c0b:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800c0f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800c13:	7f e6                	jg     800bfb <vprintfmt+0x22e>
+                putch(' ', putdat);
+            }
+            break;
+  800c15:	e9 4e 01 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // (signed) decimal
+        case 'd':
+            num = getint(&ap, lflag);
+  800c1a:	83 ec 08             	sub    $0x8,%esp
+  800c1d:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c20:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c23:	50                   	push   %eax
+  800c24:	e8 39 fd ff ff       	call   800962 <getint>
+  800c29:	83 c4 10             	add    $0x10,%esp
+  800c2c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c2f:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            if ((long long)num < 0) {
+  800c32:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c35:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800c38:	85 d2                	test   %edx,%edx
+  800c3a:	79 23                	jns    800c5f <vprintfmt+0x292>
+                putch('-', putdat);
+  800c3c:	83 ec 08             	sub    $0x8,%esp
+  800c3f:	ff 75 0c             	pushl  0xc(%ebp)
+  800c42:	6a 2d                	push   $0x2d
+  800c44:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c47:	ff d0                	call   *%eax
+  800c49:	83 c4 10             	add    $0x10,%esp
+                num = -(long long)num;
+  800c4c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c4f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800c52:	f7 d8                	neg    %eax
+  800c54:	83 d2 00             	adc    $0x0,%edx
+  800c57:	f7 da                	neg    %edx
+  800c59:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c5c:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            }
+            base = 10;
+  800c5f:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  800c66:	e9 9f 00 00 00       	jmp    800d0a <vprintfmt+0x33d>
+
+        // unsigned decimal
+        case 'u':
+            num = getuint(&ap, lflag);
+  800c6b:	83 ec 08             	sub    $0x8,%esp
+  800c6e:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c71:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c74:	50                   	push   %eax
+  800c75:	e8 99 fc ff ff       	call   800913 <getuint>
+  800c7a:	83 c4 10             	add    $0x10,%esp
+  800c7d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c80:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 10;
+  800c83:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  800c8a:	eb 7e                	jmp    800d0a <vprintfmt+0x33d>
+
+        // (unsigned) octal
+        case 'o':
+            num = getuint(&ap, lflag);
+  800c8c:	83 ec 08             	sub    $0x8,%esp
+  800c8f:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c92:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c95:	50                   	push   %eax
+  800c96:	e8 78 fc ff ff       	call   800913 <getuint>
+  800c9b:	83 c4 10             	add    $0x10,%esp
+  800c9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800ca1:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 8;
+  800ca4:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+            goto number;
+  800cab:	eb 5d                	jmp    800d0a <vprintfmt+0x33d>
+
+        // pointer
+        case 'p':
+            putch('0', putdat);
+  800cad:	83 ec 08             	sub    $0x8,%esp
+  800cb0:	ff 75 0c             	pushl  0xc(%ebp)
+  800cb3:	6a 30                	push   $0x30
+  800cb5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cb8:	ff d0                	call   *%eax
+  800cba:	83 c4 10             	add    $0x10,%esp
+            putch('x', putdat);
+  800cbd:	83 ec 08             	sub    $0x8,%esp
+  800cc0:	ff 75 0c             	pushl  0xc(%ebp)
+  800cc3:	6a 78                	push   $0x78
+  800cc5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cc8:	ff d0                	call   *%eax
+  800cca:	83 c4 10             	add    $0x10,%esp
+            num = (unsigned long long)(uintptr_t)va_arg(ap, void *);
+  800ccd:	8b 45 14             	mov    0x14(%ebp),%eax
+  800cd0:	8d 50 04             	lea    0x4(%eax),%edx
+  800cd3:	89 55 14             	mov    %edx,0x14(%ebp)
+  800cd6:	8b 00                	mov    (%eax),%eax
+  800cd8:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800cdb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+            base = 16;
+  800ce2:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+            goto number;
+  800ce9:	eb 1f                	jmp    800d0a <vprintfmt+0x33d>
+
+        // (unsigned) hexadecimal
+        case 'x':
+            num = getuint(&ap, lflag);
+  800ceb:	83 ec 08             	sub    $0x8,%esp
+  800cee:	ff 75 e0             	pushl  -0x20(%ebp)
+  800cf1:	8d 45 14             	lea    0x14(%ebp),%eax
+  800cf4:	50                   	push   %eax
+  800cf5:	e8 19 fc ff ff       	call   800913 <getuint>
+  800cfa:	83 c4 10             	add    $0x10,%esp
+  800cfd:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800d00:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 16;
+  800d03:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+        number:
+            printnum(putch, putdat, num, base, width, padc);
+  800d0a:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+  800d0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800d11:	83 ec 04             	sub    $0x4,%esp
+  800d14:	52                   	push   %edx
+  800d15:	ff 75 e8             	pushl  -0x18(%ebp)
+  800d18:	50                   	push   %eax
+  800d19:	ff 75 f4             	pushl  -0xc(%ebp)
+  800d1c:	ff 75 f0             	pushl  -0x10(%ebp)
+  800d1f:	ff 75 0c             	pushl  0xc(%ebp)
+  800d22:	ff 75 08             	pushl  0x8(%ebp)
+  800d25:	e8 f8 fa ff ff       	call   800822 <printnum>
+  800d2a:	83 c4 20             	add    $0x20,%esp
+            break;
+  800d2d:	eb 39                	jmp    800d68 <vprintfmt+0x39b>
+
+        // escaped '%' character
+        case '%':
+            putch(ch, putdat);
+  800d2f:	83 ec 08             	sub    $0x8,%esp
+  800d32:	ff 75 0c             	pushl  0xc(%ebp)
+  800d35:	53                   	push   %ebx
+  800d36:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d39:	ff d0                	call   *%eax
+  800d3b:	83 c4 10             	add    $0x10,%esp
+            break;
+  800d3e:	eb 28                	jmp    800d68 <vprintfmt+0x39b>
+
+        // unrecognized escape sequence - just print it literally
+        default:
+            putch('%', putdat);
+  800d40:	83 ec 08             	sub    $0x8,%esp
+  800d43:	ff 75 0c             	pushl  0xc(%ebp)
+  800d46:	6a 25                	push   $0x25
+  800d48:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d4b:	ff d0                	call   *%eax
+  800d4d:	83 c4 10             	add    $0x10,%esp
+            for (fmt --; fmt[-1] != '%'; fmt --)
+  800d50:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800d54:	eb 04                	jmp    800d5a <vprintfmt+0x38d>
+  800d56:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800d5a:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d5d:	83 e8 01             	sub    $0x1,%eax
+  800d60:	0f b6 00             	movzbl (%eax),%eax
+  800d63:	3c 25                	cmp    $0x25,%al
+  800d65:	75 ef                	jne    800d56 <vprintfmt+0x389>
+                /* do nothing */;
+            break;
+  800d67:	90                   	nop
+        }
+    }
+  800d68:	e9 68 fc ff ff       	jmp    8009d5 <vprintfmt+0x8>
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+            if (ch == '\0') {
+                return;
+  800d6d:	90                   	nop
+            for (fmt --; fmt[-1] != '%'; fmt --)
+                /* do nothing */;
+            break;
+        }
+    }
+}
+  800d6e:	8d 65 f8             	lea    -0x8(%ebp),%esp
+  800d71:	5b                   	pop    %ebx
+  800d72:	5e                   	pop    %esi
+  800d73:	5d                   	pop    %ebp
+  800d74:	c3                   	ret    
+
+00800d75 <sprintputch>:
+ * sprintputch - 'print' a single character in a buffer
+ * @ch:         the character will be printed
+ * @b:          the buffer to place the character @ch
+ * */
+static void
+sprintputch(int ch, struct sprintbuf *b) {
+  800d75:	55                   	push   %ebp
+  800d76:	89 e5                	mov    %esp,%ebp
+    b->cnt ++;
+  800d78:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d7b:	8b 40 08             	mov    0x8(%eax),%eax
+  800d7e:	8d 50 01             	lea    0x1(%eax),%edx
+  800d81:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d84:	89 50 08             	mov    %edx,0x8(%eax)
+    if (b->buf < b->ebuf) {
+  800d87:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8a:	8b 10                	mov    (%eax),%edx
+  800d8c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8f:	8b 40 04             	mov    0x4(%eax),%eax
+  800d92:	39 c2                	cmp    %eax,%edx
+  800d94:	73 12                	jae    800da8 <sprintputch+0x33>
+        *b->buf ++ = ch;
+  800d96:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d99:	8b 00                	mov    (%eax),%eax
+  800d9b:	8d 48 01             	lea    0x1(%eax),%ecx
+  800d9e:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800da1:	89 0a                	mov    %ecx,(%edx)
+  800da3:	8b 55 08             	mov    0x8(%ebp),%edx
+  800da6:	88 10                	mov    %dl,(%eax)
+    }
+}
+  800da8:	90                   	nop
+  800da9:	5d                   	pop    %ebp
+  800daa:	c3                   	ret    
+
+00800dab <snprintf>:
+ * @str:        the buffer to place the result into
+ * @size:       the size of buffer, including the trailing null space
+ * @fmt:        the format string to use
+ * */
+int
+snprintf(char *str, size_t size, const char *fmt, ...) {
+  800dab:	55                   	push   %ebp
+  800dac:	89 e5                	mov    %esp,%ebp
+  800dae:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    int cnt;
+    va_start(ap, fmt);
+  800db1:	8d 45 14             	lea    0x14(%ebp),%eax
+  800db4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    cnt = vsnprintf(str, size, fmt, ap);
+  800db7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800dba:	50                   	push   %eax
+  800dbb:	ff 75 10             	pushl  0x10(%ebp)
+  800dbe:	ff 75 0c             	pushl  0xc(%ebp)
+  800dc1:	ff 75 08             	pushl  0x8(%ebp)
+  800dc4:	e8 0b 00 00 00       	call   800dd4 <vsnprintf>
+  800dc9:	83 c4 10             	add    $0x10,%esp
+  800dcc:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+    return cnt;
+  800dcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800dd2:	c9                   	leave  
+  800dd3:	c3                   	ret    
+
+00800dd4 <vsnprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want snprintf() instead.
+ * */
+int
+vsnprintf(char *str, size_t size, const char *fmt, va_list ap) {
+  800dd4:	55                   	push   %ebp
+  800dd5:	89 e5                	mov    %esp,%ebp
+  800dd7:	83 ec 18             	sub    $0x18,%esp
+    struct sprintbuf b = {str, str + size - 1, 0};
+  800dda:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ddd:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800de0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800de3:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800de6:	8b 45 08             	mov    0x8(%ebp),%eax
+  800de9:	01 d0                	add    %edx,%eax
+  800deb:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800dee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    if (str == NULL || b.buf > b.ebuf) {
+  800df5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  800df9:	74 0a                	je     800e05 <vsnprintf+0x31>
+  800dfb:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  800dfe:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800e01:	39 c2                	cmp    %eax,%edx
+  800e03:	76 07                	jbe    800e0c <vsnprintf+0x38>
+        return -E_INVAL;
+  800e05:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+  800e0a:	eb 20                	jmp    800e2c <vsnprintf+0x58>
+    }
+    // print the string to the buffer
+    vprintfmt((void*)sprintputch, &b, fmt, ap);
+  800e0c:	ff 75 14             	pushl  0x14(%ebp)
+  800e0f:	ff 75 10             	pushl  0x10(%ebp)
+  800e12:	8d 45 ec             	lea    -0x14(%ebp),%eax
+  800e15:	50                   	push   %eax
+  800e16:	68 75 0d 80 00       	push   $0x800d75
+  800e1b:	e8 ad fb ff ff       	call   8009cd <vprintfmt>
+  800e20:	83 c4 10             	add    $0x10,%esp
+    // null terminate the buffer
+    *b.buf = '\0';
+  800e23:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e26:	c6 00 00             	movb   $0x0,(%eax)
+    return b.cnt;
+  800e29:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800e2c:	c9                   	leave  
+  800e2d:	c3                   	ret    
+
+00800e2e <hash32>:
+ * @bits:   the number of bits in a return value
+ *
+ * High bits are more random, so we use them.
+ * */
+uint32_t
+hash32(uint32_t val, unsigned int bits) {
+  800e2e:	55                   	push   %ebp
+  800e2f:	89 e5                	mov    %esp,%ebp
+  800e31:	83 ec 10             	sub    $0x10,%esp
+    uint32_t hash = val * GOLDEN_RATIO_PRIME_32;
+  800e34:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e37:	69 c0 01 00 37 9e    	imul   $0x9e370001,%eax,%eax
+  800e3d:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    return (hash >> (32 - bits));
+  800e40:	b8 20 00 00 00       	mov    $0x20,%eax
+  800e45:	2b 45 0c             	sub    0xc(%ebp),%eax
+  800e48:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  800e4b:	89 c1                	mov    %eax,%ecx
+  800e4d:	d3 ea                	shr    %cl,%edx
+  800e4f:	89 d0                	mov    %edx,%eax
+}
+  800e51:	c9                   	leave  
+  800e52:	c3                   	ret    
+
+00800e53 <rand>:
+ * rand - returns a pseudo-random integer
+ *
+ * The rand() function return a value in the range [0, RAND_MAX].
+ * */
+int
+rand(void) {
+  800e53:	55                   	push   %ebp
+  800e54:	89 e5                	mov    %esp,%ebp
+  800e56:	57                   	push   %edi
+  800e57:	56                   	push   %esi
+  800e58:	53                   	push   %ebx
+  800e59:	83 ec 24             	sub    $0x24,%esp
+    next = (next * 0x5DEECE66DLL + 0xBLL) & ((1LL << 48) - 1);
+  800e5c:	a1 00 20 80 00       	mov    0x802000,%eax
+  800e61:	8b 15 04 20 80 00    	mov    0x802004,%edx
+  800e67:	69 fa 6d e6 ec de    	imul   $0xdeece66d,%edx,%edi
+  800e6d:	6b f0 05             	imul   $0x5,%eax,%esi
+  800e70:	01 fe                	add    %edi,%esi
+  800e72:	bf 6d e6 ec de       	mov    $0xdeece66d,%edi
+  800e77:	f7 e7                	mul    %edi
+  800e79:	01 d6                	add    %edx,%esi
+  800e7b:	89 f2                	mov    %esi,%edx
+  800e7d:	83 c0 0b             	add    $0xb,%eax
+  800e80:	83 d2 00             	adc    $0x0,%edx
+  800e83:	89 c7                	mov    %eax,%edi
+  800e85:	83 e7 ff             	and    $0xffffffff,%edi
+  800e88:	89 f9                	mov    %edi,%ecx
+  800e8a:	0f b7 da             	movzwl %dx,%ebx
+  800e8d:	89 0d 00 20 80 00    	mov    %ecx,0x802000
+  800e93:	89 1d 04 20 80 00    	mov    %ebx,0x802004
+    unsigned long long result = (next >> 12);
+  800e99:	a1 00 20 80 00       	mov    0x802000,%eax
+  800e9e:	8b 15 04 20 80 00    	mov    0x802004,%edx
+  800ea4:	0f ac d0 0c          	shrd   $0xc,%edx,%eax
+  800ea8:	c1 ea 0c             	shr    $0xc,%edx
+  800eab:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800eae:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+    return (int)do_div(result, RAND_MAX + 1);
+  800eb1:	c7 45 dc 00 00 00 80 	movl   $0x80000000,-0x24(%ebp)
+  800eb8:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  800ebb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800ebe:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  800ec1:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  800ec4:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ec7:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800eca:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ece:	74 1c                	je     800eec <rand+0x99>
+  800ed0:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ed3:	ba 00 00 00 00       	mov    $0x0,%edx
+  800ed8:	f7 75 dc             	divl   -0x24(%ebp)
+  800edb:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  800ede:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ee1:	ba 00 00 00 00       	mov    $0x0,%edx
+  800ee6:	f7 75 dc             	divl   -0x24(%ebp)
+  800ee9:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800eec:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  800eef:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  800ef2:	f7 75 dc             	divl   -0x24(%ebp)
+  800ef5:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  800ef8:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  800efb:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  800efe:	8b 55 e8             	mov    -0x18(%ebp),%edx
+  800f01:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800f04:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  800f07:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+}
+  800f0a:	83 c4 24             	add    $0x24,%esp
+  800f0d:	5b                   	pop    %ebx
+  800f0e:	5e                   	pop    %esi
+  800f0f:	5f                   	pop    %edi
+  800f10:	5d                   	pop    %ebp
+  800f11:	c3                   	ret    
+
+00800f12 <srand>:
+/* *
+ * srand - seed the random number generator with the given number
+ * @seed:   the required seed number
+ * */
+void
+srand(unsigned int seed) {
+  800f12:	55                   	push   %ebp
+  800f13:	89 e5                	mov    %esp,%ebp
+    next = seed;
+  800f15:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f18:	ba 00 00 00 00       	mov    $0x0,%edx
+  800f1d:	a3 00 20 80 00       	mov    %eax,0x802000
+  800f22:	89 15 04 20 80 00    	mov    %edx,0x802004
+}
+  800f28:	90                   	nop
+  800f29:	5d                   	pop    %ebp
+  800f2a:	c3                   	ret    
+
+00800f2b <main>:
+#include <stdio.h>
+#include <ulib.h>
+
+int
+main(void) {
+  800f2b:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+  800f2f:	83 e4 f0             	and    $0xfffffff0,%esp
+  800f32:	ff 71 fc             	pushl  -0x4(%ecx)
+  800f35:	55                   	push   %ebp
+  800f36:	89 e5                	mov    %esp,%ebp
+  800f38:	51                   	push   %ecx
+  800f39:	83 ec 04             	sub    $0x4,%esp
+    cprintf("Hello world!!.\n");
+  800f3c:	83 ec 0c             	sub    $0xc,%esp
+  800f3f:	68 60 12 80 00       	push   $0x801260
+  800f44:	e8 90 f3 ff ff       	call   8002d9 <cprintf>
+  800f49:	83 c4 10             	add    $0x10,%esp
+    cprintf("I am process %d.\n", getpid());
+  800f4c:	e8 ed f2 ff ff       	call   80023e <getpid>
+  800f51:	83 ec 08             	sub    $0x8,%esp
+  800f54:	50                   	push   %eax
+  800f55:	68 70 12 80 00       	push   $0x801270
+  800f5a:	e8 7a f3 ff ff       	call   8002d9 <cprintf>
+  800f5f:	83 c4 10             	add    $0x10,%esp
+    cprintf("hello pass.\n");
+  800f62:	83 ec 0c             	sub    $0xc,%esp
+  800f65:	68 82 12 80 00       	push   $0x801282
+  800f6a:	e8 6a f3 ff ff       	call   8002d9 <cprintf>
+  800f6f:	83 c4 10             	add    $0x10,%esp
+    return 0;
+  800f72:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800f77:	8b 4d fc             	mov    -0x4(%ebp),%ecx
+  800f7a:	c9                   	leave  
+  800f7b:	8d 61 fc             	lea    -0x4(%ecx),%esp
+  800f7e:	c3                   	ret    
diff -r -u -P lab6_origin/obj/user/hello.d lab6/obj/user/hello.d
--- lab6_origin/obj/user/hello.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/hello.d	2019-05-13 17:39:38.311084400 +0800
@@ -0,0 +1,2 @@
+obj/user/hello.o obj/user/hello.d: user/hello.c libs/stdio.h libs/defs.h \
+ libs/stdarg.h user/libs/ulib.h
Binary files lab6_origin/obj/user/hello.o and lab6/obj/user/hello.o differ
diff -r -u -P lab6_origin/obj/user/hello.sym lab6/obj/user/hello.sym
--- lab6_origin/obj/user/hello.sym	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/hello.sym	2019-05-13 17:39:43.833914100 +0800
@@ -0,0 +1,76 @@
+00800020 .text
+00800f80 .rodata
+00802000 .data
+00200000 .stab_info
+00200010 .stab
+00202cb1 .stabstr
+00000000 panic.c
+00000000 syscall.c
+008000b5 syscall
+00000000 ulib.c
+00000000 stdio.c
+0080028c cputch
+00000000 umain.c
+00000000 string.c
+00000000 printfmt.c
+00801080 error_string
+00800822 printnum
+00800913 getuint
+00800962 getint
+00800d75 sprintputch
+00000000 hash.c
+00000000 rand.c
+00802000 next
+00000000 hello.c
+008003be strcpy
+0080021a yield
+00800201 waitpid
+00800141 sys_yield
+008006d7 memmove
+00800dab snprintf
+008009cd vprintfmt
+0080011d sys_fork
+008002d9 cprintf
+0080023e getpid
+0080077a memcpy
+00800266 lab6_set_priority
+00800dd4 vsnprintf
+0080034d umain
+00202cb0 __STAB_END__
+00800150 sys_kill
+00202cb1 __STABSTR_BEGIN__
+00800020 __panic
+0080053a strtol
+0080038e strnlen
+0080024b print_pgdir
+00800228 kill
+0080050b strfind
+008001ea wait
+0080027d _start
+00800e53 rand
+00800482 strncmp
+00800171 sys_putc
+008003fe strncpy
+008007ca memcmp
+008001dd fork
+00800697 memset
+00800f2b main
+00800f12 srand
+00800e2e hash32
+008009a9 printfmt
+00203a8f __STABSTR_END__
+00800438 strcmp
+00800259 gettime_msec
+00800192 sys_gettime
+008002b0 vcprintf
+0080006e __warn
+008002ff cputs
+008001a1 sys_lab6_set_priority
+008001b7 exit
+0080012c sys_wait
+0080010b sys_exit
+00200010 __STAB_BEGIN__
+00800366 strlen
+00800183 sys_pgdir
+008004d8 strchr
+00800162 sys_getpid
diff -r -u -P lab6_origin/obj/user/libs/initcode.d lab6/obj/user/libs/initcode.d
--- lab6_origin/obj/user/libs/initcode.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/libs/initcode.d	2019-05-13 17:39:38.447006800 +0800
@@ -0,0 +1 @@
+obj/user/libs/initcode.o obj/user/libs/initcode.d: user/libs/initcode.S
Binary files lab6_origin/obj/user/libs/initcode.o and lab6/obj/user/libs/initcode.o differ
diff -r -u -P lab6_origin/obj/user/libs/panic.d lab6/obj/user/libs/panic.d
--- lab6_origin/obj/user/libs/panic.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/libs/panic.d	2019-05-13 17:39:38.477989300 +0800
@@ -0,0 +1,2 @@
+obj/user/libs/panic.o obj/user/libs/panic.d: user/libs/panic.c \
+ libs/defs.h libs/stdarg.h libs/stdio.h user/libs/ulib.h libs/error.h
Binary files lab6_origin/obj/user/libs/panic.o and lab6/obj/user/libs/panic.o differ
diff -r -u -P lab6_origin/obj/user/libs/stdio.d lab6/obj/user/libs/stdio.d
--- lab6_origin/obj/user/libs/stdio.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/libs/stdio.d	2019-05-13 17:39:38.557942900 +0800
@@ -0,0 +1,2 @@
+obj/user/libs/stdio.o obj/user/libs/stdio.d: user/libs/stdio.c \
+ libs/defs.h libs/stdio.h libs/stdarg.h user/libs/syscall.h
Binary files lab6_origin/obj/user/libs/stdio.o and lab6/obj/user/libs/stdio.o differ
diff -r -u -P lab6_origin/obj/user/libs/syscall.d lab6/obj/user/libs/syscall.d
--- lab6_origin/obj/user/libs/syscall.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/libs/syscall.d	2019-05-13 17:39:38.548948300 +0800
@@ -0,0 +1,2 @@
+obj/user/libs/syscall.o obj/user/libs/syscall.d: user/libs/syscall.c \
+ libs/defs.h libs/unistd.h libs/stdarg.h user/libs/syscall.h
Binary files lab6_origin/obj/user/libs/syscall.o and lab6/obj/user/libs/syscall.o differ
diff -r -u -P lab6_origin/obj/user/libs/ulib.d lab6/obj/user/libs/ulib.d
--- lab6_origin/obj/user/libs/ulib.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/libs/ulib.d	2019-05-13 17:39:38.458999700 +0800
@@ -0,0 +1,2 @@
+obj/user/libs/ulib.o obj/user/libs/ulib.d: user/libs/ulib.c libs/defs.h \
+ user/libs/syscall.h libs/stdio.h libs/stdarg.h user/libs/ulib.h
Binary files lab6_origin/obj/user/libs/ulib.o and lab6/obj/user/libs/ulib.o differ
diff -r -u -P lab6_origin/obj/user/libs/umain.d lab6/obj/user/libs/umain.d
--- lab6_origin/obj/user/libs/umain.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/libs/umain.d	2019-05-13 17:39:38.558942500 +0800
@@ -0,0 +1,2 @@
+obj/user/libs/umain.o obj/user/libs/umain.d: user/libs/umain.c \
+ user/libs/ulib.h libs/defs.h
Binary files lab6_origin/obj/user/libs/umain.o and lab6/obj/user/libs/umain.o differ
diff -r -u -P lab6_origin/obj/user/matrix.asm lab6/obj/user/matrix.asm
--- lab6_origin/obj/user/matrix.asm	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/matrix.asm	2019-05-13 17:39:43.852902400 +0800
@@ -0,0 +1,3029 @@
+
+obj/__user_matrix.out:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00800020 <__panic>:
+#include <stdio.h>
+#include <ulib.h>
+#include <error.h>
+
+void
+__panic(const char *file, int line, const char *fmt, ...) {
+  800020:	55                   	push   %ebp
+  800021:	89 e5                	mov    %esp,%ebp
+  800023:	83 ec 18             	sub    $0x18,%esp
+    // print the 'message'
+    va_list ap;
+    va_start(ap, fmt);
+  800026:	8d 45 14             	lea    0x14(%ebp),%eax
+  800029:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("user panic at %s:%d:\n    ", file, line);
+  80002c:	83 ec 04             	sub    $0x4,%esp
+  80002f:	ff 75 0c             	pushl  0xc(%ebp)
+  800032:	ff 75 08             	pushl  0x8(%ebp)
+  800035:	68 20 13 80 00       	push   $0x801320
+  80003a:	e8 9a 02 00 00       	call   8002d9 <cprintf>
+  80003f:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+  800042:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800045:	83 ec 08             	sub    $0x8,%esp
+  800048:	50                   	push   %eax
+  800049:	ff 75 10             	pushl  0x10(%ebp)
+  80004c:	e8 5f 02 00 00       	call   8002b0 <vcprintf>
+  800051:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+  800054:	83 ec 0c             	sub    $0xc,%esp
+  800057:	68 3a 13 80 00       	push   $0x80133a
+  80005c:	e8 78 02 00 00       	call   8002d9 <cprintf>
+  800061:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+    exit(-E_PANIC);
+  800064:	83 ec 0c             	sub    $0xc,%esp
+  800067:	6a f6                	push   $0xfffffff6
+  800069:	e8 49 01 00 00       	call   8001b7 <exit>
+
+0080006e <__warn>:
+}
+
+void
+__warn(const char *file, int line, const char *fmt, ...) {
+  80006e:	55                   	push   %ebp
+  80006f:	89 e5                	mov    %esp,%ebp
+  800071:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    va_start(ap, fmt);
+  800074:	8d 45 14             	lea    0x14(%ebp),%eax
+  800077:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("user warning at %s:%d:\n    ", file, line);
+  80007a:	83 ec 04             	sub    $0x4,%esp
+  80007d:	ff 75 0c             	pushl  0xc(%ebp)
+  800080:	ff 75 08             	pushl  0x8(%ebp)
+  800083:	68 3c 13 80 00       	push   $0x80133c
+  800088:	e8 4c 02 00 00       	call   8002d9 <cprintf>
+  80008d:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+  800090:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800093:	83 ec 08             	sub    $0x8,%esp
+  800096:	50                   	push   %eax
+  800097:	ff 75 10             	pushl  0x10(%ebp)
+  80009a:	e8 11 02 00 00       	call   8002b0 <vcprintf>
+  80009f:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+  8000a2:	83 ec 0c             	sub    $0xc,%esp
+  8000a5:	68 3a 13 80 00       	push   $0x80133a
+  8000aa:	e8 2a 02 00 00       	call   8002d9 <cprintf>
+  8000af:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+  8000b2:	90                   	nop
+  8000b3:	c9                   	leave  
+  8000b4:	c3                   	ret    
+
+008000b5 <syscall>:
+#include <syscall.h>
+
+#define MAX_ARGS            5
+
+static inline int
+syscall(int num, ...) {
+  8000b5:	55                   	push   %ebp
+  8000b6:	89 e5                	mov    %esp,%ebp
+  8000b8:	57                   	push   %edi
+  8000b9:	56                   	push   %esi
+  8000ba:	53                   	push   %ebx
+  8000bb:	83 ec 20             	sub    $0x20,%esp
+    va_list ap;
+    va_start(ap, num);
+  8000be:	8d 45 0c             	lea    0xc(%ebp),%eax
+  8000c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    uint32_t a[MAX_ARGS];
+    int i, ret;
+    for (i = 0; i < MAX_ARGS; i ++) {
+  8000c4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  8000cb:	eb 16                	jmp    8000e3 <syscall+0x2e>
+        a[i] = va_arg(ap, uint32_t);
+  8000cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8000d0:	8d 50 04             	lea    0x4(%eax),%edx
+  8000d3:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  8000d6:	8b 10                	mov    (%eax),%edx
+  8000d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8000db:	89 54 85 d4          	mov    %edx,-0x2c(%ebp,%eax,4)
+syscall(int num, ...) {
+    va_list ap;
+    va_start(ap, num);
+    uint32_t a[MAX_ARGS];
+    int i, ret;
+    for (i = 0; i < MAX_ARGS; i ++) {
+  8000df:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+  8000e3:	83 7d f0 04          	cmpl   $0x4,-0x10(%ebp)
+  8000e7:	7e e4                	jle    8000cd <syscall+0x18>
+    asm volatile (
+        "int %1;"
+        : "=a" (ret)
+        : "i" (T_SYSCALL),
+          "a" (num),
+          "d" (a[0]),
+  8000e9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+          "c" (a[1]),
+  8000ec:	8b 4d d8             	mov    -0x28(%ebp),%ecx
+          "b" (a[2]),
+  8000ef:	8b 5d dc             	mov    -0x24(%ebp),%ebx
+          "D" (a[3]),
+  8000f2:	8b 7d e0             	mov    -0x20(%ebp),%edi
+          "S" (a[4])
+  8000f5:	8b 75 e4             	mov    -0x1c(%ebp),%esi
+    for (i = 0; i < MAX_ARGS; i ++) {
+        a[i] = va_arg(ap, uint32_t);
+    }
+    va_end(ap);
+
+    asm volatile (
+  8000f8:	8b 45 08             	mov    0x8(%ebp),%eax
+  8000fb:	cd 80                	int    $0x80
+  8000fd:	89 45 ec             	mov    %eax,-0x14(%ebp)
+          "c" (a[1]),
+          "b" (a[2]),
+          "D" (a[3]),
+          "S" (a[4])
+        : "cc", "memory");
+    return ret;
+  800100:	8b 45 ec             	mov    -0x14(%ebp),%eax
+}
+  800103:	83 c4 20             	add    $0x20,%esp
+  800106:	5b                   	pop    %ebx
+  800107:	5e                   	pop    %esi
+  800108:	5f                   	pop    %edi
+  800109:	5d                   	pop    %ebp
+  80010a:	c3                   	ret    
+
+0080010b <sys_exit>:
+
+int
+sys_exit(int error_code) {
+  80010b:	55                   	push   %ebp
+  80010c:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_exit, error_code);
+  80010e:	ff 75 08             	pushl  0x8(%ebp)
+  800111:	6a 01                	push   $0x1
+  800113:	e8 9d ff ff ff       	call   8000b5 <syscall>
+  800118:	83 c4 08             	add    $0x8,%esp
+}
+  80011b:	c9                   	leave  
+  80011c:	c3                   	ret    
+
+0080011d <sys_fork>:
+
+int
+sys_fork(void) {
+  80011d:	55                   	push   %ebp
+  80011e:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_fork);
+  800120:	6a 02                	push   $0x2
+  800122:	e8 8e ff ff ff       	call   8000b5 <syscall>
+  800127:	83 c4 04             	add    $0x4,%esp
+}
+  80012a:	c9                   	leave  
+  80012b:	c3                   	ret    
+
+0080012c <sys_wait>:
+
+int
+sys_wait(int pid, int *store) {
+  80012c:	55                   	push   %ebp
+  80012d:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_wait, pid, store);
+  80012f:	ff 75 0c             	pushl  0xc(%ebp)
+  800132:	ff 75 08             	pushl  0x8(%ebp)
+  800135:	6a 03                	push   $0x3
+  800137:	e8 79 ff ff ff       	call   8000b5 <syscall>
+  80013c:	83 c4 0c             	add    $0xc,%esp
+}
+  80013f:	c9                   	leave  
+  800140:	c3                   	ret    
+
+00800141 <sys_yield>:
+
+int
+sys_yield(void) {
+  800141:	55                   	push   %ebp
+  800142:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_yield);
+  800144:	6a 0a                	push   $0xa
+  800146:	e8 6a ff ff ff       	call   8000b5 <syscall>
+  80014b:	83 c4 04             	add    $0x4,%esp
+}
+  80014e:	c9                   	leave  
+  80014f:	c3                   	ret    
+
+00800150 <sys_kill>:
+
+int
+sys_kill(int pid) {
+  800150:	55                   	push   %ebp
+  800151:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_kill, pid);
+  800153:	ff 75 08             	pushl  0x8(%ebp)
+  800156:	6a 0c                	push   $0xc
+  800158:	e8 58 ff ff ff       	call   8000b5 <syscall>
+  80015d:	83 c4 08             	add    $0x8,%esp
+}
+  800160:	c9                   	leave  
+  800161:	c3                   	ret    
+
+00800162 <sys_getpid>:
+
+int
+sys_getpid(void) {
+  800162:	55                   	push   %ebp
+  800163:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_getpid);
+  800165:	6a 12                	push   $0x12
+  800167:	e8 49 ff ff ff       	call   8000b5 <syscall>
+  80016c:	83 c4 04             	add    $0x4,%esp
+}
+  80016f:	c9                   	leave  
+  800170:	c3                   	ret    
+
+00800171 <sys_putc>:
+
+int
+sys_putc(int c) {
+  800171:	55                   	push   %ebp
+  800172:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_putc, c);
+  800174:	ff 75 08             	pushl  0x8(%ebp)
+  800177:	6a 1e                	push   $0x1e
+  800179:	e8 37 ff ff ff       	call   8000b5 <syscall>
+  80017e:	83 c4 08             	add    $0x8,%esp
+}
+  800181:	c9                   	leave  
+  800182:	c3                   	ret    
+
+00800183 <sys_pgdir>:
+
+int
+sys_pgdir(void) {
+  800183:	55                   	push   %ebp
+  800184:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_pgdir);
+  800186:	6a 1f                	push   $0x1f
+  800188:	e8 28 ff ff ff       	call   8000b5 <syscall>
+  80018d:	83 c4 04             	add    $0x4,%esp
+}
+  800190:	c9                   	leave  
+  800191:	c3                   	ret    
+
+00800192 <sys_gettime>:
+
+int
+sys_gettime(void) {
+  800192:	55                   	push   %ebp
+  800193:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_gettime);
+  800195:	6a 11                	push   $0x11
+  800197:	e8 19 ff ff ff       	call   8000b5 <syscall>
+  80019c:	83 c4 04             	add    $0x4,%esp
+}
+  80019f:	c9                   	leave  
+  8001a0:	c3                   	ret    
+
+008001a1 <sys_lab6_set_priority>:
+
+void
+sys_lab6_set_priority(uint32_t priority)
+{
+  8001a1:	55                   	push   %ebp
+  8001a2:	89 e5                	mov    %esp,%ebp
+    syscall(SYS_lab6_set_priority, priority);
+  8001a4:	ff 75 08             	pushl  0x8(%ebp)
+  8001a7:	68 ff 00 00 00       	push   $0xff
+  8001ac:	e8 04 ff ff ff       	call   8000b5 <syscall>
+  8001b1:	83 c4 08             	add    $0x8,%esp
+}
+  8001b4:	90                   	nop
+  8001b5:	c9                   	leave  
+  8001b6:	c3                   	ret    
+
+008001b7 <exit>:
+#include <syscall.h>
+#include <stdio.h>
+#include <ulib.h>
+
+void
+exit(int error_code) {
+  8001b7:	55                   	push   %ebp
+  8001b8:	89 e5                	mov    %esp,%ebp
+  8001ba:	83 ec 08             	sub    $0x8,%esp
+    sys_exit(error_code);
+  8001bd:	83 ec 0c             	sub    $0xc,%esp
+  8001c0:	ff 75 08             	pushl  0x8(%ebp)
+  8001c3:	e8 43 ff ff ff       	call   80010b <sys_exit>
+  8001c8:	83 c4 10             	add    $0x10,%esp
+    cprintf("BUG: exit failed.\n");
+  8001cb:	83 ec 0c             	sub    $0xc,%esp
+  8001ce:	68 58 13 80 00       	push   $0x801358
+  8001d3:	e8 01 01 00 00       	call   8002d9 <cprintf>
+  8001d8:	83 c4 10             	add    $0x10,%esp
+    while (1);
+  8001db:	eb fe                	jmp    8001db <exit+0x24>
+
+008001dd <fork>:
+}
+
+int
+fork(void) {
+  8001dd:	55                   	push   %ebp
+  8001de:	89 e5                	mov    %esp,%ebp
+  8001e0:	83 ec 08             	sub    $0x8,%esp
+    return sys_fork();
+  8001e3:	e8 35 ff ff ff       	call   80011d <sys_fork>
+}
+  8001e8:	c9                   	leave  
+  8001e9:	c3                   	ret    
+
+008001ea <wait>:
+
+int
+wait(void) {
+  8001ea:	55                   	push   %ebp
+  8001eb:	89 e5                	mov    %esp,%ebp
+  8001ed:	83 ec 08             	sub    $0x8,%esp
+    return sys_wait(0, NULL);
+  8001f0:	83 ec 08             	sub    $0x8,%esp
+  8001f3:	6a 00                	push   $0x0
+  8001f5:	6a 00                	push   $0x0
+  8001f7:	e8 30 ff ff ff       	call   80012c <sys_wait>
+  8001fc:	83 c4 10             	add    $0x10,%esp
+}
+  8001ff:	c9                   	leave  
+  800200:	c3                   	ret    
+
+00800201 <waitpid>:
+
+int
+waitpid(int pid, int *store) {
+  800201:	55                   	push   %ebp
+  800202:	89 e5                	mov    %esp,%ebp
+  800204:	83 ec 08             	sub    $0x8,%esp
+    return sys_wait(pid, store);
+  800207:	83 ec 08             	sub    $0x8,%esp
+  80020a:	ff 75 0c             	pushl  0xc(%ebp)
+  80020d:	ff 75 08             	pushl  0x8(%ebp)
+  800210:	e8 17 ff ff ff       	call   80012c <sys_wait>
+  800215:	83 c4 10             	add    $0x10,%esp
+}
+  800218:	c9                   	leave  
+  800219:	c3                   	ret    
+
+0080021a <yield>:
+
+void
+yield(void) {
+  80021a:	55                   	push   %ebp
+  80021b:	89 e5                	mov    %esp,%ebp
+  80021d:	83 ec 08             	sub    $0x8,%esp
+    sys_yield();
+  800220:	e8 1c ff ff ff       	call   800141 <sys_yield>
+}
+  800225:	90                   	nop
+  800226:	c9                   	leave  
+  800227:	c3                   	ret    
+
+00800228 <kill>:
+
+int
+kill(int pid) {
+  800228:	55                   	push   %ebp
+  800229:	89 e5                	mov    %esp,%ebp
+  80022b:	83 ec 08             	sub    $0x8,%esp
+    return sys_kill(pid);
+  80022e:	83 ec 0c             	sub    $0xc,%esp
+  800231:	ff 75 08             	pushl  0x8(%ebp)
+  800234:	e8 17 ff ff ff       	call   800150 <sys_kill>
+  800239:	83 c4 10             	add    $0x10,%esp
+}
+  80023c:	c9                   	leave  
+  80023d:	c3                   	ret    
+
+0080023e <getpid>:
+
+int
+getpid(void) {
+  80023e:	55                   	push   %ebp
+  80023f:	89 e5                	mov    %esp,%ebp
+  800241:	83 ec 08             	sub    $0x8,%esp
+    return sys_getpid();
+  800244:	e8 19 ff ff ff       	call   800162 <sys_getpid>
+}
+  800249:	c9                   	leave  
+  80024a:	c3                   	ret    
+
+0080024b <print_pgdir>:
+
+//print_pgdir - print the PDT&PT
+void
+print_pgdir(void) {
+  80024b:	55                   	push   %ebp
+  80024c:	89 e5                	mov    %esp,%ebp
+  80024e:	83 ec 08             	sub    $0x8,%esp
+    sys_pgdir();
+  800251:	e8 2d ff ff ff       	call   800183 <sys_pgdir>
+}
+  800256:	90                   	nop
+  800257:	c9                   	leave  
+  800258:	c3                   	ret    
+
+00800259 <gettime_msec>:
+
+unsigned int
+gettime_msec(void) {
+  800259:	55                   	push   %ebp
+  80025a:	89 e5                	mov    %esp,%ebp
+  80025c:	83 ec 08             	sub    $0x8,%esp
+    return (unsigned int)sys_gettime();
+  80025f:	e8 2e ff ff ff       	call   800192 <sys_gettime>
+}
+  800264:	c9                   	leave  
+  800265:	c3                   	ret    
+
+00800266 <lab6_set_priority>:
+
+void
+lab6_set_priority(uint32_t priority)
+{
+  800266:	55                   	push   %ebp
+  800267:	89 e5                	mov    %esp,%ebp
+  800269:	83 ec 08             	sub    $0x8,%esp
+    sys_lab6_set_priority(priority);
+  80026c:	83 ec 0c             	sub    $0xc,%esp
+  80026f:	ff 75 08             	pushl  0x8(%ebp)
+  800272:	e8 2a ff ff ff       	call   8001a1 <sys_lab6_set_priority>
+  800277:	83 c4 10             	add    $0x10,%esp
+}
+  80027a:	90                   	nop
+  80027b:	c9                   	leave  
+  80027c:	c3                   	ret    
+
+0080027d <_start>:
+.text
+.globl _start
+_start:
+    # set ebp for backtrace
+    movl $0x0, %ebp
+  80027d:	bd 00 00 00 00       	mov    $0x0,%ebp
+
+    # move down the esp register
+    # since it may cause page fault in backtrace
+    subl $0x20, %esp
+  800282:	83 ec 20             	sub    $0x20,%esp
+
+    # call user-program function
+    call umain
+  800285:	e8 c3 00 00 00       	call   80034d <umain>
+1:  jmp 1b
+  80028a:	eb fe                	jmp    80028a <_start+0xd>
+
+0080028c <cputch>:
+/* *
+ * cputch - writes a single character @c to stdout, and it will
+ * increace the value of counter pointed by @cnt.
+ * */
+static void
+cputch(int c, int *cnt) {
+  80028c:	55                   	push   %ebp
+  80028d:	89 e5                	mov    %esp,%ebp
+  80028f:	83 ec 08             	sub    $0x8,%esp
+    sys_putc(c);
+  800292:	83 ec 0c             	sub    $0xc,%esp
+  800295:	ff 75 08             	pushl  0x8(%ebp)
+  800298:	e8 d4 fe ff ff       	call   800171 <sys_putc>
+  80029d:	83 c4 10             	add    $0x10,%esp
+    (*cnt) ++;
+  8002a0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002a3:	8b 00                	mov    (%eax),%eax
+  8002a5:	8d 50 01             	lea    0x1(%eax),%edx
+  8002a8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002ab:	89 10                	mov    %edx,(%eax)
+}
+  8002ad:	90                   	nop
+  8002ae:	c9                   	leave  
+  8002af:	c3                   	ret    
+
+008002b0 <vcprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want cprintf() instead.
+ * */
+int
+vcprintf(const char *fmt, va_list ap) {
+  8002b0:	55                   	push   %ebp
+  8002b1:	89 e5                	mov    %esp,%ebp
+  8002b3:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+  8002b6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    vprintfmt((void*)cputch, &cnt, fmt, ap);
+  8002bd:	ff 75 0c             	pushl  0xc(%ebp)
+  8002c0:	ff 75 08             	pushl  0x8(%ebp)
+  8002c3:	8d 45 f4             	lea    -0xc(%ebp),%eax
+  8002c6:	50                   	push   %eax
+  8002c7:	68 8c 02 80 00       	push   $0x80028c
+  8002cc:	e8 fc 06 00 00       	call   8009cd <vprintfmt>
+  8002d1:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+  8002d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8002d7:	c9                   	leave  
+  8002d8:	c3                   	ret    
+
+008002d9 <cprintf>:
+ *
+ * The return value is the number of characters which would be
+ * written to stdout.
+ * */
+int
+cprintf(const char *fmt, ...) {
+  8002d9:	55                   	push   %ebp
+  8002da:	89 e5                	mov    %esp,%ebp
+  8002dc:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  8002df:	8d 45 0c             	lea    0xc(%ebp),%eax
+  8002e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    int cnt = vcprintf(fmt, ap);
+  8002e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8002e8:	83 ec 08             	sub    $0x8,%esp
+  8002eb:	50                   	push   %eax
+  8002ec:	ff 75 08             	pushl  0x8(%ebp)
+  8002ef:	e8 bc ff ff ff       	call   8002b0 <vcprintf>
+  8002f4:	83 c4 10             	add    $0x10,%esp
+  8002f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+
+    return cnt;
+  8002fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8002fd:	c9                   	leave  
+  8002fe:	c3                   	ret    
+
+008002ff <cputs>:
+/* *
+ * cputs- writes the string pointed by @str to stdout and
+ * appends a newline character.
+ * */
+int
+cputs(const char *str) {
+  8002ff:	55                   	push   %ebp
+  800300:	89 e5                	mov    %esp,%ebp
+  800302:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+  800305:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    char c;
+    while ((c = *str ++) != '\0') {
+  80030c:	eb 14                	jmp    800322 <cputs+0x23>
+        cputch(c, &cnt);
+  80030e:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
+  800312:	83 ec 08             	sub    $0x8,%esp
+  800315:	8d 55 f0             	lea    -0x10(%ebp),%edx
+  800318:	52                   	push   %edx
+  800319:	50                   	push   %eax
+  80031a:	e8 6d ff ff ff       	call   80028c <cputch>
+  80031f:	83 c4 10             	add    $0x10,%esp
+ * */
+int
+cputs(const char *str) {
+    int cnt = 0;
+    char c;
+    while ((c = *str ++) != '\0') {
+  800322:	8b 45 08             	mov    0x8(%ebp),%eax
+  800325:	8d 50 01             	lea    0x1(%eax),%edx
+  800328:	89 55 08             	mov    %edx,0x8(%ebp)
+  80032b:	0f b6 00             	movzbl (%eax),%eax
+  80032e:	88 45 f7             	mov    %al,-0x9(%ebp)
+  800331:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
+  800335:	75 d7                	jne    80030e <cputs+0xf>
+        cputch(c, &cnt);
+    }
+    cputch('\n', &cnt);
+  800337:	83 ec 08             	sub    $0x8,%esp
+  80033a:	8d 45 f0             	lea    -0x10(%ebp),%eax
+  80033d:	50                   	push   %eax
+  80033e:	6a 0a                	push   $0xa
+  800340:	e8 47 ff ff ff       	call   80028c <cputch>
+  800345:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+  800348:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+  80034b:	c9                   	leave  
+  80034c:	c3                   	ret    
+
+0080034d <umain>:
+#include <ulib.h>
+
+int main(void);
+
+void
+umain(void) {
+  80034d:	55                   	push   %ebp
+  80034e:	89 e5                	mov    %esp,%ebp
+  800350:	83 ec 18             	sub    $0x18,%esp
+    int ret = main();
+  800353:	e8 07 0e 00 00       	call   80115f <main>
+  800358:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    exit(ret);
+  80035b:	83 ec 0c             	sub    $0xc,%esp
+  80035e:	ff 75 f4             	pushl  -0xc(%ebp)
+  800361:	e8 51 fe ff ff       	call   8001b7 <exit>
+
+00800366 <strlen>:
+ * @s:      the input string
+ *
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+  800366:	55                   	push   %ebp
+  800367:	89 e5                	mov    %esp,%ebp
+  800369:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  80036c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (*s ++ != '\0') {
+  800373:	eb 04                	jmp    800379 <strlen+0x13>
+        cnt ++;
+  800375:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+    size_t cnt = 0;
+    while (*s ++ != '\0') {
+  800379:	8b 45 08             	mov    0x8(%ebp),%eax
+  80037c:	8d 50 01             	lea    0x1(%eax),%edx
+  80037f:	89 55 08             	mov    %edx,0x8(%ebp)
+  800382:	0f b6 00             	movzbl (%eax),%eax
+  800385:	84 c0                	test   %al,%al
+  800387:	75 ec                	jne    800375 <strlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  800389:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  80038c:	c9                   	leave  
+  80038d:	c3                   	ret    
+
+0080038e <strnlen>:
+ * The return value is strlen(s), if that is less than @len, or
+ * @len if there is no '\0' character among the first @len characters
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+  80038e:	55                   	push   %ebp
+  80038f:	89 e5                	mov    %esp,%ebp
+  800391:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  800394:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (cnt < len && *s ++ != '\0') {
+  80039b:	eb 04                	jmp    8003a1 <strnlen+0x13>
+        cnt ++;
+  80039d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+    size_t cnt = 0;
+    while (cnt < len && *s ++ != '\0') {
+  8003a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8003a4:	3b 45 0c             	cmp    0xc(%ebp),%eax
+  8003a7:	73 10                	jae    8003b9 <strnlen+0x2b>
+  8003a9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003ac:	8d 50 01             	lea    0x1(%eax),%edx
+  8003af:	89 55 08             	mov    %edx,0x8(%ebp)
+  8003b2:	0f b6 00             	movzbl (%eax),%eax
+  8003b5:	84 c0                	test   %al,%al
+  8003b7:	75 e4                	jne    80039d <strnlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  8003b9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  8003bc:	c9                   	leave  
+  8003bd:	c3                   	ret    
+
+008003be <strcpy>:
+ * To avoid overflows, the size of array pointed by @dst should be long enough to
+ * contain the same string as @src (including the terminating null character), and
+ * should not overlap in memory with @src.
+ * */
+char *
+strcpy(char *dst, const char *src) {
+  8003be:	55                   	push   %ebp
+  8003bf:	89 e5                	mov    %esp,%ebp
+  8003c1:	57                   	push   %edi
+  8003c2:	56                   	push   %esi
+  8003c3:	83 ec 20             	sub    $0x20,%esp
+  8003c6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  8003cc:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8003cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCPY
+#define __HAVE_ARCH_STRCPY
+static inline char *
+__strcpy(char *dst, const char *src) {
+    int d0, d1, d2;
+    asm volatile (
+  8003d2:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  8003d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8003d8:	89 d1                	mov    %edx,%ecx
+  8003da:	89 c2                	mov    %eax,%edx
+  8003dc:	89 ce                	mov    %ecx,%esi
+  8003de:	89 d7                	mov    %edx,%edi
+  8003e0:	ac                   	lods   %ds:(%esi),%al
+  8003e1:	aa                   	stos   %al,%es:(%edi)
+  8003e2:	84 c0                	test   %al,%al
+  8003e4:	75 fa                	jne    8003e0 <strcpy+0x22>
+  8003e6:	89 fa                	mov    %edi,%edx
+  8003e8:	89 f1                	mov    %esi,%ecx
+  8003ea:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  8003ed:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  8003f0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+        "stosb;"
+        "testb %%al, %%al;"
+        "jne 1b;"
+        : "=&S" (d0), "=&D" (d1), "=&a" (d2)
+        : "0" (src), "1" (dst) : "memory");
+    return dst;
+  8003f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCPY
+    return __strcpy(dst, src);
+  8003f6:	90                   	nop
+    char *p = dst;
+    while ((*p ++ = *src ++) != '\0')
+        /* nothing */;
+    return dst;
+#endif /* __HAVE_ARCH_STRCPY */
+}
+  8003f7:	83 c4 20             	add    $0x20,%esp
+  8003fa:	5e                   	pop    %esi
+  8003fb:	5f                   	pop    %edi
+  8003fc:	5d                   	pop    %ebp
+  8003fd:	c3                   	ret    
+
+008003fe <strncpy>:
+ * @len:    maximum number of characters to be copied from @src
+ *
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+  8003fe:	55                   	push   %ebp
+  8003ff:	89 e5                	mov    %esp,%ebp
+  800401:	83 ec 10             	sub    $0x10,%esp
+    char *p = dst;
+  800404:	8b 45 08             	mov    0x8(%ebp),%eax
+  800407:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    while (len > 0) {
+  80040a:	eb 21                	jmp    80042d <strncpy+0x2f>
+        if ((*p = *src) != '\0') {
+  80040c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80040f:	0f b6 10             	movzbl (%eax),%edx
+  800412:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800415:	88 10                	mov    %dl,(%eax)
+  800417:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  80041a:	0f b6 00             	movzbl (%eax),%eax
+  80041d:	84 c0                	test   %al,%al
+  80041f:	74 04                	je     800425 <strncpy+0x27>
+            src ++;
+  800421:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+        }
+        p ++, len --;
+  800425:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800429:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+    char *p = dst;
+    while (len > 0) {
+  80042d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800431:	75 d9                	jne    80040c <strncpy+0xe>
+        if ((*p = *src) != '\0') {
+            src ++;
+        }
+        p ++, len --;
+    }
+    return dst;
+  800433:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800436:	c9                   	leave  
+  800437:	c3                   	ret    
+
+00800438 <strcmp>:
+ * - A value greater than zero indicates that the first character that does
+ *   not match has a greater value in @s1 than in @s2;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+strcmp(const char *s1, const char *s2) {
+  800438:	55                   	push   %ebp
+  800439:	89 e5                	mov    %esp,%ebp
+  80043b:	57                   	push   %edi
+  80043c:	56                   	push   %esi
+  80043d:	83 ec 20             	sub    $0x20,%esp
+  800440:	8b 45 08             	mov    0x8(%ebp),%eax
+  800443:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800446:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800449:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCMP
+#define __HAVE_ARCH_STRCMP
+static inline int
+__strcmp(const char *s1, const char *s2) {
+    int d0, d1, ret;
+    asm volatile (
+  80044c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80044f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800452:	89 d1                	mov    %edx,%ecx
+  800454:	89 c2                	mov    %eax,%edx
+  800456:	89 ce                	mov    %ecx,%esi
+  800458:	89 d7                	mov    %edx,%edi
+  80045a:	ac                   	lods   %ds:(%esi),%al
+  80045b:	ae                   	scas   %es:(%edi),%al
+  80045c:	75 08                	jne    800466 <strcmp+0x2e>
+  80045e:	84 c0                	test   %al,%al
+  800460:	75 f8                	jne    80045a <strcmp+0x22>
+  800462:	31 c0                	xor    %eax,%eax
+  800464:	eb 04                	jmp    80046a <strcmp+0x32>
+  800466:	19 c0                	sbb    %eax,%eax
+  800468:	0c 01                	or     $0x1,%al
+  80046a:	89 fa                	mov    %edi,%edx
+  80046c:	89 f1                	mov    %esi,%ecx
+  80046e:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800471:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  800474:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+        "orb $1, %%al;"
+        "3:"
+        : "=a" (ret), "=&S" (d0), "=&D" (d1)
+        : "1" (s1), "2" (s2)
+        : "memory");
+    return ret;
+  800477:	8b 45 ec             	mov    -0x14(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCMP
+    return __strcmp(s1, s2);
+  80047a:	90                   	nop
+    while (*s1 != '\0' && *s1 == *s2) {
+        s1 ++, s2 ++;
+    }
+    return (int)((unsigned char)*s1 - (unsigned char)*s2);
+#endif /* __HAVE_ARCH_STRCMP */
+}
+  80047b:	83 c4 20             	add    $0x20,%esp
+  80047e:	5e                   	pop    %esi
+  80047f:	5f                   	pop    %edi
+  800480:	5d                   	pop    %ebp
+  800481:	c3                   	ret    
+
+00800482 <strncmp>:
+ * they are equal to each other, it continues with the following pairs until
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+  800482:	55                   	push   %ebp
+  800483:	89 e5                	mov    %esp,%ebp
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  800485:	eb 0c                	jmp    800493 <strncmp+0x11>
+        n --, s1 ++, s2 ++;
+  800487:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  80048b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  80048f:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  800493:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800497:	74 1a                	je     8004b3 <strncmp+0x31>
+  800499:	8b 45 08             	mov    0x8(%ebp),%eax
+  80049c:	0f b6 00             	movzbl (%eax),%eax
+  80049f:	84 c0                	test   %al,%al
+  8004a1:	74 10                	je     8004b3 <strncmp+0x31>
+  8004a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004a6:	0f b6 10             	movzbl (%eax),%edx
+  8004a9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004ac:	0f b6 00             	movzbl (%eax),%eax
+  8004af:	38 c2                	cmp    %al,%dl
+  8004b1:	74 d4                	je     800487 <strncmp+0x5>
+        n --, s1 ++, s2 ++;
+    }
+    return (n == 0) ? 0 : (int)((unsigned char)*s1 - (unsigned char)*s2);
+  8004b3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8004b7:	74 18                	je     8004d1 <strncmp+0x4f>
+  8004b9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004bc:	0f b6 00             	movzbl (%eax),%eax
+  8004bf:	0f b6 d0             	movzbl %al,%edx
+  8004c2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004c5:	0f b6 00             	movzbl (%eax),%eax
+  8004c8:	0f b6 c0             	movzbl %al,%eax
+  8004cb:	29 c2                	sub    %eax,%edx
+  8004cd:	89 d0                	mov    %edx,%eax
+  8004cf:	eb 05                	jmp    8004d6 <strncmp+0x54>
+  8004d1:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  8004d6:	5d                   	pop    %ebp
+  8004d7:	c3                   	ret    
+
+008004d8 <strchr>:
+ *
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+  8004d8:	55                   	push   %ebp
+  8004d9:	89 e5                	mov    %esp,%ebp
+  8004db:	83 ec 04             	sub    $0x4,%esp
+  8004de:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004e1:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  8004e4:	eb 14                	jmp    8004fa <strchr+0x22>
+        if (*s == c) {
+  8004e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004e9:	0f b6 00             	movzbl (%eax),%eax
+  8004ec:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  8004ef:	75 05                	jne    8004f6 <strchr+0x1e>
+            return (char *)s;
+  8004f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004f4:	eb 13                	jmp    800509 <strchr+0x31>
+        }
+        s ++;
+  8004f6:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+    while (*s != '\0') {
+  8004fa:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004fd:	0f b6 00             	movzbl (%eax),%eax
+  800500:	84 c0                	test   %al,%al
+  800502:	75 e2                	jne    8004e6 <strchr+0xe>
+        if (*s == c) {
+            return (char *)s;
+        }
+        s ++;
+    }
+    return NULL;
+  800504:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800509:	c9                   	leave  
+  80050a:	c3                   	ret    
+
+0080050b <strfind>:
+ * The strfind() function is like strchr() except that if @c is
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+  80050b:	55                   	push   %ebp
+  80050c:	89 e5                	mov    %esp,%ebp
+  80050e:	83 ec 04             	sub    $0x4,%esp
+  800511:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800514:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  800517:	eb 0f                	jmp    800528 <strfind+0x1d>
+        if (*s == c) {
+  800519:	8b 45 08             	mov    0x8(%ebp),%eax
+  80051c:	0f b6 00             	movzbl (%eax),%eax
+  80051f:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800522:	74 10                	je     800534 <strfind+0x29>
+            break;
+        }
+        s ++;
+  800524:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+    while (*s != '\0') {
+  800528:	8b 45 08             	mov    0x8(%ebp),%eax
+  80052b:	0f b6 00             	movzbl (%eax),%eax
+  80052e:	84 c0                	test   %al,%al
+  800530:	75 e7                	jne    800519 <strfind+0xe>
+  800532:	eb 01                	jmp    800535 <strfind+0x2a>
+        if (*s == c) {
+            break;
+  800534:	90                   	nop
+        }
+        s ++;
+    }
+    return (char *)s;
+  800535:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800538:	c9                   	leave  
+  800539:	c3                   	ret    
+
+0080053a <strtol>:
+ * an optional "0x" or "0X" prefix.
+ *
+ * The strtol() function returns the converted integral number as a long int value.
+ * */
+long
+strtol(const char *s, char **endptr, int base) {
+  80053a:	55                   	push   %ebp
+  80053b:	89 e5                	mov    %esp,%ebp
+  80053d:	83 ec 10             	sub    $0x10,%esp
+    int neg = 0;
+  800540:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    long val = 0;
+  800547:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  80054e:	eb 04                	jmp    800554 <strtol+0x1a>
+        s ++;
+  800550:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+strtol(const char *s, char **endptr, int base) {
+    int neg = 0;
+    long val = 0;
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  800554:	8b 45 08             	mov    0x8(%ebp),%eax
+  800557:	0f b6 00             	movzbl (%eax),%eax
+  80055a:	3c 20                	cmp    $0x20,%al
+  80055c:	74 f2                	je     800550 <strtol+0x16>
+  80055e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800561:	0f b6 00             	movzbl (%eax),%eax
+  800564:	3c 09                	cmp    $0x9,%al
+  800566:	74 e8                	je     800550 <strtol+0x16>
+        s ++;
+    }
+
+    // plus/minus sign
+    if (*s == '+') {
+  800568:	8b 45 08             	mov    0x8(%ebp),%eax
+  80056b:	0f b6 00             	movzbl (%eax),%eax
+  80056e:	3c 2b                	cmp    $0x2b,%al
+  800570:	75 06                	jne    800578 <strtol+0x3e>
+        s ++;
+  800572:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800576:	eb 15                	jmp    80058d <strtol+0x53>
+    }
+    else if (*s == '-') {
+  800578:	8b 45 08             	mov    0x8(%ebp),%eax
+  80057b:	0f b6 00             	movzbl (%eax),%eax
+  80057e:	3c 2d                	cmp    $0x2d,%al
+  800580:	75 0b                	jne    80058d <strtol+0x53>
+        s ++, neg = 1;
+  800582:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800586:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+    }
+
+    // hex or octal base prefix
+    if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x')) {
+  80058d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800591:	74 06                	je     800599 <strtol+0x5f>
+  800593:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+  800597:	75 24                	jne    8005bd <strtol+0x83>
+  800599:	8b 45 08             	mov    0x8(%ebp),%eax
+  80059c:	0f b6 00             	movzbl (%eax),%eax
+  80059f:	3c 30                	cmp    $0x30,%al
+  8005a1:	75 1a                	jne    8005bd <strtol+0x83>
+  8005a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005a6:	83 c0 01             	add    $0x1,%eax
+  8005a9:	0f b6 00             	movzbl (%eax),%eax
+  8005ac:	3c 78                	cmp    $0x78,%al
+  8005ae:	75 0d                	jne    8005bd <strtol+0x83>
+        s += 2, base = 16;
+  8005b0:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+  8005b4:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+  8005bb:	eb 2a                	jmp    8005e7 <strtol+0xad>
+    }
+    else if (base == 0 && s[0] == '0') {
+  8005bd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8005c1:	75 17                	jne    8005da <strtol+0xa0>
+  8005c3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005c6:	0f b6 00             	movzbl (%eax),%eax
+  8005c9:	3c 30                	cmp    $0x30,%al
+  8005cb:	75 0d                	jne    8005da <strtol+0xa0>
+        s ++, base = 8;
+  8005cd:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  8005d1:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+  8005d8:	eb 0d                	jmp    8005e7 <strtol+0xad>
+    }
+    else if (base == 0) {
+  8005da:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8005de:	75 07                	jne    8005e7 <strtol+0xad>
+        base = 10;
+  8005e0:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+    // digits
+    while (1) {
+        int dig;
+
+        if (*s >= '0' && *s <= '9') {
+  8005e7:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005ea:	0f b6 00             	movzbl (%eax),%eax
+  8005ed:	3c 2f                	cmp    $0x2f,%al
+  8005ef:	7e 1b                	jle    80060c <strtol+0xd2>
+  8005f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005f4:	0f b6 00             	movzbl (%eax),%eax
+  8005f7:	3c 39                	cmp    $0x39,%al
+  8005f9:	7f 11                	jg     80060c <strtol+0xd2>
+            dig = *s - '0';
+  8005fb:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005fe:	0f b6 00             	movzbl (%eax),%eax
+  800601:	0f be c0             	movsbl %al,%eax
+  800604:	83 e8 30             	sub    $0x30,%eax
+  800607:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80060a:	eb 48                	jmp    800654 <strtol+0x11a>
+        }
+        else if (*s >= 'a' && *s <= 'z') {
+  80060c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80060f:	0f b6 00             	movzbl (%eax),%eax
+  800612:	3c 60                	cmp    $0x60,%al
+  800614:	7e 1b                	jle    800631 <strtol+0xf7>
+  800616:	8b 45 08             	mov    0x8(%ebp),%eax
+  800619:	0f b6 00             	movzbl (%eax),%eax
+  80061c:	3c 7a                	cmp    $0x7a,%al
+  80061e:	7f 11                	jg     800631 <strtol+0xf7>
+            dig = *s - 'a' + 10;
+  800620:	8b 45 08             	mov    0x8(%ebp),%eax
+  800623:	0f b6 00             	movzbl (%eax),%eax
+  800626:	0f be c0             	movsbl %al,%eax
+  800629:	83 e8 57             	sub    $0x57,%eax
+  80062c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80062f:	eb 23                	jmp    800654 <strtol+0x11a>
+        }
+        else if (*s >= 'A' && *s <= 'Z') {
+  800631:	8b 45 08             	mov    0x8(%ebp),%eax
+  800634:	0f b6 00             	movzbl (%eax),%eax
+  800637:	3c 40                	cmp    $0x40,%al
+  800639:	7e 3c                	jle    800677 <strtol+0x13d>
+  80063b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80063e:	0f b6 00             	movzbl (%eax),%eax
+  800641:	3c 5a                	cmp    $0x5a,%al
+  800643:	7f 32                	jg     800677 <strtol+0x13d>
+            dig = *s - 'A' + 10;
+  800645:	8b 45 08             	mov    0x8(%ebp),%eax
+  800648:	0f b6 00             	movzbl (%eax),%eax
+  80064b:	0f be c0             	movsbl %al,%eax
+  80064e:	83 e8 37             	sub    $0x37,%eax
+  800651:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+  800654:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800657:	3b 45 10             	cmp    0x10(%ebp),%eax
+  80065a:	7d 1a                	jge    800676 <strtol+0x13c>
+            break;
+        }
+        s ++, val = (val * base) + dig;
+  80065c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800660:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800663:	0f af 45 10          	imul   0x10(%ebp),%eax
+  800667:	89 c2                	mov    %eax,%edx
+  800669:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  80066c:	01 d0                	add    %edx,%eax
+  80066e:	89 45 f8             	mov    %eax,-0x8(%ebp)
+        // we don't properly detect overflow!
+    }
+  800671:	e9 71 ff ff ff       	jmp    8005e7 <strtol+0xad>
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+            break;
+  800676:	90                   	nop
+        }
+        s ++, val = (val * base) + dig;
+        // we don't properly detect overflow!
+    }
+
+    if (endptr) {
+  800677:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  80067b:	74 08                	je     800685 <strtol+0x14b>
+        *endptr = (char *) s;
+  80067d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800680:	8b 55 08             	mov    0x8(%ebp),%edx
+  800683:	89 10                	mov    %edx,(%eax)
+    }
+    return (neg ? -val : val);
+  800685:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+  800689:	74 07                	je     800692 <strtol+0x158>
+  80068b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  80068e:	f7 d8                	neg    %eax
+  800690:	eb 03                	jmp    800695 <strtol+0x15b>
+  800692:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  800695:	c9                   	leave  
+  800696:	c3                   	ret    
+
+00800697 <memset>:
+ * @n:      number of bytes to be set to the value
+ *
+ * The memset() function returns @s.
+ * */
+void *
+memset(void *s, char c, size_t n) {
+  800697:	55                   	push   %ebp
+  800698:	89 e5                	mov    %esp,%ebp
+  80069a:	57                   	push   %edi
+  80069b:	83 ec 24             	sub    $0x24,%esp
+  80069e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006a1:	88 45 d8             	mov    %al,-0x28(%ebp)
+#ifdef __HAVE_ARCH_MEMSET
+    return __memset(s, c, n);
+  8006a4:	0f be 45 d8          	movsbl -0x28(%ebp),%eax
+  8006a8:	8b 55 08             	mov    0x8(%ebp),%edx
+  8006ab:	89 55 f8             	mov    %edx,-0x8(%ebp)
+  8006ae:	88 45 f7             	mov    %al,-0x9(%ebp)
+  8006b1:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_MEMSET
+#define __HAVE_ARCH_MEMSET
+static inline void *
+__memset(void *s, char c, size_t n) {
+    int d0, d1;
+    asm volatile (
+  8006b7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+  8006ba:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
+  8006be:	8b 55 f8             	mov    -0x8(%ebp),%edx
+  8006c1:	89 d7                	mov    %edx,%edi
+  8006c3:	f3 aa                	rep stos %al,%es:(%edi)
+  8006c5:	89 fa                	mov    %edi,%edx
+  8006c7:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  8006ca:	89 55 e8             	mov    %edx,-0x18(%ebp)
+        "rep; stosb;"
+        : "=&c" (d0), "=&D" (d1)
+        : "0" (n), "a" (c), "1" (s)
+        : "memory");
+    return s;
+  8006cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8006d0:	90                   	nop
+    while (n -- > 0) {
+        *p ++ = c;
+    }
+    return s;
+#endif /* __HAVE_ARCH_MEMSET */
+}
+  8006d1:	83 c4 24             	add    $0x24,%esp
+  8006d4:	5f                   	pop    %edi
+  8006d5:	5d                   	pop    %ebp
+  8006d6:	c3                   	ret    
+
+008006d7 <memmove>:
+ * @n:      number of bytes to copy
+ *
+ * The memmove() function returns @dst.
+ * */
+void *
+memmove(void *dst, const void *src, size_t n) {
+  8006d7:	55                   	push   %ebp
+  8006d8:	89 e5                	mov    %esp,%ebp
+  8006da:	57                   	push   %edi
+  8006db:	56                   	push   %esi
+  8006dc:	53                   	push   %ebx
+  8006dd:	83 ec 30             	sub    $0x30,%esp
+  8006e0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8006e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8006e6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  8006ec:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006ef:	89 45 e8             	mov    %eax,-0x18(%ebp)
+
+#ifndef __HAVE_ARCH_MEMMOVE
+#define __HAVE_ARCH_MEMMOVE
+static inline void *
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+  8006f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006f5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  8006f8:	73 42                	jae    80073c <memmove+0x65>
+  8006fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006fd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800700:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800703:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800706:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800709:	89 45 dc             	mov    %eax,-0x24(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  80070c:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  80070f:	c1 e8 02             	shr    $0x2,%eax
+  800712:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  800714:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800717:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80071a:	89 d7                	mov    %edx,%edi
+  80071c:	89 c6                	mov    %eax,%esi
+  80071e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800720:	8b 4d dc             	mov    -0x24(%ebp),%ecx
+  800723:	83 e1 03             	and    $0x3,%ecx
+  800726:	74 02                	je     80072a <memmove+0x53>
+  800728:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  80072a:	89 f0                	mov    %esi,%eax
+  80072c:	89 fa                	mov    %edi,%edx
+  80072e:	89 4d d8             	mov    %ecx,-0x28(%ebp)
+  800731:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  800734:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  800737:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMMOVE
+    return __memmove(dst, src, n);
+  80073a:	eb 36                	jmp    800772 <memmove+0x9b>
+    asm volatile (
+        "std;"
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+  80073c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80073f:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800742:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800745:	01 c2                	add    %eax,%edx
+  800747:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80074a:	8d 48 ff             	lea    -0x1(%eax),%ecx
+  80074d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800750:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+        return __memcpy(dst, src, n);
+    }
+    int d0, d1, d2;
+    asm volatile (
+  800753:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800756:	89 c1                	mov    %eax,%ecx
+  800758:	89 d8                	mov    %ebx,%eax
+  80075a:	89 d6                	mov    %edx,%esi
+  80075c:	89 c7                	mov    %eax,%edi
+  80075e:	fd                   	std    
+  80075f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  800761:	fc                   	cld    
+  800762:	89 f8                	mov    %edi,%eax
+  800764:	89 f2                	mov    %esi,%edx
+  800766:	89 4d cc             	mov    %ecx,-0x34(%ebp)
+  800769:	89 55 c8             	mov    %edx,-0x38(%ebp)
+  80076c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+        : "memory");
+    return dst;
+  80076f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+            *d ++ = *s ++;
+        }
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMMOVE */
+}
+  800772:	83 c4 30             	add    $0x30,%esp
+  800775:	5b                   	pop    %ebx
+  800776:	5e                   	pop    %esi
+  800777:	5f                   	pop    %edi
+  800778:	5d                   	pop    %ebp
+  800779:	c3                   	ret    
+
+0080077a <memcpy>:
+ * it always copies exactly @n bytes. To avoid overflows, the size of arrays pointed
+ * by both @src and @dst, should be at least @n bytes, and should not overlap
+ * (for overlapping memory area, memmove is a safer approach).
+ * */
+void *
+memcpy(void *dst, const void *src, size_t n) {
+  80077a:	55                   	push   %ebp
+  80077b:	89 e5                	mov    %esp,%ebp
+  80077d:	57                   	push   %edi
+  80077e:	56                   	push   %esi
+  80077f:	83 ec 20             	sub    $0x20,%esp
+  800782:	8b 45 08             	mov    0x8(%ebp),%eax
+  800785:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800788:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80078b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80078e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800791:	89 45 ec             	mov    %eax,-0x14(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  800794:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800797:	c1 e8 02             	shr    $0x2,%eax
+  80079a:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  80079c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80079f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8007a2:	89 d7                	mov    %edx,%edi
+  8007a4:	89 c6                	mov    %eax,%esi
+  8007a6:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  8007a8:	8b 4d ec             	mov    -0x14(%ebp),%ecx
+  8007ab:	83 e1 03             	and    $0x3,%ecx
+  8007ae:	74 02                	je     8007b2 <memcpy+0x38>
+  8007b0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  8007b2:	89 f0                	mov    %esi,%eax
+  8007b4:	89 fa                	mov    %edi,%edx
+  8007b6:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  8007b9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  8007bc:	89 45 e0             	mov    %eax,-0x20(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  8007bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMCPY
+    return __memcpy(dst, src, n);
+  8007c2:	90                   	nop
+    while (n -- > 0) {
+        *d ++ = *s ++;
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMCPY */
+}
+  8007c3:	83 c4 20             	add    $0x20,%esp
+  8007c6:	5e                   	pop    %esi
+  8007c7:	5f                   	pop    %edi
+  8007c8:	5d                   	pop    %ebp
+  8007c9:	c3                   	ret    
+
+008007ca <memcmp>:
+ *   match in both memory blocks has a greater value in @v1 than in @v2
+ *   as if evaluated as unsigned char values;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+  8007ca:	55                   	push   %ebp
+  8007cb:	89 e5                	mov    %esp,%ebp
+  8007cd:	83 ec 10             	sub    $0x10,%esp
+    const char *s1 = (const char *)v1;
+  8007d0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8007d3:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    const char *s2 = (const char *)v2;
+  8007d6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8007d9:	89 45 f8             	mov    %eax,-0x8(%ebp)
+    while (n -- > 0) {
+  8007dc:	eb 30                	jmp    80080e <memcmp+0x44>
+        if (*s1 != *s2) {
+  8007de:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8007e1:	0f b6 10             	movzbl (%eax),%edx
+  8007e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8007e7:	0f b6 00             	movzbl (%eax),%eax
+  8007ea:	38 c2                	cmp    %al,%dl
+  8007ec:	74 18                	je     800806 <memcmp+0x3c>
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+  8007ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8007f1:	0f b6 00             	movzbl (%eax),%eax
+  8007f4:	0f b6 d0             	movzbl %al,%edx
+  8007f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8007fa:	0f b6 00             	movzbl (%eax),%eax
+  8007fd:	0f b6 c0             	movzbl %al,%eax
+  800800:	29 c2                	sub    %eax,%edx
+  800802:	89 d0                	mov    %edx,%eax
+  800804:	eb 1a                	jmp    800820 <memcmp+0x56>
+        }
+        s1 ++, s2 ++;
+  800806:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  80080a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+    const char *s1 = (const char *)v1;
+    const char *s2 = (const char *)v2;
+    while (n -- > 0) {
+  80080e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800811:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800814:	89 55 10             	mov    %edx,0x10(%ebp)
+  800817:	85 c0                	test   %eax,%eax
+  800819:	75 c3                	jne    8007de <memcmp+0x14>
+        if (*s1 != *s2) {
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+        }
+        s1 ++, s2 ++;
+    }
+    return 0;
+  80081b:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800820:	c9                   	leave  
+  800821:	c3                   	ret    
+
+00800822 <printnum>:
+ * @width:      maximum number of digits, if the actual width is less than @width, use @padc instead
+ * @padc:       character that padded on the left if the actual width is less than @width
+ * */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+        unsigned long long num, unsigned base, int width, int padc) {
+  800822:	55                   	push   %ebp
+  800823:	89 e5                	mov    %esp,%ebp
+  800825:	83 ec 38             	sub    $0x38,%esp
+  800828:	8b 45 10             	mov    0x10(%ebp),%eax
+  80082b:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  80082e:	8b 45 14             	mov    0x14(%ebp),%eax
+  800831:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+    unsigned long long result = num;
+  800834:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  800837:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  80083a:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  80083d:	89 55 ec             	mov    %edx,-0x14(%ebp)
+    unsigned mod = do_div(result, base);
+  800840:	8b 45 18             	mov    0x18(%ebp),%eax
+  800843:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800846:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800849:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  80084c:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  80084f:	89 55 f0             	mov    %edx,-0x10(%ebp)
+  800852:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800855:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800858:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  80085c:	74 1c                	je     80087a <printnum+0x58>
+  80085e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800861:	ba 00 00 00 00       	mov    $0x0,%edx
+  800866:	f7 75 e4             	divl   -0x1c(%ebp)
+  800869:	89 55 f4             	mov    %edx,-0xc(%ebp)
+  80086c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  80086f:	ba 00 00 00 00       	mov    $0x0,%edx
+  800874:	f7 75 e4             	divl   -0x1c(%ebp)
+  800877:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80087a:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80087d:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800880:	f7 75 e4             	divl   -0x1c(%ebp)
+  800883:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800886:	89 55 dc             	mov    %edx,-0x24(%ebp)
+  800889:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80088c:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  80088f:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800892:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  800895:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  800898:	89 45 d8             	mov    %eax,-0x28(%ebp)
+
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+  80089b:	8b 45 18             	mov    0x18(%ebp),%eax
+  80089e:	ba 00 00 00 00       	mov    $0x0,%edx
+  8008a3:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  8008a6:	77 41                	ja     8008e9 <printnum+0xc7>
+  8008a8:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  8008ab:	72 05                	jb     8008b2 <printnum+0x90>
+  8008ad:	3b 45 d0             	cmp    -0x30(%ebp),%eax
+  8008b0:	77 37                	ja     8008e9 <printnum+0xc7>
+        printnum(putch, putdat, result, base, width - 1, padc);
+  8008b2:	8b 45 1c             	mov    0x1c(%ebp),%eax
+  8008b5:	83 e8 01             	sub    $0x1,%eax
+  8008b8:	83 ec 04             	sub    $0x4,%esp
+  8008bb:	ff 75 20             	pushl  0x20(%ebp)
+  8008be:	50                   	push   %eax
+  8008bf:	ff 75 18             	pushl  0x18(%ebp)
+  8008c2:	ff 75 ec             	pushl  -0x14(%ebp)
+  8008c5:	ff 75 e8             	pushl  -0x18(%ebp)
+  8008c8:	ff 75 0c             	pushl  0xc(%ebp)
+  8008cb:	ff 75 08             	pushl  0x8(%ebp)
+  8008ce:	e8 4f ff ff ff       	call   800822 <printnum>
+  8008d3:	83 c4 20             	add    $0x20,%esp
+  8008d6:	eb 1b                	jmp    8008f3 <printnum+0xd1>
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+            putch(padc, putdat);
+  8008d8:	83 ec 08             	sub    $0x8,%esp
+  8008db:	ff 75 0c             	pushl  0xc(%ebp)
+  8008de:	ff 75 20             	pushl  0x20(%ebp)
+  8008e1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8008e4:	ff d0                	call   *%eax
+  8008e6:	83 c4 10             	add    $0x10,%esp
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+        printnum(putch, putdat, result, base, width - 1, padc);
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+  8008e9:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+  8008ed:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+  8008f1:	7f e5                	jg     8008d8 <printnum+0xb6>
+            putch(padc, putdat);
+    }
+    // then print this (the least significant) digit
+    putch("0123456789abcdef"[mod], putdat);
+  8008f3:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  8008f6:	05 84 14 80 00       	add    $0x801484,%eax
+  8008fb:	0f b6 00             	movzbl (%eax),%eax
+  8008fe:	0f be c0             	movsbl %al,%eax
+  800901:	83 ec 08             	sub    $0x8,%esp
+  800904:	ff 75 0c             	pushl  0xc(%ebp)
+  800907:	50                   	push   %eax
+  800908:	8b 45 08             	mov    0x8(%ebp),%eax
+  80090b:	ff d0                	call   *%eax
+  80090d:	83 c4 10             	add    $0x10,%esp
+}
+  800910:	90                   	nop
+  800911:	c9                   	leave  
+  800912:	c3                   	ret    
+
+00800913 <getuint>:
+ * getuint - get an unsigned int of various possible sizes from a varargs list
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static unsigned long long
+getuint(va_list *ap, int lflag) {
+  800913:	55                   	push   %ebp
+  800914:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  800916:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  80091a:	7e 14                	jle    800930 <getuint+0x1d>
+        return va_arg(*ap, unsigned long long);
+  80091c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80091f:	8b 00                	mov    (%eax),%eax
+  800921:	8d 48 08             	lea    0x8(%eax),%ecx
+  800924:	8b 55 08             	mov    0x8(%ebp),%edx
+  800927:	89 0a                	mov    %ecx,(%edx)
+  800929:	8b 50 04             	mov    0x4(%eax),%edx
+  80092c:	8b 00                	mov    (%eax),%eax
+  80092e:	eb 30                	jmp    800960 <getuint+0x4d>
+    }
+    else if (lflag) {
+  800930:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800934:	74 16                	je     80094c <getuint+0x39>
+        return va_arg(*ap, unsigned long);
+  800936:	8b 45 08             	mov    0x8(%ebp),%eax
+  800939:	8b 00                	mov    (%eax),%eax
+  80093b:	8d 48 04             	lea    0x4(%eax),%ecx
+  80093e:	8b 55 08             	mov    0x8(%ebp),%edx
+  800941:	89 0a                	mov    %ecx,(%edx)
+  800943:	8b 00                	mov    (%eax),%eax
+  800945:	ba 00 00 00 00       	mov    $0x0,%edx
+  80094a:	eb 14                	jmp    800960 <getuint+0x4d>
+    }
+    else {
+        return va_arg(*ap, unsigned int);
+  80094c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80094f:	8b 00                	mov    (%eax),%eax
+  800951:	8d 48 04             	lea    0x4(%eax),%ecx
+  800954:	8b 55 08             	mov    0x8(%ebp),%edx
+  800957:	89 0a                	mov    %ecx,(%edx)
+  800959:	8b 00                	mov    (%eax),%eax
+  80095b:	ba 00 00 00 00       	mov    $0x0,%edx
+    }
+}
+  800960:	5d                   	pop    %ebp
+  800961:	c3                   	ret    
+
+00800962 <getint>:
+ * getint - same as getuint but signed, we can't use getuint because of sign extension
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static long long
+getint(va_list *ap, int lflag) {
+  800962:	55                   	push   %ebp
+  800963:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  800965:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  800969:	7e 14                	jle    80097f <getint+0x1d>
+        return va_arg(*ap, long long);
+  80096b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80096e:	8b 00                	mov    (%eax),%eax
+  800970:	8d 48 08             	lea    0x8(%eax),%ecx
+  800973:	8b 55 08             	mov    0x8(%ebp),%edx
+  800976:	89 0a                	mov    %ecx,(%edx)
+  800978:	8b 50 04             	mov    0x4(%eax),%edx
+  80097b:	8b 00                	mov    (%eax),%eax
+  80097d:	eb 28                	jmp    8009a7 <getint+0x45>
+    }
+    else if (lflag) {
+  80097f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800983:	74 12                	je     800997 <getint+0x35>
+        return va_arg(*ap, long);
+  800985:	8b 45 08             	mov    0x8(%ebp),%eax
+  800988:	8b 00                	mov    (%eax),%eax
+  80098a:	8d 48 04             	lea    0x4(%eax),%ecx
+  80098d:	8b 55 08             	mov    0x8(%ebp),%edx
+  800990:	89 0a                	mov    %ecx,(%edx)
+  800992:	8b 00                	mov    (%eax),%eax
+  800994:	99                   	cltd   
+  800995:	eb 10                	jmp    8009a7 <getint+0x45>
+    }
+    else {
+        return va_arg(*ap, int);
+  800997:	8b 45 08             	mov    0x8(%ebp),%eax
+  80099a:	8b 00                	mov    (%eax),%eax
+  80099c:	8d 48 04             	lea    0x4(%eax),%ecx
+  80099f:	8b 55 08             	mov    0x8(%ebp),%edx
+  8009a2:	89 0a                	mov    %ecx,(%edx)
+  8009a4:	8b 00                	mov    (%eax),%eax
+  8009a6:	99                   	cltd   
+    }
+}
+  8009a7:	5d                   	pop    %ebp
+  8009a8:	c3                   	ret    
+
+008009a9 <printfmt>:
+ * @putch:      specified putch function, print a single character
+ * @putdat:     used by @putch function
+ * @fmt:        the format string to use
+ * */
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...) {
+  8009a9:	55                   	push   %ebp
+  8009aa:	89 e5                	mov    %esp,%ebp
+  8009ac:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  8009af:	8d 45 14             	lea    0x14(%ebp),%eax
+  8009b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    vprintfmt(putch, putdat, fmt, ap);
+  8009b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8009b8:	50                   	push   %eax
+  8009b9:	ff 75 10             	pushl  0x10(%ebp)
+  8009bc:	ff 75 0c             	pushl  0xc(%ebp)
+  8009bf:	ff 75 08             	pushl  0x8(%ebp)
+  8009c2:	e8 06 00 00 00       	call   8009cd <vprintfmt>
+  8009c7:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+  8009ca:	90                   	nop
+  8009cb:	c9                   	leave  
+  8009cc:	c3                   	ret    
+
+008009cd <vprintfmt>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want printfmt() instead.
+ * */
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap) {
+  8009cd:	55                   	push   %ebp
+  8009ce:	89 e5                	mov    %esp,%ebp
+  8009d0:	56                   	push   %esi
+  8009d1:	53                   	push   %ebx
+  8009d2:	83 ec 20             	sub    $0x20,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  8009d5:	eb 17                	jmp    8009ee <vprintfmt+0x21>
+            if (ch == '\0') {
+  8009d7:	85 db                	test   %ebx,%ebx
+  8009d9:	0f 84 8e 03 00 00    	je     800d6d <vprintfmt+0x3a0>
+                return;
+            }
+            putch(ch, putdat);
+  8009df:	83 ec 08             	sub    $0x8,%esp
+  8009e2:	ff 75 0c             	pushl  0xc(%ebp)
+  8009e5:	53                   	push   %ebx
+  8009e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009e9:	ff d0                	call   *%eax
+  8009eb:	83 c4 10             	add    $0x10,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  8009ee:	8b 45 10             	mov    0x10(%ebp),%eax
+  8009f1:	8d 50 01             	lea    0x1(%eax),%edx
+  8009f4:	89 55 10             	mov    %edx,0x10(%ebp)
+  8009f7:	0f b6 00             	movzbl (%eax),%eax
+  8009fa:	0f b6 d8             	movzbl %al,%ebx
+  8009fd:	83 fb 25             	cmp    $0x25,%ebx
+  800a00:	75 d5                	jne    8009d7 <vprintfmt+0xa>
+            }
+            putch(ch, putdat);
+        }
+
+        // Process a %-escape sequence
+        char padc = ' ';
+  800a02:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+        width = precision = -1;
+  800a06:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+  800a0d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800a10:	89 45 e8             	mov    %eax,-0x18(%ebp)
+        lflag = altflag = 0;
+  800a13:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+  800a1a:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  800a1d:	89 45 e0             	mov    %eax,-0x20(%ebp)
+
+    reswitch:
+        switch (ch = *(unsigned char *)fmt ++) {
+  800a20:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a23:	8d 50 01             	lea    0x1(%eax),%edx
+  800a26:	89 55 10             	mov    %edx,0x10(%ebp)
+  800a29:	0f b6 00             	movzbl (%eax),%eax
+  800a2c:	0f b6 d8             	movzbl %al,%ebx
+  800a2f:	8d 43 dd             	lea    -0x23(%ebx),%eax
+  800a32:	83 f8 55             	cmp    $0x55,%eax
+  800a35:	0f 87 05 03 00 00    	ja     800d40 <vprintfmt+0x373>
+  800a3b:	8b 04 85 a8 14 80 00 	mov    0x8014a8(,%eax,4),%eax
+  800a42:	ff e0                	jmp    *%eax
+
+        // flag to pad on the right
+        case '-':
+            padc = '-';
+  800a44:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+            goto reswitch;
+  800a48:	eb d6                	jmp    800a20 <vprintfmt+0x53>
+
+        // flag to pad with 0's instead of spaces
+        case '0':
+            padc = '0';
+  800a4a:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+            goto reswitch;
+  800a4e:	eb d0                	jmp    800a20 <vprintfmt+0x53>
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  800a50:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+                precision = precision * 10 + ch - '0';
+  800a57:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800a5a:	89 d0                	mov    %edx,%eax
+  800a5c:	c1 e0 02             	shl    $0x2,%eax
+  800a5f:	01 d0                	add    %edx,%eax
+  800a61:	01 c0                	add    %eax,%eax
+  800a63:	01 d8                	add    %ebx,%eax
+  800a65:	83 e8 30             	sub    $0x30,%eax
+  800a68:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+                ch = *fmt;
+  800a6b:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a6e:	0f b6 00             	movzbl (%eax),%eax
+  800a71:	0f be d8             	movsbl %al,%ebx
+                if (ch < '0' || ch > '9') {
+  800a74:	83 fb 2f             	cmp    $0x2f,%ebx
+  800a77:	7e 39                	jle    800ab2 <vprintfmt+0xe5>
+  800a79:	83 fb 39             	cmp    $0x39,%ebx
+  800a7c:	7f 34                	jg     800ab2 <vprintfmt+0xe5>
+            padc = '0';
+            goto reswitch;
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  800a7e:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+                precision = precision * 10 + ch - '0';
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+  800a82:	eb d3                	jmp    800a57 <vprintfmt+0x8a>
+            goto process_precision;
+
+        case '*':
+            precision = va_arg(ap, int);
+  800a84:	8b 45 14             	mov    0x14(%ebp),%eax
+  800a87:	8d 50 04             	lea    0x4(%eax),%edx
+  800a8a:	89 55 14             	mov    %edx,0x14(%ebp)
+  800a8d:	8b 00                	mov    (%eax),%eax
+  800a8f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+            goto process_precision;
+  800a92:	eb 1f                	jmp    800ab3 <vprintfmt+0xe6>
+
+        case '.':
+            if (width < 0)
+  800a94:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800a98:	79 86                	jns    800a20 <vprintfmt+0x53>
+                width = 0;
+  800a9a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+            goto reswitch;
+  800aa1:	e9 7a ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        case '#':
+            altflag = 1;
+  800aa6:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+            goto reswitch;
+  800aad:	e9 6e ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+            goto process_precision;
+  800ab2:	90                   	nop
+        case '#':
+            altflag = 1;
+            goto reswitch;
+
+        process_precision:
+            if (width < 0)
+  800ab3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ab7:	0f 89 63 ff ff ff    	jns    800a20 <vprintfmt+0x53>
+                width = precision, precision = -1;
+  800abd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800ac0:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800ac3:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+            goto reswitch;
+  800aca:	e9 51 ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        // long flag (doubled for long long)
+        case 'l':
+            lflag ++;
+  800acf:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
+            goto reswitch;
+  800ad3:	e9 48 ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        // character
+        case 'c':
+            putch(va_arg(ap, int), putdat);
+  800ad8:	8b 45 14             	mov    0x14(%ebp),%eax
+  800adb:	8d 50 04             	lea    0x4(%eax),%edx
+  800ade:	89 55 14             	mov    %edx,0x14(%ebp)
+  800ae1:	8b 00                	mov    (%eax),%eax
+  800ae3:	83 ec 08             	sub    $0x8,%esp
+  800ae6:	ff 75 0c             	pushl  0xc(%ebp)
+  800ae9:	50                   	push   %eax
+  800aea:	8b 45 08             	mov    0x8(%ebp),%eax
+  800aed:	ff d0                	call   *%eax
+  800aef:	83 c4 10             	add    $0x10,%esp
+            break;
+  800af2:	e9 71 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // error message
+        case 'e':
+            err = va_arg(ap, int);
+  800af7:	8b 45 14             	mov    0x14(%ebp),%eax
+  800afa:	8d 50 04             	lea    0x4(%eax),%edx
+  800afd:	89 55 14             	mov    %edx,0x14(%ebp)
+  800b00:	8b 18                	mov    (%eax),%ebx
+            if (err < 0) {
+  800b02:	85 db                	test   %ebx,%ebx
+  800b04:	79 02                	jns    800b08 <vprintfmt+0x13b>
+                err = -err;
+  800b06:	f7 db                	neg    %ebx
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+  800b08:	83 fb 18             	cmp    $0x18,%ebx
+  800b0b:	7f 0b                	jg     800b18 <vprintfmt+0x14b>
+  800b0d:	8b 34 9d 20 14 80 00 	mov    0x801420(,%ebx,4),%esi
+  800b14:	85 f6                	test   %esi,%esi
+  800b16:	75 19                	jne    800b31 <vprintfmt+0x164>
+                printfmt(putch, putdat, "error %d", err);
+  800b18:	53                   	push   %ebx
+  800b19:	68 95 14 80 00       	push   $0x801495
+  800b1e:	ff 75 0c             	pushl  0xc(%ebp)
+  800b21:	ff 75 08             	pushl  0x8(%ebp)
+  800b24:	e8 80 fe ff ff       	call   8009a9 <printfmt>
+  800b29:	83 c4 10             	add    $0x10,%esp
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+            }
+            break;
+  800b2c:	e9 37 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+                printfmt(putch, putdat, "error %d", err);
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+  800b31:	56                   	push   %esi
+  800b32:	68 9e 14 80 00       	push   $0x80149e
+  800b37:	ff 75 0c             	pushl  0xc(%ebp)
+  800b3a:	ff 75 08             	pushl  0x8(%ebp)
+  800b3d:	e8 67 fe ff ff       	call   8009a9 <printfmt>
+  800b42:	83 c4 10             	add    $0x10,%esp
+            }
+            break;
+  800b45:	e9 1e 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // string
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+  800b4a:	8b 45 14             	mov    0x14(%ebp),%eax
+  800b4d:	8d 50 04             	lea    0x4(%eax),%edx
+  800b50:	89 55 14             	mov    %edx,0x14(%ebp)
+  800b53:	8b 30                	mov    (%eax),%esi
+  800b55:	85 f6                	test   %esi,%esi
+  800b57:	75 05                	jne    800b5e <vprintfmt+0x191>
+                p = "(null)";
+  800b59:	be a1 14 80 00       	mov    $0x8014a1,%esi
+            }
+            if (width > 0 && padc != '-') {
+  800b5e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800b62:	7e 76                	jle    800bda <vprintfmt+0x20d>
+  800b64:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+  800b68:	74 70                	je     800bda <vprintfmt+0x20d>
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  800b6a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800b6d:	83 ec 08             	sub    $0x8,%esp
+  800b70:	50                   	push   %eax
+  800b71:	56                   	push   %esi
+  800b72:	e8 17 f8 ff ff       	call   80038e <strnlen>
+  800b77:	83 c4 10             	add    $0x10,%esp
+  800b7a:	89 c2                	mov    %eax,%edx
+  800b7c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800b7f:	29 d0                	sub    %edx,%eax
+  800b81:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800b84:	eb 17                	jmp    800b9d <vprintfmt+0x1d0>
+                    putch(padc, putdat);
+  800b86:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+  800b8a:	83 ec 08             	sub    $0x8,%esp
+  800b8d:	ff 75 0c             	pushl  0xc(%ebp)
+  800b90:	50                   	push   %eax
+  800b91:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b94:	ff d0                	call   *%eax
+  800b96:	83 c4 10             	add    $0x10,%esp
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+                p = "(null)";
+            }
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  800b99:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800b9d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ba1:	7f e3                	jg     800b86 <vprintfmt+0x1b9>
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  800ba3:	eb 35                	jmp    800bda <vprintfmt+0x20d>
+                if (altflag && (ch < ' ' || ch > '~')) {
+  800ba5:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+  800ba9:	74 1c                	je     800bc7 <vprintfmt+0x1fa>
+  800bab:	83 fb 1f             	cmp    $0x1f,%ebx
+  800bae:	7e 05                	jle    800bb5 <vprintfmt+0x1e8>
+  800bb0:	83 fb 7e             	cmp    $0x7e,%ebx
+  800bb3:	7e 12                	jle    800bc7 <vprintfmt+0x1fa>
+                    putch('?', putdat);
+  800bb5:	83 ec 08             	sub    $0x8,%esp
+  800bb8:	ff 75 0c             	pushl  0xc(%ebp)
+  800bbb:	6a 3f                	push   $0x3f
+  800bbd:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bc0:	ff d0                	call   *%eax
+  800bc2:	83 c4 10             	add    $0x10,%esp
+  800bc5:	eb 0f                	jmp    800bd6 <vprintfmt+0x209>
+                }
+                else {
+                    putch(ch, putdat);
+  800bc7:	83 ec 08             	sub    $0x8,%esp
+  800bca:	ff 75 0c             	pushl  0xc(%ebp)
+  800bcd:	53                   	push   %ebx
+  800bce:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bd1:	ff d0                	call   *%eax
+  800bd3:	83 c4 10             	add    $0x10,%esp
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  800bd6:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800bda:	89 f0                	mov    %esi,%eax
+  800bdc:	8d 70 01             	lea    0x1(%eax),%esi
+  800bdf:	0f b6 00             	movzbl (%eax),%eax
+  800be2:	0f be d8             	movsbl %al,%ebx
+  800be5:	85 db                	test   %ebx,%ebx
+  800be7:	74 26                	je     800c0f <vprintfmt+0x242>
+  800be9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800bed:	78 b6                	js     800ba5 <vprintfmt+0x1d8>
+  800bef:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800bf3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800bf7:	79 ac                	jns    800ba5 <vprintfmt+0x1d8>
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  800bf9:	eb 14                	jmp    800c0f <vprintfmt+0x242>
+                putch(' ', putdat);
+  800bfb:	83 ec 08             	sub    $0x8,%esp
+  800bfe:	ff 75 0c             	pushl  0xc(%ebp)
+  800c01:	6a 20                	push   $0x20
+  800c03:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c06:	ff d0                	call   *%eax
+  800c08:	83 c4 10             	add    $0x10,%esp
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  800c0b:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800c0f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800c13:	7f e6                	jg     800bfb <vprintfmt+0x22e>
+                putch(' ', putdat);
+            }
+            break;
+  800c15:	e9 4e 01 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // (signed) decimal
+        case 'd':
+            num = getint(&ap, lflag);
+  800c1a:	83 ec 08             	sub    $0x8,%esp
+  800c1d:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c20:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c23:	50                   	push   %eax
+  800c24:	e8 39 fd ff ff       	call   800962 <getint>
+  800c29:	83 c4 10             	add    $0x10,%esp
+  800c2c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c2f:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            if ((long long)num < 0) {
+  800c32:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c35:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800c38:	85 d2                	test   %edx,%edx
+  800c3a:	79 23                	jns    800c5f <vprintfmt+0x292>
+                putch('-', putdat);
+  800c3c:	83 ec 08             	sub    $0x8,%esp
+  800c3f:	ff 75 0c             	pushl  0xc(%ebp)
+  800c42:	6a 2d                	push   $0x2d
+  800c44:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c47:	ff d0                	call   *%eax
+  800c49:	83 c4 10             	add    $0x10,%esp
+                num = -(long long)num;
+  800c4c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c4f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800c52:	f7 d8                	neg    %eax
+  800c54:	83 d2 00             	adc    $0x0,%edx
+  800c57:	f7 da                	neg    %edx
+  800c59:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c5c:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            }
+            base = 10;
+  800c5f:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  800c66:	e9 9f 00 00 00       	jmp    800d0a <vprintfmt+0x33d>
+
+        // unsigned decimal
+        case 'u':
+            num = getuint(&ap, lflag);
+  800c6b:	83 ec 08             	sub    $0x8,%esp
+  800c6e:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c71:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c74:	50                   	push   %eax
+  800c75:	e8 99 fc ff ff       	call   800913 <getuint>
+  800c7a:	83 c4 10             	add    $0x10,%esp
+  800c7d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c80:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 10;
+  800c83:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  800c8a:	eb 7e                	jmp    800d0a <vprintfmt+0x33d>
+
+        // (unsigned) octal
+        case 'o':
+            num = getuint(&ap, lflag);
+  800c8c:	83 ec 08             	sub    $0x8,%esp
+  800c8f:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c92:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c95:	50                   	push   %eax
+  800c96:	e8 78 fc ff ff       	call   800913 <getuint>
+  800c9b:	83 c4 10             	add    $0x10,%esp
+  800c9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800ca1:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 8;
+  800ca4:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+            goto number;
+  800cab:	eb 5d                	jmp    800d0a <vprintfmt+0x33d>
+
+        // pointer
+        case 'p':
+            putch('0', putdat);
+  800cad:	83 ec 08             	sub    $0x8,%esp
+  800cb0:	ff 75 0c             	pushl  0xc(%ebp)
+  800cb3:	6a 30                	push   $0x30
+  800cb5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cb8:	ff d0                	call   *%eax
+  800cba:	83 c4 10             	add    $0x10,%esp
+            putch('x', putdat);
+  800cbd:	83 ec 08             	sub    $0x8,%esp
+  800cc0:	ff 75 0c             	pushl  0xc(%ebp)
+  800cc3:	6a 78                	push   $0x78
+  800cc5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cc8:	ff d0                	call   *%eax
+  800cca:	83 c4 10             	add    $0x10,%esp
+            num = (unsigned long long)(uintptr_t)va_arg(ap, void *);
+  800ccd:	8b 45 14             	mov    0x14(%ebp),%eax
+  800cd0:	8d 50 04             	lea    0x4(%eax),%edx
+  800cd3:	89 55 14             	mov    %edx,0x14(%ebp)
+  800cd6:	8b 00                	mov    (%eax),%eax
+  800cd8:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800cdb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+            base = 16;
+  800ce2:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+            goto number;
+  800ce9:	eb 1f                	jmp    800d0a <vprintfmt+0x33d>
+
+        // (unsigned) hexadecimal
+        case 'x':
+            num = getuint(&ap, lflag);
+  800ceb:	83 ec 08             	sub    $0x8,%esp
+  800cee:	ff 75 e0             	pushl  -0x20(%ebp)
+  800cf1:	8d 45 14             	lea    0x14(%ebp),%eax
+  800cf4:	50                   	push   %eax
+  800cf5:	e8 19 fc ff ff       	call   800913 <getuint>
+  800cfa:	83 c4 10             	add    $0x10,%esp
+  800cfd:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800d00:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 16;
+  800d03:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+        number:
+            printnum(putch, putdat, num, base, width, padc);
+  800d0a:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+  800d0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800d11:	83 ec 04             	sub    $0x4,%esp
+  800d14:	52                   	push   %edx
+  800d15:	ff 75 e8             	pushl  -0x18(%ebp)
+  800d18:	50                   	push   %eax
+  800d19:	ff 75 f4             	pushl  -0xc(%ebp)
+  800d1c:	ff 75 f0             	pushl  -0x10(%ebp)
+  800d1f:	ff 75 0c             	pushl  0xc(%ebp)
+  800d22:	ff 75 08             	pushl  0x8(%ebp)
+  800d25:	e8 f8 fa ff ff       	call   800822 <printnum>
+  800d2a:	83 c4 20             	add    $0x20,%esp
+            break;
+  800d2d:	eb 39                	jmp    800d68 <vprintfmt+0x39b>
+
+        // escaped '%' character
+        case '%':
+            putch(ch, putdat);
+  800d2f:	83 ec 08             	sub    $0x8,%esp
+  800d32:	ff 75 0c             	pushl  0xc(%ebp)
+  800d35:	53                   	push   %ebx
+  800d36:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d39:	ff d0                	call   *%eax
+  800d3b:	83 c4 10             	add    $0x10,%esp
+            break;
+  800d3e:	eb 28                	jmp    800d68 <vprintfmt+0x39b>
+
+        // unrecognized escape sequence - just print it literally
+        default:
+            putch('%', putdat);
+  800d40:	83 ec 08             	sub    $0x8,%esp
+  800d43:	ff 75 0c             	pushl  0xc(%ebp)
+  800d46:	6a 25                	push   $0x25
+  800d48:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d4b:	ff d0                	call   *%eax
+  800d4d:	83 c4 10             	add    $0x10,%esp
+            for (fmt --; fmt[-1] != '%'; fmt --)
+  800d50:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800d54:	eb 04                	jmp    800d5a <vprintfmt+0x38d>
+  800d56:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800d5a:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d5d:	83 e8 01             	sub    $0x1,%eax
+  800d60:	0f b6 00             	movzbl (%eax),%eax
+  800d63:	3c 25                	cmp    $0x25,%al
+  800d65:	75 ef                	jne    800d56 <vprintfmt+0x389>
+                /* do nothing */;
+            break;
+  800d67:	90                   	nop
+        }
+    }
+  800d68:	e9 68 fc ff ff       	jmp    8009d5 <vprintfmt+0x8>
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+            if (ch == '\0') {
+                return;
+  800d6d:	90                   	nop
+            for (fmt --; fmt[-1] != '%'; fmt --)
+                /* do nothing */;
+            break;
+        }
+    }
+}
+  800d6e:	8d 65 f8             	lea    -0x8(%ebp),%esp
+  800d71:	5b                   	pop    %ebx
+  800d72:	5e                   	pop    %esi
+  800d73:	5d                   	pop    %ebp
+  800d74:	c3                   	ret    
+
+00800d75 <sprintputch>:
+ * sprintputch - 'print' a single character in a buffer
+ * @ch:         the character will be printed
+ * @b:          the buffer to place the character @ch
+ * */
+static void
+sprintputch(int ch, struct sprintbuf *b) {
+  800d75:	55                   	push   %ebp
+  800d76:	89 e5                	mov    %esp,%ebp
+    b->cnt ++;
+  800d78:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d7b:	8b 40 08             	mov    0x8(%eax),%eax
+  800d7e:	8d 50 01             	lea    0x1(%eax),%edx
+  800d81:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d84:	89 50 08             	mov    %edx,0x8(%eax)
+    if (b->buf < b->ebuf) {
+  800d87:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8a:	8b 10                	mov    (%eax),%edx
+  800d8c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8f:	8b 40 04             	mov    0x4(%eax),%eax
+  800d92:	39 c2                	cmp    %eax,%edx
+  800d94:	73 12                	jae    800da8 <sprintputch+0x33>
+        *b->buf ++ = ch;
+  800d96:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d99:	8b 00                	mov    (%eax),%eax
+  800d9b:	8d 48 01             	lea    0x1(%eax),%ecx
+  800d9e:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800da1:	89 0a                	mov    %ecx,(%edx)
+  800da3:	8b 55 08             	mov    0x8(%ebp),%edx
+  800da6:	88 10                	mov    %dl,(%eax)
+    }
+}
+  800da8:	90                   	nop
+  800da9:	5d                   	pop    %ebp
+  800daa:	c3                   	ret    
+
+00800dab <snprintf>:
+ * @str:        the buffer to place the result into
+ * @size:       the size of buffer, including the trailing null space
+ * @fmt:        the format string to use
+ * */
+int
+snprintf(char *str, size_t size, const char *fmt, ...) {
+  800dab:	55                   	push   %ebp
+  800dac:	89 e5                	mov    %esp,%ebp
+  800dae:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    int cnt;
+    va_start(ap, fmt);
+  800db1:	8d 45 14             	lea    0x14(%ebp),%eax
+  800db4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    cnt = vsnprintf(str, size, fmt, ap);
+  800db7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800dba:	50                   	push   %eax
+  800dbb:	ff 75 10             	pushl  0x10(%ebp)
+  800dbe:	ff 75 0c             	pushl  0xc(%ebp)
+  800dc1:	ff 75 08             	pushl  0x8(%ebp)
+  800dc4:	e8 0b 00 00 00       	call   800dd4 <vsnprintf>
+  800dc9:	83 c4 10             	add    $0x10,%esp
+  800dcc:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+    return cnt;
+  800dcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800dd2:	c9                   	leave  
+  800dd3:	c3                   	ret    
+
+00800dd4 <vsnprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want snprintf() instead.
+ * */
+int
+vsnprintf(char *str, size_t size, const char *fmt, va_list ap) {
+  800dd4:	55                   	push   %ebp
+  800dd5:	89 e5                	mov    %esp,%ebp
+  800dd7:	83 ec 18             	sub    $0x18,%esp
+    struct sprintbuf b = {str, str + size - 1, 0};
+  800dda:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ddd:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800de0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800de3:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800de6:	8b 45 08             	mov    0x8(%ebp),%eax
+  800de9:	01 d0                	add    %edx,%eax
+  800deb:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800dee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    if (str == NULL || b.buf > b.ebuf) {
+  800df5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  800df9:	74 0a                	je     800e05 <vsnprintf+0x31>
+  800dfb:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  800dfe:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800e01:	39 c2                	cmp    %eax,%edx
+  800e03:	76 07                	jbe    800e0c <vsnprintf+0x38>
+        return -E_INVAL;
+  800e05:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+  800e0a:	eb 20                	jmp    800e2c <vsnprintf+0x58>
+    }
+    // print the string to the buffer
+    vprintfmt((void*)sprintputch, &b, fmt, ap);
+  800e0c:	ff 75 14             	pushl  0x14(%ebp)
+  800e0f:	ff 75 10             	pushl  0x10(%ebp)
+  800e12:	8d 45 ec             	lea    -0x14(%ebp),%eax
+  800e15:	50                   	push   %eax
+  800e16:	68 75 0d 80 00       	push   $0x800d75
+  800e1b:	e8 ad fb ff ff       	call   8009cd <vprintfmt>
+  800e20:	83 c4 10             	add    $0x10,%esp
+    // null terminate the buffer
+    *b.buf = '\0';
+  800e23:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e26:	c6 00 00             	movb   $0x0,(%eax)
+    return b.cnt;
+  800e29:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800e2c:	c9                   	leave  
+  800e2d:	c3                   	ret    
+
+00800e2e <hash32>:
+ * @bits:   the number of bits in a return value
+ *
+ * High bits are more random, so we use them.
+ * */
+uint32_t
+hash32(uint32_t val, unsigned int bits) {
+  800e2e:	55                   	push   %ebp
+  800e2f:	89 e5                	mov    %esp,%ebp
+  800e31:	83 ec 10             	sub    $0x10,%esp
+    uint32_t hash = val * GOLDEN_RATIO_PRIME_32;
+  800e34:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e37:	69 c0 01 00 37 9e    	imul   $0x9e370001,%eax,%eax
+  800e3d:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    return (hash >> (32 - bits));
+  800e40:	b8 20 00 00 00       	mov    $0x20,%eax
+  800e45:	2b 45 0c             	sub    0xc(%ebp),%eax
+  800e48:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  800e4b:	89 c1                	mov    %eax,%ecx
+  800e4d:	d3 ea                	shr    %cl,%edx
+  800e4f:	89 d0                	mov    %edx,%eax
+}
+  800e51:	c9                   	leave  
+  800e52:	c3                   	ret    
+
+00800e53 <rand>:
+ * rand - returns a pseudo-random integer
+ *
+ * The rand() function return a value in the range [0, RAND_MAX].
+ * */
+int
+rand(void) {
+  800e53:	55                   	push   %ebp
+  800e54:	89 e5                	mov    %esp,%ebp
+  800e56:	57                   	push   %edi
+  800e57:	56                   	push   %esi
+  800e58:	53                   	push   %ebx
+  800e59:	83 ec 24             	sub    $0x24,%esp
+    next = (next * 0x5DEECE66DLL + 0xBLL) & ((1LL << 48) - 1);
+  800e5c:	a1 00 20 80 00       	mov    0x802000,%eax
+  800e61:	8b 15 04 20 80 00    	mov    0x802004,%edx
+  800e67:	69 fa 6d e6 ec de    	imul   $0xdeece66d,%edx,%edi
+  800e6d:	6b f0 05             	imul   $0x5,%eax,%esi
+  800e70:	01 fe                	add    %edi,%esi
+  800e72:	bf 6d e6 ec de       	mov    $0xdeece66d,%edi
+  800e77:	f7 e7                	mul    %edi
+  800e79:	01 d6                	add    %edx,%esi
+  800e7b:	89 f2                	mov    %esi,%edx
+  800e7d:	83 c0 0b             	add    $0xb,%eax
+  800e80:	83 d2 00             	adc    $0x0,%edx
+  800e83:	89 c7                	mov    %eax,%edi
+  800e85:	83 e7 ff             	and    $0xffffffff,%edi
+  800e88:	89 f9                	mov    %edi,%ecx
+  800e8a:	0f b7 da             	movzwl %dx,%ebx
+  800e8d:	89 0d 00 20 80 00    	mov    %ecx,0x802000
+  800e93:	89 1d 04 20 80 00    	mov    %ebx,0x802004
+    unsigned long long result = (next >> 12);
+  800e99:	a1 00 20 80 00       	mov    0x802000,%eax
+  800e9e:	8b 15 04 20 80 00    	mov    0x802004,%edx
+  800ea4:	0f ac d0 0c          	shrd   $0xc,%edx,%eax
+  800ea8:	c1 ea 0c             	shr    $0xc,%edx
+  800eab:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800eae:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+    return (int)do_div(result, RAND_MAX + 1);
+  800eb1:	c7 45 dc 00 00 00 80 	movl   $0x80000000,-0x24(%ebp)
+  800eb8:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  800ebb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800ebe:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  800ec1:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  800ec4:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ec7:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800eca:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ece:	74 1c                	je     800eec <rand+0x99>
+  800ed0:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ed3:	ba 00 00 00 00       	mov    $0x0,%edx
+  800ed8:	f7 75 dc             	divl   -0x24(%ebp)
+  800edb:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  800ede:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ee1:	ba 00 00 00 00       	mov    $0x0,%edx
+  800ee6:	f7 75 dc             	divl   -0x24(%ebp)
+  800ee9:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800eec:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  800eef:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  800ef2:	f7 75 dc             	divl   -0x24(%ebp)
+  800ef5:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  800ef8:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  800efb:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  800efe:	8b 55 e8             	mov    -0x18(%ebp),%edx
+  800f01:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800f04:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  800f07:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+}
+  800f0a:	83 c4 24             	add    $0x24,%esp
+  800f0d:	5b                   	pop    %ebx
+  800f0e:	5e                   	pop    %esi
+  800f0f:	5f                   	pop    %edi
+  800f10:	5d                   	pop    %ebp
+  800f11:	c3                   	ret    
+
+00800f12 <srand>:
+/* *
+ * srand - seed the random number generator with the given number
+ * @seed:   the required seed number
+ * */
+void
+srand(unsigned int seed) {
+  800f12:	55                   	push   %ebp
+  800f13:	89 e5                	mov    %esp,%ebp
+    next = seed;
+  800f15:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f18:	ba 00 00 00 00       	mov    $0x0,%edx
+  800f1d:	a3 00 20 80 00       	mov    %eax,0x802000
+  800f22:	89 15 04 20 80 00    	mov    %edx,0x802004
+}
+  800f28:	90                   	nop
+  800f29:	5d                   	pop    %ebp
+  800f2a:	c3                   	ret    
+
+00800f2b <work>:
+static int mata[MATSIZE][MATSIZE];
+static int matb[MATSIZE][MATSIZE];
+static int matc[MATSIZE][MATSIZE];
+
+void
+work(unsigned int times) {
+  800f2b:	55                   	push   %ebp
+  800f2c:	89 e5                	mov    %esp,%ebp
+  800f2e:	53                   	push   %ebx
+  800f2f:	83 ec 14             	sub    $0x14,%esp
+    int i, j, k, size = MATSIZE;
+  800f32:	c7 45 e8 0a 00 00 00 	movl   $0xa,-0x18(%ebp)
+    for (i = 0; i < size; i ++) {
+  800f39:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  800f40:	eb 65                	jmp    800fa7 <work+0x7c>
+        for (j = 0; j < size; j ++) {
+  800f42:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  800f49:	eb 50                	jmp    800f9b <work+0x70>
+            mata[i][j] = matb[i][j] = 1;
+  800f4b:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800f4e:	89 d0                	mov    %edx,%eax
+  800f50:	c1 e0 02             	shl    $0x2,%eax
+  800f53:	01 d0                	add    %edx,%eax
+  800f55:	01 c0                	add    %eax,%eax
+  800f57:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800f5a:	01 d0                	add    %edx,%eax
+  800f5c:	c7 04 85 c0 21 80 00 	movl   $0x1,0x8021c0(,%eax,4)
+  800f63:	01 00 00 00 
+  800f67:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800f6a:	89 d0                	mov    %edx,%eax
+  800f6c:	c1 e0 02             	shl    $0x2,%eax
+  800f6f:	01 d0                	add    %edx,%eax
+  800f71:	01 c0                	add    %eax,%eax
+  800f73:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800f76:	01 d0                	add    %edx,%eax
+  800f78:	8b 0c 85 c0 21 80 00 	mov    0x8021c0(,%eax,4),%ecx
+  800f7f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800f82:	89 d0                	mov    %edx,%eax
+  800f84:	c1 e0 02             	shl    $0x2,%eax
+  800f87:	01 d0                	add    %edx,%eax
+  800f89:	01 c0                	add    %eax,%eax
+  800f8b:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800f8e:	01 d0                	add    %edx,%eax
+  800f90:	89 0c 85 20 20 80 00 	mov    %ecx,0x802020(,%eax,4)
+
+void
+work(unsigned int times) {
+    int i, j, k, size = MATSIZE;
+    for (i = 0; i < size; i ++) {
+        for (j = 0; j < size; j ++) {
+  800f97:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+  800f9b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800f9e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
+  800fa1:	7c a8                	jl     800f4b <work+0x20>
+static int matc[MATSIZE][MATSIZE];
+
+void
+work(unsigned int times) {
+    int i, j, k, size = MATSIZE;
+    for (i = 0; i < size; i ++) {
+  800fa3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  800fa7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800faa:	3b 45 e8             	cmp    -0x18(%ebp),%eax
+  800fad:	7c 93                	jl     800f42 <work+0x17>
+        for (j = 0; j < size; j ++) {
+            mata[i][j] = matb[i][j] = 1;
+        }
+    }
+
+    yield();
+  800faf:	e8 66 f2 ff ff       	call   80021a <yield>
+
+    cprintf("pid %d is running (%d times)!.\n", getpid(), times);
+  800fb4:	e8 85 f2 ff ff       	call   80023e <getpid>
+  800fb9:	83 ec 04             	sub    $0x4,%esp
+  800fbc:	ff 75 08             	pushl  0x8(%ebp)
+  800fbf:	50                   	push   %eax
+  800fc0:	68 00 16 80 00       	push   $0x801600
+  800fc5:	e8 0f f3 ff ff       	call   8002d9 <cprintf>
+  800fca:	83 c4 10             	add    $0x10,%esp
+
+    while (times -- > 0) {
+  800fcd:	e9 5c 01 00 00       	jmp    80112e <work+0x203>
+        for (i = 0; i < size; i ++) {
+  800fd2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  800fd9:	e9 b6 00 00 00       	jmp    801094 <work+0x169>
+            for (j = 0; j < size; j ++) {
+  800fde:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  800fe5:	e9 9a 00 00 00       	jmp    801084 <work+0x159>
+                matc[i][j] = 0;
+  800fea:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800fed:	89 d0                	mov    %edx,%eax
+  800fef:	c1 e0 02             	shl    $0x2,%eax
+  800ff2:	01 d0                	add    %edx,%eax
+  800ff4:	01 c0                	add    %eax,%eax
+  800ff6:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800ff9:	01 d0                	add    %edx,%eax
+  800ffb:	c7 04 85 60 23 80 00 	movl   $0x0,0x802360(,%eax,4)
+  801002:	00 00 00 00 
+                for (k = 0; k < size; k ++) {
+  801006:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  80100d:	eb 69                	jmp    801078 <work+0x14d>
+                    matc[i][j] += mata[i][k] * matb[k][j];
+  80100f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  801012:	89 d0                	mov    %edx,%eax
+  801014:	c1 e0 02             	shl    $0x2,%eax
+  801017:	01 d0                	add    %edx,%eax
+  801019:	01 c0                	add    %eax,%eax
+  80101b:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  80101e:	01 d0                	add    %edx,%eax
+  801020:	8b 0c 85 60 23 80 00 	mov    0x802360(,%eax,4),%ecx
+  801027:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80102a:	89 d0                	mov    %edx,%eax
+  80102c:	c1 e0 02             	shl    $0x2,%eax
+  80102f:	01 d0                	add    %edx,%eax
+  801031:	01 c0                	add    %eax,%eax
+  801033:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  801036:	01 d0                	add    %edx,%eax
+  801038:	8b 1c 85 20 20 80 00 	mov    0x802020(,%eax,4),%ebx
+  80103f:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  801042:	89 d0                	mov    %edx,%eax
+  801044:	c1 e0 02             	shl    $0x2,%eax
+  801047:	01 d0                	add    %edx,%eax
+  801049:	01 c0                	add    %eax,%eax
+  80104b:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  80104e:	01 d0                	add    %edx,%eax
+  801050:	8b 04 85 c0 21 80 00 	mov    0x8021c0(,%eax,4),%eax
+  801057:	0f af c3             	imul   %ebx,%eax
+  80105a:	01 c1                	add    %eax,%ecx
+  80105c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80105f:	89 d0                	mov    %edx,%eax
+  801061:	c1 e0 02             	shl    $0x2,%eax
+  801064:	01 d0                	add    %edx,%eax
+  801066:	01 c0                	add    %eax,%eax
+  801068:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  80106b:	01 d0                	add    %edx,%eax
+  80106d:	89 0c 85 60 23 80 00 	mov    %ecx,0x802360(,%eax,4)
+
+    while (times -- > 0) {
+        for (i = 0; i < size; i ++) {
+            for (j = 0; j < size; j ++) {
+                matc[i][j] = 0;
+                for (k = 0; k < size; k ++) {
+  801074:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
+  801078:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  80107b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
+  80107e:	7c 8f                	jl     80100f <work+0xe4>
+
+    cprintf("pid %d is running (%d times)!.\n", getpid(), times);
+
+    while (times -- > 0) {
+        for (i = 0; i < size; i ++) {
+            for (j = 0; j < size; j ++) {
+  801080:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+  801084:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  801087:	3b 45 e8             	cmp    -0x18(%ebp),%eax
+  80108a:	0f 8c 5a ff ff ff    	jl     800fea <work+0xbf>
+    yield();
+
+    cprintf("pid %d is running (%d times)!.\n", getpid(), times);
+
+    while (times -- > 0) {
+        for (i = 0; i < size; i ++) {
+  801090:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  801094:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  801097:	3b 45 e8             	cmp    -0x18(%ebp),%eax
+  80109a:	0f 8c 3e ff ff ff    	jl     800fde <work+0xb3>
+                for (k = 0; k < size; k ++) {
+                    matc[i][j] += mata[i][k] * matb[k][j];
+                }
+            }
+        }
+        for (i = 0; i < size; i ++) {
+  8010a0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  8010a7:	eb 79                	jmp    801122 <work+0x1f7>
+            for (j = 0; j < size; j ++) {
+  8010a9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  8010b0:	eb 64                	jmp    801116 <work+0x1eb>
+                mata[i][j] = matb[i][j] = matc[i][j];
+  8010b2:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8010b5:	89 d0                	mov    %edx,%eax
+  8010b7:	c1 e0 02             	shl    $0x2,%eax
+  8010ba:	01 d0                	add    %edx,%eax
+  8010bc:	01 c0                	add    %eax,%eax
+  8010be:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  8010c1:	01 d0                	add    %edx,%eax
+  8010c3:	8b 0c 85 60 23 80 00 	mov    0x802360(,%eax,4),%ecx
+  8010ca:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8010cd:	89 d0                	mov    %edx,%eax
+  8010cf:	c1 e0 02             	shl    $0x2,%eax
+  8010d2:	01 d0                	add    %edx,%eax
+  8010d4:	01 c0                	add    %eax,%eax
+  8010d6:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  8010d9:	01 d0                	add    %edx,%eax
+  8010db:	89 0c 85 c0 21 80 00 	mov    %ecx,0x8021c0(,%eax,4)
+  8010e2:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8010e5:	89 d0                	mov    %edx,%eax
+  8010e7:	c1 e0 02             	shl    $0x2,%eax
+  8010ea:	01 d0                	add    %edx,%eax
+  8010ec:	01 c0                	add    %eax,%eax
+  8010ee:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  8010f1:	01 d0                	add    %edx,%eax
+  8010f3:	8b 0c 85 c0 21 80 00 	mov    0x8021c0(,%eax,4),%ecx
+  8010fa:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8010fd:	89 d0                	mov    %edx,%eax
+  8010ff:	c1 e0 02             	shl    $0x2,%eax
+  801102:	01 d0                	add    %edx,%eax
+  801104:	01 c0                	add    %eax,%eax
+  801106:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  801109:	01 d0                	add    %edx,%eax
+  80110b:	89 0c 85 20 20 80 00 	mov    %ecx,0x802020(,%eax,4)
+                    matc[i][j] += mata[i][k] * matb[k][j];
+                }
+            }
+        }
+        for (i = 0; i < size; i ++) {
+            for (j = 0; j < size; j ++) {
+  801112:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+  801116:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  801119:	3b 45 e8             	cmp    -0x18(%ebp),%eax
+  80111c:	7c 94                	jl     8010b2 <work+0x187>
+                for (k = 0; k < size; k ++) {
+                    matc[i][j] += mata[i][k] * matb[k][j];
+                }
+            }
+        }
+        for (i = 0; i < size; i ++) {
+  80111e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  801122:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  801125:	3b 45 e8             	cmp    -0x18(%ebp),%eax
+  801128:	0f 8c 7b ff ff ff    	jl     8010a9 <work+0x17e>
+
+    yield();
+
+    cprintf("pid %d is running (%d times)!.\n", getpid(), times);
+
+    while (times -- > 0) {
+  80112e:	8b 45 08             	mov    0x8(%ebp),%eax
+  801131:	8d 50 ff             	lea    -0x1(%eax),%edx
+  801134:	89 55 08             	mov    %edx,0x8(%ebp)
+  801137:	85 c0                	test   %eax,%eax
+  801139:	0f 85 93 fe ff ff    	jne    800fd2 <work+0xa7>
+            for (j = 0; j < size; j ++) {
+                mata[i][j] = matb[i][j] = matc[i][j];
+            }
+        }
+    }
+    cprintf("pid %d done!.\n", getpid());
+  80113f:	e8 fa f0 ff ff       	call   80023e <getpid>
+  801144:	83 ec 08             	sub    $0x8,%esp
+  801147:	50                   	push   %eax
+  801148:	68 20 16 80 00       	push   $0x801620
+  80114d:	e8 87 f1 ff ff       	call   8002d9 <cprintf>
+  801152:	83 c4 10             	add    $0x10,%esp
+    exit(0);
+  801155:	83 ec 0c             	sub    $0xc,%esp
+  801158:	6a 00                	push   $0x0
+  80115a:	e8 58 f0 ff ff       	call   8001b7 <exit>
+
+0080115f <main>:
+}
+
+const int total = 21;
+
+int
+main(void) {
+  80115f:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+  801163:	83 e4 f0             	and    $0xfffffff0,%esp
+  801166:	ff 71 fc             	pushl  -0x4(%ecx)
+  801169:	55                   	push   %ebp
+  80116a:	89 e5                	mov    %esp,%ebp
+  80116c:	53                   	push   %ebx
+  80116d:	51                   	push   %ecx
+  80116e:	83 ec 10             	sub    $0x10,%esp
+  801171:	89 e0                	mov    %esp,%eax
+  801173:	89 c3                	mov    %eax,%ebx
+    int pids[total];
+  801175:	b8 15 00 00 00       	mov    $0x15,%eax
+  80117a:	83 e8 01             	sub    $0x1,%eax
+  80117d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  801180:	b8 15 00 00 00       	mov    $0x15,%eax
+  801185:	c1 e0 02             	shl    $0x2,%eax
+  801188:	8d 50 03             	lea    0x3(%eax),%edx
+  80118b:	b8 10 00 00 00       	mov    $0x10,%eax
+  801190:	83 e8 01             	sub    $0x1,%eax
+  801193:	01 d0                	add    %edx,%eax
+  801195:	b9 10 00 00 00       	mov    $0x10,%ecx
+  80119a:	ba 00 00 00 00       	mov    $0x0,%edx
+  80119f:	f7 f1                	div    %ecx
+  8011a1:	6b c0 10             	imul   $0x10,%eax,%eax
+  8011a4:	29 c4                	sub    %eax,%esp
+  8011a6:	89 e0                	mov    %esp,%eax
+  8011a8:	83 c0 03             	add    $0x3,%eax
+  8011ab:	c1 e8 02             	shr    $0x2,%eax
+  8011ae:	c1 e0 02             	shl    $0x2,%eax
+  8011b1:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    memset(pids, 0, sizeof(pids));
+  8011b4:	b8 15 00 00 00       	mov    $0x15,%eax
+  8011b9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+  8011c0:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  8011c3:	83 ec 04             	sub    $0x4,%esp
+  8011c6:	52                   	push   %edx
+  8011c7:	6a 00                	push   $0x0
+  8011c9:	50                   	push   %eax
+  8011ca:	e8 c8 f4 ff ff       	call   800697 <memset>
+  8011cf:	83 c4 10             	add    $0x10,%esp
+
+    int i;
+    for (i = 0; i < total; i ++) {
+  8011d2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  8011d9:	eb 78                	jmp    801253 <main+0xf4>
+        if ((pids[i] = fork()) == 0) {
+  8011db:	e8 fd ef ff ff       	call   8001dd <fork>
+  8011e0:	89 c1                	mov    %eax,%ecx
+  8011e2:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  8011e5:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8011e8:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
+  8011eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  8011ee:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8011f1:	8b 04 90             	mov    (%eax,%edx,4),%eax
+  8011f4:	85 c0                	test   %eax,%eax
+  8011f6:	75 4a                	jne    801242 <main+0xe3>
+            srand(i * i);
+  8011f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8011fb:	0f af 45 f4          	imul   -0xc(%ebp),%eax
+  8011ff:	83 ec 0c             	sub    $0xc,%esp
+  801202:	50                   	push   %eax
+  801203:	e8 0a fd ff ff       	call   800f12 <srand>
+  801208:	83 c4 10             	add    $0x10,%esp
+            int times = (((unsigned int)rand()) % total);
+  80120b:	e8 43 fc ff ff       	call   800e53 <rand>
+  801210:	ba 15 00 00 00       	mov    $0x15,%edx
+  801215:	89 d1                	mov    %edx,%ecx
+  801217:	ba 00 00 00 00       	mov    $0x0,%edx
+  80121c:	f7 f1                	div    %ecx
+  80121e:	89 d0                	mov    %edx,%eax
+  801220:	89 45 e8             	mov    %eax,-0x18(%ebp)
+            times = (times * times + 10) * 100;
+  801223:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  801226:	0f af 45 e8          	imul   -0x18(%ebp),%eax
+  80122a:	83 c0 0a             	add    $0xa,%eax
+  80122d:	6b c0 64             	imul   $0x64,%eax,%eax
+  801230:	89 45 e8             	mov    %eax,-0x18(%ebp)
+            work(times);
+  801233:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  801236:	83 ec 0c             	sub    $0xc,%esp
+  801239:	50                   	push   %eax
+  80123a:	e8 ec fc ff ff       	call   800f2b <work>
+  80123f:	83 c4 10             	add    $0x10,%esp
+        }
+        if (pids[i] < 0) {
+  801242:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  801245:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  801248:	8b 04 90             	mov    (%eax,%edx,4),%eax
+  80124b:	85 c0                	test   %eax,%eax
+  80124d:	78 6d                	js     8012bc <main+0x15d>
+main(void) {
+    int pids[total];
+    memset(pids, 0, sizeof(pids));
+
+    int i;
+    for (i = 0; i < total; i ++) {
+  80124f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  801253:	b8 15 00 00 00       	mov    $0x15,%eax
+  801258:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+  80125b:	0f 8c 7a ff ff ff    	jl     8011db <main+0x7c>
+        if (pids[i] < 0) {
+            goto failed;
+        }
+    }
+
+    cprintf("fork ok.\n");
+  801261:	83 ec 0c             	sub    $0xc,%esp
+  801264:	68 34 16 80 00       	push   $0x801634
+  801269:	e8 6b f0 ff ff       	call   8002d9 <cprintf>
+  80126e:	83 c4 10             	add    $0x10,%esp
+
+    for (i = 0; i < total; i ++) {
+  801271:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  801278:	eb 1f                	jmp    801299 <main+0x13a>
+        if (wait() != 0) {
+  80127a:	e8 6b ef ff ff       	call   8001ea <wait>
+  80127f:	85 c0                	test   %eax,%eax
+  801281:	74 12                	je     801295 <main+0x136>
+            cprintf("wait failed.\n");
+  801283:	83 ec 0c             	sub    $0xc,%esp
+  801286:	68 3e 16 80 00       	push   $0x80163e
+  80128b:	e8 49 f0 ff ff       	call   8002d9 <cprintf>
+  801290:	83 c4 10             	add    $0x10,%esp
+            goto failed;
+  801293:	eb 28                	jmp    8012bd <main+0x15e>
+        }
+    }
+
+    cprintf("fork ok.\n");
+
+    for (i = 0; i < total; i ++) {
+  801295:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  801299:	b8 15 00 00 00       	mov    $0x15,%eax
+  80129e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+  8012a1:	7c d7                	jl     80127a <main+0x11b>
+            cprintf("wait failed.\n");
+            goto failed;
+        }
+    }
+
+    cprintf("matrix pass.\n");
+  8012a3:	83 ec 0c             	sub    $0xc,%esp
+  8012a6:	68 4c 16 80 00       	push   $0x80164c
+  8012ab:	e8 29 f0 ff ff       	call   8002d9 <cprintf>
+  8012b0:	83 c4 10             	add    $0x10,%esp
+    return 0;
+  8012b3:	b8 00 00 00 00       	mov    $0x0,%eax
+  8012b8:	89 dc                	mov    %ebx,%esp
+  8012ba:	eb 4e                	jmp    80130a <main+0x1ab>
+            int times = (((unsigned int)rand()) % total);
+            times = (times * times + 10) * 100;
+            work(times);
+        }
+        if (pids[i] < 0) {
+            goto failed;
+  8012bc:	90                   	nop
+
+    cprintf("matrix pass.\n");
+    return 0;
+
+failed:
+    for (i = 0; i < total; i ++) {
+  8012bd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  8012c4:	eb 26                	jmp    8012ec <main+0x18d>
+        if (pids[i] > 0) {
+  8012c6:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  8012c9:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8012cc:	8b 04 90             	mov    (%eax,%edx,4),%eax
+  8012cf:	85 c0                	test   %eax,%eax
+  8012d1:	7e 15                	jle    8012e8 <main+0x189>
+            kill(pids[i]);
+  8012d3:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  8012d6:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8012d9:	8b 04 90             	mov    (%eax,%edx,4),%eax
+  8012dc:	83 ec 0c             	sub    $0xc,%esp
+  8012df:	50                   	push   %eax
+  8012e0:	e8 43 ef ff ff       	call   800228 <kill>
+  8012e5:	83 c4 10             	add    $0x10,%esp
+
+    cprintf("matrix pass.\n");
+    return 0;
+
+failed:
+    for (i = 0; i < total; i ++) {
+  8012e8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  8012ec:	b8 15 00 00 00       	mov    $0x15,%eax
+  8012f1:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+  8012f4:	7c d0                	jl     8012c6 <main+0x167>
+        if (pids[i] > 0) {
+            kill(pids[i]);
+        }
+    }
+    panic("FAIL: T.T\n");
+  8012f6:	83 ec 04             	sub    $0x4,%esp
+  8012f9:	68 5a 16 80 00       	push   $0x80165a
+  8012fe:	6a 52                	push   $0x52
+  801300:	68 65 16 80 00       	push   $0x801665
+  801305:	e8 16 ed ff ff       	call   800020 <__panic>
+}
+  80130a:	8d 65 f8             	lea    -0x8(%ebp),%esp
+  80130d:	59                   	pop    %ecx
+  80130e:	5b                   	pop    %ebx
+  80130f:	5d                   	pop    %ebp
+  801310:	8d 61 fc             	lea    -0x4(%ecx),%esp
+  801313:	c3                   	ret    
diff -r -u -P lab6_origin/obj/user/matrix.d lab6/obj/user/matrix.d
--- lab6_origin/obj/user/matrix.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/matrix.d	2019-05-13 17:39:38.295093600 +0800
@@ -0,0 +1,2 @@
+obj/user/matrix.o obj/user/matrix.d: user/matrix.c user/libs/ulib.h \
+ libs/defs.h libs/stdio.h libs/stdarg.h libs/string.h libs/stdlib.h
Binary files lab6_origin/obj/user/matrix.o and lab6/obj/user/matrix.o differ
diff -r -u -P lab6_origin/obj/user/matrix.sym lab6/obj/user/matrix.sym
--- lab6_origin/obj/user/matrix.sym	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/matrix.sym	2019-05-13 17:39:43.943851100 +0800
@@ -0,0 +1,82 @@
+00800020 .text
+00801320 .rodata
+00802000 .data
+00802020 .bss
+00200000 .stab_info
+00200010 .stab
+00203041 .stabstr
+00000000 panic.c
+00000000 syscall.c
+008000b5 syscall
+00000000 ulib.c
+00000000 stdio.c
+0080028c cputch
+00000000 umain.c
+00000000 string.c
+00000000 printfmt.c
+00801420 error_string
+00800822 printnum
+00800913 getuint
+00800962 getint
+00800d75 sprintputch
+00000000 hash.c
+00000000 rand.c
+00802000 next
+00000000 matrix.c
+00802020 mata
+008021c0 matb
+00802360 matc
+008003be strcpy
+0080021a yield
+00800201 waitpid
+00800141 sys_yield
+008006d7 memmove
+00800dab snprintf
+008009cd vprintfmt
+0080011d sys_fork
+008002d9 cprintf
+0080023e getpid
+0080077a memcpy
+00800266 lab6_set_priority
+00800dd4 vsnprintf
+0080034d umain
+00203040 __STAB_END__
+00800150 sys_kill
+00203041 __STABSTR_BEGIN__
+00800020 __panic
+0080053a strtol
+0080038e strnlen
+0080024b print_pgdir
+00800228 kill
+0080050b strfind
+008001ea wait
+0080027d _start
+00800e53 rand
+00800482 strncmp
+00800171 sys_putc
+008003fe strncpy
+008007ca memcmp
+008001dd fork
+00800697 memset
+0080115f main
+00800f12 srand
+00800e2e hash32
+008009a9 printfmt
+00203ed2 __STABSTR_END__
+00800438 strcmp
+00800259 gettime_msec
+00800192 sys_gettime
+008002b0 vcprintf
+0080006e __warn
+008002ff cputs
+008001a1 sys_lab6_set_priority
+00801630 total
+008001b7 exit
+0080012c sys_wait
+0080010b sys_exit
+00200010 __STAB_BEGIN__
+00800366 strlen
+00800183 sys_pgdir
+008004d8 strchr
+00800162 sys_getpid
+00800f2b work
diff -r -u -P lab6_origin/obj/user/pgdir.asm lab6/obj/user/pgdir.asm
--- lab6_origin/obj/user/pgdir.asm	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/pgdir.asm	2019-05-13 17:39:43.894878600 +0800
@@ -0,0 +1,2591 @@
+
+obj/__user_pgdir.out:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00800020 <__panic>:
+#include <stdio.h>
+#include <ulib.h>
+#include <error.h>
+
+void
+__panic(const char *file, int line, const char *fmt, ...) {
+  800020:	55                   	push   %ebp
+  800021:	89 e5                	mov    %esp,%ebp
+  800023:	83 ec 18             	sub    $0x18,%esp
+    // print the 'message'
+    va_list ap;
+    va_start(ap, fmt);
+  800026:	8d 45 14             	lea    0x14(%ebp),%eax
+  800029:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("user panic at %s:%d:\n    ", file, line);
+  80002c:	83 ec 04             	sub    $0x4,%esp
+  80002f:	ff 75 0c             	pushl  0xc(%ebp)
+  800032:	ff 75 08             	pushl  0x8(%ebp)
+  800035:	68 80 0f 80 00       	push   $0x800f80
+  80003a:	e8 9a 02 00 00       	call   8002d9 <cprintf>
+  80003f:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+  800042:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800045:	83 ec 08             	sub    $0x8,%esp
+  800048:	50                   	push   %eax
+  800049:	ff 75 10             	pushl  0x10(%ebp)
+  80004c:	e8 5f 02 00 00       	call   8002b0 <vcprintf>
+  800051:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+  800054:	83 ec 0c             	sub    $0xc,%esp
+  800057:	68 9a 0f 80 00       	push   $0x800f9a
+  80005c:	e8 78 02 00 00       	call   8002d9 <cprintf>
+  800061:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+    exit(-E_PANIC);
+  800064:	83 ec 0c             	sub    $0xc,%esp
+  800067:	6a f6                	push   $0xfffffff6
+  800069:	e8 49 01 00 00       	call   8001b7 <exit>
+
+0080006e <__warn>:
+}
+
+void
+__warn(const char *file, int line, const char *fmt, ...) {
+  80006e:	55                   	push   %ebp
+  80006f:	89 e5                	mov    %esp,%ebp
+  800071:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    va_start(ap, fmt);
+  800074:	8d 45 14             	lea    0x14(%ebp),%eax
+  800077:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("user warning at %s:%d:\n    ", file, line);
+  80007a:	83 ec 04             	sub    $0x4,%esp
+  80007d:	ff 75 0c             	pushl  0xc(%ebp)
+  800080:	ff 75 08             	pushl  0x8(%ebp)
+  800083:	68 9c 0f 80 00       	push   $0x800f9c
+  800088:	e8 4c 02 00 00       	call   8002d9 <cprintf>
+  80008d:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+  800090:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800093:	83 ec 08             	sub    $0x8,%esp
+  800096:	50                   	push   %eax
+  800097:	ff 75 10             	pushl  0x10(%ebp)
+  80009a:	e8 11 02 00 00       	call   8002b0 <vcprintf>
+  80009f:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+  8000a2:	83 ec 0c             	sub    $0xc,%esp
+  8000a5:	68 9a 0f 80 00       	push   $0x800f9a
+  8000aa:	e8 2a 02 00 00       	call   8002d9 <cprintf>
+  8000af:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+  8000b2:	90                   	nop
+  8000b3:	c9                   	leave  
+  8000b4:	c3                   	ret    
+
+008000b5 <syscall>:
+#include <syscall.h>
+
+#define MAX_ARGS            5
+
+static inline int
+syscall(int num, ...) {
+  8000b5:	55                   	push   %ebp
+  8000b6:	89 e5                	mov    %esp,%ebp
+  8000b8:	57                   	push   %edi
+  8000b9:	56                   	push   %esi
+  8000ba:	53                   	push   %ebx
+  8000bb:	83 ec 20             	sub    $0x20,%esp
+    va_list ap;
+    va_start(ap, num);
+  8000be:	8d 45 0c             	lea    0xc(%ebp),%eax
+  8000c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    uint32_t a[MAX_ARGS];
+    int i, ret;
+    for (i = 0; i < MAX_ARGS; i ++) {
+  8000c4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  8000cb:	eb 16                	jmp    8000e3 <syscall+0x2e>
+        a[i] = va_arg(ap, uint32_t);
+  8000cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8000d0:	8d 50 04             	lea    0x4(%eax),%edx
+  8000d3:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  8000d6:	8b 10                	mov    (%eax),%edx
+  8000d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8000db:	89 54 85 d4          	mov    %edx,-0x2c(%ebp,%eax,4)
+syscall(int num, ...) {
+    va_list ap;
+    va_start(ap, num);
+    uint32_t a[MAX_ARGS];
+    int i, ret;
+    for (i = 0; i < MAX_ARGS; i ++) {
+  8000df:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+  8000e3:	83 7d f0 04          	cmpl   $0x4,-0x10(%ebp)
+  8000e7:	7e e4                	jle    8000cd <syscall+0x18>
+    asm volatile (
+        "int %1;"
+        : "=a" (ret)
+        : "i" (T_SYSCALL),
+          "a" (num),
+          "d" (a[0]),
+  8000e9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+          "c" (a[1]),
+  8000ec:	8b 4d d8             	mov    -0x28(%ebp),%ecx
+          "b" (a[2]),
+  8000ef:	8b 5d dc             	mov    -0x24(%ebp),%ebx
+          "D" (a[3]),
+  8000f2:	8b 7d e0             	mov    -0x20(%ebp),%edi
+          "S" (a[4])
+  8000f5:	8b 75 e4             	mov    -0x1c(%ebp),%esi
+    for (i = 0; i < MAX_ARGS; i ++) {
+        a[i] = va_arg(ap, uint32_t);
+    }
+    va_end(ap);
+
+    asm volatile (
+  8000f8:	8b 45 08             	mov    0x8(%ebp),%eax
+  8000fb:	cd 80                	int    $0x80
+  8000fd:	89 45 ec             	mov    %eax,-0x14(%ebp)
+          "c" (a[1]),
+          "b" (a[2]),
+          "D" (a[3]),
+          "S" (a[4])
+        : "cc", "memory");
+    return ret;
+  800100:	8b 45 ec             	mov    -0x14(%ebp),%eax
+}
+  800103:	83 c4 20             	add    $0x20,%esp
+  800106:	5b                   	pop    %ebx
+  800107:	5e                   	pop    %esi
+  800108:	5f                   	pop    %edi
+  800109:	5d                   	pop    %ebp
+  80010a:	c3                   	ret    
+
+0080010b <sys_exit>:
+
+int
+sys_exit(int error_code) {
+  80010b:	55                   	push   %ebp
+  80010c:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_exit, error_code);
+  80010e:	ff 75 08             	pushl  0x8(%ebp)
+  800111:	6a 01                	push   $0x1
+  800113:	e8 9d ff ff ff       	call   8000b5 <syscall>
+  800118:	83 c4 08             	add    $0x8,%esp
+}
+  80011b:	c9                   	leave  
+  80011c:	c3                   	ret    
+
+0080011d <sys_fork>:
+
+int
+sys_fork(void) {
+  80011d:	55                   	push   %ebp
+  80011e:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_fork);
+  800120:	6a 02                	push   $0x2
+  800122:	e8 8e ff ff ff       	call   8000b5 <syscall>
+  800127:	83 c4 04             	add    $0x4,%esp
+}
+  80012a:	c9                   	leave  
+  80012b:	c3                   	ret    
+
+0080012c <sys_wait>:
+
+int
+sys_wait(int pid, int *store) {
+  80012c:	55                   	push   %ebp
+  80012d:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_wait, pid, store);
+  80012f:	ff 75 0c             	pushl  0xc(%ebp)
+  800132:	ff 75 08             	pushl  0x8(%ebp)
+  800135:	6a 03                	push   $0x3
+  800137:	e8 79 ff ff ff       	call   8000b5 <syscall>
+  80013c:	83 c4 0c             	add    $0xc,%esp
+}
+  80013f:	c9                   	leave  
+  800140:	c3                   	ret    
+
+00800141 <sys_yield>:
+
+int
+sys_yield(void) {
+  800141:	55                   	push   %ebp
+  800142:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_yield);
+  800144:	6a 0a                	push   $0xa
+  800146:	e8 6a ff ff ff       	call   8000b5 <syscall>
+  80014b:	83 c4 04             	add    $0x4,%esp
+}
+  80014e:	c9                   	leave  
+  80014f:	c3                   	ret    
+
+00800150 <sys_kill>:
+
+int
+sys_kill(int pid) {
+  800150:	55                   	push   %ebp
+  800151:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_kill, pid);
+  800153:	ff 75 08             	pushl  0x8(%ebp)
+  800156:	6a 0c                	push   $0xc
+  800158:	e8 58 ff ff ff       	call   8000b5 <syscall>
+  80015d:	83 c4 08             	add    $0x8,%esp
+}
+  800160:	c9                   	leave  
+  800161:	c3                   	ret    
+
+00800162 <sys_getpid>:
+
+int
+sys_getpid(void) {
+  800162:	55                   	push   %ebp
+  800163:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_getpid);
+  800165:	6a 12                	push   $0x12
+  800167:	e8 49 ff ff ff       	call   8000b5 <syscall>
+  80016c:	83 c4 04             	add    $0x4,%esp
+}
+  80016f:	c9                   	leave  
+  800170:	c3                   	ret    
+
+00800171 <sys_putc>:
+
+int
+sys_putc(int c) {
+  800171:	55                   	push   %ebp
+  800172:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_putc, c);
+  800174:	ff 75 08             	pushl  0x8(%ebp)
+  800177:	6a 1e                	push   $0x1e
+  800179:	e8 37 ff ff ff       	call   8000b5 <syscall>
+  80017e:	83 c4 08             	add    $0x8,%esp
+}
+  800181:	c9                   	leave  
+  800182:	c3                   	ret    
+
+00800183 <sys_pgdir>:
+
+int
+sys_pgdir(void) {
+  800183:	55                   	push   %ebp
+  800184:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_pgdir);
+  800186:	6a 1f                	push   $0x1f
+  800188:	e8 28 ff ff ff       	call   8000b5 <syscall>
+  80018d:	83 c4 04             	add    $0x4,%esp
+}
+  800190:	c9                   	leave  
+  800191:	c3                   	ret    
+
+00800192 <sys_gettime>:
+
+int
+sys_gettime(void) {
+  800192:	55                   	push   %ebp
+  800193:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_gettime);
+  800195:	6a 11                	push   $0x11
+  800197:	e8 19 ff ff ff       	call   8000b5 <syscall>
+  80019c:	83 c4 04             	add    $0x4,%esp
+}
+  80019f:	c9                   	leave  
+  8001a0:	c3                   	ret    
+
+008001a1 <sys_lab6_set_priority>:
+
+void
+sys_lab6_set_priority(uint32_t priority)
+{
+  8001a1:	55                   	push   %ebp
+  8001a2:	89 e5                	mov    %esp,%ebp
+    syscall(SYS_lab6_set_priority, priority);
+  8001a4:	ff 75 08             	pushl  0x8(%ebp)
+  8001a7:	68 ff 00 00 00       	push   $0xff
+  8001ac:	e8 04 ff ff ff       	call   8000b5 <syscall>
+  8001b1:	83 c4 08             	add    $0x8,%esp
+}
+  8001b4:	90                   	nop
+  8001b5:	c9                   	leave  
+  8001b6:	c3                   	ret    
+
+008001b7 <exit>:
+#include <syscall.h>
+#include <stdio.h>
+#include <ulib.h>
+
+void
+exit(int error_code) {
+  8001b7:	55                   	push   %ebp
+  8001b8:	89 e5                	mov    %esp,%ebp
+  8001ba:	83 ec 08             	sub    $0x8,%esp
+    sys_exit(error_code);
+  8001bd:	83 ec 0c             	sub    $0xc,%esp
+  8001c0:	ff 75 08             	pushl  0x8(%ebp)
+  8001c3:	e8 43 ff ff ff       	call   80010b <sys_exit>
+  8001c8:	83 c4 10             	add    $0x10,%esp
+    cprintf("BUG: exit failed.\n");
+  8001cb:	83 ec 0c             	sub    $0xc,%esp
+  8001ce:	68 b8 0f 80 00       	push   $0x800fb8
+  8001d3:	e8 01 01 00 00       	call   8002d9 <cprintf>
+  8001d8:	83 c4 10             	add    $0x10,%esp
+    while (1);
+  8001db:	eb fe                	jmp    8001db <exit+0x24>
+
+008001dd <fork>:
+}
+
+int
+fork(void) {
+  8001dd:	55                   	push   %ebp
+  8001de:	89 e5                	mov    %esp,%ebp
+  8001e0:	83 ec 08             	sub    $0x8,%esp
+    return sys_fork();
+  8001e3:	e8 35 ff ff ff       	call   80011d <sys_fork>
+}
+  8001e8:	c9                   	leave  
+  8001e9:	c3                   	ret    
+
+008001ea <wait>:
+
+int
+wait(void) {
+  8001ea:	55                   	push   %ebp
+  8001eb:	89 e5                	mov    %esp,%ebp
+  8001ed:	83 ec 08             	sub    $0x8,%esp
+    return sys_wait(0, NULL);
+  8001f0:	83 ec 08             	sub    $0x8,%esp
+  8001f3:	6a 00                	push   $0x0
+  8001f5:	6a 00                	push   $0x0
+  8001f7:	e8 30 ff ff ff       	call   80012c <sys_wait>
+  8001fc:	83 c4 10             	add    $0x10,%esp
+}
+  8001ff:	c9                   	leave  
+  800200:	c3                   	ret    
+
+00800201 <waitpid>:
+
+int
+waitpid(int pid, int *store) {
+  800201:	55                   	push   %ebp
+  800202:	89 e5                	mov    %esp,%ebp
+  800204:	83 ec 08             	sub    $0x8,%esp
+    return sys_wait(pid, store);
+  800207:	83 ec 08             	sub    $0x8,%esp
+  80020a:	ff 75 0c             	pushl  0xc(%ebp)
+  80020d:	ff 75 08             	pushl  0x8(%ebp)
+  800210:	e8 17 ff ff ff       	call   80012c <sys_wait>
+  800215:	83 c4 10             	add    $0x10,%esp
+}
+  800218:	c9                   	leave  
+  800219:	c3                   	ret    
+
+0080021a <yield>:
+
+void
+yield(void) {
+  80021a:	55                   	push   %ebp
+  80021b:	89 e5                	mov    %esp,%ebp
+  80021d:	83 ec 08             	sub    $0x8,%esp
+    sys_yield();
+  800220:	e8 1c ff ff ff       	call   800141 <sys_yield>
+}
+  800225:	90                   	nop
+  800226:	c9                   	leave  
+  800227:	c3                   	ret    
+
+00800228 <kill>:
+
+int
+kill(int pid) {
+  800228:	55                   	push   %ebp
+  800229:	89 e5                	mov    %esp,%ebp
+  80022b:	83 ec 08             	sub    $0x8,%esp
+    return sys_kill(pid);
+  80022e:	83 ec 0c             	sub    $0xc,%esp
+  800231:	ff 75 08             	pushl  0x8(%ebp)
+  800234:	e8 17 ff ff ff       	call   800150 <sys_kill>
+  800239:	83 c4 10             	add    $0x10,%esp
+}
+  80023c:	c9                   	leave  
+  80023d:	c3                   	ret    
+
+0080023e <getpid>:
+
+int
+getpid(void) {
+  80023e:	55                   	push   %ebp
+  80023f:	89 e5                	mov    %esp,%ebp
+  800241:	83 ec 08             	sub    $0x8,%esp
+    return sys_getpid();
+  800244:	e8 19 ff ff ff       	call   800162 <sys_getpid>
+}
+  800249:	c9                   	leave  
+  80024a:	c3                   	ret    
+
+0080024b <print_pgdir>:
+
+//print_pgdir - print the PDT&PT
+void
+print_pgdir(void) {
+  80024b:	55                   	push   %ebp
+  80024c:	89 e5                	mov    %esp,%ebp
+  80024e:	83 ec 08             	sub    $0x8,%esp
+    sys_pgdir();
+  800251:	e8 2d ff ff ff       	call   800183 <sys_pgdir>
+}
+  800256:	90                   	nop
+  800257:	c9                   	leave  
+  800258:	c3                   	ret    
+
+00800259 <gettime_msec>:
+
+unsigned int
+gettime_msec(void) {
+  800259:	55                   	push   %ebp
+  80025a:	89 e5                	mov    %esp,%ebp
+  80025c:	83 ec 08             	sub    $0x8,%esp
+    return (unsigned int)sys_gettime();
+  80025f:	e8 2e ff ff ff       	call   800192 <sys_gettime>
+}
+  800264:	c9                   	leave  
+  800265:	c3                   	ret    
+
+00800266 <lab6_set_priority>:
+
+void
+lab6_set_priority(uint32_t priority)
+{
+  800266:	55                   	push   %ebp
+  800267:	89 e5                	mov    %esp,%ebp
+  800269:	83 ec 08             	sub    $0x8,%esp
+    sys_lab6_set_priority(priority);
+  80026c:	83 ec 0c             	sub    $0xc,%esp
+  80026f:	ff 75 08             	pushl  0x8(%ebp)
+  800272:	e8 2a ff ff ff       	call   8001a1 <sys_lab6_set_priority>
+  800277:	83 c4 10             	add    $0x10,%esp
+}
+  80027a:	90                   	nop
+  80027b:	c9                   	leave  
+  80027c:	c3                   	ret    
+
+0080027d <_start>:
+.text
+.globl _start
+_start:
+    # set ebp for backtrace
+    movl $0x0, %ebp
+  80027d:	bd 00 00 00 00       	mov    $0x0,%ebp
+
+    # move down the esp register
+    # since it may cause page fault in backtrace
+    subl $0x20, %esp
+  800282:	83 ec 20             	sub    $0x20,%esp
+
+    # call user-program function
+    call umain
+  800285:	e8 c3 00 00 00       	call   80034d <umain>
+1:  jmp 1b
+  80028a:	eb fe                	jmp    80028a <_start+0xd>
+
+0080028c <cputch>:
+/* *
+ * cputch - writes a single character @c to stdout, and it will
+ * increace the value of counter pointed by @cnt.
+ * */
+static void
+cputch(int c, int *cnt) {
+  80028c:	55                   	push   %ebp
+  80028d:	89 e5                	mov    %esp,%ebp
+  80028f:	83 ec 08             	sub    $0x8,%esp
+    sys_putc(c);
+  800292:	83 ec 0c             	sub    $0xc,%esp
+  800295:	ff 75 08             	pushl  0x8(%ebp)
+  800298:	e8 d4 fe ff ff       	call   800171 <sys_putc>
+  80029d:	83 c4 10             	add    $0x10,%esp
+    (*cnt) ++;
+  8002a0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002a3:	8b 00                	mov    (%eax),%eax
+  8002a5:	8d 50 01             	lea    0x1(%eax),%edx
+  8002a8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002ab:	89 10                	mov    %edx,(%eax)
+}
+  8002ad:	90                   	nop
+  8002ae:	c9                   	leave  
+  8002af:	c3                   	ret    
+
+008002b0 <vcprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want cprintf() instead.
+ * */
+int
+vcprintf(const char *fmt, va_list ap) {
+  8002b0:	55                   	push   %ebp
+  8002b1:	89 e5                	mov    %esp,%ebp
+  8002b3:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+  8002b6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    vprintfmt((void*)cputch, &cnt, fmt, ap);
+  8002bd:	ff 75 0c             	pushl  0xc(%ebp)
+  8002c0:	ff 75 08             	pushl  0x8(%ebp)
+  8002c3:	8d 45 f4             	lea    -0xc(%ebp),%eax
+  8002c6:	50                   	push   %eax
+  8002c7:	68 8c 02 80 00       	push   $0x80028c
+  8002cc:	e8 fc 06 00 00       	call   8009cd <vprintfmt>
+  8002d1:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+  8002d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8002d7:	c9                   	leave  
+  8002d8:	c3                   	ret    
+
+008002d9 <cprintf>:
+ *
+ * The return value is the number of characters which would be
+ * written to stdout.
+ * */
+int
+cprintf(const char *fmt, ...) {
+  8002d9:	55                   	push   %ebp
+  8002da:	89 e5                	mov    %esp,%ebp
+  8002dc:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  8002df:	8d 45 0c             	lea    0xc(%ebp),%eax
+  8002e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    int cnt = vcprintf(fmt, ap);
+  8002e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8002e8:	83 ec 08             	sub    $0x8,%esp
+  8002eb:	50                   	push   %eax
+  8002ec:	ff 75 08             	pushl  0x8(%ebp)
+  8002ef:	e8 bc ff ff ff       	call   8002b0 <vcprintf>
+  8002f4:	83 c4 10             	add    $0x10,%esp
+  8002f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+
+    return cnt;
+  8002fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8002fd:	c9                   	leave  
+  8002fe:	c3                   	ret    
+
+008002ff <cputs>:
+/* *
+ * cputs- writes the string pointed by @str to stdout and
+ * appends a newline character.
+ * */
+int
+cputs(const char *str) {
+  8002ff:	55                   	push   %ebp
+  800300:	89 e5                	mov    %esp,%ebp
+  800302:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+  800305:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    char c;
+    while ((c = *str ++) != '\0') {
+  80030c:	eb 14                	jmp    800322 <cputs+0x23>
+        cputch(c, &cnt);
+  80030e:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
+  800312:	83 ec 08             	sub    $0x8,%esp
+  800315:	8d 55 f0             	lea    -0x10(%ebp),%edx
+  800318:	52                   	push   %edx
+  800319:	50                   	push   %eax
+  80031a:	e8 6d ff ff ff       	call   80028c <cputch>
+  80031f:	83 c4 10             	add    $0x10,%esp
+ * */
+int
+cputs(const char *str) {
+    int cnt = 0;
+    char c;
+    while ((c = *str ++) != '\0') {
+  800322:	8b 45 08             	mov    0x8(%ebp),%eax
+  800325:	8d 50 01             	lea    0x1(%eax),%edx
+  800328:	89 55 08             	mov    %edx,0x8(%ebp)
+  80032b:	0f b6 00             	movzbl (%eax),%eax
+  80032e:	88 45 f7             	mov    %al,-0x9(%ebp)
+  800331:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
+  800335:	75 d7                	jne    80030e <cputs+0xf>
+        cputch(c, &cnt);
+    }
+    cputch('\n', &cnt);
+  800337:	83 ec 08             	sub    $0x8,%esp
+  80033a:	8d 45 f0             	lea    -0x10(%ebp),%eax
+  80033d:	50                   	push   %eax
+  80033e:	6a 0a                	push   $0xa
+  800340:	e8 47 ff ff ff       	call   80028c <cputch>
+  800345:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+  800348:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+  80034b:	c9                   	leave  
+  80034c:	c3                   	ret    
+
+0080034d <umain>:
+#include <ulib.h>
+
+int main(void);
+
+void
+umain(void) {
+  80034d:	55                   	push   %ebp
+  80034e:	89 e5                	mov    %esp,%ebp
+  800350:	83 ec 18             	sub    $0x18,%esp
+    int ret = main();
+  800353:	e8 d3 0b 00 00       	call   800f2b <main>
+  800358:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    exit(ret);
+  80035b:	83 ec 0c             	sub    $0xc,%esp
+  80035e:	ff 75 f4             	pushl  -0xc(%ebp)
+  800361:	e8 51 fe ff ff       	call   8001b7 <exit>
+
+00800366 <strlen>:
+ * @s:      the input string
+ *
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+  800366:	55                   	push   %ebp
+  800367:	89 e5                	mov    %esp,%ebp
+  800369:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  80036c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (*s ++ != '\0') {
+  800373:	eb 04                	jmp    800379 <strlen+0x13>
+        cnt ++;
+  800375:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+    size_t cnt = 0;
+    while (*s ++ != '\0') {
+  800379:	8b 45 08             	mov    0x8(%ebp),%eax
+  80037c:	8d 50 01             	lea    0x1(%eax),%edx
+  80037f:	89 55 08             	mov    %edx,0x8(%ebp)
+  800382:	0f b6 00             	movzbl (%eax),%eax
+  800385:	84 c0                	test   %al,%al
+  800387:	75 ec                	jne    800375 <strlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  800389:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  80038c:	c9                   	leave  
+  80038d:	c3                   	ret    
+
+0080038e <strnlen>:
+ * The return value is strlen(s), if that is less than @len, or
+ * @len if there is no '\0' character among the first @len characters
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+  80038e:	55                   	push   %ebp
+  80038f:	89 e5                	mov    %esp,%ebp
+  800391:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  800394:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (cnt < len && *s ++ != '\0') {
+  80039b:	eb 04                	jmp    8003a1 <strnlen+0x13>
+        cnt ++;
+  80039d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+    size_t cnt = 0;
+    while (cnt < len && *s ++ != '\0') {
+  8003a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8003a4:	3b 45 0c             	cmp    0xc(%ebp),%eax
+  8003a7:	73 10                	jae    8003b9 <strnlen+0x2b>
+  8003a9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003ac:	8d 50 01             	lea    0x1(%eax),%edx
+  8003af:	89 55 08             	mov    %edx,0x8(%ebp)
+  8003b2:	0f b6 00             	movzbl (%eax),%eax
+  8003b5:	84 c0                	test   %al,%al
+  8003b7:	75 e4                	jne    80039d <strnlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  8003b9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  8003bc:	c9                   	leave  
+  8003bd:	c3                   	ret    
+
+008003be <strcpy>:
+ * To avoid overflows, the size of array pointed by @dst should be long enough to
+ * contain the same string as @src (including the terminating null character), and
+ * should not overlap in memory with @src.
+ * */
+char *
+strcpy(char *dst, const char *src) {
+  8003be:	55                   	push   %ebp
+  8003bf:	89 e5                	mov    %esp,%ebp
+  8003c1:	57                   	push   %edi
+  8003c2:	56                   	push   %esi
+  8003c3:	83 ec 20             	sub    $0x20,%esp
+  8003c6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  8003cc:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8003cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCPY
+#define __HAVE_ARCH_STRCPY
+static inline char *
+__strcpy(char *dst, const char *src) {
+    int d0, d1, d2;
+    asm volatile (
+  8003d2:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  8003d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8003d8:	89 d1                	mov    %edx,%ecx
+  8003da:	89 c2                	mov    %eax,%edx
+  8003dc:	89 ce                	mov    %ecx,%esi
+  8003de:	89 d7                	mov    %edx,%edi
+  8003e0:	ac                   	lods   %ds:(%esi),%al
+  8003e1:	aa                   	stos   %al,%es:(%edi)
+  8003e2:	84 c0                	test   %al,%al
+  8003e4:	75 fa                	jne    8003e0 <strcpy+0x22>
+  8003e6:	89 fa                	mov    %edi,%edx
+  8003e8:	89 f1                	mov    %esi,%ecx
+  8003ea:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  8003ed:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  8003f0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+        "stosb;"
+        "testb %%al, %%al;"
+        "jne 1b;"
+        : "=&S" (d0), "=&D" (d1), "=&a" (d2)
+        : "0" (src), "1" (dst) : "memory");
+    return dst;
+  8003f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCPY
+    return __strcpy(dst, src);
+  8003f6:	90                   	nop
+    char *p = dst;
+    while ((*p ++ = *src ++) != '\0')
+        /* nothing */;
+    return dst;
+#endif /* __HAVE_ARCH_STRCPY */
+}
+  8003f7:	83 c4 20             	add    $0x20,%esp
+  8003fa:	5e                   	pop    %esi
+  8003fb:	5f                   	pop    %edi
+  8003fc:	5d                   	pop    %ebp
+  8003fd:	c3                   	ret    
+
+008003fe <strncpy>:
+ * @len:    maximum number of characters to be copied from @src
+ *
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+  8003fe:	55                   	push   %ebp
+  8003ff:	89 e5                	mov    %esp,%ebp
+  800401:	83 ec 10             	sub    $0x10,%esp
+    char *p = dst;
+  800404:	8b 45 08             	mov    0x8(%ebp),%eax
+  800407:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    while (len > 0) {
+  80040a:	eb 21                	jmp    80042d <strncpy+0x2f>
+        if ((*p = *src) != '\0') {
+  80040c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80040f:	0f b6 10             	movzbl (%eax),%edx
+  800412:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800415:	88 10                	mov    %dl,(%eax)
+  800417:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  80041a:	0f b6 00             	movzbl (%eax),%eax
+  80041d:	84 c0                	test   %al,%al
+  80041f:	74 04                	je     800425 <strncpy+0x27>
+            src ++;
+  800421:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+        }
+        p ++, len --;
+  800425:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800429:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+    char *p = dst;
+    while (len > 0) {
+  80042d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800431:	75 d9                	jne    80040c <strncpy+0xe>
+        if ((*p = *src) != '\0') {
+            src ++;
+        }
+        p ++, len --;
+    }
+    return dst;
+  800433:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800436:	c9                   	leave  
+  800437:	c3                   	ret    
+
+00800438 <strcmp>:
+ * - A value greater than zero indicates that the first character that does
+ *   not match has a greater value in @s1 than in @s2;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+strcmp(const char *s1, const char *s2) {
+  800438:	55                   	push   %ebp
+  800439:	89 e5                	mov    %esp,%ebp
+  80043b:	57                   	push   %edi
+  80043c:	56                   	push   %esi
+  80043d:	83 ec 20             	sub    $0x20,%esp
+  800440:	8b 45 08             	mov    0x8(%ebp),%eax
+  800443:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800446:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800449:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCMP
+#define __HAVE_ARCH_STRCMP
+static inline int
+__strcmp(const char *s1, const char *s2) {
+    int d0, d1, ret;
+    asm volatile (
+  80044c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80044f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800452:	89 d1                	mov    %edx,%ecx
+  800454:	89 c2                	mov    %eax,%edx
+  800456:	89 ce                	mov    %ecx,%esi
+  800458:	89 d7                	mov    %edx,%edi
+  80045a:	ac                   	lods   %ds:(%esi),%al
+  80045b:	ae                   	scas   %es:(%edi),%al
+  80045c:	75 08                	jne    800466 <strcmp+0x2e>
+  80045e:	84 c0                	test   %al,%al
+  800460:	75 f8                	jne    80045a <strcmp+0x22>
+  800462:	31 c0                	xor    %eax,%eax
+  800464:	eb 04                	jmp    80046a <strcmp+0x32>
+  800466:	19 c0                	sbb    %eax,%eax
+  800468:	0c 01                	or     $0x1,%al
+  80046a:	89 fa                	mov    %edi,%edx
+  80046c:	89 f1                	mov    %esi,%ecx
+  80046e:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800471:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  800474:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+        "orb $1, %%al;"
+        "3:"
+        : "=a" (ret), "=&S" (d0), "=&D" (d1)
+        : "1" (s1), "2" (s2)
+        : "memory");
+    return ret;
+  800477:	8b 45 ec             	mov    -0x14(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCMP
+    return __strcmp(s1, s2);
+  80047a:	90                   	nop
+    while (*s1 != '\0' && *s1 == *s2) {
+        s1 ++, s2 ++;
+    }
+    return (int)((unsigned char)*s1 - (unsigned char)*s2);
+#endif /* __HAVE_ARCH_STRCMP */
+}
+  80047b:	83 c4 20             	add    $0x20,%esp
+  80047e:	5e                   	pop    %esi
+  80047f:	5f                   	pop    %edi
+  800480:	5d                   	pop    %ebp
+  800481:	c3                   	ret    
+
+00800482 <strncmp>:
+ * they are equal to each other, it continues with the following pairs until
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+  800482:	55                   	push   %ebp
+  800483:	89 e5                	mov    %esp,%ebp
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  800485:	eb 0c                	jmp    800493 <strncmp+0x11>
+        n --, s1 ++, s2 ++;
+  800487:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  80048b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  80048f:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  800493:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800497:	74 1a                	je     8004b3 <strncmp+0x31>
+  800499:	8b 45 08             	mov    0x8(%ebp),%eax
+  80049c:	0f b6 00             	movzbl (%eax),%eax
+  80049f:	84 c0                	test   %al,%al
+  8004a1:	74 10                	je     8004b3 <strncmp+0x31>
+  8004a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004a6:	0f b6 10             	movzbl (%eax),%edx
+  8004a9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004ac:	0f b6 00             	movzbl (%eax),%eax
+  8004af:	38 c2                	cmp    %al,%dl
+  8004b1:	74 d4                	je     800487 <strncmp+0x5>
+        n --, s1 ++, s2 ++;
+    }
+    return (n == 0) ? 0 : (int)((unsigned char)*s1 - (unsigned char)*s2);
+  8004b3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8004b7:	74 18                	je     8004d1 <strncmp+0x4f>
+  8004b9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004bc:	0f b6 00             	movzbl (%eax),%eax
+  8004bf:	0f b6 d0             	movzbl %al,%edx
+  8004c2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004c5:	0f b6 00             	movzbl (%eax),%eax
+  8004c8:	0f b6 c0             	movzbl %al,%eax
+  8004cb:	29 c2                	sub    %eax,%edx
+  8004cd:	89 d0                	mov    %edx,%eax
+  8004cf:	eb 05                	jmp    8004d6 <strncmp+0x54>
+  8004d1:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  8004d6:	5d                   	pop    %ebp
+  8004d7:	c3                   	ret    
+
+008004d8 <strchr>:
+ *
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+  8004d8:	55                   	push   %ebp
+  8004d9:	89 e5                	mov    %esp,%ebp
+  8004db:	83 ec 04             	sub    $0x4,%esp
+  8004de:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004e1:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  8004e4:	eb 14                	jmp    8004fa <strchr+0x22>
+        if (*s == c) {
+  8004e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004e9:	0f b6 00             	movzbl (%eax),%eax
+  8004ec:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  8004ef:	75 05                	jne    8004f6 <strchr+0x1e>
+            return (char *)s;
+  8004f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004f4:	eb 13                	jmp    800509 <strchr+0x31>
+        }
+        s ++;
+  8004f6:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+    while (*s != '\0') {
+  8004fa:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004fd:	0f b6 00             	movzbl (%eax),%eax
+  800500:	84 c0                	test   %al,%al
+  800502:	75 e2                	jne    8004e6 <strchr+0xe>
+        if (*s == c) {
+            return (char *)s;
+        }
+        s ++;
+    }
+    return NULL;
+  800504:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800509:	c9                   	leave  
+  80050a:	c3                   	ret    
+
+0080050b <strfind>:
+ * The strfind() function is like strchr() except that if @c is
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+  80050b:	55                   	push   %ebp
+  80050c:	89 e5                	mov    %esp,%ebp
+  80050e:	83 ec 04             	sub    $0x4,%esp
+  800511:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800514:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  800517:	eb 0f                	jmp    800528 <strfind+0x1d>
+        if (*s == c) {
+  800519:	8b 45 08             	mov    0x8(%ebp),%eax
+  80051c:	0f b6 00             	movzbl (%eax),%eax
+  80051f:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800522:	74 10                	je     800534 <strfind+0x29>
+            break;
+        }
+        s ++;
+  800524:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+    while (*s != '\0') {
+  800528:	8b 45 08             	mov    0x8(%ebp),%eax
+  80052b:	0f b6 00             	movzbl (%eax),%eax
+  80052e:	84 c0                	test   %al,%al
+  800530:	75 e7                	jne    800519 <strfind+0xe>
+  800532:	eb 01                	jmp    800535 <strfind+0x2a>
+        if (*s == c) {
+            break;
+  800534:	90                   	nop
+        }
+        s ++;
+    }
+    return (char *)s;
+  800535:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800538:	c9                   	leave  
+  800539:	c3                   	ret    
+
+0080053a <strtol>:
+ * an optional "0x" or "0X" prefix.
+ *
+ * The strtol() function returns the converted integral number as a long int value.
+ * */
+long
+strtol(const char *s, char **endptr, int base) {
+  80053a:	55                   	push   %ebp
+  80053b:	89 e5                	mov    %esp,%ebp
+  80053d:	83 ec 10             	sub    $0x10,%esp
+    int neg = 0;
+  800540:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    long val = 0;
+  800547:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  80054e:	eb 04                	jmp    800554 <strtol+0x1a>
+        s ++;
+  800550:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+strtol(const char *s, char **endptr, int base) {
+    int neg = 0;
+    long val = 0;
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  800554:	8b 45 08             	mov    0x8(%ebp),%eax
+  800557:	0f b6 00             	movzbl (%eax),%eax
+  80055a:	3c 20                	cmp    $0x20,%al
+  80055c:	74 f2                	je     800550 <strtol+0x16>
+  80055e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800561:	0f b6 00             	movzbl (%eax),%eax
+  800564:	3c 09                	cmp    $0x9,%al
+  800566:	74 e8                	je     800550 <strtol+0x16>
+        s ++;
+    }
+
+    // plus/minus sign
+    if (*s == '+') {
+  800568:	8b 45 08             	mov    0x8(%ebp),%eax
+  80056b:	0f b6 00             	movzbl (%eax),%eax
+  80056e:	3c 2b                	cmp    $0x2b,%al
+  800570:	75 06                	jne    800578 <strtol+0x3e>
+        s ++;
+  800572:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800576:	eb 15                	jmp    80058d <strtol+0x53>
+    }
+    else if (*s == '-') {
+  800578:	8b 45 08             	mov    0x8(%ebp),%eax
+  80057b:	0f b6 00             	movzbl (%eax),%eax
+  80057e:	3c 2d                	cmp    $0x2d,%al
+  800580:	75 0b                	jne    80058d <strtol+0x53>
+        s ++, neg = 1;
+  800582:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800586:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+    }
+
+    // hex or octal base prefix
+    if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x')) {
+  80058d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800591:	74 06                	je     800599 <strtol+0x5f>
+  800593:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+  800597:	75 24                	jne    8005bd <strtol+0x83>
+  800599:	8b 45 08             	mov    0x8(%ebp),%eax
+  80059c:	0f b6 00             	movzbl (%eax),%eax
+  80059f:	3c 30                	cmp    $0x30,%al
+  8005a1:	75 1a                	jne    8005bd <strtol+0x83>
+  8005a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005a6:	83 c0 01             	add    $0x1,%eax
+  8005a9:	0f b6 00             	movzbl (%eax),%eax
+  8005ac:	3c 78                	cmp    $0x78,%al
+  8005ae:	75 0d                	jne    8005bd <strtol+0x83>
+        s += 2, base = 16;
+  8005b0:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+  8005b4:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+  8005bb:	eb 2a                	jmp    8005e7 <strtol+0xad>
+    }
+    else if (base == 0 && s[0] == '0') {
+  8005bd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8005c1:	75 17                	jne    8005da <strtol+0xa0>
+  8005c3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005c6:	0f b6 00             	movzbl (%eax),%eax
+  8005c9:	3c 30                	cmp    $0x30,%al
+  8005cb:	75 0d                	jne    8005da <strtol+0xa0>
+        s ++, base = 8;
+  8005cd:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  8005d1:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+  8005d8:	eb 0d                	jmp    8005e7 <strtol+0xad>
+    }
+    else if (base == 0) {
+  8005da:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8005de:	75 07                	jne    8005e7 <strtol+0xad>
+        base = 10;
+  8005e0:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+    // digits
+    while (1) {
+        int dig;
+
+        if (*s >= '0' && *s <= '9') {
+  8005e7:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005ea:	0f b6 00             	movzbl (%eax),%eax
+  8005ed:	3c 2f                	cmp    $0x2f,%al
+  8005ef:	7e 1b                	jle    80060c <strtol+0xd2>
+  8005f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005f4:	0f b6 00             	movzbl (%eax),%eax
+  8005f7:	3c 39                	cmp    $0x39,%al
+  8005f9:	7f 11                	jg     80060c <strtol+0xd2>
+            dig = *s - '0';
+  8005fb:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005fe:	0f b6 00             	movzbl (%eax),%eax
+  800601:	0f be c0             	movsbl %al,%eax
+  800604:	83 e8 30             	sub    $0x30,%eax
+  800607:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80060a:	eb 48                	jmp    800654 <strtol+0x11a>
+        }
+        else if (*s >= 'a' && *s <= 'z') {
+  80060c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80060f:	0f b6 00             	movzbl (%eax),%eax
+  800612:	3c 60                	cmp    $0x60,%al
+  800614:	7e 1b                	jle    800631 <strtol+0xf7>
+  800616:	8b 45 08             	mov    0x8(%ebp),%eax
+  800619:	0f b6 00             	movzbl (%eax),%eax
+  80061c:	3c 7a                	cmp    $0x7a,%al
+  80061e:	7f 11                	jg     800631 <strtol+0xf7>
+            dig = *s - 'a' + 10;
+  800620:	8b 45 08             	mov    0x8(%ebp),%eax
+  800623:	0f b6 00             	movzbl (%eax),%eax
+  800626:	0f be c0             	movsbl %al,%eax
+  800629:	83 e8 57             	sub    $0x57,%eax
+  80062c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80062f:	eb 23                	jmp    800654 <strtol+0x11a>
+        }
+        else if (*s >= 'A' && *s <= 'Z') {
+  800631:	8b 45 08             	mov    0x8(%ebp),%eax
+  800634:	0f b6 00             	movzbl (%eax),%eax
+  800637:	3c 40                	cmp    $0x40,%al
+  800639:	7e 3c                	jle    800677 <strtol+0x13d>
+  80063b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80063e:	0f b6 00             	movzbl (%eax),%eax
+  800641:	3c 5a                	cmp    $0x5a,%al
+  800643:	7f 32                	jg     800677 <strtol+0x13d>
+            dig = *s - 'A' + 10;
+  800645:	8b 45 08             	mov    0x8(%ebp),%eax
+  800648:	0f b6 00             	movzbl (%eax),%eax
+  80064b:	0f be c0             	movsbl %al,%eax
+  80064e:	83 e8 37             	sub    $0x37,%eax
+  800651:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+  800654:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800657:	3b 45 10             	cmp    0x10(%ebp),%eax
+  80065a:	7d 1a                	jge    800676 <strtol+0x13c>
+            break;
+        }
+        s ++, val = (val * base) + dig;
+  80065c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800660:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800663:	0f af 45 10          	imul   0x10(%ebp),%eax
+  800667:	89 c2                	mov    %eax,%edx
+  800669:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  80066c:	01 d0                	add    %edx,%eax
+  80066e:	89 45 f8             	mov    %eax,-0x8(%ebp)
+        // we don't properly detect overflow!
+    }
+  800671:	e9 71 ff ff ff       	jmp    8005e7 <strtol+0xad>
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+            break;
+  800676:	90                   	nop
+        }
+        s ++, val = (val * base) + dig;
+        // we don't properly detect overflow!
+    }
+
+    if (endptr) {
+  800677:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  80067b:	74 08                	je     800685 <strtol+0x14b>
+        *endptr = (char *) s;
+  80067d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800680:	8b 55 08             	mov    0x8(%ebp),%edx
+  800683:	89 10                	mov    %edx,(%eax)
+    }
+    return (neg ? -val : val);
+  800685:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+  800689:	74 07                	je     800692 <strtol+0x158>
+  80068b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  80068e:	f7 d8                	neg    %eax
+  800690:	eb 03                	jmp    800695 <strtol+0x15b>
+  800692:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  800695:	c9                   	leave  
+  800696:	c3                   	ret    
+
+00800697 <memset>:
+ * @n:      number of bytes to be set to the value
+ *
+ * The memset() function returns @s.
+ * */
+void *
+memset(void *s, char c, size_t n) {
+  800697:	55                   	push   %ebp
+  800698:	89 e5                	mov    %esp,%ebp
+  80069a:	57                   	push   %edi
+  80069b:	83 ec 24             	sub    $0x24,%esp
+  80069e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006a1:	88 45 d8             	mov    %al,-0x28(%ebp)
+#ifdef __HAVE_ARCH_MEMSET
+    return __memset(s, c, n);
+  8006a4:	0f be 45 d8          	movsbl -0x28(%ebp),%eax
+  8006a8:	8b 55 08             	mov    0x8(%ebp),%edx
+  8006ab:	89 55 f8             	mov    %edx,-0x8(%ebp)
+  8006ae:	88 45 f7             	mov    %al,-0x9(%ebp)
+  8006b1:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_MEMSET
+#define __HAVE_ARCH_MEMSET
+static inline void *
+__memset(void *s, char c, size_t n) {
+    int d0, d1;
+    asm volatile (
+  8006b7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+  8006ba:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
+  8006be:	8b 55 f8             	mov    -0x8(%ebp),%edx
+  8006c1:	89 d7                	mov    %edx,%edi
+  8006c3:	f3 aa                	rep stos %al,%es:(%edi)
+  8006c5:	89 fa                	mov    %edi,%edx
+  8006c7:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  8006ca:	89 55 e8             	mov    %edx,-0x18(%ebp)
+        "rep; stosb;"
+        : "=&c" (d0), "=&D" (d1)
+        : "0" (n), "a" (c), "1" (s)
+        : "memory");
+    return s;
+  8006cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8006d0:	90                   	nop
+    while (n -- > 0) {
+        *p ++ = c;
+    }
+    return s;
+#endif /* __HAVE_ARCH_MEMSET */
+}
+  8006d1:	83 c4 24             	add    $0x24,%esp
+  8006d4:	5f                   	pop    %edi
+  8006d5:	5d                   	pop    %ebp
+  8006d6:	c3                   	ret    
+
+008006d7 <memmove>:
+ * @n:      number of bytes to copy
+ *
+ * The memmove() function returns @dst.
+ * */
+void *
+memmove(void *dst, const void *src, size_t n) {
+  8006d7:	55                   	push   %ebp
+  8006d8:	89 e5                	mov    %esp,%ebp
+  8006da:	57                   	push   %edi
+  8006db:	56                   	push   %esi
+  8006dc:	53                   	push   %ebx
+  8006dd:	83 ec 30             	sub    $0x30,%esp
+  8006e0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8006e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8006e6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  8006ec:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006ef:	89 45 e8             	mov    %eax,-0x18(%ebp)
+
+#ifndef __HAVE_ARCH_MEMMOVE
+#define __HAVE_ARCH_MEMMOVE
+static inline void *
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+  8006f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006f5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  8006f8:	73 42                	jae    80073c <memmove+0x65>
+  8006fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006fd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800700:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800703:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800706:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800709:	89 45 dc             	mov    %eax,-0x24(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  80070c:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  80070f:	c1 e8 02             	shr    $0x2,%eax
+  800712:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  800714:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800717:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80071a:	89 d7                	mov    %edx,%edi
+  80071c:	89 c6                	mov    %eax,%esi
+  80071e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800720:	8b 4d dc             	mov    -0x24(%ebp),%ecx
+  800723:	83 e1 03             	and    $0x3,%ecx
+  800726:	74 02                	je     80072a <memmove+0x53>
+  800728:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  80072a:	89 f0                	mov    %esi,%eax
+  80072c:	89 fa                	mov    %edi,%edx
+  80072e:	89 4d d8             	mov    %ecx,-0x28(%ebp)
+  800731:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  800734:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  800737:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMMOVE
+    return __memmove(dst, src, n);
+  80073a:	eb 36                	jmp    800772 <memmove+0x9b>
+    asm volatile (
+        "std;"
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+  80073c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80073f:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800742:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800745:	01 c2                	add    %eax,%edx
+  800747:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80074a:	8d 48 ff             	lea    -0x1(%eax),%ecx
+  80074d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800750:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+        return __memcpy(dst, src, n);
+    }
+    int d0, d1, d2;
+    asm volatile (
+  800753:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800756:	89 c1                	mov    %eax,%ecx
+  800758:	89 d8                	mov    %ebx,%eax
+  80075a:	89 d6                	mov    %edx,%esi
+  80075c:	89 c7                	mov    %eax,%edi
+  80075e:	fd                   	std    
+  80075f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  800761:	fc                   	cld    
+  800762:	89 f8                	mov    %edi,%eax
+  800764:	89 f2                	mov    %esi,%edx
+  800766:	89 4d cc             	mov    %ecx,-0x34(%ebp)
+  800769:	89 55 c8             	mov    %edx,-0x38(%ebp)
+  80076c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+        : "memory");
+    return dst;
+  80076f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+            *d ++ = *s ++;
+        }
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMMOVE */
+}
+  800772:	83 c4 30             	add    $0x30,%esp
+  800775:	5b                   	pop    %ebx
+  800776:	5e                   	pop    %esi
+  800777:	5f                   	pop    %edi
+  800778:	5d                   	pop    %ebp
+  800779:	c3                   	ret    
+
+0080077a <memcpy>:
+ * it always copies exactly @n bytes. To avoid overflows, the size of arrays pointed
+ * by both @src and @dst, should be at least @n bytes, and should not overlap
+ * (for overlapping memory area, memmove is a safer approach).
+ * */
+void *
+memcpy(void *dst, const void *src, size_t n) {
+  80077a:	55                   	push   %ebp
+  80077b:	89 e5                	mov    %esp,%ebp
+  80077d:	57                   	push   %edi
+  80077e:	56                   	push   %esi
+  80077f:	83 ec 20             	sub    $0x20,%esp
+  800782:	8b 45 08             	mov    0x8(%ebp),%eax
+  800785:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800788:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80078b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80078e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800791:	89 45 ec             	mov    %eax,-0x14(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  800794:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800797:	c1 e8 02             	shr    $0x2,%eax
+  80079a:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  80079c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80079f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8007a2:	89 d7                	mov    %edx,%edi
+  8007a4:	89 c6                	mov    %eax,%esi
+  8007a6:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  8007a8:	8b 4d ec             	mov    -0x14(%ebp),%ecx
+  8007ab:	83 e1 03             	and    $0x3,%ecx
+  8007ae:	74 02                	je     8007b2 <memcpy+0x38>
+  8007b0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  8007b2:	89 f0                	mov    %esi,%eax
+  8007b4:	89 fa                	mov    %edi,%edx
+  8007b6:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  8007b9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  8007bc:	89 45 e0             	mov    %eax,-0x20(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  8007bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMCPY
+    return __memcpy(dst, src, n);
+  8007c2:	90                   	nop
+    while (n -- > 0) {
+        *d ++ = *s ++;
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMCPY */
+}
+  8007c3:	83 c4 20             	add    $0x20,%esp
+  8007c6:	5e                   	pop    %esi
+  8007c7:	5f                   	pop    %edi
+  8007c8:	5d                   	pop    %ebp
+  8007c9:	c3                   	ret    
+
+008007ca <memcmp>:
+ *   match in both memory blocks has a greater value in @v1 than in @v2
+ *   as if evaluated as unsigned char values;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+  8007ca:	55                   	push   %ebp
+  8007cb:	89 e5                	mov    %esp,%ebp
+  8007cd:	83 ec 10             	sub    $0x10,%esp
+    const char *s1 = (const char *)v1;
+  8007d0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8007d3:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    const char *s2 = (const char *)v2;
+  8007d6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8007d9:	89 45 f8             	mov    %eax,-0x8(%ebp)
+    while (n -- > 0) {
+  8007dc:	eb 30                	jmp    80080e <memcmp+0x44>
+        if (*s1 != *s2) {
+  8007de:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8007e1:	0f b6 10             	movzbl (%eax),%edx
+  8007e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8007e7:	0f b6 00             	movzbl (%eax),%eax
+  8007ea:	38 c2                	cmp    %al,%dl
+  8007ec:	74 18                	je     800806 <memcmp+0x3c>
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+  8007ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8007f1:	0f b6 00             	movzbl (%eax),%eax
+  8007f4:	0f b6 d0             	movzbl %al,%edx
+  8007f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8007fa:	0f b6 00             	movzbl (%eax),%eax
+  8007fd:	0f b6 c0             	movzbl %al,%eax
+  800800:	29 c2                	sub    %eax,%edx
+  800802:	89 d0                	mov    %edx,%eax
+  800804:	eb 1a                	jmp    800820 <memcmp+0x56>
+        }
+        s1 ++, s2 ++;
+  800806:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  80080a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+    const char *s1 = (const char *)v1;
+    const char *s2 = (const char *)v2;
+    while (n -- > 0) {
+  80080e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800811:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800814:	89 55 10             	mov    %edx,0x10(%ebp)
+  800817:	85 c0                	test   %eax,%eax
+  800819:	75 c3                	jne    8007de <memcmp+0x14>
+        if (*s1 != *s2) {
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+        }
+        s1 ++, s2 ++;
+    }
+    return 0;
+  80081b:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800820:	c9                   	leave  
+  800821:	c3                   	ret    
+
+00800822 <printnum>:
+ * @width:      maximum number of digits, if the actual width is less than @width, use @padc instead
+ * @padc:       character that padded on the left if the actual width is less than @width
+ * */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+        unsigned long long num, unsigned base, int width, int padc) {
+  800822:	55                   	push   %ebp
+  800823:	89 e5                	mov    %esp,%ebp
+  800825:	83 ec 38             	sub    $0x38,%esp
+  800828:	8b 45 10             	mov    0x10(%ebp),%eax
+  80082b:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  80082e:	8b 45 14             	mov    0x14(%ebp),%eax
+  800831:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+    unsigned long long result = num;
+  800834:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  800837:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  80083a:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  80083d:	89 55 ec             	mov    %edx,-0x14(%ebp)
+    unsigned mod = do_div(result, base);
+  800840:	8b 45 18             	mov    0x18(%ebp),%eax
+  800843:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800846:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800849:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  80084c:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  80084f:	89 55 f0             	mov    %edx,-0x10(%ebp)
+  800852:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800855:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800858:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  80085c:	74 1c                	je     80087a <printnum+0x58>
+  80085e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800861:	ba 00 00 00 00       	mov    $0x0,%edx
+  800866:	f7 75 e4             	divl   -0x1c(%ebp)
+  800869:	89 55 f4             	mov    %edx,-0xc(%ebp)
+  80086c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  80086f:	ba 00 00 00 00       	mov    $0x0,%edx
+  800874:	f7 75 e4             	divl   -0x1c(%ebp)
+  800877:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80087a:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80087d:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800880:	f7 75 e4             	divl   -0x1c(%ebp)
+  800883:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800886:	89 55 dc             	mov    %edx,-0x24(%ebp)
+  800889:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80088c:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  80088f:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800892:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  800895:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  800898:	89 45 d8             	mov    %eax,-0x28(%ebp)
+
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+  80089b:	8b 45 18             	mov    0x18(%ebp),%eax
+  80089e:	ba 00 00 00 00       	mov    $0x0,%edx
+  8008a3:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  8008a6:	77 41                	ja     8008e9 <printnum+0xc7>
+  8008a8:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  8008ab:	72 05                	jb     8008b2 <printnum+0x90>
+  8008ad:	3b 45 d0             	cmp    -0x30(%ebp),%eax
+  8008b0:	77 37                	ja     8008e9 <printnum+0xc7>
+        printnum(putch, putdat, result, base, width - 1, padc);
+  8008b2:	8b 45 1c             	mov    0x1c(%ebp),%eax
+  8008b5:	83 e8 01             	sub    $0x1,%eax
+  8008b8:	83 ec 04             	sub    $0x4,%esp
+  8008bb:	ff 75 20             	pushl  0x20(%ebp)
+  8008be:	50                   	push   %eax
+  8008bf:	ff 75 18             	pushl  0x18(%ebp)
+  8008c2:	ff 75 ec             	pushl  -0x14(%ebp)
+  8008c5:	ff 75 e8             	pushl  -0x18(%ebp)
+  8008c8:	ff 75 0c             	pushl  0xc(%ebp)
+  8008cb:	ff 75 08             	pushl  0x8(%ebp)
+  8008ce:	e8 4f ff ff ff       	call   800822 <printnum>
+  8008d3:	83 c4 20             	add    $0x20,%esp
+  8008d6:	eb 1b                	jmp    8008f3 <printnum+0xd1>
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+            putch(padc, putdat);
+  8008d8:	83 ec 08             	sub    $0x8,%esp
+  8008db:	ff 75 0c             	pushl  0xc(%ebp)
+  8008de:	ff 75 20             	pushl  0x20(%ebp)
+  8008e1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8008e4:	ff d0                	call   *%eax
+  8008e6:	83 c4 10             	add    $0x10,%esp
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+        printnum(putch, putdat, result, base, width - 1, padc);
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+  8008e9:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+  8008ed:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+  8008f1:	7f e5                	jg     8008d8 <printnum+0xb6>
+            putch(padc, putdat);
+    }
+    // then print this (the least significant) digit
+    putch("0123456789abcdef"[mod], putdat);
+  8008f3:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  8008f6:	05 e4 10 80 00       	add    $0x8010e4,%eax
+  8008fb:	0f b6 00             	movzbl (%eax),%eax
+  8008fe:	0f be c0             	movsbl %al,%eax
+  800901:	83 ec 08             	sub    $0x8,%esp
+  800904:	ff 75 0c             	pushl  0xc(%ebp)
+  800907:	50                   	push   %eax
+  800908:	8b 45 08             	mov    0x8(%ebp),%eax
+  80090b:	ff d0                	call   *%eax
+  80090d:	83 c4 10             	add    $0x10,%esp
+}
+  800910:	90                   	nop
+  800911:	c9                   	leave  
+  800912:	c3                   	ret    
+
+00800913 <getuint>:
+ * getuint - get an unsigned int of various possible sizes from a varargs list
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static unsigned long long
+getuint(va_list *ap, int lflag) {
+  800913:	55                   	push   %ebp
+  800914:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  800916:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  80091a:	7e 14                	jle    800930 <getuint+0x1d>
+        return va_arg(*ap, unsigned long long);
+  80091c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80091f:	8b 00                	mov    (%eax),%eax
+  800921:	8d 48 08             	lea    0x8(%eax),%ecx
+  800924:	8b 55 08             	mov    0x8(%ebp),%edx
+  800927:	89 0a                	mov    %ecx,(%edx)
+  800929:	8b 50 04             	mov    0x4(%eax),%edx
+  80092c:	8b 00                	mov    (%eax),%eax
+  80092e:	eb 30                	jmp    800960 <getuint+0x4d>
+    }
+    else if (lflag) {
+  800930:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800934:	74 16                	je     80094c <getuint+0x39>
+        return va_arg(*ap, unsigned long);
+  800936:	8b 45 08             	mov    0x8(%ebp),%eax
+  800939:	8b 00                	mov    (%eax),%eax
+  80093b:	8d 48 04             	lea    0x4(%eax),%ecx
+  80093e:	8b 55 08             	mov    0x8(%ebp),%edx
+  800941:	89 0a                	mov    %ecx,(%edx)
+  800943:	8b 00                	mov    (%eax),%eax
+  800945:	ba 00 00 00 00       	mov    $0x0,%edx
+  80094a:	eb 14                	jmp    800960 <getuint+0x4d>
+    }
+    else {
+        return va_arg(*ap, unsigned int);
+  80094c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80094f:	8b 00                	mov    (%eax),%eax
+  800951:	8d 48 04             	lea    0x4(%eax),%ecx
+  800954:	8b 55 08             	mov    0x8(%ebp),%edx
+  800957:	89 0a                	mov    %ecx,(%edx)
+  800959:	8b 00                	mov    (%eax),%eax
+  80095b:	ba 00 00 00 00       	mov    $0x0,%edx
+    }
+}
+  800960:	5d                   	pop    %ebp
+  800961:	c3                   	ret    
+
+00800962 <getint>:
+ * getint - same as getuint but signed, we can't use getuint because of sign extension
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static long long
+getint(va_list *ap, int lflag) {
+  800962:	55                   	push   %ebp
+  800963:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  800965:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  800969:	7e 14                	jle    80097f <getint+0x1d>
+        return va_arg(*ap, long long);
+  80096b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80096e:	8b 00                	mov    (%eax),%eax
+  800970:	8d 48 08             	lea    0x8(%eax),%ecx
+  800973:	8b 55 08             	mov    0x8(%ebp),%edx
+  800976:	89 0a                	mov    %ecx,(%edx)
+  800978:	8b 50 04             	mov    0x4(%eax),%edx
+  80097b:	8b 00                	mov    (%eax),%eax
+  80097d:	eb 28                	jmp    8009a7 <getint+0x45>
+    }
+    else if (lflag) {
+  80097f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800983:	74 12                	je     800997 <getint+0x35>
+        return va_arg(*ap, long);
+  800985:	8b 45 08             	mov    0x8(%ebp),%eax
+  800988:	8b 00                	mov    (%eax),%eax
+  80098a:	8d 48 04             	lea    0x4(%eax),%ecx
+  80098d:	8b 55 08             	mov    0x8(%ebp),%edx
+  800990:	89 0a                	mov    %ecx,(%edx)
+  800992:	8b 00                	mov    (%eax),%eax
+  800994:	99                   	cltd   
+  800995:	eb 10                	jmp    8009a7 <getint+0x45>
+    }
+    else {
+        return va_arg(*ap, int);
+  800997:	8b 45 08             	mov    0x8(%ebp),%eax
+  80099a:	8b 00                	mov    (%eax),%eax
+  80099c:	8d 48 04             	lea    0x4(%eax),%ecx
+  80099f:	8b 55 08             	mov    0x8(%ebp),%edx
+  8009a2:	89 0a                	mov    %ecx,(%edx)
+  8009a4:	8b 00                	mov    (%eax),%eax
+  8009a6:	99                   	cltd   
+    }
+}
+  8009a7:	5d                   	pop    %ebp
+  8009a8:	c3                   	ret    
+
+008009a9 <printfmt>:
+ * @putch:      specified putch function, print a single character
+ * @putdat:     used by @putch function
+ * @fmt:        the format string to use
+ * */
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...) {
+  8009a9:	55                   	push   %ebp
+  8009aa:	89 e5                	mov    %esp,%ebp
+  8009ac:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  8009af:	8d 45 14             	lea    0x14(%ebp),%eax
+  8009b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    vprintfmt(putch, putdat, fmt, ap);
+  8009b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8009b8:	50                   	push   %eax
+  8009b9:	ff 75 10             	pushl  0x10(%ebp)
+  8009bc:	ff 75 0c             	pushl  0xc(%ebp)
+  8009bf:	ff 75 08             	pushl  0x8(%ebp)
+  8009c2:	e8 06 00 00 00       	call   8009cd <vprintfmt>
+  8009c7:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+  8009ca:	90                   	nop
+  8009cb:	c9                   	leave  
+  8009cc:	c3                   	ret    
+
+008009cd <vprintfmt>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want printfmt() instead.
+ * */
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap) {
+  8009cd:	55                   	push   %ebp
+  8009ce:	89 e5                	mov    %esp,%ebp
+  8009d0:	56                   	push   %esi
+  8009d1:	53                   	push   %ebx
+  8009d2:	83 ec 20             	sub    $0x20,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  8009d5:	eb 17                	jmp    8009ee <vprintfmt+0x21>
+            if (ch == '\0') {
+  8009d7:	85 db                	test   %ebx,%ebx
+  8009d9:	0f 84 8e 03 00 00    	je     800d6d <vprintfmt+0x3a0>
+                return;
+            }
+            putch(ch, putdat);
+  8009df:	83 ec 08             	sub    $0x8,%esp
+  8009e2:	ff 75 0c             	pushl  0xc(%ebp)
+  8009e5:	53                   	push   %ebx
+  8009e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009e9:	ff d0                	call   *%eax
+  8009eb:	83 c4 10             	add    $0x10,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  8009ee:	8b 45 10             	mov    0x10(%ebp),%eax
+  8009f1:	8d 50 01             	lea    0x1(%eax),%edx
+  8009f4:	89 55 10             	mov    %edx,0x10(%ebp)
+  8009f7:	0f b6 00             	movzbl (%eax),%eax
+  8009fa:	0f b6 d8             	movzbl %al,%ebx
+  8009fd:	83 fb 25             	cmp    $0x25,%ebx
+  800a00:	75 d5                	jne    8009d7 <vprintfmt+0xa>
+            }
+            putch(ch, putdat);
+        }
+
+        // Process a %-escape sequence
+        char padc = ' ';
+  800a02:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+        width = precision = -1;
+  800a06:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+  800a0d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800a10:	89 45 e8             	mov    %eax,-0x18(%ebp)
+        lflag = altflag = 0;
+  800a13:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+  800a1a:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  800a1d:	89 45 e0             	mov    %eax,-0x20(%ebp)
+
+    reswitch:
+        switch (ch = *(unsigned char *)fmt ++) {
+  800a20:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a23:	8d 50 01             	lea    0x1(%eax),%edx
+  800a26:	89 55 10             	mov    %edx,0x10(%ebp)
+  800a29:	0f b6 00             	movzbl (%eax),%eax
+  800a2c:	0f b6 d8             	movzbl %al,%ebx
+  800a2f:	8d 43 dd             	lea    -0x23(%ebx),%eax
+  800a32:	83 f8 55             	cmp    $0x55,%eax
+  800a35:	0f 87 05 03 00 00    	ja     800d40 <vprintfmt+0x373>
+  800a3b:	8b 04 85 08 11 80 00 	mov    0x801108(,%eax,4),%eax
+  800a42:	ff e0                	jmp    *%eax
+
+        // flag to pad on the right
+        case '-':
+            padc = '-';
+  800a44:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+            goto reswitch;
+  800a48:	eb d6                	jmp    800a20 <vprintfmt+0x53>
+
+        // flag to pad with 0's instead of spaces
+        case '0':
+            padc = '0';
+  800a4a:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+            goto reswitch;
+  800a4e:	eb d0                	jmp    800a20 <vprintfmt+0x53>
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  800a50:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+                precision = precision * 10 + ch - '0';
+  800a57:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800a5a:	89 d0                	mov    %edx,%eax
+  800a5c:	c1 e0 02             	shl    $0x2,%eax
+  800a5f:	01 d0                	add    %edx,%eax
+  800a61:	01 c0                	add    %eax,%eax
+  800a63:	01 d8                	add    %ebx,%eax
+  800a65:	83 e8 30             	sub    $0x30,%eax
+  800a68:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+                ch = *fmt;
+  800a6b:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a6e:	0f b6 00             	movzbl (%eax),%eax
+  800a71:	0f be d8             	movsbl %al,%ebx
+                if (ch < '0' || ch > '9') {
+  800a74:	83 fb 2f             	cmp    $0x2f,%ebx
+  800a77:	7e 39                	jle    800ab2 <vprintfmt+0xe5>
+  800a79:	83 fb 39             	cmp    $0x39,%ebx
+  800a7c:	7f 34                	jg     800ab2 <vprintfmt+0xe5>
+            padc = '0';
+            goto reswitch;
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  800a7e:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+                precision = precision * 10 + ch - '0';
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+  800a82:	eb d3                	jmp    800a57 <vprintfmt+0x8a>
+            goto process_precision;
+
+        case '*':
+            precision = va_arg(ap, int);
+  800a84:	8b 45 14             	mov    0x14(%ebp),%eax
+  800a87:	8d 50 04             	lea    0x4(%eax),%edx
+  800a8a:	89 55 14             	mov    %edx,0x14(%ebp)
+  800a8d:	8b 00                	mov    (%eax),%eax
+  800a8f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+            goto process_precision;
+  800a92:	eb 1f                	jmp    800ab3 <vprintfmt+0xe6>
+
+        case '.':
+            if (width < 0)
+  800a94:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800a98:	79 86                	jns    800a20 <vprintfmt+0x53>
+                width = 0;
+  800a9a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+            goto reswitch;
+  800aa1:	e9 7a ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        case '#':
+            altflag = 1;
+  800aa6:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+            goto reswitch;
+  800aad:	e9 6e ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+            goto process_precision;
+  800ab2:	90                   	nop
+        case '#':
+            altflag = 1;
+            goto reswitch;
+
+        process_precision:
+            if (width < 0)
+  800ab3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ab7:	0f 89 63 ff ff ff    	jns    800a20 <vprintfmt+0x53>
+                width = precision, precision = -1;
+  800abd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800ac0:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800ac3:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+            goto reswitch;
+  800aca:	e9 51 ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        // long flag (doubled for long long)
+        case 'l':
+            lflag ++;
+  800acf:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
+            goto reswitch;
+  800ad3:	e9 48 ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        // character
+        case 'c':
+            putch(va_arg(ap, int), putdat);
+  800ad8:	8b 45 14             	mov    0x14(%ebp),%eax
+  800adb:	8d 50 04             	lea    0x4(%eax),%edx
+  800ade:	89 55 14             	mov    %edx,0x14(%ebp)
+  800ae1:	8b 00                	mov    (%eax),%eax
+  800ae3:	83 ec 08             	sub    $0x8,%esp
+  800ae6:	ff 75 0c             	pushl  0xc(%ebp)
+  800ae9:	50                   	push   %eax
+  800aea:	8b 45 08             	mov    0x8(%ebp),%eax
+  800aed:	ff d0                	call   *%eax
+  800aef:	83 c4 10             	add    $0x10,%esp
+            break;
+  800af2:	e9 71 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // error message
+        case 'e':
+            err = va_arg(ap, int);
+  800af7:	8b 45 14             	mov    0x14(%ebp),%eax
+  800afa:	8d 50 04             	lea    0x4(%eax),%edx
+  800afd:	89 55 14             	mov    %edx,0x14(%ebp)
+  800b00:	8b 18                	mov    (%eax),%ebx
+            if (err < 0) {
+  800b02:	85 db                	test   %ebx,%ebx
+  800b04:	79 02                	jns    800b08 <vprintfmt+0x13b>
+                err = -err;
+  800b06:	f7 db                	neg    %ebx
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+  800b08:	83 fb 18             	cmp    $0x18,%ebx
+  800b0b:	7f 0b                	jg     800b18 <vprintfmt+0x14b>
+  800b0d:	8b 34 9d 80 10 80 00 	mov    0x801080(,%ebx,4),%esi
+  800b14:	85 f6                	test   %esi,%esi
+  800b16:	75 19                	jne    800b31 <vprintfmt+0x164>
+                printfmt(putch, putdat, "error %d", err);
+  800b18:	53                   	push   %ebx
+  800b19:	68 f5 10 80 00       	push   $0x8010f5
+  800b1e:	ff 75 0c             	pushl  0xc(%ebp)
+  800b21:	ff 75 08             	pushl  0x8(%ebp)
+  800b24:	e8 80 fe ff ff       	call   8009a9 <printfmt>
+  800b29:	83 c4 10             	add    $0x10,%esp
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+            }
+            break;
+  800b2c:	e9 37 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+                printfmt(putch, putdat, "error %d", err);
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+  800b31:	56                   	push   %esi
+  800b32:	68 fe 10 80 00       	push   $0x8010fe
+  800b37:	ff 75 0c             	pushl  0xc(%ebp)
+  800b3a:	ff 75 08             	pushl  0x8(%ebp)
+  800b3d:	e8 67 fe ff ff       	call   8009a9 <printfmt>
+  800b42:	83 c4 10             	add    $0x10,%esp
+            }
+            break;
+  800b45:	e9 1e 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // string
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+  800b4a:	8b 45 14             	mov    0x14(%ebp),%eax
+  800b4d:	8d 50 04             	lea    0x4(%eax),%edx
+  800b50:	89 55 14             	mov    %edx,0x14(%ebp)
+  800b53:	8b 30                	mov    (%eax),%esi
+  800b55:	85 f6                	test   %esi,%esi
+  800b57:	75 05                	jne    800b5e <vprintfmt+0x191>
+                p = "(null)";
+  800b59:	be 01 11 80 00       	mov    $0x801101,%esi
+            }
+            if (width > 0 && padc != '-') {
+  800b5e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800b62:	7e 76                	jle    800bda <vprintfmt+0x20d>
+  800b64:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+  800b68:	74 70                	je     800bda <vprintfmt+0x20d>
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  800b6a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800b6d:	83 ec 08             	sub    $0x8,%esp
+  800b70:	50                   	push   %eax
+  800b71:	56                   	push   %esi
+  800b72:	e8 17 f8 ff ff       	call   80038e <strnlen>
+  800b77:	83 c4 10             	add    $0x10,%esp
+  800b7a:	89 c2                	mov    %eax,%edx
+  800b7c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800b7f:	29 d0                	sub    %edx,%eax
+  800b81:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800b84:	eb 17                	jmp    800b9d <vprintfmt+0x1d0>
+                    putch(padc, putdat);
+  800b86:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+  800b8a:	83 ec 08             	sub    $0x8,%esp
+  800b8d:	ff 75 0c             	pushl  0xc(%ebp)
+  800b90:	50                   	push   %eax
+  800b91:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b94:	ff d0                	call   *%eax
+  800b96:	83 c4 10             	add    $0x10,%esp
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+                p = "(null)";
+            }
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  800b99:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800b9d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ba1:	7f e3                	jg     800b86 <vprintfmt+0x1b9>
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  800ba3:	eb 35                	jmp    800bda <vprintfmt+0x20d>
+                if (altflag && (ch < ' ' || ch > '~')) {
+  800ba5:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+  800ba9:	74 1c                	je     800bc7 <vprintfmt+0x1fa>
+  800bab:	83 fb 1f             	cmp    $0x1f,%ebx
+  800bae:	7e 05                	jle    800bb5 <vprintfmt+0x1e8>
+  800bb0:	83 fb 7e             	cmp    $0x7e,%ebx
+  800bb3:	7e 12                	jle    800bc7 <vprintfmt+0x1fa>
+                    putch('?', putdat);
+  800bb5:	83 ec 08             	sub    $0x8,%esp
+  800bb8:	ff 75 0c             	pushl  0xc(%ebp)
+  800bbb:	6a 3f                	push   $0x3f
+  800bbd:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bc0:	ff d0                	call   *%eax
+  800bc2:	83 c4 10             	add    $0x10,%esp
+  800bc5:	eb 0f                	jmp    800bd6 <vprintfmt+0x209>
+                }
+                else {
+                    putch(ch, putdat);
+  800bc7:	83 ec 08             	sub    $0x8,%esp
+  800bca:	ff 75 0c             	pushl  0xc(%ebp)
+  800bcd:	53                   	push   %ebx
+  800bce:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bd1:	ff d0                	call   *%eax
+  800bd3:	83 c4 10             	add    $0x10,%esp
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  800bd6:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800bda:	89 f0                	mov    %esi,%eax
+  800bdc:	8d 70 01             	lea    0x1(%eax),%esi
+  800bdf:	0f b6 00             	movzbl (%eax),%eax
+  800be2:	0f be d8             	movsbl %al,%ebx
+  800be5:	85 db                	test   %ebx,%ebx
+  800be7:	74 26                	je     800c0f <vprintfmt+0x242>
+  800be9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800bed:	78 b6                	js     800ba5 <vprintfmt+0x1d8>
+  800bef:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800bf3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800bf7:	79 ac                	jns    800ba5 <vprintfmt+0x1d8>
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  800bf9:	eb 14                	jmp    800c0f <vprintfmt+0x242>
+                putch(' ', putdat);
+  800bfb:	83 ec 08             	sub    $0x8,%esp
+  800bfe:	ff 75 0c             	pushl  0xc(%ebp)
+  800c01:	6a 20                	push   $0x20
+  800c03:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c06:	ff d0                	call   *%eax
+  800c08:	83 c4 10             	add    $0x10,%esp
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  800c0b:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800c0f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800c13:	7f e6                	jg     800bfb <vprintfmt+0x22e>
+                putch(' ', putdat);
+            }
+            break;
+  800c15:	e9 4e 01 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // (signed) decimal
+        case 'd':
+            num = getint(&ap, lflag);
+  800c1a:	83 ec 08             	sub    $0x8,%esp
+  800c1d:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c20:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c23:	50                   	push   %eax
+  800c24:	e8 39 fd ff ff       	call   800962 <getint>
+  800c29:	83 c4 10             	add    $0x10,%esp
+  800c2c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c2f:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            if ((long long)num < 0) {
+  800c32:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c35:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800c38:	85 d2                	test   %edx,%edx
+  800c3a:	79 23                	jns    800c5f <vprintfmt+0x292>
+                putch('-', putdat);
+  800c3c:	83 ec 08             	sub    $0x8,%esp
+  800c3f:	ff 75 0c             	pushl  0xc(%ebp)
+  800c42:	6a 2d                	push   $0x2d
+  800c44:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c47:	ff d0                	call   *%eax
+  800c49:	83 c4 10             	add    $0x10,%esp
+                num = -(long long)num;
+  800c4c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c4f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800c52:	f7 d8                	neg    %eax
+  800c54:	83 d2 00             	adc    $0x0,%edx
+  800c57:	f7 da                	neg    %edx
+  800c59:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c5c:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            }
+            base = 10;
+  800c5f:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  800c66:	e9 9f 00 00 00       	jmp    800d0a <vprintfmt+0x33d>
+
+        // unsigned decimal
+        case 'u':
+            num = getuint(&ap, lflag);
+  800c6b:	83 ec 08             	sub    $0x8,%esp
+  800c6e:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c71:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c74:	50                   	push   %eax
+  800c75:	e8 99 fc ff ff       	call   800913 <getuint>
+  800c7a:	83 c4 10             	add    $0x10,%esp
+  800c7d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c80:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 10;
+  800c83:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  800c8a:	eb 7e                	jmp    800d0a <vprintfmt+0x33d>
+
+        // (unsigned) octal
+        case 'o':
+            num = getuint(&ap, lflag);
+  800c8c:	83 ec 08             	sub    $0x8,%esp
+  800c8f:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c92:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c95:	50                   	push   %eax
+  800c96:	e8 78 fc ff ff       	call   800913 <getuint>
+  800c9b:	83 c4 10             	add    $0x10,%esp
+  800c9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800ca1:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 8;
+  800ca4:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+            goto number;
+  800cab:	eb 5d                	jmp    800d0a <vprintfmt+0x33d>
+
+        // pointer
+        case 'p':
+            putch('0', putdat);
+  800cad:	83 ec 08             	sub    $0x8,%esp
+  800cb0:	ff 75 0c             	pushl  0xc(%ebp)
+  800cb3:	6a 30                	push   $0x30
+  800cb5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cb8:	ff d0                	call   *%eax
+  800cba:	83 c4 10             	add    $0x10,%esp
+            putch('x', putdat);
+  800cbd:	83 ec 08             	sub    $0x8,%esp
+  800cc0:	ff 75 0c             	pushl  0xc(%ebp)
+  800cc3:	6a 78                	push   $0x78
+  800cc5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cc8:	ff d0                	call   *%eax
+  800cca:	83 c4 10             	add    $0x10,%esp
+            num = (unsigned long long)(uintptr_t)va_arg(ap, void *);
+  800ccd:	8b 45 14             	mov    0x14(%ebp),%eax
+  800cd0:	8d 50 04             	lea    0x4(%eax),%edx
+  800cd3:	89 55 14             	mov    %edx,0x14(%ebp)
+  800cd6:	8b 00                	mov    (%eax),%eax
+  800cd8:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800cdb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+            base = 16;
+  800ce2:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+            goto number;
+  800ce9:	eb 1f                	jmp    800d0a <vprintfmt+0x33d>
+
+        // (unsigned) hexadecimal
+        case 'x':
+            num = getuint(&ap, lflag);
+  800ceb:	83 ec 08             	sub    $0x8,%esp
+  800cee:	ff 75 e0             	pushl  -0x20(%ebp)
+  800cf1:	8d 45 14             	lea    0x14(%ebp),%eax
+  800cf4:	50                   	push   %eax
+  800cf5:	e8 19 fc ff ff       	call   800913 <getuint>
+  800cfa:	83 c4 10             	add    $0x10,%esp
+  800cfd:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800d00:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 16;
+  800d03:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+        number:
+            printnum(putch, putdat, num, base, width, padc);
+  800d0a:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+  800d0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800d11:	83 ec 04             	sub    $0x4,%esp
+  800d14:	52                   	push   %edx
+  800d15:	ff 75 e8             	pushl  -0x18(%ebp)
+  800d18:	50                   	push   %eax
+  800d19:	ff 75 f4             	pushl  -0xc(%ebp)
+  800d1c:	ff 75 f0             	pushl  -0x10(%ebp)
+  800d1f:	ff 75 0c             	pushl  0xc(%ebp)
+  800d22:	ff 75 08             	pushl  0x8(%ebp)
+  800d25:	e8 f8 fa ff ff       	call   800822 <printnum>
+  800d2a:	83 c4 20             	add    $0x20,%esp
+            break;
+  800d2d:	eb 39                	jmp    800d68 <vprintfmt+0x39b>
+
+        // escaped '%' character
+        case '%':
+            putch(ch, putdat);
+  800d2f:	83 ec 08             	sub    $0x8,%esp
+  800d32:	ff 75 0c             	pushl  0xc(%ebp)
+  800d35:	53                   	push   %ebx
+  800d36:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d39:	ff d0                	call   *%eax
+  800d3b:	83 c4 10             	add    $0x10,%esp
+            break;
+  800d3e:	eb 28                	jmp    800d68 <vprintfmt+0x39b>
+
+        // unrecognized escape sequence - just print it literally
+        default:
+            putch('%', putdat);
+  800d40:	83 ec 08             	sub    $0x8,%esp
+  800d43:	ff 75 0c             	pushl  0xc(%ebp)
+  800d46:	6a 25                	push   $0x25
+  800d48:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d4b:	ff d0                	call   *%eax
+  800d4d:	83 c4 10             	add    $0x10,%esp
+            for (fmt --; fmt[-1] != '%'; fmt --)
+  800d50:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800d54:	eb 04                	jmp    800d5a <vprintfmt+0x38d>
+  800d56:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800d5a:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d5d:	83 e8 01             	sub    $0x1,%eax
+  800d60:	0f b6 00             	movzbl (%eax),%eax
+  800d63:	3c 25                	cmp    $0x25,%al
+  800d65:	75 ef                	jne    800d56 <vprintfmt+0x389>
+                /* do nothing */;
+            break;
+  800d67:	90                   	nop
+        }
+    }
+  800d68:	e9 68 fc ff ff       	jmp    8009d5 <vprintfmt+0x8>
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+            if (ch == '\0') {
+                return;
+  800d6d:	90                   	nop
+            for (fmt --; fmt[-1] != '%'; fmt --)
+                /* do nothing */;
+            break;
+        }
+    }
+}
+  800d6e:	8d 65 f8             	lea    -0x8(%ebp),%esp
+  800d71:	5b                   	pop    %ebx
+  800d72:	5e                   	pop    %esi
+  800d73:	5d                   	pop    %ebp
+  800d74:	c3                   	ret    
+
+00800d75 <sprintputch>:
+ * sprintputch - 'print' a single character in a buffer
+ * @ch:         the character will be printed
+ * @b:          the buffer to place the character @ch
+ * */
+static void
+sprintputch(int ch, struct sprintbuf *b) {
+  800d75:	55                   	push   %ebp
+  800d76:	89 e5                	mov    %esp,%ebp
+    b->cnt ++;
+  800d78:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d7b:	8b 40 08             	mov    0x8(%eax),%eax
+  800d7e:	8d 50 01             	lea    0x1(%eax),%edx
+  800d81:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d84:	89 50 08             	mov    %edx,0x8(%eax)
+    if (b->buf < b->ebuf) {
+  800d87:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8a:	8b 10                	mov    (%eax),%edx
+  800d8c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8f:	8b 40 04             	mov    0x4(%eax),%eax
+  800d92:	39 c2                	cmp    %eax,%edx
+  800d94:	73 12                	jae    800da8 <sprintputch+0x33>
+        *b->buf ++ = ch;
+  800d96:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d99:	8b 00                	mov    (%eax),%eax
+  800d9b:	8d 48 01             	lea    0x1(%eax),%ecx
+  800d9e:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800da1:	89 0a                	mov    %ecx,(%edx)
+  800da3:	8b 55 08             	mov    0x8(%ebp),%edx
+  800da6:	88 10                	mov    %dl,(%eax)
+    }
+}
+  800da8:	90                   	nop
+  800da9:	5d                   	pop    %ebp
+  800daa:	c3                   	ret    
+
+00800dab <snprintf>:
+ * @str:        the buffer to place the result into
+ * @size:       the size of buffer, including the trailing null space
+ * @fmt:        the format string to use
+ * */
+int
+snprintf(char *str, size_t size, const char *fmt, ...) {
+  800dab:	55                   	push   %ebp
+  800dac:	89 e5                	mov    %esp,%ebp
+  800dae:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    int cnt;
+    va_start(ap, fmt);
+  800db1:	8d 45 14             	lea    0x14(%ebp),%eax
+  800db4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    cnt = vsnprintf(str, size, fmt, ap);
+  800db7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800dba:	50                   	push   %eax
+  800dbb:	ff 75 10             	pushl  0x10(%ebp)
+  800dbe:	ff 75 0c             	pushl  0xc(%ebp)
+  800dc1:	ff 75 08             	pushl  0x8(%ebp)
+  800dc4:	e8 0b 00 00 00       	call   800dd4 <vsnprintf>
+  800dc9:	83 c4 10             	add    $0x10,%esp
+  800dcc:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+    return cnt;
+  800dcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800dd2:	c9                   	leave  
+  800dd3:	c3                   	ret    
+
+00800dd4 <vsnprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want snprintf() instead.
+ * */
+int
+vsnprintf(char *str, size_t size, const char *fmt, va_list ap) {
+  800dd4:	55                   	push   %ebp
+  800dd5:	89 e5                	mov    %esp,%ebp
+  800dd7:	83 ec 18             	sub    $0x18,%esp
+    struct sprintbuf b = {str, str + size - 1, 0};
+  800dda:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ddd:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800de0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800de3:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800de6:	8b 45 08             	mov    0x8(%ebp),%eax
+  800de9:	01 d0                	add    %edx,%eax
+  800deb:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800dee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    if (str == NULL || b.buf > b.ebuf) {
+  800df5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  800df9:	74 0a                	je     800e05 <vsnprintf+0x31>
+  800dfb:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  800dfe:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800e01:	39 c2                	cmp    %eax,%edx
+  800e03:	76 07                	jbe    800e0c <vsnprintf+0x38>
+        return -E_INVAL;
+  800e05:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+  800e0a:	eb 20                	jmp    800e2c <vsnprintf+0x58>
+    }
+    // print the string to the buffer
+    vprintfmt((void*)sprintputch, &b, fmt, ap);
+  800e0c:	ff 75 14             	pushl  0x14(%ebp)
+  800e0f:	ff 75 10             	pushl  0x10(%ebp)
+  800e12:	8d 45 ec             	lea    -0x14(%ebp),%eax
+  800e15:	50                   	push   %eax
+  800e16:	68 75 0d 80 00       	push   $0x800d75
+  800e1b:	e8 ad fb ff ff       	call   8009cd <vprintfmt>
+  800e20:	83 c4 10             	add    $0x10,%esp
+    // null terminate the buffer
+    *b.buf = '\0';
+  800e23:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e26:	c6 00 00             	movb   $0x0,(%eax)
+    return b.cnt;
+  800e29:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800e2c:	c9                   	leave  
+  800e2d:	c3                   	ret    
+
+00800e2e <hash32>:
+ * @bits:   the number of bits in a return value
+ *
+ * High bits are more random, so we use them.
+ * */
+uint32_t
+hash32(uint32_t val, unsigned int bits) {
+  800e2e:	55                   	push   %ebp
+  800e2f:	89 e5                	mov    %esp,%ebp
+  800e31:	83 ec 10             	sub    $0x10,%esp
+    uint32_t hash = val * GOLDEN_RATIO_PRIME_32;
+  800e34:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e37:	69 c0 01 00 37 9e    	imul   $0x9e370001,%eax,%eax
+  800e3d:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    return (hash >> (32 - bits));
+  800e40:	b8 20 00 00 00       	mov    $0x20,%eax
+  800e45:	2b 45 0c             	sub    0xc(%ebp),%eax
+  800e48:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  800e4b:	89 c1                	mov    %eax,%ecx
+  800e4d:	d3 ea                	shr    %cl,%edx
+  800e4f:	89 d0                	mov    %edx,%eax
+}
+  800e51:	c9                   	leave  
+  800e52:	c3                   	ret    
+
+00800e53 <rand>:
+ * rand - returns a pseudo-random integer
+ *
+ * The rand() function return a value in the range [0, RAND_MAX].
+ * */
+int
+rand(void) {
+  800e53:	55                   	push   %ebp
+  800e54:	89 e5                	mov    %esp,%ebp
+  800e56:	57                   	push   %edi
+  800e57:	56                   	push   %esi
+  800e58:	53                   	push   %ebx
+  800e59:	83 ec 24             	sub    $0x24,%esp
+    next = (next * 0x5DEECE66DLL + 0xBLL) & ((1LL << 48) - 1);
+  800e5c:	a1 00 20 80 00       	mov    0x802000,%eax
+  800e61:	8b 15 04 20 80 00    	mov    0x802004,%edx
+  800e67:	69 fa 6d e6 ec de    	imul   $0xdeece66d,%edx,%edi
+  800e6d:	6b f0 05             	imul   $0x5,%eax,%esi
+  800e70:	01 fe                	add    %edi,%esi
+  800e72:	bf 6d e6 ec de       	mov    $0xdeece66d,%edi
+  800e77:	f7 e7                	mul    %edi
+  800e79:	01 d6                	add    %edx,%esi
+  800e7b:	89 f2                	mov    %esi,%edx
+  800e7d:	83 c0 0b             	add    $0xb,%eax
+  800e80:	83 d2 00             	adc    $0x0,%edx
+  800e83:	89 c7                	mov    %eax,%edi
+  800e85:	83 e7 ff             	and    $0xffffffff,%edi
+  800e88:	89 f9                	mov    %edi,%ecx
+  800e8a:	0f b7 da             	movzwl %dx,%ebx
+  800e8d:	89 0d 00 20 80 00    	mov    %ecx,0x802000
+  800e93:	89 1d 04 20 80 00    	mov    %ebx,0x802004
+    unsigned long long result = (next >> 12);
+  800e99:	a1 00 20 80 00       	mov    0x802000,%eax
+  800e9e:	8b 15 04 20 80 00    	mov    0x802004,%edx
+  800ea4:	0f ac d0 0c          	shrd   $0xc,%edx,%eax
+  800ea8:	c1 ea 0c             	shr    $0xc,%edx
+  800eab:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800eae:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+    return (int)do_div(result, RAND_MAX + 1);
+  800eb1:	c7 45 dc 00 00 00 80 	movl   $0x80000000,-0x24(%ebp)
+  800eb8:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  800ebb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800ebe:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  800ec1:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  800ec4:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ec7:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800eca:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ece:	74 1c                	je     800eec <rand+0x99>
+  800ed0:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ed3:	ba 00 00 00 00       	mov    $0x0,%edx
+  800ed8:	f7 75 dc             	divl   -0x24(%ebp)
+  800edb:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  800ede:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ee1:	ba 00 00 00 00       	mov    $0x0,%edx
+  800ee6:	f7 75 dc             	divl   -0x24(%ebp)
+  800ee9:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800eec:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  800eef:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  800ef2:	f7 75 dc             	divl   -0x24(%ebp)
+  800ef5:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  800ef8:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  800efb:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  800efe:	8b 55 e8             	mov    -0x18(%ebp),%edx
+  800f01:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800f04:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  800f07:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+}
+  800f0a:	83 c4 24             	add    $0x24,%esp
+  800f0d:	5b                   	pop    %ebx
+  800f0e:	5e                   	pop    %esi
+  800f0f:	5f                   	pop    %edi
+  800f10:	5d                   	pop    %ebp
+  800f11:	c3                   	ret    
+
+00800f12 <srand>:
+/* *
+ * srand - seed the random number generator with the given number
+ * @seed:   the required seed number
+ * */
+void
+srand(unsigned int seed) {
+  800f12:	55                   	push   %ebp
+  800f13:	89 e5                	mov    %esp,%ebp
+    next = seed;
+  800f15:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f18:	ba 00 00 00 00       	mov    $0x0,%edx
+  800f1d:	a3 00 20 80 00       	mov    %eax,0x802000
+  800f22:	89 15 04 20 80 00    	mov    %edx,0x802004
+}
+  800f28:	90                   	nop
+  800f29:	5d                   	pop    %ebp
+  800f2a:	c3                   	ret    
+
+00800f2b <main>:
+#include <stdio.h>
+#include <ulib.h>
+
+int
+main(void) {
+  800f2b:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+  800f2f:	83 e4 f0             	and    $0xfffffff0,%esp
+  800f32:	ff 71 fc             	pushl  -0x4(%ecx)
+  800f35:	55                   	push   %ebp
+  800f36:	89 e5                	mov    %esp,%ebp
+  800f38:	51                   	push   %ecx
+  800f39:	83 ec 04             	sub    $0x4,%esp
+    cprintf("I am %d, print pgdir.\n", getpid());
+  800f3c:	e8 fd f2 ff ff       	call   80023e <getpid>
+  800f41:	83 ec 08             	sub    $0x8,%esp
+  800f44:	50                   	push   %eax
+  800f45:	68 60 12 80 00       	push   $0x801260
+  800f4a:	e8 8a f3 ff ff       	call   8002d9 <cprintf>
+  800f4f:	83 c4 10             	add    $0x10,%esp
+    print_pgdir();
+  800f52:	e8 f4 f2 ff ff       	call   80024b <print_pgdir>
+    cprintf("pgdir pass.\n");
+  800f57:	83 ec 0c             	sub    $0xc,%esp
+  800f5a:	68 77 12 80 00       	push   $0x801277
+  800f5f:	e8 75 f3 ff ff       	call   8002d9 <cprintf>
+  800f64:	83 c4 10             	add    $0x10,%esp
+    return 0;
+  800f67:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800f6c:	8b 4d fc             	mov    -0x4(%ebp),%ecx
+  800f6f:	c9                   	leave  
+  800f70:	8d 61 fc             	lea    -0x4(%ecx),%esp
+  800f73:	c3                   	ret    
diff -r -u -P lab6_origin/obj/user/pgdir.d lab6/obj/user/pgdir.d
--- lab6_origin/obj/user/pgdir.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/pgdir.d	2019-05-13 17:39:38.398034700 +0800
@@ -0,0 +1,2 @@
+obj/user/pgdir.o obj/user/pgdir.d: user/pgdir.c libs/stdio.h libs/defs.h \
+ libs/stdarg.h user/libs/ulib.h
Binary files lab6_origin/obj/user/pgdir.o and lab6/obj/user/pgdir.o differ
diff -r -u -P lab6_origin/obj/user/pgdir.sym lab6/obj/user/pgdir.sym
--- lab6_origin/obj/user/pgdir.sym	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/pgdir.sym	2019-05-13 17:39:43.952845700 +0800
@@ -0,0 +1,76 @@
+00800020 .text
+00800f80 .rodata
+00802000 .data
+00200000 .stab_info
+00200010 .stab
+00202cb1 .stabstr
+00000000 panic.c
+00000000 syscall.c
+008000b5 syscall
+00000000 ulib.c
+00000000 stdio.c
+0080028c cputch
+00000000 umain.c
+00000000 string.c
+00000000 printfmt.c
+00801080 error_string
+00800822 printnum
+00800913 getuint
+00800962 getint
+00800d75 sprintputch
+00000000 hash.c
+00000000 rand.c
+00802000 next
+00000000 pgdir.c
+008003be strcpy
+0080021a yield
+00800201 waitpid
+00800141 sys_yield
+008006d7 memmove
+00800dab snprintf
+008009cd vprintfmt
+0080011d sys_fork
+008002d9 cprintf
+0080023e getpid
+0080077a memcpy
+00800266 lab6_set_priority
+00800dd4 vsnprintf
+0080034d umain
+00202cb0 __STAB_END__
+00800150 sys_kill
+00202cb1 __STABSTR_BEGIN__
+00800020 __panic
+0080053a strtol
+0080038e strnlen
+0080024b print_pgdir
+00800228 kill
+0080050b strfind
+008001ea wait
+0080027d _start
+00800e53 rand
+00800482 strncmp
+00800171 sys_putc
+008003fe strncpy
+008007ca memcmp
+008001dd fork
+00800697 memset
+00800f2b main
+00800f12 srand
+00800e2e hash32
+008009a9 printfmt
+00203a8f __STABSTR_END__
+00800438 strcmp
+00800259 gettime_msec
+00800192 sys_gettime
+008002b0 vcprintf
+0080006e __warn
+008002ff cputs
+008001a1 sys_lab6_set_priority
+008001b7 exit
+0080012c sys_wait
+0080010b sys_exit
+00200010 __STAB_BEGIN__
+00800366 strlen
+00800183 sys_pgdir
+008004d8 strchr
+00800162 sys_getpid
diff -r -u -P lab6_origin/obj/user/priority.asm lab6/obj/user/priority.asm
--- lab6_origin/obj/user/priority.asm	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/priority.asm	2019-05-13 17:39:43.946849000 +0800
@@ -0,0 +1,2871 @@
+
+obj/__user_priority.out:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00800020 <__panic>:
+#include <stdio.h>
+#include <ulib.h>
+#include <error.h>
+
+void
+__panic(const char *file, int line, const char *fmt, ...) {
+  800020:	55                   	push   %ebp
+  800021:	89 e5                	mov    %esp,%ebp
+  800023:	83 ec 18             	sub    $0x18,%esp
+    // print the 'message'
+    va_list ap;
+    va_start(ap, fmt);
+  800026:	8d 45 14             	lea    0x14(%ebp),%eax
+  800029:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("user panic at %s:%d:\n    ", file, line);
+  80002c:	83 ec 04             	sub    $0x4,%esp
+  80002f:	ff 75 0c             	pushl  0xc(%ebp)
+  800032:	ff 75 08             	pushl  0x8(%ebp)
+  800035:	68 e0 11 80 00       	push   $0x8011e0
+  80003a:	e8 9a 02 00 00       	call   8002d9 <cprintf>
+  80003f:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+  800042:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800045:	83 ec 08             	sub    $0x8,%esp
+  800048:	50                   	push   %eax
+  800049:	ff 75 10             	pushl  0x10(%ebp)
+  80004c:	e8 5f 02 00 00       	call   8002b0 <vcprintf>
+  800051:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+  800054:	83 ec 0c             	sub    $0xc,%esp
+  800057:	68 fa 11 80 00       	push   $0x8011fa
+  80005c:	e8 78 02 00 00       	call   8002d9 <cprintf>
+  800061:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+    exit(-E_PANIC);
+  800064:	83 ec 0c             	sub    $0xc,%esp
+  800067:	6a f6                	push   $0xfffffff6
+  800069:	e8 49 01 00 00       	call   8001b7 <exit>
+
+0080006e <__warn>:
+}
+
+void
+__warn(const char *file, int line, const char *fmt, ...) {
+  80006e:	55                   	push   %ebp
+  80006f:	89 e5                	mov    %esp,%ebp
+  800071:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    va_start(ap, fmt);
+  800074:	8d 45 14             	lea    0x14(%ebp),%eax
+  800077:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("user warning at %s:%d:\n    ", file, line);
+  80007a:	83 ec 04             	sub    $0x4,%esp
+  80007d:	ff 75 0c             	pushl  0xc(%ebp)
+  800080:	ff 75 08             	pushl  0x8(%ebp)
+  800083:	68 fc 11 80 00       	push   $0x8011fc
+  800088:	e8 4c 02 00 00       	call   8002d9 <cprintf>
+  80008d:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+  800090:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800093:	83 ec 08             	sub    $0x8,%esp
+  800096:	50                   	push   %eax
+  800097:	ff 75 10             	pushl  0x10(%ebp)
+  80009a:	e8 11 02 00 00       	call   8002b0 <vcprintf>
+  80009f:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+  8000a2:	83 ec 0c             	sub    $0xc,%esp
+  8000a5:	68 fa 11 80 00       	push   $0x8011fa
+  8000aa:	e8 2a 02 00 00       	call   8002d9 <cprintf>
+  8000af:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+  8000b2:	90                   	nop
+  8000b3:	c9                   	leave  
+  8000b4:	c3                   	ret    
+
+008000b5 <syscall>:
+#include <syscall.h>
+
+#define MAX_ARGS            5
+
+static inline int
+syscall(int num, ...) {
+  8000b5:	55                   	push   %ebp
+  8000b6:	89 e5                	mov    %esp,%ebp
+  8000b8:	57                   	push   %edi
+  8000b9:	56                   	push   %esi
+  8000ba:	53                   	push   %ebx
+  8000bb:	83 ec 20             	sub    $0x20,%esp
+    va_list ap;
+    va_start(ap, num);
+  8000be:	8d 45 0c             	lea    0xc(%ebp),%eax
+  8000c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    uint32_t a[MAX_ARGS];
+    int i, ret;
+    for (i = 0; i < MAX_ARGS; i ++) {
+  8000c4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  8000cb:	eb 16                	jmp    8000e3 <syscall+0x2e>
+        a[i] = va_arg(ap, uint32_t);
+  8000cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8000d0:	8d 50 04             	lea    0x4(%eax),%edx
+  8000d3:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  8000d6:	8b 10                	mov    (%eax),%edx
+  8000d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8000db:	89 54 85 d4          	mov    %edx,-0x2c(%ebp,%eax,4)
+syscall(int num, ...) {
+    va_list ap;
+    va_start(ap, num);
+    uint32_t a[MAX_ARGS];
+    int i, ret;
+    for (i = 0; i < MAX_ARGS; i ++) {
+  8000df:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+  8000e3:	83 7d f0 04          	cmpl   $0x4,-0x10(%ebp)
+  8000e7:	7e e4                	jle    8000cd <syscall+0x18>
+    asm volatile (
+        "int %1;"
+        : "=a" (ret)
+        : "i" (T_SYSCALL),
+          "a" (num),
+          "d" (a[0]),
+  8000e9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+          "c" (a[1]),
+  8000ec:	8b 4d d8             	mov    -0x28(%ebp),%ecx
+          "b" (a[2]),
+  8000ef:	8b 5d dc             	mov    -0x24(%ebp),%ebx
+          "D" (a[3]),
+  8000f2:	8b 7d e0             	mov    -0x20(%ebp),%edi
+          "S" (a[4])
+  8000f5:	8b 75 e4             	mov    -0x1c(%ebp),%esi
+    for (i = 0; i < MAX_ARGS; i ++) {
+        a[i] = va_arg(ap, uint32_t);
+    }
+    va_end(ap);
+
+    asm volatile (
+  8000f8:	8b 45 08             	mov    0x8(%ebp),%eax
+  8000fb:	cd 80                	int    $0x80
+  8000fd:	89 45 ec             	mov    %eax,-0x14(%ebp)
+          "c" (a[1]),
+          "b" (a[2]),
+          "D" (a[3]),
+          "S" (a[4])
+        : "cc", "memory");
+    return ret;
+  800100:	8b 45 ec             	mov    -0x14(%ebp),%eax
+}
+  800103:	83 c4 20             	add    $0x20,%esp
+  800106:	5b                   	pop    %ebx
+  800107:	5e                   	pop    %esi
+  800108:	5f                   	pop    %edi
+  800109:	5d                   	pop    %ebp
+  80010a:	c3                   	ret    
+
+0080010b <sys_exit>:
+
+int
+sys_exit(int error_code) {
+  80010b:	55                   	push   %ebp
+  80010c:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_exit, error_code);
+  80010e:	ff 75 08             	pushl  0x8(%ebp)
+  800111:	6a 01                	push   $0x1
+  800113:	e8 9d ff ff ff       	call   8000b5 <syscall>
+  800118:	83 c4 08             	add    $0x8,%esp
+}
+  80011b:	c9                   	leave  
+  80011c:	c3                   	ret    
+
+0080011d <sys_fork>:
+
+int
+sys_fork(void) {
+  80011d:	55                   	push   %ebp
+  80011e:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_fork);
+  800120:	6a 02                	push   $0x2
+  800122:	e8 8e ff ff ff       	call   8000b5 <syscall>
+  800127:	83 c4 04             	add    $0x4,%esp
+}
+  80012a:	c9                   	leave  
+  80012b:	c3                   	ret    
+
+0080012c <sys_wait>:
+
+int
+sys_wait(int pid, int *store) {
+  80012c:	55                   	push   %ebp
+  80012d:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_wait, pid, store);
+  80012f:	ff 75 0c             	pushl  0xc(%ebp)
+  800132:	ff 75 08             	pushl  0x8(%ebp)
+  800135:	6a 03                	push   $0x3
+  800137:	e8 79 ff ff ff       	call   8000b5 <syscall>
+  80013c:	83 c4 0c             	add    $0xc,%esp
+}
+  80013f:	c9                   	leave  
+  800140:	c3                   	ret    
+
+00800141 <sys_yield>:
+
+int
+sys_yield(void) {
+  800141:	55                   	push   %ebp
+  800142:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_yield);
+  800144:	6a 0a                	push   $0xa
+  800146:	e8 6a ff ff ff       	call   8000b5 <syscall>
+  80014b:	83 c4 04             	add    $0x4,%esp
+}
+  80014e:	c9                   	leave  
+  80014f:	c3                   	ret    
+
+00800150 <sys_kill>:
+
+int
+sys_kill(int pid) {
+  800150:	55                   	push   %ebp
+  800151:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_kill, pid);
+  800153:	ff 75 08             	pushl  0x8(%ebp)
+  800156:	6a 0c                	push   $0xc
+  800158:	e8 58 ff ff ff       	call   8000b5 <syscall>
+  80015d:	83 c4 08             	add    $0x8,%esp
+}
+  800160:	c9                   	leave  
+  800161:	c3                   	ret    
+
+00800162 <sys_getpid>:
+
+int
+sys_getpid(void) {
+  800162:	55                   	push   %ebp
+  800163:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_getpid);
+  800165:	6a 12                	push   $0x12
+  800167:	e8 49 ff ff ff       	call   8000b5 <syscall>
+  80016c:	83 c4 04             	add    $0x4,%esp
+}
+  80016f:	c9                   	leave  
+  800170:	c3                   	ret    
+
+00800171 <sys_putc>:
+
+int
+sys_putc(int c) {
+  800171:	55                   	push   %ebp
+  800172:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_putc, c);
+  800174:	ff 75 08             	pushl  0x8(%ebp)
+  800177:	6a 1e                	push   $0x1e
+  800179:	e8 37 ff ff ff       	call   8000b5 <syscall>
+  80017e:	83 c4 08             	add    $0x8,%esp
+}
+  800181:	c9                   	leave  
+  800182:	c3                   	ret    
+
+00800183 <sys_pgdir>:
+
+int
+sys_pgdir(void) {
+  800183:	55                   	push   %ebp
+  800184:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_pgdir);
+  800186:	6a 1f                	push   $0x1f
+  800188:	e8 28 ff ff ff       	call   8000b5 <syscall>
+  80018d:	83 c4 04             	add    $0x4,%esp
+}
+  800190:	c9                   	leave  
+  800191:	c3                   	ret    
+
+00800192 <sys_gettime>:
+
+int
+sys_gettime(void) {
+  800192:	55                   	push   %ebp
+  800193:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_gettime);
+  800195:	6a 11                	push   $0x11
+  800197:	e8 19 ff ff ff       	call   8000b5 <syscall>
+  80019c:	83 c4 04             	add    $0x4,%esp
+}
+  80019f:	c9                   	leave  
+  8001a0:	c3                   	ret    
+
+008001a1 <sys_lab6_set_priority>:
+
+void
+sys_lab6_set_priority(uint32_t priority)
+{
+  8001a1:	55                   	push   %ebp
+  8001a2:	89 e5                	mov    %esp,%ebp
+    syscall(SYS_lab6_set_priority, priority);
+  8001a4:	ff 75 08             	pushl  0x8(%ebp)
+  8001a7:	68 ff 00 00 00       	push   $0xff
+  8001ac:	e8 04 ff ff ff       	call   8000b5 <syscall>
+  8001b1:	83 c4 08             	add    $0x8,%esp
+}
+  8001b4:	90                   	nop
+  8001b5:	c9                   	leave  
+  8001b6:	c3                   	ret    
+
+008001b7 <exit>:
+#include <syscall.h>
+#include <stdio.h>
+#include <ulib.h>
+
+void
+exit(int error_code) {
+  8001b7:	55                   	push   %ebp
+  8001b8:	89 e5                	mov    %esp,%ebp
+  8001ba:	83 ec 08             	sub    $0x8,%esp
+    sys_exit(error_code);
+  8001bd:	83 ec 0c             	sub    $0xc,%esp
+  8001c0:	ff 75 08             	pushl  0x8(%ebp)
+  8001c3:	e8 43 ff ff ff       	call   80010b <sys_exit>
+  8001c8:	83 c4 10             	add    $0x10,%esp
+    cprintf("BUG: exit failed.\n");
+  8001cb:	83 ec 0c             	sub    $0xc,%esp
+  8001ce:	68 18 12 80 00       	push   $0x801218
+  8001d3:	e8 01 01 00 00       	call   8002d9 <cprintf>
+  8001d8:	83 c4 10             	add    $0x10,%esp
+    while (1);
+  8001db:	eb fe                	jmp    8001db <exit+0x24>
+
+008001dd <fork>:
+}
+
+int
+fork(void) {
+  8001dd:	55                   	push   %ebp
+  8001de:	89 e5                	mov    %esp,%ebp
+  8001e0:	83 ec 08             	sub    $0x8,%esp
+    return sys_fork();
+  8001e3:	e8 35 ff ff ff       	call   80011d <sys_fork>
+}
+  8001e8:	c9                   	leave  
+  8001e9:	c3                   	ret    
+
+008001ea <wait>:
+
+int
+wait(void) {
+  8001ea:	55                   	push   %ebp
+  8001eb:	89 e5                	mov    %esp,%ebp
+  8001ed:	83 ec 08             	sub    $0x8,%esp
+    return sys_wait(0, NULL);
+  8001f0:	83 ec 08             	sub    $0x8,%esp
+  8001f3:	6a 00                	push   $0x0
+  8001f5:	6a 00                	push   $0x0
+  8001f7:	e8 30 ff ff ff       	call   80012c <sys_wait>
+  8001fc:	83 c4 10             	add    $0x10,%esp
+}
+  8001ff:	c9                   	leave  
+  800200:	c3                   	ret    
+
+00800201 <waitpid>:
+
+int
+waitpid(int pid, int *store) {
+  800201:	55                   	push   %ebp
+  800202:	89 e5                	mov    %esp,%ebp
+  800204:	83 ec 08             	sub    $0x8,%esp
+    return sys_wait(pid, store);
+  800207:	83 ec 08             	sub    $0x8,%esp
+  80020a:	ff 75 0c             	pushl  0xc(%ebp)
+  80020d:	ff 75 08             	pushl  0x8(%ebp)
+  800210:	e8 17 ff ff ff       	call   80012c <sys_wait>
+  800215:	83 c4 10             	add    $0x10,%esp
+}
+  800218:	c9                   	leave  
+  800219:	c3                   	ret    
+
+0080021a <yield>:
+
+void
+yield(void) {
+  80021a:	55                   	push   %ebp
+  80021b:	89 e5                	mov    %esp,%ebp
+  80021d:	83 ec 08             	sub    $0x8,%esp
+    sys_yield();
+  800220:	e8 1c ff ff ff       	call   800141 <sys_yield>
+}
+  800225:	90                   	nop
+  800226:	c9                   	leave  
+  800227:	c3                   	ret    
+
+00800228 <kill>:
+
+int
+kill(int pid) {
+  800228:	55                   	push   %ebp
+  800229:	89 e5                	mov    %esp,%ebp
+  80022b:	83 ec 08             	sub    $0x8,%esp
+    return sys_kill(pid);
+  80022e:	83 ec 0c             	sub    $0xc,%esp
+  800231:	ff 75 08             	pushl  0x8(%ebp)
+  800234:	e8 17 ff ff ff       	call   800150 <sys_kill>
+  800239:	83 c4 10             	add    $0x10,%esp
+}
+  80023c:	c9                   	leave  
+  80023d:	c3                   	ret    
+
+0080023e <getpid>:
+
+int
+getpid(void) {
+  80023e:	55                   	push   %ebp
+  80023f:	89 e5                	mov    %esp,%ebp
+  800241:	83 ec 08             	sub    $0x8,%esp
+    return sys_getpid();
+  800244:	e8 19 ff ff ff       	call   800162 <sys_getpid>
+}
+  800249:	c9                   	leave  
+  80024a:	c3                   	ret    
+
+0080024b <print_pgdir>:
+
+//print_pgdir - print the PDT&PT
+void
+print_pgdir(void) {
+  80024b:	55                   	push   %ebp
+  80024c:	89 e5                	mov    %esp,%ebp
+  80024e:	83 ec 08             	sub    $0x8,%esp
+    sys_pgdir();
+  800251:	e8 2d ff ff ff       	call   800183 <sys_pgdir>
+}
+  800256:	90                   	nop
+  800257:	c9                   	leave  
+  800258:	c3                   	ret    
+
+00800259 <gettime_msec>:
+
+unsigned int
+gettime_msec(void) {
+  800259:	55                   	push   %ebp
+  80025a:	89 e5                	mov    %esp,%ebp
+  80025c:	83 ec 08             	sub    $0x8,%esp
+    return (unsigned int)sys_gettime();
+  80025f:	e8 2e ff ff ff       	call   800192 <sys_gettime>
+}
+  800264:	c9                   	leave  
+  800265:	c3                   	ret    
+
+00800266 <lab6_set_priority>:
+
+void
+lab6_set_priority(uint32_t priority)
+{
+  800266:	55                   	push   %ebp
+  800267:	89 e5                	mov    %esp,%ebp
+  800269:	83 ec 08             	sub    $0x8,%esp
+    sys_lab6_set_priority(priority);
+  80026c:	83 ec 0c             	sub    $0xc,%esp
+  80026f:	ff 75 08             	pushl  0x8(%ebp)
+  800272:	e8 2a ff ff ff       	call   8001a1 <sys_lab6_set_priority>
+  800277:	83 c4 10             	add    $0x10,%esp
+}
+  80027a:	90                   	nop
+  80027b:	c9                   	leave  
+  80027c:	c3                   	ret    
+
+0080027d <_start>:
+.text
+.globl _start
+_start:
+    # set ebp for backtrace
+    movl $0x0, %ebp
+  80027d:	bd 00 00 00 00       	mov    $0x0,%ebp
+
+    # move down the esp register
+    # since it may cause page fault in backtrace
+    subl $0x20, %esp
+  800282:	83 ec 20             	sub    $0x20,%esp
+
+    # call user-program function
+    call umain
+  800285:	e8 c3 00 00 00       	call   80034d <umain>
+1:  jmp 1b
+  80028a:	eb fe                	jmp    80028a <_start+0xd>
+
+0080028c <cputch>:
+/* *
+ * cputch - writes a single character @c to stdout, and it will
+ * increace the value of counter pointed by @cnt.
+ * */
+static void
+cputch(int c, int *cnt) {
+  80028c:	55                   	push   %ebp
+  80028d:	89 e5                	mov    %esp,%ebp
+  80028f:	83 ec 08             	sub    $0x8,%esp
+    sys_putc(c);
+  800292:	83 ec 0c             	sub    $0xc,%esp
+  800295:	ff 75 08             	pushl  0x8(%ebp)
+  800298:	e8 d4 fe ff ff       	call   800171 <sys_putc>
+  80029d:	83 c4 10             	add    $0x10,%esp
+    (*cnt) ++;
+  8002a0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002a3:	8b 00                	mov    (%eax),%eax
+  8002a5:	8d 50 01             	lea    0x1(%eax),%edx
+  8002a8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002ab:	89 10                	mov    %edx,(%eax)
+}
+  8002ad:	90                   	nop
+  8002ae:	c9                   	leave  
+  8002af:	c3                   	ret    
+
+008002b0 <vcprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want cprintf() instead.
+ * */
+int
+vcprintf(const char *fmt, va_list ap) {
+  8002b0:	55                   	push   %ebp
+  8002b1:	89 e5                	mov    %esp,%ebp
+  8002b3:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+  8002b6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    vprintfmt((void*)cputch, &cnt, fmt, ap);
+  8002bd:	ff 75 0c             	pushl  0xc(%ebp)
+  8002c0:	ff 75 08             	pushl  0x8(%ebp)
+  8002c3:	8d 45 f4             	lea    -0xc(%ebp),%eax
+  8002c6:	50                   	push   %eax
+  8002c7:	68 8c 02 80 00       	push   $0x80028c
+  8002cc:	e8 fc 06 00 00       	call   8009cd <vprintfmt>
+  8002d1:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+  8002d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8002d7:	c9                   	leave  
+  8002d8:	c3                   	ret    
+
+008002d9 <cprintf>:
+ *
+ * The return value is the number of characters which would be
+ * written to stdout.
+ * */
+int
+cprintf(const char *fmt, ...) {
+  8002d9:	55                   	push   %ebp
+  8002da:	89 e5                	mov    %esp,%ebp
+  8002dc:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  8002df:	8d 45 0c             	lea    0xc(%ebp),%eax
+  8002e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    int cnt = vcprintf(fmt, ap);
+  8002e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8002e8:	83 ec 08             	sub    $0x8,%esp
+  8002eb:	50                   	push   %eax
+  8002ec:	ff 75 08             	pushl  0x8(%ebp)
+  8002ef:	e8 bc ff ff ff       	call   8002b0 <vcprintf>
+  8002f4:	83 c4 10             	add    $0x10,%esp
+  8002f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+
+    return cnt;
+  8002fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8002fd:	c9                   	leave  
+  8002fe:	c3                   	ret    
+
+008002ff <cputs>:
+/* *
+ * cputs- writes the string pointed by @str to stdout and
+ * appends a newline character.
+ * */
+int
+cputs(const char *str) {
+  8002ff:	55                   	push   %ebp
+  800300:	89 e5                	mov    %esp,%ebp
+  800302:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+  800305:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    char c;
+    while ((c = *str ++) != '\0') {
+  80030c:	eb 14                	jmp    800322 <cputs+0x23>
+        cputch(c, &cnt);
+  80030e:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
+  800312:	83 ec 08             	sub    $0x8,%esp
+  800315:	8d 55 f0             	lea    -0x10(%ebp),%edx
+  800318:	52                   	push   %edx
+  800319:	50                   	push   %eax
+  80031a:	e8 6d ff ff ff       	call   80028c <cputch>
+  80031f:	83 c4 10             	add    $0x10,%esp
+ * */
+int
+cputs(const char *str) {
+    int cnt = 0;
+    char c;
+    while ((c = *str ++) != '\0') {
+  800322:	8b 45 08             	mov    0x8(%ebp),%eax
+  800325:	8d 50 01             	lea    0x1(%eax),%edx
+  800328:	89 55 08             	mov    %edx,0x8(%ebp)
+  80032b:	0f b6 00             	movzbl (%eax),%eax
+  80032e:	88 45 f7             	mov    %al,-0x9(%ebp)
+  800331:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
+  800335:	75 d7                	jne    80030e <cputs+0xf>
+        cputch(c, &cnt);
+    }
+    cputch('\n', &cnt);
+  800337:	83 ec 08             	sub    $0x8,%esp
+  80033a:	8d 45 f0             	lea    -0x10(%ebp),%eax
+  80033d:	50                   	push   %eax
+  80033e:	6a 0a                	push   $0xa
+  800340:	e8 47 ff ff ff       	call   80028c <cputch>
+  800345:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+  800348:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+  80034b:	c9                   	leave  
+  80034c:	c3                   	ret    
+
+0080034d <umain>:
+#include <ulib.h>
+
+int main(void);
+
+void
+umain(void) {
+  80034d:	55                   	push   %ebp
+  80034e:	89 e5                	mov    %esp,%ebp
+  800350:	83 ec 18             	sub    $0x18,%esp
+    int ret = main();
+  800353:	e8 00 0c 00 00       	call   800f58 <main>
+  800358:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    exit(ret);
+  80035b:	83 ec 0c             	sub    $0xc,%esp
+  80035e:	ff 75 f4             	pushl  -0xc(%ebp)
+  800361:	e8 51 fe ff ff       	call   8001b7 <exit>
+
+00800366 <strlen>:
+ * @s:      the input string
+ *
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+  800366:	55                   	push   %ebp
+  800367:	89 e5                	mov    %esp,%ebp
+  800369:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  80036c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (*s ++ != '\0') {
+  800373:	eb 04                	jmp    800379 <strlen+0x13>
+        cnt ++;
+  800375:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+    size_t cnt = 0;
+    while (*s ++ != '\0') {
+  800379:	8b 45 08             	mov    0x8(%ebp),%eax
+  80037c:	8d 50 01             	lea    0x1(%eax),%edx
+  80037f:	89 55 08             	mov    %edx,0x8(%ebp)
+  800382:	0f b6 00             	movzbl (%eax),%eax
+  800385:	84 c0                	test   %al,%al
+  800387:	75 ec                	jne    800375 <strlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  800389:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  80038c:	c9                   	leave  
+  80038d:	c3                   	ret    
+
+0080038e <strnlen>:
+ * The return value is strlen(s), if that is less than @len, or
+ * @len if there is no '\0' character among the first @len characters
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+  80038e:	55                   	push   %ebp
+  80038f:	89 e5                	mov    %esp,%ebp
+  800391:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  800394:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (cnt < len && *s ++ != '\0') {
+  80039b:	eb 04                	jmp    8003a1 <strnlen+0x13>
+        cnt ++;
+  80039d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+    size_t cnt = 0;
+    while (cnt < len && *s ++ != '\0') {
+  8003a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8003a4:	3b 45 0c             	cmp    0xc(%ebp),%eax
+  8003a7:	73 10                	jae    8003b9 <strnlen+0x2b>
+  8003a9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003ac:	8d 50 01             	lea    0x1(%eax),%edx
+  8003af:	89 55 08             	mov    %edx,0x8(%ebp)
+  8003b2:	0f b6 00             	movzbl (%eax),%eax
+  8003b5:	84 c0                	test   %al,%al
+  8003b7:	75 e4                	jne    80039d <strnlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  8003b9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  8003bc:	c9                   	leave  
+  8003bd:	c3                   	ret    
+
+008003be <strcpy>:
+ * To avoid overflows, the size of array pointed by @dst should be long enough to
+ * contain the same string as @src (including the terminating null character), and
+ * should not overlap in memory with @src.
+ * */
+char *
+strcpy(char *dst, const char *src) {
+  8003be:	55                   	push   %ebp
+  8003bf:	89 e5                	mov    %esp,%ebp
+  8003c1:	57                   	push   %edi
+  8003c2:	56                   	push   %esi
+  8003c3:	83 ec 20             	sub    $0x20,%esp
+  8003c6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  8003cc:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8003cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCPY
+#define __HAVE_ARCH_STRCPY
+static inline char *
+__strcpy(char *dst, const char *src) {
+    int d0, d1, d2;
+    asm volatile (
+  8003d2:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  8003d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8003d8:	89 d1                	mov    %edx,%ecx
+  8003da:	89 c2                	mov    %eax,%edx
+  8003dc:	89 ce                	mov    %ecx,%esi
+  8003de:	89 d7                	mov    %edx,%edi
+  8003e0:	ac                   	lods   %ds:(%esi),%al
+  8003e1:	aa                   	stos   %al,%es:(%edi)
+  8003e2:	84 c0                	test   %al,%al
+  8003e4:	75 fa                	jne    8003e0 <strcpy+0x22>
+  8003e6:	89 fa                	mov    %edi,%edx
+  8003e8:	89 f1                	mov    %esi,%ecx
+  8003ea:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  8003ed:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  8003f0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+        "stosb;"
+        "testb %%al, %%al;"
+        "jne 1b;"
+        : "=&S" (d0), "=&D" (d1), "=&a" (d2)
+        : "0" (src), "1" (dst) : "memory");
+    return dst;
+  8003f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCPY
+    return __strcpy(dst, src);
+  8003f6:	90                   	nop
+    char *p = dst;
+    while ((*p ++ = *src ++) != '\0')
+        /* nothing */;
+    return dst;
+#endif /* __HAVE_ARCH_STRCPY */
+}
+  8003f7:	83 c4 20             	add    $0x20,%esp
+  8003fa:	5e                   	pop    %esi
+  8003fb:	5f                   	pop    %edi
+  8003fc:	5d                   	pop    %ebp
+  8003fd:	c3                   	ret    
+
+008003fe <strncpy>:
+ * @len:    maximum number of characters to be copied from @src
+ *
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+  8003fe:	55                   	push   %ebp
+  8003ff:	89 e5                	mov    %esp,%ebp
+  800401:	83 ec 10             	sub    $0x10,%esp
+    char *p = dst;
+  800404:	8b 45 08             	mov    0x8(%ebp),%eax
+  800407:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    while (len > 0) {
+  80040a:	eb 21                	jmp    80042d <strncpy+0x2f>
+        if ((*p = *src) != '\0') {
+  80040c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80040f:	0f b6 10             	movzbl (%eax),%edx
+  800412:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800415:	88 10                	mov    %dl,(%eax)
+  800417:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  80041a:	0f b6 00             	movzbl (%eax),%eax
+  80041d:	84 c0                	test   %al,%al
+  80041f:	74 04                	je     800425 <strncpy+0x27>
+            src ++;
+  800421:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+        }
+        p ++, len --;
+  800425:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800429:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+    char *p = dst;
+    while (len > 0) {
+  80042d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800431:	75 d9                	jne    80040c <strncpy+0xe>
+        if ((*p = *src) != '\0') {
+            src ++;
+        }
+        p ++, len --;
+    }
+    return dst;
+  800433:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800436:	c9                   	leave  
+  800437:	c3                   	ret    
+
+00800438 <strcmp>:
+ * - A value greater than zero indicates that the first character that does
+ *   not match has a greater value in @s1 than in @s2;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+strcmp(const char *s1, const char *s2) {
+  800438:	55                   	push   %ebp
+  800439:	89 e5                	mov    %esp,%ebp
+  80043b:	57                   	push   %edi
+  80043c:	56                   	push   %esi
+  80043d:	83 ec 20             	sub    $0x20,%esp
+  800440:	8b 45 08             	mov    0x8(%ebp),%eax
+  800443:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800446:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800449:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCMP
+#define __HAVE_ARCH_STRCMP
+static inline int
+__strcmp(const char *s1, const char *s2) {
+    int d0, d1, ret;
+    asm volatile (
+  80044c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80044f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800452:	89 d1                	mov    %edx,%ecx
+  800454:	89 c2                	mov    %eax,%edx
+  800456:	89 ce                	mov    %ecx,%esi
+  800458:	89 d7                	mov    %edx,%edi
+  80045a:	ac                   	lods   %ds:(%esi),%al
+  80045b:	ae                   	scas   %es:(%edi),%al
+  80045c:	75 08                	jne    800466 <strcmp+0x2e>
+  80045e:	84 c0                	test   %al,%al
+  800460:	75 f8                	jne    80045a <strcmp+0x22>
+  800462:	31 c0                	xor    %eax,%eax
+  800464:	eb 04                	jmp    80046a <strcmp+0x32>
+  800466:	19 c0                	sbb    %eax,%eax
+  800468:	0c 01                	or     $0x1,%al
+  80046a:	89 fa                	mov    %edi,%edx
+  80046c:	89 f1                	mov    %esi,%ecx
+  80046e:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800471:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  800474:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+        "orb $1, %%al;"
+        "3:"
+        : "=a" (ret), "=&S" (d0), "=&D" (d1)
+        : "1" (s1), "2" (s2)
+        : "memory");
+    return ret;
+  800477:	8b 45 ec             	mov    -0x14(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCMP
+    return __strcmp(s1, s2);
+  80047a:	90                   	nop
+    while (*s1 != '\0' && *s1 == *s2) {
+        s1 ++, s2 ++;
+    }
+    return (int)((unsigned char)*s1 - (unsigned char)*s2);
+#endif /* __HAVE_ARCH_STRCMP */
+}
+  80047b:	83 c4 20             	add    $0x20,%esp
+  80047e:	5e                   	pop    %esi
+  80047f:	5f                   	pop    %edi
+  800480:	5d                   	pop    %ebp
+  800481:	c3                   	ret    
+
+00800482 <strncmp>:
+ * they are equal to each other, it continues with the following pairs until
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+  800482:	55                   	push   %ebp
+  800483:	89 e5                	mov    %esp,%ebp
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  800485:	eb 0c                	jmp    800493 <strncmp+0x11>
+        n --, s1 ++, s2 ++;
+  800487:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  80048b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  80048f:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  800493:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800497:	74 1a                	je     8004b3 <strncmp+0x31>
+  800499:	8b 45 08             	mov    0x8(%ebp),%eax
+  80049c:	0f b6 00             	movzbl (%eax),%eax
+  80049f:	84 c0                	test   %al,%al
+  8004a1:	74 10                	je     8004b3 <strncmp+0x31>
+  8004a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004a6:	0f b6 10             	movzbl (%eax),%edx
+  8004a9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004ac:	0f b6 00             	movzbl (%eax),%eax
+  8004af:	38 c2                	cmp    %al,%dl
+  8004b1:	74 d4                	je     800487 <strncmp+0x5>
+        n --, s1 ++, s2 ++;
+    }
+    return (n == 0) ? 0 : (int)((unsigned char)*s1 - (unsigned char)*s2);
+  8004b3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8004b7:	74 18                	je     8004d1 <strncmp+0x4f>
+  8004b9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004bc:	0f b6 00             	movzbl (%eax),%eax
+  8004bf:	0f b6 d0             	movzbl %al,%edx
+  8004c2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004c5:	0f b6 00             	movzbl (%eax),%eax
+  8004c8:	0f b6 c0             	movzbl %al,%eax
+  8004cb:	29 c2                	sub    %eax,%edx
+  8004cd:	89 d0                	mov    %edx,%eax
+  8004cf:	eb 05                	jmp    8004d6 <strncmp+0x54>
+  8004d1:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  8004d6:	5d                   	pop    %ebp
+  8004d7:	c3                   	ret    
+
+008004d8 <strchr>:
+ *
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+  8004d8:	55                   	push   %ebp
+  8004d9:	89 e5                	mov    %esp,%ebp
+  8004db:	83 ec 04             	sub    $0x4,%esp
+  8004de:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004e1:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  8004e4:	eb 14                	jmp    8004fa <strchr+0x22>
+        if (*s == c) {
+  8004e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004e9:	0f b6 00             	movzbl (%eax),%eax
+  8004ec:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  8004ef:	75 05                	jne    8004f6 <strchr+0x1e>
+            return (char *)s;
+  8004f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004f4:	eb 13                	jmp    800509 <strchr+0x31>
+        }
+        s ++;
+  8004f6:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+    while (*s != '\0') {
+  8004fa:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004fd:	0f b6 00             	movzbl (%eax),%eax
+  800500:	84 c0                	test   %al,%al
+  800502:	75 e2                	jne    8004e6 <strchr+0xe>
+        if (*s == c) {
+            return (char *)s;
+        }
+        s ++;
+    }
+    return NULL;
+  800504:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800509:	c9                   	leave  
+  80050a:	c3                   	ret    
+
+0080050b <strfind>:
+ * The strfind() function is like strchr() except that if @c is
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+  80050b:	55                   	push   %ebp
+  80050c:	89 e5                	mov    %esp,%ebp
+  80050e:	83 ec 04             	sub    $0x4,%esp
+  800511:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800514:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  800517:	eb 0f                	jmp    800528 <strfind+0x1d>
+        if (*s == c) {
+  800519:	8b 45 08             	mov    0x8(%ebp),%eax
+  80051c:	0f b6 00             	movzbl (%eax),%eax
+  80051f:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800522:	74 10                	je     800534 <strfind+0x29>
+            break;
+        }
+        s ++;
+  800524:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+    while (*s != '\0') {
+  800528:	8b 45 08             	mov    0x8(%ebp),%eax
+  80052b:	0f b6 00             	movzbl (%eax),%eax
+  80052e:	84 c0                	test   %al,%al
+  800530:	75 e7                	jne    800519 <strfind+0xe>
+  800532:	eb 01                	jmp    800535 <strfind+0x2a>
+        if (*s == c) {
+            break;
+  800534:	90                   	nop
+        }
+        s ++;
+    }
+    return (char *)s;
+  800535:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800538:	c9                   	leave  
+  800539:	c3                   	ret    
+
+0080053a <strtol>:
+ * an optional "0x" or "0X" prefix.
+ *
+ * The strtol() function returns the converted integral number as a long int value.
+ * */
+long
+strtol(const char *s, char **endptr, int base) {
+  80053a:	55                   	push   %ebp
+  80053b:	89 e5                	mov    %esp,%ebp
+  80053d:	83 ec 10             	sub    $0x10,%esp
+    int neg = 0;
+  800540:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    long val = 0;
+  800547:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  80054e:	eb 04                	jmp    800554 <strtol+0x1a>
+        s ++;
+  800550:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+strtol(const char *s, char **endptr, int base) {
+    int neg = 0;
+    long val = 0;
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  800554:	8b 45 08             	mov    0x8(%ebp),%eax
+  800557:	0f b6 00             	movzbl (%eax),%eax
+  80055a:	3c 20                	cmp    $0x20,%al
+  80055c:	74 f2                	je     800550 <strtol+0x16>
+  80055e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800561:	0f b6 00             	movzbl (%eax),%eax
+  800564:	3c 09                	cmp    $0x9,%al
+  800566:	74 e8                	je     800550 <strtol+0x16>
+        s ++;
+    }
+
+    // plus/minus sign
+    if (*s == '+') {
+  800568:	8b 45 08             	mov    0x8(%ebp),%eax
+  80056b:	0f b6 00             	movzbl (%eax),%eax
+  80056e:	3c 2b                	cmp    $0x2b,%al
+  800570:	75 06                	jne    800578 <strtol+0x3e>
+        s ++;
+  800572:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800576:	eb 15                	jmp    80058d <strtol+0x53>
+    }
+    else if (*s == '-') {
+  800578:	8b 45 08             	mov    0x8(%ebp),%eax
+  80057b:	0f b6 00             	movzbl (%eax),%eax
+  80057e:	3c 2d                	cmp    $0x2d,%al
+  800580:	75 0b                	jne    80058d <strtol+0x53>
+        s ++, neg = 1;
+  800582:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800586:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+    }
+
+    // hex or octal base prefix
+    if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x')) {
+  80058d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800591:	74 06                	je     800599 <strtol+0x5f>
+  800593:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+  800597:	75 24                	jne    8005bd <strtol+0x83>
+  800599:	8b 45 08             	mov    0x8(%ebp),%eax
+  80059c:	0f b6 00             	movzbl (%eax),%eax
+  80059f:	3c 30                	cmp    $0x30,%al
+  8005a1:	75 1a                	jne    8005bd <strtol+0x83>
+  8005a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005a6:	83 c0 01             	add    $0x1,%eax
+  8005a9:	0f b6 00             	movzbl (%eax),%eax
+  8005ac:	3c 78                	cmp    $0x78,%al
+  8005ae:	75 0d                	jne    8005bd <strtol+0x83>
+        s += 2, base = 16;
+  8005b0:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+  8005b4:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+  8005bb:	eb 2a                	jmp    8005e7 <strtol+0xad>
+    }
+    else if (base == 0 && s[0] == '0') {
+  8005bd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8005c1:	75 17                	jne    8005da <strtol+0xa0>
+  8005c3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005c6:	0f b6 00             	movzbl (%eax),%eax
+  8005c9:	3c 30                	cmp    $0x30,%al
+  8005cb:	75 0d                	jne    8005da <strtol+0xa0>
+        s ++, base = 8;
+  8005cd:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  8005d1:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+  8005d8:	eb 0d                	jmp    8005e7 <strtol+0xad>
+    }
+    else if (base == 0) {
+  8005da:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8005de:	75 07                	jne    8005e7 <strtol+0xad>
+        base = 10;
+  8005e0:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+    // digits
+    while (1) {
+        int dig;
+
+        if (*s >= '0' && *s <= '9') {
+  8005e7:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005ea:	0f b6 00             	movzbl (%eax),%eax
+  8005ed:	3c 2f                	cmp    $0x2f,%al
+  8005ef:	7e 1b                	jle    80060c <strtol+0xd2>
+  8005f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005f4:	0f b6 00             	movzbl (%eax),%eax
+  8005f7:	3c 39                	cmp    $0x39,%al
+  8005f9:	7f 11                	jg     80060c <strtol+0xd2>
+            dig = *s - '0';
+  8005fb:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005fe:	0f b6 00             	movzbl (%eax),%eax
+  800601:	0f be c0             	movsbl %al,%eax
+  800604:	83 e8 30             	sub    $0x30,%eax
+  800607:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80060a:	eb 48                	jmp    800654 <strtol+0x11a>
+        }
+        else if (*s >= 'a' && *s <= 'z') {
+  80060c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80060f:	0f b6 00             	movzbl (%eax),%eax
+  800612:	3c 60                	cmp    $0x60,%al
+  800614:	7e 1b                	jle    800631 <strtol+0xf7>
+  800616:	8b 45 08             	mov    0x8(%ebp),%eax
+  800619:	0f b6 00             	movzbl (%eax),%eax
+  80061c:	3c 7a                	cmp    $0x7a,%al
+  80061e:	7f 11                	jg     800631 <strtol+0xf7>
+            dig = *s - 'a' + 10;
+  800620:	8b 45 08             	mov    0x8(%ebp),%eax
+  800623:	0f b6 00             	movzbl (%eax),%eax
+  800626:	0f be c0             	movsbl %al,%eax
+  800629:	83 e8 57             	sub    $0x57,%eax
+  80062c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80062f:	eb 23                	jmp    800654 <strtol+0x11a>
+        }
+        else if (*s >= 'A' && *s <= 'Z') {
+  800631:	8b 45 08             	mov    0x8(%ebp),%eax
+  800634:	0f b6 00             	movzbl (%eax),%eax
+  800637:	3c 40                	cmp    $0x40,%al
+  800639:	7e 3c                	jle    800677 <strtol+0x13d>
+  80063b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80063e:	0f b6 00             	movzbl (%eax),%eax
+  800641:	3c 5a                	cmp    $0x5a,%al
+  800643:	7f 32                	jg     800677 <strtol+0x13d>
+            dig = *s - 'A' + 10;
+  800645:	8b 45 08             	mov    0x8(%ebp),%eax
+  800648:	0f b6 00             	movzbl (%eax),%eax
+  80064b:	0f be c0             	movsbl %al,%eax
+  80064e:	83 e8 37             	sub    $0x37,%eax
+  800651:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+  800654:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800657:	3b 45 10             	cmp    0x10(%ebp),%eax
+  80065a:	7d 1a                	jge    800676 <strtol+0x13c>
+            break;
+        }
+        s ++, val = (val * base) + dig;
+  80065c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800660:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800663:	0f af 45 10          	imul   0x10(%ebp),%eax
+  800667:	89 c2                	mov    %eax,%edx
+  800669:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  80066c:	01 d0                	add    %edx,%eax
+  80066e:	89 45 f8             	mov    %eax,-0x8(%ebp)
+        // we don't properly detect overflow!
+    }
+  800671:	e9 71 ff ff ff       	jmp    8005e7 <strtol+0xad>
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+            break;
+  800676:	90                   	nop
+        }
+        s ++, val = (val * base) + dig;
+        // we don't properly detect overflow!
+    }
+
+    if (endptr) {
+  800677:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  80067b:	74 08                	je     800685 <strtol+0x14b>
+        *endptr = (char *) s;
+  80067d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800680:	8b 55 08             	mov    0x8(%ebp),%edx
+  800683:	89 10                	mov    %edx,(%eax)
+    }
+    return (neg ? -val : val);
+  800685:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+  800689:	74 07                	je     800692 <strtol+0x158>
+  80068b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  80068e:	f7 d8                	neg    %eax
+  800690:	eb 03                	jmp    800695 <strtol+0x15b>
+  800692:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  800695:	c9                   	leave  
+  800696:	c3                   	ret    
+
+00800697 <memset>:
+ * @n:      number of bytes to be set to the value
+ *
+ * The memset() function returns @s.
+ * */
+void *
+memset(void *s, char c, size_t n) {
+  800697:	55                   	push   %ebp
+  800698:	89 e5                	mov    %esp,%ebp
+  80069a:	57                   	push   %edi
+  80069b:	83 ec 24             	sub    $0x24,%esp
+  80069e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006a1:	88 45 d8             	mov    %al,-0x28(%ebp)
+#ifdef __HAVE_ARCH_MEMSET
+    return __memset(s, c, n);
+  8006a4:	0f be 45 d8          	movsbl -0x28(%ebp),%eax
+  8006a8:	8b 55 08             	mov    0x8(%ebp),%edx
+  8006ab:	89 55 f8             	mov    %edx,-0x8(%ebp)
+  8006ae:	88 45 f7             	mov    %al,-0x9(%ebp)
+  8006b1:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_MEMSET
+#define __HAVE_ARCH_MEMSET
+static inline void *
+__memset(void *s, char c, size_t n) {
+    int d0, d1;
+    asm volatile (
+  8006b7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+  8006ba:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
+  8006be:	8b 55 f8             	mov    -0x8(%ebp),%edx
+  8006c1:	89 d7                	mov    %edx,%edi
+  8006c3:	f3 aa                	rep stos %al,%es:(%edi)
+  8006c5:	89 fa                	mov    %edi,%edx
+  8006c7:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  8006ca:	89 55 e8             	mov    %edx,-0x18(%ebp)
+        "rep; stosb;"
+        : "=&c" (d0), "=&D" (d1)
+        : "0" (n), "a" (c), "1" (s)
+        : "memory");
+    return s;
+  8006cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8006d0:	90                   	nop
+    while (n -- > 0) {
+        *p ++ = c;
+    }
+    return s;
+#endif /* __HAVE_ARCH_MEMSET */
+}
+  8006d1:	83 c4 24             	add    $0x24,%esp
+  8006d4:	5f                   	pop    %edi
+  8006d5:	5d                   	pop    %ebp
+  8006d6:	c3                   	ret    
+
+008006d7 <memmove>:
+ * @n:      number of bytes to copy
+ *
+ * The memmove() function returns @dst.
+ * */
+void *
+memmove(void *dst, const void *src, size_t n) {
+  8006d7:	55                   	push   %ebp
+  8006d8:	89 e5                	mov    %esp,%ebp
+  8006da:	57                   	push   %edi
+  8006db:	56                   	push   %esi
+  8006dc:	53                   	push   %ebx
+  8006dd:	83 ec 30             	sub    $0x30,%esp
+  8006e0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8006e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8006e6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  8006ec:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006ef:	89 45 e8             	mov    %eax,-0x18(%ebp)
+
+#ifndef __HAVE_ARCH_MEMMOVE
+#define __HAVE_ARCH_MEMMOVE
+static inline void *
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+  8006f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006f5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  8006f8:	73 42                	jae    80073c <memmove+0x65>
+  8006fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006fd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800700:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800703:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800706:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800709:	89 45 dc             	mov    %eax,-0x24(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  80070c:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  80070f:	c1 e8 02             	shr    $0x2,%eax
+  800712:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  800714:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800717:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80071a:	89 d7                	mov    %edx,%edi
+  80071c:	89 c6                	mov    %eax,%esi
+  80071e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800720:	8b 4d dc             	mov    -0x24(%ebp),%ecx
+  800723:	83 e1 03             	and    $0x3,%ecx
+  800726:	74 02                	je     80072a <memmove+0x53>
+  800728:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  80072a:	89 f0                	mov    %esi,%eax
+  80072c:	89 fa                	mov    %edi,%edx
+  80072e:	89 4d d8             	mov    %ecx,-0x28(%ebp)
+  800731:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  800734:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  800737:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMMOVE
+    return __memmove(dst, src, n);
+  80073a:	eb 36                	jmp    800772 <memmove+0x9b>
+    asm volatile (
+        "std;"
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+  80073c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80073f:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800742:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800745:	01 c2                	add    %eax,%edx
+  800747:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80074a:	8d 48 ff             	lea    -0x1(%eax),%ecx
+  80074d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800750:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+        return __memcpy(dst, src, n);
+    }
+    int d0, d1, d2;
+    asm volatile (
+  800753:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800756:	89 c1                	mov    %eax,%ecx
+  800758:	89 d8                	mov    %ebx,%eax
+  80075a:	89 d6                	mov    %edx,%esi
+  80075c:	89 c7                	mov    %eax,%edi
+  80075e:	fd                   	std    
+  80075f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  800761:	fc                   	cld    
+  800762:	89 f8                	mov    %edi,%eax
+  800764:	89 f2                	mov    %esi,%edx
+  800766:	89 4d cc             	mov    %ecx,-0x34(%ebp)
+  800769:	89 55 c8             	mov    %edx,-0x38(%ebp)
+  80076c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+        : "memory");
+    return dst;
+  80076f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+            *d ++ = *s ++;
+        }
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMMOVE */
+}
+  800772:	83 c4 30             	add    $0x30,%esp
+  800775:	5b                   	pop    %ebx
+  800776:	5e                   	pop    %esi
+  800777:	5f                   	pop    %edi
+  800778:	5d                   	pop    %ebp
+  800779:	c3                   	ret    
+
+0080077a <memcpy>:
+ * it always copies exactly @n bytes. To avoid overflows, the size of arrays pointed
+ * by both @src and @dst, should be at least @n bytes, and should not overlap
+ * (for overlapping memory area, memmove is a safer approach).
+ * */
+void *
+memcpy(void *dst, const void *src, size_t n) {
+  80077a:	55                   	push   %ebp
+  80077b:	89 e5                	mov    %esp,%ebp
+  80077d:	57                   	push   %edi
+  80077e:	56                   	push   %esi
+  80077f:	83 ec 20             	sub    $0x20,%esp
+  800782:	8b 45 08             	mov    0x8(%ebp),%eax
+  800785:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800788:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80078b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80078e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800791:	89 45 ec             	mov    %eax,-0x14(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  800794:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800797:	c1 e8 02             	shr    $0x2,%eax
+  80079a:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  80079c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80079f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8007a2:	89 d7                	mov    %edx,%edi
+  8007a4:	89 c6                	mov    %eax,%esi
+  8007a6:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  8007a8:	8b 4d ec             	mov    -0x14(%ebp),%ecx
+  8007ab:	83 e1 03             	and    $0x3,%ecx
+  8007ae:	74 02                	je     8007b2 <memcpy+0x38>
+  8007b0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  8007b2:	89 f0                	mov    %esi,%eax
+  8007b4:	89 fa                	mov    %edi,%edx
+  8007b6:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  8007b9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  8007bc:	89 45 e0             	mov    %eax,-0x20(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  8007bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMCPY
+    return __memcpy(dst, src, n);
+  8007c2:	90                   	nop
+    while (n -- > 0) {
+        *d ++ = *s ++;
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMCPY */
+}
+  8007c3:	83 c4 20             	add    $0x20,%esp
+  8007c6:	5e                   	pop    %esi
+  8007c7:	5f                   	pop    %edi
+  8007c8:	5d                   	pop    %ebp
+  8007c9:	c3                   	ret    
+
+008007ca <memcmp>:
+ *   match in both memory blocks has a greater value in @v1 than in @v2
+ *   as if evaluated as unsigned char values;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+  8007ca:	55                   	push   %ebp
+  8007cb:	89 e5                	mov    %esp,%ebp
+  8007cd:	83 ec 10             	sub    $0x10,%esp
+    const char *s1 = (const char *)v1;
+  8007d0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8007d3:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    const char *s2 = (const char *)v2;
+  8007d6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8007d9:	89 45 f8             	mov    %eax,-0x8(%ebp)
+    while (n -- > 0) {
+  8007dc:	eb 30                	jmp    80080e <memcmp+0x44>
+        if (*s1 != *s2) {
+  8007de:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8007e1:	0f b6 10             	movzbl (%eax),%edx
+  8007e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8007e7:	0f b6 00             	movzbl (%eax),%eax
+  8007ea:	38 c2                	cmp    %al,%dl
+  8007ec:	74 18                	je     800806 <memcmp+0x3c>
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+  8007ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8007f1:	0f b6 00             	movzbl (%eax),%eax
+  8007f4:	0f b6 d0             	movzbl %al,%edx
+  8007f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8007fa:	0f b6 00             	movzbl (%eax),%eax
+  8007fd:	0f b6 c0             	movzbl %al,%eax
+  800800:	29 c2                	sub    %eax,%edx
+  800802:	89 d0                	mov    %edx,%eax
+  800804:	eb 1a                	jmp    800820 <memcmp+0x56>
+        }
+        s1 ++, s2 ++;
+  800806:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  80080a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+    const char *s1 = (const char *)v1;
+    const char *s2 = (const char *)v2;
+    while (n -- > 0) {
+  80080e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800811:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800814:	89 55 10             	mov    %edx,0x10(%ebp)
+  800817:	85 c0                	test   %eax,%eax
+  800819:	75 c3                	jne    8007de <memcmp+0x14>
+        if (*s1 != *s2) {
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+        }
+        s1 ++, s2 ++;
+    }
+    return 0;
+  80081b:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800820:	c9                   	leave  
+  800821:	c3                   	ret    
+
+00800822 <printnum>:
+ * @width:      maximum number of digits, if the actual width is less than @width, use @padc instead
+ * @padc:       character that padded on the left if the actual width is less than @width
+ * */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+        unsigned long long num, unsigned base, int width, int padc) {
+  800822:	55                   	push   %ebp
+  800823:	89 e5                	mov    %esp,%ebp
+  800825:	83 ec 38             	sub    $0x38,%esp
+  800828:	8b 45 10             	mov    0x10(%ebp),%eax
+  80082b:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  80082e:	8b 45 14             	mov    0x14(%ebp),%eax
+  800831:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+    unsigned long long result = num;
+  800834:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  800837:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  80083a:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  80083d:	89 55 ec             	mov    %edx,-0x14(%ebp)
+    unsigned mod = do_div(result, base);
+  800840:	8b 45 18             	mov    0x18(%ebp),%eax
+  800843:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800846:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800849:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  80084c:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  80084f:	89 55 f0             	mov    %edx,-0x10(%ebp)
+  800852:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800855:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800858:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  80085c:	74 1c                	je     80087a <printnum+0x58>
+  80085e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800861:	ba 00 00 00 00       	mov    $0x0,%edx
+  800866:	f7 75 e4             	divl   -0x1c(%ebp)
+  800869:	89 55 f4             	mov    %edx,-0xc(%ebp)
+  80086c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  80086f:	ba 00 00 00 00       	mov    $0x0,%edx
+  800874:	f7 75 e4             	divl   -0x1c(%ebp)
+  800877:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80087a:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80087d:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800880:	f7 75 e4             	divl   -0x1c(%ebp)
+  800883:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800886:	89 55 dc             	mov    %edx,-0x24(%ebp)
+  800889:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80088c:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  80088f:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800892:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  800895:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  800898:	89 45 d8             	mov    %eax,-0x28(%ebp)
+
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+  80089b:	8b 45 18             	mov    0x18(%ebp),%eax
+  80089e:	ba 00 00 00 00       	mov    $0x0,%edx
+  8008a3:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  8008a6:	77 41                	ja     8008e9 <printnum+0xc7>
+  8008a8:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  8008ab:	72 05                	jb     8008b2 <printnum+0x90>
+  8008ad:	3b 45 d0             	cmp    -0x30(%ebp),%eax
+  8008b0:	77 37                	ja     8008e9 <printnum+0xc7>
+        printnum(putch, putdat, result, base, width - 1, padc);
+  8008b2:	8b 45 1c             	mov    0x1c(%ebp),%eax
+  8008b5:	83 e8 01             	sub    $0x1,%eax
+  8008b8:	83 ec 04             	sub    $0x4,%esp
+  8008bb:	ff 75 20             	pushl  0x20(%ebp)
+  8008be:	50                   	push   %eax
+  8008bf:	ff 75 18             	pushl  0x18(%ebp)
+  8008c2:	ff 75 ec             	pushl  -0x14(%ebp)
+  8008c5:	ff 75 e8             	pushl  -0x18(%ebp)
+  8008c8:	ff 75 0c             	pushl  0xc(%ebp)
+  8008cb:	ff 75 08             	pushl  0x8(%ebp)
+  8008ce:	e8 4f ff ff ff       	call   800822 <printnum>
+  8008d3:	83 c4 20             	add    $0x20,%esp
+  8008d6:	eb 1b                	jmp    8008f3 <printnum+0xd1>
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+            putch(padc, putdat);
+  8008d8:	83 ec 08             	sub    $0x8,%esp
+  8008db:	ff 75 0c             	pushl  0xc(%ebp)
+  8008de:	ff 75 20             	pushl  0x20(%ebp)
+  8008e1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8008e4:	ff d0                	call   *%eax
+  8008e6:	83 c4 10             	add    $0x10,%esp
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+        printnum(putch, putdat, result, base, width - 1, padc);
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+  8008e9:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+  8008ed:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+  8008f1:	7f e5                	jg     8008d8 <printnum+0xb6>
+            putch(padc, putdat);
+    }
+    // then print this (the least significant) digit
+    putch("0123456789abcdef"[mod], putdat);
+  8008f3:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  8008f6:	05 44 13 80 00       	add    $0x801344,%eax
+  8008fb:	0f b6 00             	movzbl (%eax),%eax
+  8008fe:	0f be c0             	movsbl %al,%eax
+  800901:	83 ec 08             	sub    $0x8,%esp
+  800904:	ff 75 0c             	pushl  0xc(%ebp)
+  800907:	50                   	push   %eax
+  800908:	8b 45 08             	mov    0x8(%ebp),%eax
+  80090b:	ff d0                	call   *%eax
+  80090d:	83 c4 10             	add    $0x10,%esp
+}
+  800910:	90                   	nop
+  800911:	c9                   	leave  
+  800912:	c3                   	ret    
+
+00800913 <getuint>:
+ * getuint - get an unsigned int of various possible sizes from a varargs list
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static unsigned long long
+getuint(va_list *ap, int lflag) {
+  800913:	55                   	push   %ebp
+  800914:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  800916:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  80091a:	7e 14                	jle    800930 <getuint+0x1d>
+        return va_arg(*ap, unsigned long long);
+  80091c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80091f:	8b 00                	mov    (%eax),%eax
+  800921:	8d 48 08             	lea    0x8(%eax),%ecx
+  800924:	8b 55 08             	mov    0x8(%ebp),%edx
+  800927:	89 0a                	mov    %ecx,(%edx)
+  800929:	8b 50 04             	mov    0x4(%eax),%edx
+  80092c:	8b 00                	mov    (%eax),%eax
+  80092e:	eb 30                	jmp    800960 <getuint+0x4d>
+    }
+    else if (lflag) {
+  800930:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800934:	74 16                	je     80094c <getuint+0x39>
+        return va_arg(*ap, unsigned long);
+  800936:	8b 45 08             	mov    0x8(%ebp),%eax
+  800939:	8b 00                	mov    (%eax),%eax
+  80093b:	8d 48 04             	lea    0x4(%eax),%ecx
+  80093e:	8b 55 08             	mov    0x8(%ebp),%edx
+  800941:	89 0a                	mov    %ecx,(%edx)
+  800943:	8b 00                	mov    (%eax),%eax
+  800945:	ba 00 00 00 00       	mov    $0x0,%edx
+  80094a:	eb 14                	jmp    800960 <getuint+0x4d>
+    }
+    else {
+        return va_arg(*ap, unsigned int);
+  80094c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80094f:	8b 00                	mov    (%eax),%eax
+  800951:	8d 48 04             	lea    0x4(%eax),%ecx
+  800954:	8b 55 08             	mov    0x8(%ebp),%edx
+  800957:	89 0a                	mov    %ecx,(%edx)
+  800959:	8b 00                	mov    (%eax),%eax
+  80095b:	ba 00 00 00 00       	mov    $0x0,%edx
+    }
+}
+  800960:	5d                   	pop    %ebp
+  800961:	c3                   	ret    
+
+00800962 <getint>:
+ * getint - same as getuint but signed, we can't use getuint because of sign extension
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static long long
+getint(va_list *ap, int lflag) {
+  800962:	55                   	push   %ebp
+  800963:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  800965:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  800969:	7e 14                	jle    80097f <getint+0x1d>
+        return va_arg(*ap, long long);
+  80096b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80096e:	8b 00                	mov    (%eax),%eax
+  800970:	8d 48 08             	lea    0x8(%eax),%ecx
+  800973:	8b 55 08             	mov    0x8(%ebp),%edx
+  800976:	89 0a                	mov    %ecx,(%edx)
+  800978:	8b 50 04             	mov    0x4(%eax),%edx
+  80097b:	8b 00                	mov    (%eax),%eax
+  80097d:	eb 28                	jmp    8009a7 <getint+0x45>
+    }
+    else if (lflag) {
+  80097f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800983:	74 12                	je     800997 <getint+0x35>
+        return va_arg(*ap, long);
+  800985:	8b 45 08             	mov    0x8(%ebp),%eax
+  800988:	8b 00                	mov    (%eax),%eax
+  80098a:	8d 48 04             	lea    0x4(%eax),%ecx
+  80098d:	8b 55 08             	mov    0x8(%ebp),%edx
+  800990:	89 0a                	mov    %ecx,(%edx)
+  800992:	8b 00                	mov    (%eax),%eax
+  800994:	99                   	cltd   
+  800995:	eb 10                	jmp    8009a7 <getint+0x45>
+    }
+    else {
+        return va_arg(*ap, int);
+  800997:	8b 45 08             	mov    0x8(%ebp),%eax
+  80099a:	8b 00                	mov    (%eax),%eax
+  80099c:	8d 48 04             	lea    0x4(%eax),%ecx
+  80099f:	8b 55 08             	mov    0x8(%ebp),%edx
+  8009a2:	89 0a                	mov    %ecx,(%edx)
+  8009a4:	8b 00                	mov    (%eax),%eax
+  8009a6:	99                   	cltd   
+    }
+}
+  8009a7:	5d                   	pop    %ebp
+  8009a8:	c3                   	ret    
+
+008009a9 <printfmt>:
+ * @putch:      specified putch function, print a single character
+ * @putdat:     used by @putch function
+ * @fmt:        the format string to use
+ * */
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...) {
+  8009a9:	55                   	push   %ebp
+  8009aa:	89 e5                	mov    %esp,%ebp
+  8009ac:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  8009af:	8d 45 14             	lea    0x14(%ebp),%eax
+  8009b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    vprintfmt(putch, putdat, fmt, ap);
+  8009b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8009b8:	50                   	push   %eax
+  8009b9:	ff 75 10             	pushl  0x10(%ebp)
+  8009bc:	ff 75 0c             	pushl  0xc(%ebp)
+  8009bf:	ff 75 08             	pushl  0x8(%ebp)
+  8009c2:	e8 06 00 00 00       	call   8009cd <vprintfmt>
+  8009c7:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+  8009ca:	90                   	nop
+  8009cb:	c9                   	leave  
+  8009cc:	c3                   	ret    
+
+008009cd <vprintfmt>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want printfmt() instead.
+ * */
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap) {
+  8009cd:	55                   	push   %ebp
+  8009ce:	89 e5                	mov    %esp,%ebp
+  8009d0:	56                   	push   %esi
+  8009d1:	53                   	push   %ebx
+  8009d2:	83 ec 20             	sub    $0x20,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  8009d5:	eb 17                	jmp    8009ee <vprintfmt+0x21>
+            if (ch == '\0') {
+  8009d7:	85 db                	test   %ebx,%ebx
+  8009d9:	0f 84 8e 03 00 00    	je     800d6d <vprintfmt+0x3a0>
+                return;
+            }
+            putch(ch, putdat);
+  8009df:	83 ec 08             	sub    $0x8,%esp
+  8009e2:	ff 75 0c             	pushl  0xc(%ebp)
+  8009e5:	53                   	push   %ebx
+  8009e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009e9:	ff d0                	call   *%eax
+  8009eb:	83 c4 10             	add    $0x10,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  8009ee:	8b 45 10             	mov    0x10(%ebp),%eax
+  8009f1:	8d 50 01             	lea    0x1(%eax),%edx
+  8009f4:	89 55 10             	mov    %edx,0x10(%ebp)
+  8009f7:	0f b6 00             	movzbl (%eax),%eax
+  8009fa:	0f b6 d8             	movzbl %al,%ebx
+  8009fd:	83 fb 25             	cmp    $0x25,%ebx
+  800a00:	75 d5                	jne    8009d7 <vprintfmt+0xa>
+            }
+            putch(ch, putdat);
+        }
+
+        // Process a %-escape sequence
+        char padc = ' ';
+  800a02:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+        width = precision = -1;
+  800a06:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+  800a0d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800a10:	89 45 e8             	mov    %eax,-0x18(%ebp)
+        lflag = altflag = 0;
+  800a13:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+  800a1a:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  800a1d:	89 45 e0             	mov    %eax,-0x20(%ebp)
+
+    reswitch:
+        switch (ch = *(unsigned char *)fmt ++) {
+  800a20:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a23:	8d 50 01             	lea    0x1(%eax),%edx
+  800a26:	89 55 10             	mov    %edx,0x10(%ebp)
+  800a29:	0f b6 00             	movzbl (%eax),%eax
+  800a2c:	0f b6 d8             	movzbl %al,%ebx
+  800a2f:	8d 43 dd             	lea    -0x23(%ebx),%eax
+  800a32:	83 f8 55             	cmp    $0x55,%eax
+  800a35:	0f 87 05 03 00 00    	ja     800d40 <vprintfmt+0x373>
+  800a3b:	8b 04 85 68 13 80 00 	mov    0x801368(,%eax,4),%eax
+  800a42:	ff e0                	jmp    *%eax
+
+        // flag to pad on the right
+        case '-':
+            padc = '-';
+  800a44:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+            goto reswitch;
+  800a48:	eb d6                	jmp    800a20 <vprintfmt+0x53>
+
+        // flag to pad with 0's instead of spaces
+        case '0':
+            padc = '0';
+  800a4a:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+            goto reswitch;
+  800a4e:	eb d0                	jmp    800a20 <vprintfmt+0x53>
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  800a50:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+                precision = precision * 10 + ch - '0';
+  800a57:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800a5a:	89 d0                	mov    %edx,%eax
+  800a5c:	c1 e0 02             	shl    $0x2,%eax
+  800a5f:	01 d0                	add    %edx,%eax
+  800a61:	01 c0                	add    %eax,%eax
+  800a63:	01 d8                	add    %ebx,%eax
+  800a65:	83 e8 30             	sub    $0x30,%eax
+  800a68:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+                ch = *fmt;
+  800a6b:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a6e:	0f b6 00             	movzbl (%eax),%eax
+  800a71:	0f be d8             	movsbl %al,%ebx
+                if (ch < '0' || ch > '9') {
+  800a74:	83 fb 2f             	cmp    $0x2f,%ebx
+  800a77:	7e 39                	jle    800ab2 <vprintfmt+0xe5>
+  800a79:	83 fb 39             	cmp    $0x39,%ebx
+  800a7c:	7f 34                	jg     800ab2 <vprintfmt+0xe5>
+            padc = '0';
+            goto reswitch;
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  800a7e:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+                precision = precision * 10 + ch - '0';
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+  800a82:	eb d3                	jmp    800a57 <vprintfmt+0x8a>
+            goto process_precision;
+
+        case '*':
+            precision = va_arg(ap, int);
+  800a84:	8b 45 14             	mov    0x14(%ebp),%eax
+  800a87:	8d 50 04             	lea    0x4(%eax),%edx
+  800a8a:	89 55 14             	mov    %edx,0x14(%ebp)
+  800a8d:	8b 00                	mov    (%eax),%eax
+  800a8f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+            goto process_precision;
+  800a92:	eb 1f                	jmp    800ab3 <vprintfmt+0xe6>
+
+        case '.':
+            if (width < 0)
+  800a94:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800a98:	79 86                	jns    800a20 <vprintfmt+0x53>
+                width = 0;
+  800a9a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+            goto reswitch;
+  800aa1:	e9 7a ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        case '#':
+            altflag = 1;
+  800aa6:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+            goto reswitch;
+  800aad:	e9 6e ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+            goto process_precision;
+  800ab2:	90                   	nop
+        case '#':
+            altflag = 1;
+            goto reswitch;
+
+        process_precision:
+            if (width < 0)
+  800ab3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ab7:	0f 89 63 ff ff ff    	jns    800a20 <vprintfmt+0x53>
+                width = precision, precision = -1;
+  800abd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800ac0:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800ac3:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+            goto reswitch;
+  800aca:	e9 51 ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        // long flag (doubled for long long)
+        case 'l':
+            lflag ++;
+  800acf:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
+            goto reswitch;
+  800ad3:	e9 48 ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        // character
+        case 'c':
+            putch(va_arg(ap, int), putdat);
+  800ad8:	8b 45 14             	mov    0x14(%ebp),%eax
+  800adb:	8d 50 04             	lea    0x4(%eax),%edx
+  800ade:	89 55 14             	mov    %edx,0x14(%ebp)
+  800ae1:	8b 00                	mov    (%eax),%eax
+  800ae3:	83 ec 08             	sub    $0x8,%esp
+  800ae6:	ff 75 0c             	pushl  0xc(%ebp)
+  800ae9:	50                   	push   %eax
+  800aea:	8b 45 08             	mov    0x8(%ebp),%eax
+  800aed:	ff d0                	call   *%eax
+  800aef:	83 c4 10             	add    $0x10,%esp
+            break;
+  800af2:	e9 71 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // error message
+        case 'e':
+            err = va_arg(ap, int);
+  800af7:	8b 45 14             	mov    0x14(%ebp),%eax
+  800afa:	8d 50 04             	lea    0x4(%eax),%edx
+  800afd:	89 55 14             	mov    %edx,0x14(%ebp)
+  800b00:	8b 18                	mov    (%eax),%ebx
+            if (err < 0) {
+  800b02:	85 db                	test   %ebx,%ebx
+  800b04:	79 02                	jns    800b08 <vprintfmt+0x13b>
+                err = -err;
+  800b06:	f7 db                	neg    %ebx
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+  800b08:	83 fb 18             	cmp    $0x18,%ebx
+  800b0b:	7f 0b                	jg     800b18 <vprintfmt+0x14b>
+  800b0d:	8b 34 9d e0 12 80 00 	mov    0x8012e0(,%ebx,4),%esi
+  800b14:	85 f6                	test   %esi,%esi
+  800b16:	75 19                	jne    800b31 <vprintfmt+0x164>
+                printfmt(putch, putdat, "error %d", err);
+  800b18:	53                   	push   %ebx
+  800b19:	68 55 13 80 00       	push   $0x801355
+  800b1e:	ff 75 0c             	pushl  0xc(%ebp)
+  800b21:	ff 75 08             	pushl  0x8(%ebp)
+  800b24:	e8 80 fe ff ff       	call   8009a9 <printfmt>
+  800b29:	83 c4 10             	add    $0x10,%esp
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+            }
+            break;
+  800b2c:	e9 37 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+                printfmt(putch, putdat, "error %d", err);
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+  800b31:	56                   	push   %esi
+  800b32:	68 5e 13 80 00       	push   $0x80135e
+  800b37:	ff 75 0c             	pushl  0xc(%ebp)
+  800b3a:	ff 75 08             	pushl  0x8(%ebp)
+  800b3d:	e8 67 fe ff ff       	call   8009a9 <printfmt>
+  800b42:	83 c4 10             	add    $0x10,%esp
+            }
+            break;
+  800b45:	e9 1e 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // string
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+  800b4a:	8b 45 14             	mov    0x14(%ebp),%eax
+  800b4d:	8d 50 04             	lea    0x4(%eax),%edx
+  800b50:	89 55 14             	mov    %edx,0x14(%ebp)
+  800b53:	8b 30                	mov    (%eax),%esi
+  800b55:	85 f6                	test   %esi,%esi
+  800b57:	75 05                	jne    800b5e <vprintfmt+0x191>
+                p = "(null)";
+  800b59:	be 61 13 80 00       	mov    $0x801361,%esi
+            }
+            if (width > 0 && padc != '-') {
+  800b5e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800b62:	7e 76                	jle    800bda <vprintfmt+0x20d>
+  800b64:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+  800b68:	74 70                	je     800bda <vprintfmt+0x20d>
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  800b6a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800b6d:	83 ec 08             	sub    $0x8,%esp
+  800b70:	50                   	push   %eax
+  800b71:	56                   	push   %esi
+  800b72:	e8 17 f8 ff ff       	call   80038e <strnlen>
+  800b77:	83 c4 10             	add    $0x10,%esp
+  800b7a:	89 c2                	mov    %eax,%edx
+  800b7c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800b7f:	29 d0                	sub    %edx,%eax
+  800b81:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800b84:	eb 17                	jmp    800b9d <vprintfmt+0x1d0>
+                    putch(padc, putdat);
+  800b86:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+  800b8a:	83 ec 08             	sub    $0x8,%esp
+  800b8d:	ff 75 0c             	pushl  0xc(%ebp)
+  800b90:	50                   	push   %eax
+  800b91:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b94:	ff d0                	call   *%eax
+  800b96:	83 c4 10             	add    $0x10,%esp
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+                p = "(null)";
+            }
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  800b99:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800b9d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ba1:	7f e3                	jg     800b86 <vprintfmt+0x1b9>
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  800ba3:	eb 35                	jmp    800bda <vprintfmt+0x20d>
+                if (altflag && (ch < ' ' || ch > '~')) {
+  800ba5:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+  800ba9:	74 1c                	je     800bc7 <vprintfmt+0x1fa>
+  800bab:	83 fb 1f             	cmp    $0x1f,%ebx
+  800bae:	7e 05                	jle    800bb5 <vprintfmt+0x1e8>
+  800bb0:	83 fb 7e             	cmp    $0x7e,%ebx
+  800bb3:	7e 12                	jle    800bc7 <vprintfmt+0x1fa>
+                    putch('?', putdat);
+  800bb5:	83 ec 08             	sub    $0x8,%esp
+  800bb8:	ff 75 0c             	pushl  0xc(%ebp)
+  800bbb:	6a 3f                	push   $0x3f
+  800bbd:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bc0:	ff d0                	call   *%eax
+  800bc2:	83 c4 10             	add    $0x10,%esp
+  800bc5:	eb 0f                	jmp    800bd6 <vprintfmt+0x209>
+                }
+                else {
+                    putch(ch, putdat);
+  800bc7:	83 ec 08             	sub    $0x8,%esp
+  800bca:	ff 75 0c             	pushl  0xc(%ebp)
+  800bcd:	53                   	push   %ebx
+  800bce:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bd1:	ff d0                	call   *%eax
+  800bd3:	83 c4 10             	add    $0x10,%esp
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  800bd6:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800bda:	89 f0                	mov    %esi,%eax
+  800bdc:	8d 70 01             	lea    0x1(%eax),%esi
+  800bdf:	0f b6 00             	movzbl (%eax),%eax
+  800be2:	0f be d8             	movsbl %al,%ebx
+  800be5:	85 db                	test   %ebx,%ebx
+  800be7:	74 26                	je     800c0f <vprintfmt+0x242>
+  800be9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800bed:	78 b6                	js     800ba5 <vprintfmt+0x1d8>
+  800bef:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800bf3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800bf7:	79 ac                	jns    800ba5 <vprintfmt+0x1d8>
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  800bf9:	eb 14                	jmp    800c0f <vprintfmt+0x242>
+                putch(' ', putdat);
+  800bfb:	83 ec 08             	sub    $0x8,%esp
+  800bfe:	ff 75 0c             	pushl  0xc(%ebp)
+  800c01:	6a 20                	push   $0x20
+  800c03:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c06:	ff d0                	call   *%eax
+  800c08:	83 c4 10             	add    $0x10,%esp
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  800c0b:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800c0f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800c13:	7f e6                	jg     800bfb <vprintfmt+0x22e>
+                putch(' ', putdat);
+            }
+            break;
+  800c15:	e9 4e 01 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // (signed) decimal
+        case 'd':
+            num = getint(&ap, lflag);
+  800c1a:	83 ec 08             	sub    $0x8,%esp
+  800c1d:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c20:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c23:	50                   	push   %eax
+  800c24:	e8 39 fd ff ff       	call   800962 <getint>
+  800c29:	83 c4 10             	add    $0x10,%esp
+  800c2c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c2f:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            if ((long long)num < 0) {
+  800c32:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c35:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800c38:	85 d2                	test   %edx,%edx
+  800c3a:	79 23                	jns    800c5f <vprintfmt+0x292>
+                putch('-', putdat);
+  800c3c:	83 ec 08             	sub    $0x8,%esp
+  800c3f:	ff 75 0c             	pushl  0xc(%ebp)
+  800c42:	6a 2d                	push   $0x2d
+  800c44:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c47:	ff d0                	call   *%eax
+  800c49:	83 c4 10             	add    $0x10,%esp
+                num = -(long long)num;
+  800c4c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c4f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800c52:	f7 d8                	neg    %eax
+  800c54:	83 d2 00             	adc    $0x0,%edx
+  800c57:	f7 da                	neg    %edx
+  800c59:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c5c:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            }
+            base = 10;
+  800c5f:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  800c66:	e9 9f 00 00 00       	jmp    800d0a <vprintfmt+0x33d>
+
+        // unsigned decimal
+        case 'u':
+            num = getuint(&ap, lflag);
+  800c6b:	83 ec 08             	sub    $0x8,%esp
+  800c6e:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c71:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c74:	50                   	push   %eax
+  800c75:	e8 99 fc ff ff       	call   800913 <getuint>
+  800c7a:	83 c4 10             	add    $0x10,%esp
+  800c7d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c80:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 10;
+  800c83:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  800c8a:	eb 7e                	jmp    800d0a <vprintfmt+0x33d>
+
+        // (unsigned) octal
+        case 'o':
+            num = getuint(&ap, lflag);
+  800c8c:	83 ec 08             	sub    $0x8,%esp
+  800c8f:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c92:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c95:	50                   	push   %eax
+  800c96:	e8 78 fc ff ff       	call   800913 <getuint>
+  800c9b:	83 c4 10             	add    $0x10,%esp
+  800c9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800ca1:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 8;
+  800ca4:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+            goto number;
+  800cab:	eb 5d                	jmp    800d0a <vprintfmt+0x33d>
+
+        // pointer
+        case 'p':
+            putch('0', putdat);
+  800cad:	83 ec 08             	sub    $0x8,%esp
+  800cb0:	ff 75 0c             	pushl  0xc(%ebp)
+  800cb3:	6a 30                	push   $0x30
+  800cb5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cb8:	ff d0                	call   *%eax
+  800cba:	83 c4 10             	add    $0x10,%esp
+            putch('x', putdat);
+  800cbd:	83 ec 08             	sub    $0x8,%esp
+  800cc0:	ff 75 0c             	pushl  0xc(%ebp)
+  800cc3:	6a 78                	push   $0x78
+  800cc5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cc8:	ff d0                	call   *%eax
+  800cca:	83 c4 10             	add    $0x10,%esp
+            num = (unsigned long long)(uintptr_t)va_arg(ap, void *);
+  800ccd:	8b 45 14             	mov    0x14(%ebp),%eax
+  800cd0:	8d 50 04             	lea    0x4(%eax),%edx
+  800cd3:	89 55 14             	mov    %edx,0x14(%ebp)
+  800cd6:	8b 00                	mov    (%eax),%eax
+  800cd8:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800cdb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+            base = 16;
+  800ce2:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+            goto number;
+  800ce9:	eb 1f                	jmp    800d0a <vprintfmt+0x33d>
+
+        // (unsigned) hexadecimal
+        case 'x':
+            num = getuint(&ap, lflag);
+  800ceb:	83 ec 08             	sub    $0x8,%esp
+  800cee:	ff 75 e0             	pushl  -0x20(%ebp)
+  800cf1:	8d 45 14             	lea    0x14(%ebp),%eax
+  800cf4:	50                   	push   %eax
+  800cf5:	e8 19 fc ff ff       	call   800913 <getuint>
+  800cfa:	83 c4 10             	add    $0x10,%esp
+  800cfd:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800d00:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 16;
+  800d03:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+        number:
+            printnum(putch, putdat, num, base, width, padc);
+  800d0a:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+  800d0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800d11:	83 ec 04             	sub    $0x4,%esp
+  800d14:	52                   	push   %edx
+  800d15:	ff 75 e8             	pushl  -0x18(%ebp)
+  800d18:	50                   	push   %eax
+  800d19:	ff 75 f4             	pushl  -0xc(%ebp)
+  800d1c:	ff 75 f0             	pushl  -0x10(%ebp)
+  800d1f:	ff 75 0c             	pushl  0xc(%ebp)
+  800d22:	ff 75 08             	pushl  0x8(%ebp)
+  800d25:	e8 f8 fa ff ff       	call   800822 <printnum>
+  800d2a:	83 c4 20             	add    $0x20,%esp
+            break;
+  800d2d:	eb 39                	jmp    800d68 <vprintfmt+0x39b>
+
+        // escaped '%' character
+        case '%':
+            putch(ch, putdat);
+  800d2f:	83 ec 08             	sub    $0x8,%esp
+  800d32:	ff 75 0c             	pushl  0xc(%ebp)
+  800d35:	53                   	push   %ebx
+  800d36:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d39:	ff d0                	call   *%eax
+  800d3b:	83 c4 10             	add    $0x10,%esp
+            break;
+  800d3e:	eb 28                	jmp    800d68 <vprintfmt+0x39b>
+
+        // unrecognized escape sequence - just print it literally
+        default:
+            putch('%', putdat);
+  800d40:	83 ec 08             	sub    $0x8,%esp
+  800d43:	ff 75 0c             	pushl  0xc(%ebp)
+  800d46:	6a 25                	push   $0x25
+  800d48:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d4b:	ff d0                	call   *%eax
+  800d4d:	83 c4 10             	add    $0x10,%esp
+            for (fmt --; fmt[-1] != '%'; fmt --)
+  800d50:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800d54:	eb 04                	jmp    800d5a <vprintfmt+0x38d>
+  800d56:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800d5a:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d5d:	83 e8 01             	sub    $0x1,%eax
+  800d60:	0f b6 00             	movzbl (%eax),%eax
+  800d63:	3c 25                	cmp    $0x25,%al
+  800d65:	75 ef                	jne    800d56 <vprintfmt+0x389>
+                /* do nothing */;
+            break;
+  800d67:	90                   	nop
+        }
+    }
+  800d68:	e9 68 fc ff ff       	jmp    8009d5 <vprintfmt+0x8>
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+            if (ch == '\0') {
+                return;
+  800d6d:	90                   	nop
+            for (fmt --; fmt[-1] != '%'; fmt --)
+                /* do nothing */;
+            break;
+        }
+    }
+}
+  800d6e:	8d 65 f8             	lea    -0x8(%ebp),%esp
+  800d71:	5b                   	pop    %ebx
+  800d72:	5e                   	pop    %esi
+  800d73:	5d                   	pop    %ebp
+  800d74:	c3                   	ret    
+
+00800d75 <sprintputch>:
+ * sprintputch - 'print' a single character in a buffer
+ * @ch:         the character will be printed
+ * @b:          the buffer to place the character @ch
+ * */
+static void
+sprintputch(int ch, struct sprintbuf *b) {
+  800d75:	55                   	push   %ebp
+  800d76:	89 e5                	mov    %esp,%ebp
+    b->cnt ++;
+  800d78:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d7b:	8b 40 08             	mov    0x8(%eax),%eax
+  800d7e:	8d 50 01             	lea    0x1(%eax),%edx
+  800d81:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d84:	89 50 08             	mov    %edx,0x8(%eax)
+    if (b->buf < b->ebuf) {
+  800d87:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8a:	8b 10                	mov    (%eax),%edx
+  800d8c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8f:	8b 40 04             	mov    0x4(%eax),%eax
+  800d92:	39 c2                	cmp    %eax,%edx
+  800d94:	73 12                	jae    800da8 <sprintputch+0x33>
+        *b->buf ++ = ch;
+  800d96:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d99:	8b 00                	mov    (%eax),%eax
+  800d9b:	8d 48 01             	lea    0x1(%eax),%ecx
+  800d9e:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800da1:	89 0a                	mov    %ecx,(%edx)
+  800da3:	8b 55 08             	mov    0x8(%ebp),%edx
+  800da6:	88 10                	mov    %dl,(%eax)
+    }
+}
+  800da8:	90                   	nop
+  800da9:	5d                   	pop    %ebp
+  800daa:	c3                   	ret    
+
+00800dab <snprintf>:
+ * @str:        the buffer to place the result into
+ * @size:       the size of buffer, including the trailing null space
+ * @fmt:        the format string to use
+ * */
+int
+snprintf(char *str, size_t size, const char *fmt, ...) {
+  800dab:	55                   	push   %ebp
+  800dac:	89 e5                	mov    %esp,%ebp
+  800dae:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    int cnt;
+    va_start(ap, fmt);
+  800db1:	8d 45 14             	lea    0x14(%ebp),%eax
+  800db4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    cnt = vsnprintf(str, size, fmt, ap);
+  800db7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800dba:	50                   	push   %eax
+  800dbb:	ff 75 10             	pushl  0x10(%ebp)
+  800dbe:	ff 75 0c             	pushl  0xc(%ebp)
+  800dc1:	ff 75 08             	pushl  0x8(%ebp)
+  800dc4:	e8 0b 00 00 00       	call   800dd4 <vsnprintf>
+  800dc9:	83 c4 10             	add    $0x10,%esp
+  800dcc:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+    return cnt;
+  800dcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800dd2:	c9                   	leave  
+  800dd3:	c3                   	ret    
+
+00800dd4 <vsnprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want snprintf() instead.
+ * */
+int
+vsnprintf(char *str, size_t size, const char *fmt, va_list ap) {
+  800dd4:	55                   	push   %ebp
+  800dd5:	89 e5                	mov    %esp,%ebp
+  800dd7:	83 ec 18             	sub    $0x18,%esp
+    struct sprintbuf b = {str, str + size - 1, 0};
+  800dda:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ddd:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800de0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800de3:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800de6:	8b 45 08             	mov    0x8(%ebp),%eax
+  800de9:	01 d0                	add    %edx,%eax
+  800deb:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800dee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    if (str == NULL || b.buf > b.ebuf) {
+  800df5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  800df9:	74 0a                	je     800e05 <vsnprintf+0x31>
+  800dfb:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  800dfe:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800e01:	39 c2                	cmp    %eax,%edx
+  800e03:	76 07                	jbe    800e0c <vsnprintf+0x38>
+        return -E_INVAL;
+  800e05:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+  800e0a:	eb 20                	jmp    800e2c <vsnprintf+0x58>
+    }
+    // print the string to the buffer
+    vprintfmt((void*)sprintputch, &b, fmt, ap);
+  800e0c:	ff 75 14             	pushl  0x14(%ebp)
+  800e0f:	ff 75 10             	pushl  0x10(%ebp)
+  800e12:	8d 45 ec             	lea    -0x14(%ebp),%eax
+  800e15:	50                   	push   %eax
+  800e16:	68 75 0d 80 00       	push   $0x800d75
+  800e1b:	e8 ad fb ff ff       	call   8009cd <vprintfmt>
+  800e20:	83 c4 10             	add    $0x10,%esp
+    // null terminate the buffer
+    *b.buf = '\0';
+  800e23:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e26:	c6 00 00             	movb   $0x0,(%eax)
+    return b.cnt;
+  800e29:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800e2c:	c9                   	leave  
+  800e2d:	c3                   	ret    
+
+00800e2e <hash32>:
+ * @bits:   the number of bits in a return value
+ *
+ * High bits are more random, so we use them.
+ * */
+uint32_t
+hash32(uint32_t val, unsigned int bits) {
+  800e2e:	55                   	push   %ebp
+  800e2f:	89 e5                	mov    %esp,%ebp
+  800e31:	83 ec 10             	sub    $0x10,%esp
+    uint32_t hash = val * GOLDEN_RATIO_PRIME_32;
+  800e34:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e37:	69 c0 01 00 37 9e    	imul   $0x9e370001,%eax,%eax
+  800e3d:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    return (hash >> (32 - bits));
+  800e40:	b8 20 00 00 00       	mov    $0x20,%eax
+  800e45:	2b 45 0c             	sub    0xc(%ebp),%eax
+  800e48:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  800e4b:	89 c1                	mov    %eax,%ecx
+  800e4d:	d3 ea                	shr    %cl,%edx
+  800e4f:	89 d0                	mov    %edx,%eax
+}
+  800e51:	c9                   	leave  
+  800e52:	c3                   	ret    
+
+00800e53 <rand>:
+ * rand - returns a pseudo-random integer
+ *
+ * The rand() function return a value in the range [0, RAND_MAX].
+ * */
+int
+rand(void) {
+  800e53:	55                   	push   %ebp
+  800e54:	89 e5                	mov    %esp,%ebp
+  800e56:	57                   	push   %edi
+  800e57:	56                   	push   %esi
+  800e58:	53                   	push   %ebx
+  800e59:	83 ec 24             	sub    $0x24,%esp
+    next = (next * 0x5DEECE66DLL + 0xBLL) & ((1LL << 48) - 1);
+  800e5c:	a1 00 20 80 00       	mov    0x802000,%eax
+  800e61:	8b 15 04 20 80 00    	mov    0x802004,%edx
+  800e67:	69 fa 6d e6 ec de    	imul   $0xdeece66d,%edx,%edi
+  800e6d:	6b f0 05             	imul   $0x5,%eax,%esi
+  800e70:	01 fe                	add    %edi,%esi
+  800e72:	bf 6d e6 ec de       	mov    $0xdeece66d,%edi
+  800e77:	f7 e7                	mul    %edi
+  800e79:	01 d6                	add    %edx,%esi
+  800e7b:	89 f2                	mov    %esi,%edx
+  800e7d:	83 c0 0b             	add    $0xb,%eax
+  800e80:	83 d2 00             	adc    $0x0,%edx
+  800e83:	89 c7                	mov    %eax,%edi
+  800e85:	83 e7 ff             	and    $0xffffffff,%edi
+  800e88:	89 f9                	mov    %edi,%ecx
+  800e8a:	0f b7 da             	movzwl %dx,%ebx
+  800e8d:	89 0d 00 20 80 00    	mov    %ecx,0x802000
+  800e93:	89 1d 04 20 80 00    	mov    %ebx,0x802004
+    unsigned long long result = (next >> 12);
+  800e99:	a1 00 20 80 00       	mov    0x802000,%eax
+  800e9e:	8b 15 04 20 80 00    	mov    0x802004,%edx
+  800ea4:	0f ac d0 0c          	shrd   $0xc,%edx,%eax
+  800ea8:	c1 ea 0c             	shr    $0xc,%edx
+  800eab:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800eae:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+    return (int)do_div(result, RAND_MAX + 1);
+  800eb1:	c7 45 dc 00 00 00 80 	movl   $0x80000000,-0x24(%ebp)
+  800eb8:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  800ebb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800ebe:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  800ec1:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  800ec4:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ec7:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800eca:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ece:	74 1c                	je     800eec <rand+0x99>
+  800ed0:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ed3:	ba 00 00 00 00       	mov    $0x0,%edx
+  800ed8:	f7 75 dc             	divl   -0x24(%ebp)
+  800edb:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  800ede:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ee1:	ba 00 00 00 00       	mov    $0x0,%edx
+  800ee6:	f7 75 dc             	divl   -0x24(%ebp)
+  800ee9:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800eec:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  800eef:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  800ef2:	f7 75 dc             	divl   -0x24(%ebp)
+  800ef5:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  800ef8:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  800efb:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  800efe:	8b 55 e8             	mov    -0x18(%ebp),%edx
+  800f01:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800f04:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  800f07:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+}
+  800f0a:	83 c4 24             	add    $0x24,%esp
+  800f0d:	5b                   	pop    %ebx
+  800f0e:	5e                   	pop    %esi
+  800f0f:	5f                   	pop    %edi
+  800f10:	5d                   	pop    %ebp
+  800f11:	c3                   	ret    
+
+00800f12 <srand>:
+/* *
+ * srand - seed the random number generator with the given number
+ * @seed:   the required seed number
+ * */
+void
+srand(unsigned int seed) {
+  800f12:	55                   	push   %ebp
+  800f13:	89 e5                	mov    %esp,%ebp
+    next = seed;
+  800f15:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f18:	ba 00 00 00 00       	mov    $0x0,%edx
+  800f1d:	a3 00 20 80 00       	mov    %eax,0x802000
+  800f22:	89 15 04 20 80 00    	mov    %edx,0x802004
+}
+  800f28:	90                   	nop
+  800f29:	5d                   	pop    %ebp
+  800f2a:	c3                   	ret    
+
+00800f2b <spin_delay>:
+int status[TOTAL];
+int pids[TOTAL];
+
+static void
+spin_delay(void)
+{
+  800f2b:	55                   	push   %ebp
+  800f2c:	89 e5                	mov    %esp,%ebp
+  800f2e:	83 ec 10             	sub    $0x10,%esp
+     int i;
+     volatile int j;
+     for (i = 0; i != 200; ++ i)
+  800f31:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800f38:	eb 12                	jmp    800f4c <spin_delay+0x21>
+     {
+          j = !j;
+  800f3a:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800f3d:	85 c0                	test   %eax,%eax
+  800f3f:	0f 94 c0             	sete   %al
+  800f42:	0f b6 c0             	movzbl %al,%eax
+  800f45:	89 45 f8             	mov    %eax,-0x8(%ebp)
+static void
+spin_delay(void)
+{
+     int i;
+     volatile int j;
+     for (i = 0; i != 200; ++ i)
+  800f48:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800f4c:	81 7d fc c8 00 00 00 	cmpl   $0xc8,-0x4(%ebp)
+  800f53:	75 e5                	jne    800f3a <spin_delay+0xf>
+     {
+          j = !j;
+     }
+}
+  800f55:	90                   	nop
+  800f56:	c9                   	leave  
+  800f57:	c3                   	ret    
+
+00800f58 <main>:
+
+int
+main(void) {
+  800f58:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+  800f5c:	83 e4 f0             	and    $0xfffffff0,%esp
+  800f5f:	ff 71 fc             	pushl  -0x4(%ecx)
+  800f62:	55                   	push   %ebp
+  800f63:	89 e5                	mov    %esp,%ebp
+  800f65:	53                   	push   %ebx
+  800f66:	51                   	push   %ecx
+  800f67:	83 ec 10             	sub    $0x10,%esp
+     int i,time;
+     memset(pids, 0, sizeof(pids));
+  800f6a:	83 ec 04             	sub    $0x4,%esp
+  800f6d:	6a 14                	push   $0x14
+  800f6f:	6a 00                	push   $0x0
+  800f71:	68 30 20 80 00       	push   $0x802030
+  800f76:	e8 1c f7 ff ff       	call   800697 <memset>
+  800f7b:	83 c4 10             	add    $0x10,%esp
+     lab6_set_priority(TOTAL + 1);
+  800f7e:	83 ec 0c             	sub    $0xc,%esp
+  800f81:	6a 06                	push   $0x6
+  800f83:	e8 de f2 ff ff       	call   800266 <lab6_set_priority>
+  800f88:	83 c4 10             	add    $0x10,%esp
+
+     for (i = 0; i < TOTAL; i ++) {
+  800f8b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  800f92:	e9 ee 00 00 00       	jmp    801085 <main+0x12d>
+          acc[i]=0;
+  800f97:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800f9a:	c7 04 85 08 20 80 00 	movl   $0x0,0x802008(,%eax,4)
+  800fa1:	00 00 00 00 
+          if ((pids[i] = fork()) == 0) {
+  800fa5:	e8 33 f2 ff ff       	call   8001dd <fork>
+  800faa:	89 c2                	mov    %eax,%edx
+  800fac:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800faf:	89 14 85 30 20 80 00 	mov    %edx,0x802030(,%eax,4)
+  800fb6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800fb9:	8b 04 85 30 20 80 00 	mov    0x802030(,%eax,4),%eax
+  800fc0:	85 c0                	test   %eax,%eax
+  800fc2:	0f 85 a7 00 00 00    	jne    80106f <main+0x117>
+               lab6_set_priority(i + 1);
+  800fc8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800fcb:	83 c0 01             	add    $0x1,%eax
+  800fce:	83 ec 0c             	sub    $0xc,%esp
+  800fd1:	50                   	push   %eax
+  800fd2:	e8 8f f2 ff ff       	call   800266 <lab6_set_priority>
+  800fd7:	83 c4 10             	add    $0x10,%esp
+               acc[i] = 0;
+  800fda:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800fdd:	c7 04 85 08 20 80 00 	movl   $0x0,0x802008(,%eax,4)
+  800fe4:	00 00 00 00 
+               while (1) {
+                    spin_delay();
+  800fe8:	e8 3e ff ff ff       	call   800f2b <spin_delay>
+                    ++ acc[i];
+  800fed:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800ff0:	8b 04 85 08 20 80 00 	mov    0x802008(,%eax,4),%eax
+  800ff7:	8d 50 01             	lea    0x1(%eax),%edx
+  800ffa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800ffd:	89 14 85 08 20 80 00 	mov    %edx,0x802008(,%eax,4)
+                    if(acc[i]%4000==0) {
+  801004:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  801007:	8b 0c 85 08 20 80 00 	mov    0x802008(,%eax,4),%ecx
+  80100e:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
+  801013:	89 c8                	mov    %ecx,%eax
+  801015:	f7 e2                	mul    %edx
+  801017:	89 d0                	mov    %edx,%eax
+  801019:	c1 e8 08             	shr    $0x8,%eax
+  80101c:	69 c0 a0 0f 00 00    	imul   $0xfa0,%eax,%eax
+  801022:	29 c1                	sub    %eax,%ecx
+  801024:	89 c8                	mov    %ecx,%eax
+  801026:	85 c0                	test   %eax,%eax
+  801028:	75 be                	jne    800fe8 <main+0x90>
+                        if((time=gettime_msec())>MAX_TIME) {
+  80102a:	e8 2a f2 ff ff       	call   800259 <gettime_msec>
+  80102f:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  801032:	81 7d f0 e8 03 00 00 	cmpl   $0x3e8,-0x10(%ebp)
+  801039:	7e ad                	jle    800fe8 <main+0x90>
+                            cprintf("child pid %d, acc %d, time %d\n",getpid(),acc[i],time);
+  80103b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  80103e:	8b 1c 85 08 20 80 00 	mov    0x802008(,%eax,4),%ebx
+  801045:	e8 f4 f1 ff ff       	call   80023e <getpid>
+  80104a:	ff 75 f0             	pushl  -0x10(%ebp)
+  80104d:	53                   	push   %ebx
+  80104e:	50                   	push   %eax
+  80104f:	68 c0 14 80 00       	push   $0x8014c0
+  801054:	e8 80 f2 ff ff       	call   8002d9 <cprintf>
+  801059:	83 c4 10             	add    $0x10,%esp
+                            exit(acc[i]);
+  80105c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  80105f:	8b 04 85 08 20 80 00 	mov    0x802008(,%eax,4),%eax
+  801066:	83 ec 0c             	sub    $0xc,%esp
+  801069:	50                   	push   %eax
+  80106a:	e8 48 f1 ff ff       	call   8001b7 <exit>
+                        }
+                    }
+               }
+               
+          }
+          if (pids[i] < 0) {
+  80106f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  801072:	8b 04 85 30 20 80 00 	mov    0x802030(,%eax,4),%eax
+  801079:	85 c0                	test   %eax,%eax
+  80107b:	0f 88 09 01 00 00    	js     80118a <main+0x232>
+main(void) {
+     int i,time;
+     memset(pids, 0, sizeof(pids));
+     lab6_set_priority(TOTAL + 1);
+
+     for (i = 0; i < TOTAL; i ++) {
+  801081:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  801085:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
+  801089:	0f 8e 08 ff ff ff    	jle    800f97 <main+0x3f>
+          if (pids[i] < 0) {
+               goto failed;
+          }
+     }
+
+     cprintf("main: fork ok,now need to wait pids.\n");
+  80108f:	83 ec 0c             	sub    $0xc,%esp
+  801092:	68 e0 14 80 00       	push   $0x8014e0
+  801097:	e8 3d f2 ff ff       	call   8002d9 <cprintf>
+  80109c:	83 c4 10             	add    $0x10,%esp
+
+     for (i = 0; i < TOTAL; i ++) {
+  80109f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  8010a6:	eb 60                	jmp    801108 <main+0x1b0>
+         status[i]=0;
+  8010a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8010ab:	c7 04 85 1c 20 80 00 	movl   $0x0,0x80201c(,%eax,4)
+  8010b2:	00 00 00 00 
+         waitpid(pids[i],&status[i]);
+  8010b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8010b9:	c1 e0 02             	shl    $0x2,%eax
+  8010bc:	8d 90 1c 20 80 00    	lea    0x80201c(%eax),%edx
+  8010c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8010c5:	8b 04 85 30 20 80 00 	mov    0x802030(,%eax,4),%eax
+  8010cc:	83 ec 08             	sub    $0x8,%esp
+  8010cf:	52                   	push   %edx
+  8010d0:	50                   	push   %eax
+  8010d1:	e8 2b f1 ff ff       	call   800201 <waitpid>
+  8010d6:	83 c4 10             	add    $0x10,%esp
+         cprintf("main: pid %d, acc %d, time %d\n",pids[i],status[i],gettime_msec()); 
+  8010d9:	e8 7b f1 ff ff       	call   800259 <gettime_msec>
+  8010de:	89 c1                	mov    %eax,%ecx
+  8010e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8010e3:	8b 14 85 1c 20 80 00 	mov    0x80201c(,%eax,4),%edx
+  8010ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8010ed:	8b 04 85 30 20 80 00 	mov    0x802030(,%eax,4),%eax
+  8010f4:	51                   	push   %ecx
+  8010f5:	52                   	push   %edx
+  8010f6:	50                   	push   %eax
+  8010f7:	68 08 15 80 00       	push   $0x801508
+  8010fc:	e8 d8 f1 ff ff       	call   8002d9 <cprintf>
+  801101:	83 c4 10             	add    $0x10,%esp
+          }
+     }
+
+     cprintf("main: fork ok,now need to wait pids.\n");
+
+     for (i = 0; i < TOTAL; i ++) {
+  801104:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  801108:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
+  80110c:	7e 9a                	jle    8010a8 <main+0x150>
+         status[i]=0;
+         waitpid(pids[i],&status[i]);
+         cprintf("main: pid %d, acc %d, time %d\n",pids[i],status[i],gettime_msec()); 
+     }
+     cprintf("main: wait pids over\n");
+  80110e:	83 ec 0c             	sub    $0xc,%esp
+  801111:	68 27 15 80 00       	push   $0x801527
+  801116:	e8 be f1 ff ff       	call   8002d9 <cprintf>
+  80111b:	83 c4 10             	add    $0x10,%esp
+     cprintf("stride sched correct result:");
+  80111e:	83 ec 0c             	sub    $0xc,%esp
+  801121:	68 3d 15 80 00       	push   $0x80153d
+  801126:	e8 ae f1 ff ff       	call   8002d9 <cprintf>
+  80112b:	83 c4 10             	add    $0x10,%esp
+     for (i = 0; i < TOTAL; i ++)
+  80112e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  801135:	eb 36                	jmp    80116d <main+0x215>
+     {
+         cprintf(" %d", (status[i] * 2 / status[0] + 1) / 2);
+  801137:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  80113a:	8b 04 85 1c 20 80 00 	mov    0x80201c(,%eax,4),%eax
+  801141:	01 c0                	add    %eax,%eax
+  801143:	8b 1d 1c 20 80 00    	mov    0x80201c,%ebx
+  801149:	99                   	cltd   
+  80114a:	f7 fb                	idiv   %ebx
+  80114c:	83 c0 01             	add    $0x1,%eax
+  80114f:	89 c2                	mov    %eax,%edx
+  801151:	c1 ea 1f             	shr    $0x1f,%edx
+  801154:	01 d0                	add    %edx,%eax
+  801156:	d1 f8                	sar    %eax
+  801158:	83 ec 08             	sub    $0x8,%esp
+  80115b:	50                   	push   %eax
+  80115c:	68 5a 15 80 00       	push   $0x80155a
+  801161:	e8 73 f1 ff ff       	call   8002d9 <cprintf>
+  801166:	83 c4 10             	add    $0x10,%esp
+         waitpid(pids[i],&status[i]);
+         cprintf("main: pid %d, acc %d, time %d\n",pids[i],status[i],gettime_msec()); 
+     }
+     cprintf("main: wait pids over\n");
+     cprintf("stride sched correct result:");
+     for (i = 0; i < TOTAL; i ++)
+  801169:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  80116d:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
+  801171:	7e c4                	jle    801137 <main+0x1df>
+     {
+         cprintf(" %d", (status[i] * 2 / status[0] + 1) / 2);
+     }
+     cprintf("\n");
+  801173:	83 ec 0c             	sub    $0xc,%esp
+  801176:	68 5e 15 80 00       	push   $0x80155e
+  80117b:	e8 59 f1 ff ff       	call   8002d9 <cprintf>
+  801180:	83 c4 10             	add    $0x10,%esp
+
+     return 0;
+  801183:	b8 00 00 00 00       	mov    $0x0,%eax
+  801188:	eb 4c                	jmp    8011d6 <main+0x27e>
+                    }
+               }
+               
+          }
+          if (pids[i] < 0) {
+               goto failed;
+  80118a:	90                   	nop
+     cprintf("\n");
+
+     return 0;
+
+failed:
+     for (i = 0; i < TOTAL; i ++) {
+  80118b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  801192:	eb 28                	jmp    8011bc <main+0x264>
+          if (pids[i] > 0) {
+  801194:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  801197:	8b 04 85 30 20 80 00 	mov    0x802030(,%eax,4),%eax
+  80119e:	85 c0                	test   %eax,%eax
+  8011a0:	7e 16                	jle    8011b8 <main+0x260>
+               kill(pids[i]);
+  8011a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8011a5:	8b 04 85 30 20 80 00 	mov    0x802030(,%eax,4),%eax
+  8011ac:	83 ec 0c             	sub    $0xc,%esp
+  8011af:	50                   	push   %eax
+  8011b0:	e8 73 f0 ff ff       	call   800228 <kill>
+  8011b5:	83 c4 10             	add    $0x10,%esp
+     cprintf("\n");
+
+     return 0;
+
+failed:
+     for (i = 0; i < TOTAL; i ++) {
+  8011b8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  8011bc:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
+  8011c0:	7e d2                	jle    801194 <main+0x23c>
+          if (pids[i] > 0) {
+               kill(pids[i]);
+          }
+     }
+     panic("FAIL: T.T\n");
+  8011c2:	83 ec 04             	sub    $0x4,%esp
+  8011c5:	68 60 15 80 00       	push   $0x801560
+  8011ca:	6a 4b                	push   $0x4b
+  8011cc:	68 6b 15 80 00       	push   $0x80156b
+  8011d1:	e8 4a ee ff ff       	call   800020 <__panic>
+}
+  8011d6:	8d 65 f8             	lea    -0x8(%ebp),%esp
+  8011d9:	59                   	pop    %ecx
+  8011da:	5b                   	pop    %ebx
+  8011db:	5d                   	pop    %ebp
+  8011dc:	8d 61 fc             	lea    -0x4(%ecx),%esp
+  8011df:	c3                   	ret    
diff -r -u -P lab6_origin/obj/user/priority.d lab6/obj/user/priority.d
--- lab6_origin/obj/user/priority.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/priority.d	2019-05-13 17:39:38.335071000 +0800
@@ -0,0 +1,2 @@
+obj/user/priority.o obj/user/priority.d: user/priority.c user/libs/ulib.h \
+ libs/defs.h libs/stdio.h libs/stdarg.h libs/string.h libs/stdlib.h
Binary files lab6_origin/obj/user/priority.o and lab6/obj/user/priority.o differ
diff -r -u -P lab6_origin/obj/user/priority.sym lab6/obj/user/priority.sym
--- lab6_origin/obj/user/priority.sym	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/priority.sym	2019-05-13 17:39:43.979832000 +0800
@@ -0,0 +1,81 @@
+00800020 .text
+008011e0 .rodata
+00802000 .data
+00802008 .bss
+00200000 .stab_info
+00200010 .stab
+00202f2d .stabstr
+00000000 panic.c
+00000000 syscall.c
+008000b5 syscall
+00000000 ulib.c
+00000000 stdio.c
+0080028c cputch
+00000000 umain.c
+00000000 string.c
+00000000 printfmt.c
+008012e0 error_string
+00800822 printnum
+00800913 getuint
+00800962 getint
+00800d75 sprintputch
+00000000 hash.c
+00000000 rand.c
+00802000 next
+00000000 priority.c
+00800f2b spin_delay
+008003be strcpy
+0080021a yield
+00802008 acc
+00800201 waitpid
+00800141 sys_yield
+008006d7 memmove
+00800dab snprintf
+008009cd vprintfmt
+0080011d sys_fork
+008002d9 cprintf
+0080023e getpid
+0080077a memcpy
+00800266 lab6_set_priority
+00800dd4 vsnprintf
+0080034d umain
+00202f2c __STAB_END__
+00800150 sys_kill
+00202f2d __STABSTR_BEGIN__
+00800020 __panic
+0080053a strtol
+0080038e strnlen
+0080024b print_pgdir
+00800228 kill
+0080050b strfind
+008001ea wait
+0080027d _start
+00800e53 rand
+00800482 strncmp
+00800171 sys_putc
+008003fe strncpy
+008007ca memcmp
+008001dd fork
+00800697 memset
+00800f58 main
+00800f12 srand
+00800e2e hash32
+008009a9 printfmt
+00203d98 __STABSTR_END__
+00800438 strcmp
+00800259 gettime_msec
+00800192 sys_gettime
+008002b0 vcprintf
+0080006e __warn
+008002ff cputs
+008001a1 sys_lab6_set_priority
+008001b7 exit
+0080012c sys_wait
+0080010b sys_exit
+00200010 __STAB_BEGIN__
+00800366 strlen
+00800183 sys_pgdir
+008004d8 strchr
+00800162 sys_getpid
+0080201c status
+00802030 pids
diff -r -u -P lab6_origin/obj/user/softint.asm lab6/obj/user/softint.asm
--- lab6_origin/obj/user/softint.asm	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/softint.asm	2019-05-13 17:39:43.255245900 +0800
@@ -0,0 +1,2578 @@
+
+obj/__user_softint.out:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00800020 <__panic>:
+#include <stdio.h>
+#include <ulib.h>
+#include <error.h>
+
+void
+__panic(const char *file, int line, const char *fmt, ...) {
+  800020:	55                   	push   %ebp
+  800021:	89 e5                	mov    %esp,%ebp
+  800023:	83 ec 18             	sub    $0x18,%esp
+    // print the 'message'
+    va_list ap;
+    va_start(ap, fmt);
+  800026:	8d 45 14             	lea    0x14(%ebp),%eax
+  800029:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("user panic at %s:%d:\n    ", file, line);
+  80002c:	83 ec 04             	sub    $0x4,%esp
+  80002f:	ff 75 0c             	pushl  0xc(%ebp)
+  800032:	ff 75 08             	pushl  0x8(%ebp)
+  800035:	68 60 0f 80 00       	push   $0x800f60
+  80003a:	e8 9a 02 00 00       	call   8002d9 <cprintf>
+  80003f:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+  800042:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800045:	83 ec 08             	sub    $0x8,%esp
+  800048:	50                   	push   %eax
+  800049:	ff 75 10             	pushl  0x10(%ebp)
+  80004c:	e8 5f 02 00 00       	call   8002b0 <vcprintf>
+  800051:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+  800054:	83 ec 0c             	sub    $0xc,%esp
+  800057:	68 7a 0f 80 00       	push   $0x800f7a
+  80005c:	e8 78 02 00 00       	call   8002d9 <cprintf>
+  800061:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+    exit(-E_PANIC);
+  800064:	83 ec 0c             	sub    $0xc,%esp
+  800067:	6a f6                	push   $0xfffffff6
+  800069:	e8 49 01 00 00       	call   8001b7 <exit>
+
+0080006e <__warn>:
+}
+
+void
+__warn(const char *file, int line, const char *fmt, ...) {
+  80006e:	55                   	push   %ebp
+  80006f:	89 e5                	mov    %esp,%ebp
+  800071:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    va_start(ap, fmt);
+  800074:	8d 45 14             	lea    0x14(%ebp),%eax
+  800077:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("user warning at %s:%d:\n    ", file, line);
+  80007a:	83 ec 04             	sub    $0x4,%esp
+  80007d:	ff 75 0c             	pushl  0xc(%ebp)
+  800080:	ff 75 08             	pushl  0x8(%ebp)
+  800083:	68 7c 0f 80 00       	push   $0x800f7c
+  800088:	e8 4c 02 00 00       	call   8002d9 <cprintf>
+  80008d:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+  800090:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800093:	83 ec 08             	sub    $0x8,%esp
+  800096:	50                   	push   %eax
+  800097:	ff 75 10             	pushl  0x10(%ebp)
+  80009a:	e8 11 02 00 00       	call   8002b0 <vcprintf>
+  80009f:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+  8000a2:	83 ec 0c             	sub    $0xc,%esp
+  8000a5:	68 7a 0f 80 00       	push   $0x800f7a
+  8000aa:	e8 2a 02 00 00       	call   8002d9 <cprintf>
+  8000af:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+  8000b2:	90                   	nop
+  8000b3:	c9                   	leave  
+  8000b4:	c3                   	ret    
+
+008000b5 <syscall>:
+#include <syscall.h>
+
+#define MAX_ARGS            5
+
+static inline int
+syscall(int num, ...) {
+  8000b5:	55                   	push   %ebp
+  8000b6:	89 e5                	mov    %esp,%ebp
+  8000b8:	57                   	push   %edi
+  8000b9:	56                   	push   %esi
+  8000ba:	53                   	push   %ebx
+  8000bb:	83 ec 20             	sub    $0x20,%esp
+    va_list ap;
+    va_start(ap, num);
+  8000be:	8d 45 0c             	lea    0xc(%ebp),%eax
+  8000c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    uint32_t a[MAX_ARGS];
+    int i, ret;
+    for (i = 0; i < MAX_ARGS; i ++) {
+  8000c4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  8000cb:	eb 16                	jmp    8000e3 <syscall+0x2e>
+        a[i] = va_arg(ap, uint32_t);
+  8000cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8000d0:	8d 50 04             	lea    0x4(%eax),%edx
+  8000d3:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  8000d6:	8b 10                	mov    (%eax),%edx
+  8000d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8000db:	89 54 85 d4          	mov    %edx,-0x2c(%ebp,%eax,4)
+syscall(int num, ...) {
+    va_list ap;
+    va_start(ap, num);
+    uint32_t a[MAX_ARGS];
+    int i, ret;
+    for (i = 0; i < MAX_ARGS; i ++) {
+  8000df:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+  8000e3:	83 7d f0 04          	cmpl   $0x4,-0x10(%ebp)
+  8000e7:	7e e4                	jle    8000cd <syscall+0x18>
+    asm volatile (
+        "int %1;"
+        : "=a" (ret)
+        : "i" (T_SYSCALL),
+          "a" (num),
+          "d" (a[0]),
+  8000e9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+          "c" (a[1]),
+  8000ec:	8b 4d d8             	mov    -0x28(%ebp),%ecx
+          "b" (a[2]),
+  8000ef:	8b 5d dc             	mov    -0x24(%ebp),%ebx
+          "D" (a[3]),
+  8000f2:	8b 7d e0             	mov    -0x20(%ebp),%edi
+          "S" (a[4])
+  8000f5:	8b 75 e4             	mov    -0x1c(%ebp),%esi
+    for (i = 0; i < MAX_ARGS; i ++) {
+        a[i] = va_arg(ap, uint32_t);
+    }
+    va_end(ap);
+
+    asm volatile (
+  8000f8:	8b 45 08             	mov    0x8(%ebp),%eax
+  8000fb:	cd 80                	int    $0x80
+  8000fd:	89 45 ec             	mov    %eax,-0x14(%ebp)
+          "c" (a[1]),
+          "b" (a[2]),
+          "D" (a[3]),
+          "S" (a[4])
+        : "cc", "memory");
+    return ret;
+  800100:	8b 45 ec             	mov    -0x14(%ebp),%eax
+}
+  800103:	83 c4 20             	add    $0x20,%esp
+  800106:	5b                   	pop    %ebx
+  800107:	5e                   	pop    %esi
+  800108:	5f                   	pop    %edi
+  800109:	5d                   	pop    %ebp
+  80010a:	c3                   	ret    
+
+0080010b <sys_exit>:
+
+int
+sys_exit(int error_code) {
+  80010b:	55                   	push   %ebp
+  80010c:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_exit, error_code);
+  80010e:	ff 75 08             	pushl  0x8(%ebp)
+  800111:	6a 01                	push   $0x1
+  800113:	e8 9d ff ff ff       	call   8000b5 <syscall>
+  800118:	83 c4 08             	add    $0x8,%esp
+}
+  80011b:	c9                   	leave  
+  80011c:	c3                   	ret    
+
+0080011d <sys_fork>:
+
+int
+sys_fork(void) {
+  80011d:	55                   	push   %ebp
+  80011e:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_fork);
+  800120:	6a 02                	push   $0x2
+  800122:	e8 8e ff ff ff       	call   8000b5 <syscall>
+  800127:	83 c4 04             	add    $0x4,%esp
+}
+  80012a:	c9                   	leave  
+  80012b:	c3                   	ret    
+
+0080012c <sys_wait>:
+
+int
+sys_wait(int pid, int *store) {
+  80012c:	55                   	push   %ebp
+  80012d:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_wait, pid, store);
+  80012f:	ff 75 0c             	pushl  0xc(%ebp)
+  800132:	ff 75 08             	pushl  0x8(%ebp)
+  800135:	6a 03                	push   $0x3
+  800137:	e8 79 ff ff ff       	call   8000b5 <syscall>
+  80013c:	83 c4 0c             	add    $0xc,%esp
+}
+  80013f:	c9                   	leave  
+  800140:	c3                   	ret    
+
+00800141 <sys_yield>:
+
+int
+sys_yield(void) {
+  800141:	55                   	push   %ebp
+  800142:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_yield);
+  800144:	6a 0a                	push   $0xa
+  800146:	e8 6a ff ff ff       	call   8000b5 <syscall>
+  80014b:	83 c4 04             	add    $0x4,%esp
+}
+  80014e:	c9                   	leave  
+  80014f:	c3                   	ret    
+
+00800150 <sys_kill>:
+
+int
+sys_kill(int pid) {
+  800150:	55                   	push   %ebp
+  800151:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_kill, pid);
+  800153:	ff 75 08             	pushl  0x8(%ebp)
+  800156:	6a 0c                	push   $0xc
+  800158:	e8 58 ff ff ff       	call   8000b5 <syscall>
+  80015d:	83 c4 08             	add    $0x8,%esp
+}
+  800160:	c9                   	leave  
+  800161:	c3                   	ret    
+
+00800162 <sys_getpid>:
+
+int
+sys_getpid(void) {
+  800162:	55                   	push   %ebp
+  800163:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_getpid);
+  800165:	6a 12                	push   $0x12
+  800167:	e8 49 ff ff ff       	call   8000b5 <syscall>
+  80016c:	83 c4 04             	add    $0x4,%esp
+}
+  80016f:	c9                   	leave  
+  800170:	c3                   	ret    
+
+00800171 <sys_putc>:
+
+int
+sys_putc(int c) {
+  800171:	55                   	push   %ebp
+  800172:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_putc, c);
+  800174:	ff 75 08             	pushl  0x8(%ebp)
+  800177:	6a 1e                	push   $0x1e
+  800179:	e8 37 ff ff ff       	call   8000b5 <syscall>
+  80017e:	83 c4 08             	add    $0x8,%esp
+}
+  800181:	c9                   	leave  
+  800182:	c3                   	ret    
+
+00800183 <sys_pgdir>:
+
+int
+sys_pgdir(void) {
+  800183:	55                   	push   %ebp
+  800184:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_pgdir);
+  800186:	6a 1f                	push   $0x1f
+  800188:	e8 28 ff ff ff       	call   8000b5 <syscall>
+  80018d:	83 c4 04             	add    $0x4,%esp
+}
+  800190:	c9                   	leave  
+  800191:	c3                   	ret    
+
+00800192 <sys_gettime>:
+
+int
+sys_gettime(void) {
+  800192:	55                   	push   %ebp
+  800193:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_gettime);
+  800195:	6a 11                	push   $0x11
+  800197:	e8 19 ff ff ff       	call   8000b5 <syscall>
+  80019c:	83 c4 04             	add    $0x4,%esp
+}
+  80019f:	c9                   	leave  
+  8001a0:	c3                   	ret    
+
+008001a1 <sys_lab6_set_priority>:
+
+void
+sys_lab6_set_priority(uint32_t priority)
+{
+  8001a1:	55                   	push   %ebp
+  8001a2:	89 e5                	mov    %esp,%ebp
+    syscall(SYS_lab6_set_priority, priority);
+  8001a4:	ff 75 08             	pushl  0x8(%ebp)
+  8001a7:	68 ff 00 00 00       	push   $0xff
+  8001ac:	e8 04 ff ff ff       	call   8000b5 <syscall>
+  8001b1:	83 c4 08             	add    $0x8,%esp
+}
+  8001b4:	90                   	nop
+  8001b5:	c9                   	leave  
+  8001b6:	c3                   	ret    
+
+008001b7 <exit>:
+#include <syscall.h>
+#include <stdio.h>
+#include <ulib.h>
+
+void
+exit(int error_code) {
+  8001b7:	55                   	push   %ebp
+  8001b8:	89 e5                	mov    %esp,%ebp
+  8001ba:	83 ec 08             	sub    $0x8,%esp
+    sys_exit(error_code);
+  8001bd:	83 ec 0c             	sub    $0xc,%esp
+  8001c0:	ff 75 08             	pushl  0x8(%ebp)
+  8001c3:	e8 43 ff ff ff       	call   80010b <sys_exit>
+  8001c8:	83 c4 10             	add    $0x10,%esp
+    cprintf("BUG: exit failed.\n");
+  8001cb:	83 ec 0c             	sub    $0xc,%esp
+  8001ce:	68 98 0f 80 00       	push   $0x800f98
+  8001d3:	e8 01 01 00 00       	call   8002d9 <cprintf>
+  8001d8:	83 c4 10             	add    $0x10,%esp
+    while (1);
+  8001db:	eb fe                	jmp    8001db <exit+0x24>
+
+008001dd <fork>:
+}
+
+int
+fork(void) {
+  8001dd:	55                   	push   %ebp
+  8001de:	89 e5                	mov    %esp,%ebp
+  8001e0:	83 ec 08             	sub    $0x8,%esp
+    return sys_fork();
+  8001e3:	e8 35 ff ff ff       	call   80011d <sys_fork>
+}
+  8001e8:	c9                   	leave  
+  8001e9:	c3                   	ret    
+
+008001ea <wait>:
+
+int
+wait(void) {
+  8001ea:	55                   	push   %ebp
+  8001eb:	89 e5                	mov    %esp,%ebp
+  8001ed:	83 ec 08             	sub    $0x8,%esp
+    return sys_wait(0, NULL);
+  8001f0:	83 ec 08             	sub    $0x8,%esp
+  8001f3:	6a 00                	push   $0x0
+  8001f5:	6a 00                	push   $0x0
+  8001f7:	e8 30 ff ff ff       	call   80012c <sys_wait>
+  8001fc:	83 c4 10             	add    $0x10,%esp
+}
+  8001ff:	c9                   	leave  
+  800200:	c3                   	ret    
+
+00800201 <waitpid>:
+
+int
+waitpid(int pid, int *store) {
+  800201:	55                   	push   %ebp
+  800202:	89 e5                	mov    %esp,%ebp
+  800204:	83 ec 08             	sub    $0x8,%esp
+    return sys_wait(pid, store);
+  800207:	83 ec 08             	sub    $0x8,%esp
+  80020a:	ff 75 0c             	pushl  0xc(%ebp)
+  80020d:	ff 75 08             	pushl  0x8(%ebp)
+  800210:	e8 17 ff ff ff       	call   80012c <sys_wait>
+  800215:	83 c4 10             	add    $0x10,%esp
+}
+  800218:	c9                   	leave  
+  800219:	c3                   	ret    
+
+0080021a <yield>:
+
+void
+yield(void) {
+  80021a:	55                   	push   %ebp
+  80021b:	89 e5                	mov    %esp,%ebp
+  80021d:	83 ec 08             	sub    $0x8,%esp
+    sys_yield();
+  800220:	e8 1c ff ff ff       	call   800141 <sys_yield>
+}
+  800225:	90                   	nop
+  800226:	c9                   	leave  
+  800227:	c3                   	ret    
+
+00800228 <kill>:
+
+int
+kill(int pid) {
+  800228:	55                   	push   %ebp
+  800229:	89 e5                	mov    %esp,%ebp
+  80022b:	83 ec 08             	sub    $0x8,%esp
+    return sys_kill(pid);
+  80022e:	83 ec 0c             	sub    $0xc,%esp
+  800231:	ff 75 08             	pushl  0x8(%ebp)
+  800234:	e8 17 ff ff ff       	call   800150 <sys_kill>
+  800239:	83 c4 10             	add    $0x10,%esp
+}
+  80023c:	c9                   	leave  
+  80023d:	c3                   	ret    
+
+0080023e <getpid>:
+
+int
+getpid(void) {
+  80023e:	55                   	push   %ebp
+  80023f:	89 e5                	mov    %esp,%ebp
+  800241:	83 ec 08             	sub    $0x8,%esp
+    return sys_getpid();
+  800244:	e8 19 ff ff ff       	call   800162 <sys_getpid>
+}
+  800249:	c9                   	leave  
+  80024a:	c3                   	ret    
+
+0080024b <print_pgdir>:
+
+//print_pgdir - print the PDT&PT
+void
+print_pgdir(void) {
+  80024b:	55                   	push   %ebp
+  80024c:	89 e5                	mov    %esp,%ebp
+  80024e:	83 ec 08             	sub    $0x8,%esp
+    sys_pgdir();
+  800251:	e8 2d ff ff ff       	call   800183 <sys_pgdir>
+}
+  800256:	90                   	nop
+  800257:	c9                   	leave  
+  800258:	c3                   	ret    
+
+00800259 <gettime_msec>:
+
+unsigned int
+gettime_msec(void) {
+  800259:	55                   	push   %ebp
+  80025a:	89 e5                	mov    %esp,%ebp
+  80025c:	83 ec 08             	sub    $0x8,%esp
+    return (unsigned int)sys_gettime();
+  80025f:	e8 2e ff ff ff       	call   800192 <sys_gettime>
+}
+  800264:	c9                   	leave  
+  800265:	c3                   	ret    
+
+00800266 <lab6_set_priority>:
+
+void
+lab6_set_priority(uint32_t priority)
+{
+  800266:	55                   	push   %ebp
+  800267:	89 e5                	mov    %esp,%ebp
+  800269:	83 ec 08             	sub    $0x8,%esp
+    sys_lab6_set_priority(priority);
+  80026c:	83 ec 0c             	sub    $0xc,%esp
+  80026f:	ff 75 08             	pushl  0x8(%ebp)
+  800272:	e8 2a ff ff ff       	call   8001a1 <sys_lab6_set_priority>
+  800277:	83 c4 10             	add    $0x10,%esp
+}
+  80027a:	90                   	nop
+  80027b:	c9                   	leave  
+  80027c:	c3                   	ret    
+
+0080027d <_start>:
+.text
+.globl _start
+_start:
+    # set ebp for backtrace
+    movl $0x0, %ebp
+  80027d:	bd 00 00 00 00       	mov    $0x0,%ebp
+
+    # move down the esp register
+    # since it may cause page fault in backtrace
+    subl $0x20, %esp
+  800282:	83 ec 20             	sub    $0x20,%esp
+
+    # call user-program function
+    call umain
+  800285:	e8 c3 00 00 00       	call   80034d <umain>
+1:  jmp 1b
+  80028a:	eb fe                	jmp    80028a <_start+0xd>
+
+0080028c <cputch>:
+/* *
+ * cputch - writes a single character @c to stdout, and it will
+ * increace the value of counter pointed by @cnt.
+ * */
+static void
+cputch(int c, int *cnt) {
+  80028c:	55                   	push   %ebp
+  80028d:	89 e5                	mov    %esp,%ebp
+  80028f:	83 ec 08             	sub    $0x8,%esp
+    sys_putc(c);
+  800292:	83 ec 0c             	sub    $0xc,%esp
+  800295:	ff 75 08             	pushl  0x8(%ebp)
+  800298:	e8 d4 fe ff ff       	call   800171 <sys_putc>
+  80029d:	83 c4 10             	add    $0x10,%esp
+    (*cnt) ++;
+  8002a0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002a3:	8b 00                	mov    (%eax),%eax
+  8002a5:	8d 50 01             	lea    0x1(%eax),%edx
+  8002a8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002ab:	89 10                	mov    %edx,(%eax)
+}
+  8002ad:	90                   	nop
+  8002ae:	c9                   	leave  
+  8002af:	c3                   	ret    
+
+008002b0 <vcprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want cprintf() instead.
+ * */
+int
+vcprintf(const char *fmt, va_list ap) {
+  8002b0:	55                   	push   %ebp
+  8002b1:	89 e5                	mov    %esp,%ebp
+  8002b3:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+  8002b6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    vprintfmt((void*)cputch, &cnt, fmt, ap);
+  8002bd:	ff 75 0c             	pushl  0xc(%ebp)
+  8002c0:	ff 75 08             	pushl  0x8(%ebp)
+  8002c3:	8d 45 f4             	lea    -0xc(%ebp),%eax
+  8002c6:	50                   	push   %eax
+  8002c7:	68 8c 02 80 00       	push   $0x80028c
+  8002cc:	e8 fc 06 00 00       	call   8009cd <vprintfmt>
+  8002d1:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+  8002d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8002d7:	c9                   	leave  
+  8002d8:	c3                   	ret    
+
+008002d9 <cprintf>:
+ *
+ * The return value is the number of characters which would be
+ * written to stdout.
+ * */
+int
+cprintf(const char *fmt, ...) {
+  8002d9:	55                   	push   %ebp
+  8002da:	89 e5                	mov    %esp,%ebp
+  8002dc:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  8002df:	8d 45 0c             	lea    0xc(%ebp),%eax
+  8002e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    int cnt = vcprintf(fmt, ap);
+  8002e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8002e8:	83 ec 08             	sub    $0x8,%esp
+  8002eb:	50                   	push   %eax
+  8002ec:	ff 75 08             	pushl  0x8(%ebp)
+  8002ef:	e8 bc ff ff ff       	call   8002b0 <vcprintf>
+  8002f4:	83 c4 10             	add    $0x10,%esp
+  8002f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+
+    return cnt;
+  8002fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8002fd:	c9                   	leave  
+  8002fe:	c3                   	ret    
+
+008002ff <cputs>:
+/* *
+ * cputs- writes the string pointed by @str to stdout and
+ * appends a newline character.
+ * */
+int
+cputs(const char *str) {
+  8002ff:	55                   	push   %ebp
+  800300:	89 e5                	mov    %esp,%ebp
+  800302:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+  800305:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    char c;
+    while ((c = *str ++) != '\0') {
+  80030c:	eb 14                	jmp    800322 <cputs+0x23>
+        cputch(c, &cnt);
+  80030e:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
+  800312:	83 ec 08             	sub    $0x8,%esp
+  800315:	8d 55 f0             	lea    -0x10(%ebp),%edx
+  800318:	52                   	push   %edx
+  800319:	50                   	push   %eax
+  80031a:	e8 6d ff ff ff       	call   80028c <cputch>
+  80031f:	83 c4 10             	add    $0x10,%esp
+ * */
+int
+cputs(const char *str) {
+    int cnt = 0;
+    char c;
+    while ((c = *str ++) != '\0') {
+  800322:	8b 45 08             	mov    0x8(%ebp),%eax
+  800325:	8d 50 01             	lea    0x1(%eax),%edx
+  800328:	89 55 08             	mov    %edx,0x8(%ebp)
+  80032b:	0f b6 00             	movzbl (%eax),%eax
+  80032e:	88 45 f7             	mov    %al,-0x9(%ebp)
+  800331:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
+  800335:	75 d7                	jne    80030e <cputs+0xf>
+        cputch(c, &cnt);
+    }
+    cputch('\n', &cnt);
+  800337:	83 ec 08             	sub    $0x8,%esp
+  80033a:	8d 45 f0             	lea    -0x10(%ebp),%eax
+  80033d:	50                   	push   %eax
+  80033e:	6a 0a                	push   $0xa
+  800340:	e8 47 ff ff ff       	call   80028c <cputch>
+  800345:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+  800348:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+  80034b:	c9                   	leave  
+  80034c:	c3                   	ret    
+
+0080034d <umain>:
+#include <ulib.h>
+
+int main(void);
+
+void
+umain(void) {
+  80034d:	55                   	push   %ebp
+  80034e:	89 e5                	mov    %esp,%ebp
+  800350:	83 ec 18             	sub    $0x18,%esp
+    int ret = main();
+  800353:	e8 d3 0b 00 00       	call   800f2b <main>
+  800358:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    exit(ret);
+  80035b:	83 ec 0c             	sub    $0xc,%esp
+  80035e:	ff 75 f4             	pushl  -0xc(%ebp)
+  800361:	e8 51 fe ff ff       	call   8001b7 <exit>
+
+00800366 <strlen>:
+ * @s:      the input string
+ *
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+  800366:	55                   	push   %ebp
+  800367:	89 e5                	mov    %esp,%ebp
+  800369:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  80036c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (*s ++ != '\0') {
+  800373:	eb 04                	jmp    800379 <strlen+0x13>
+        cnt ++;
+  800375:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+    size_t cnt = 0;
+    while (*s ++ != '\0') {
+  800379:	8b 45 08             	mov    0x8(%ebp),%eax
+  80037c:	8d 50 01             	lea    0x1(%eax),%edx
+  80037f:	89 55 08             	mov    %edx,0x8(%ebp)
+  800382:	0f b6 00             	movzbl (%eax),%eax
+  800385:	84 c0                	test   %al,%al
+  800387:	75 ec                	jne    800375 <strlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  800389:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  80038c:	c9                   	leave  
+  80038d:	c3                   	ret    
+
+0080038e <strnlen>:
+ * The return value is strlen(s), if that is less than @len, or
+ * @len if there is no '\0' character among the first @len characters
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+  80038e:	55                   	push   %ebp
+  80038f:	89 e5                	mov    %esp,%ebp
+  800391:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  800394:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (cnt < len && *s ++ != '\0') {
+  80039b:	eb 04                	jmp    8003a1 <strnlen+0x13>
+        cnt ++;
+  80039d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+    size_t cnt = 0;
+    while (cnt < len && *s ++ != '\0') {
+  8003a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8003a4:	3b 45 0c             	cmp    0xc(%ebp),%eax
+  8003a7:	73 10                	jae    8003b9 <strnlen+0x2b>
+  8003a9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003ac:	8d 50 01             	lea    0x1(%eax),%edx
+  8003af:	89 55 08             	mov    %edx,0x8(%ebp)
+  8003b2:	0f b6 00             	movzbl (%eax),%eax
+  8003b5:	84 c0                	test   %al,%al
+  8003b7:	75 e4                	jne    80039d <strnlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  8003b9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  8003bc:	c9                   	leave  
+  8003bd:	c3                   	ret    
+
+008003be <strcpy>:
+ * To avoid overflows, the size of array pointed by @dst should be long enough to
+ * contain the same string as @src (including the terminating null character), and
+ * should not overlap in memory with @src.
+ * */
+char *
+strcpy(char *dst, const char *src) {
+  8003be:	55                   	push   %ebp
+  8003bf:	89 e5                	mov    %esp,%ebp
+  8003c1:	57                   	push   %edi
+  8003c2:	56                   	push   %esi
+  8003c3:	83 ec 20             	sub    $0x20,%esp
+  8003c6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  8003cc:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8003cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCPY
+#define __HAVE_ARCH_STRCPY
+static inline char *
+__strcpy(char *dst, const char *src) {
+    int d0, d1, d2;
+    asm volatile (
+  8003d2:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  8003d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8003d8:	89 d1                	mov    %edx,%ecx
+  8003da:	89 c2                	mov    %eax,%edx
+  8003dc:	89 ce                	mov    %ecx,%esi
+  8003de:	89 d7                	mov    %edx,%edi
+  8003e0:	ac                   	lods   %ds:(%esi),%al
+  8003e1:	aa                   	stos   %al,%es:(%edi)
+  8003e2:	84 c0                	test   %al,%al
+  8003e4:	75 fa                	jne    8003e0 <strcpy+0x22>
+  8003e6:	89 fa                	mov    %edi,%edx
+  8003e8:	89 f1                	mov    %esi,%ecx
+  8003ea:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  8003ed:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  8003f0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+        "stosb;"
+        "testb %%al, %%al;"
+        "jne 1b;"
+        : "=&S" (d0), "=&D" (d1), "=&a" (d2)
+        : "0" (src), "1" (dst) : "memory");
+    return dst;
+  8003f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCPY
+    return __strcpy(dst, src);
+  8003f6:	90                   	nop
+    char *p = dst;
+    while ((*p ++ = *src ++) != '\0')
+        /* nothing */;
+    return dst;
+#endif /* __HAVE_ARCH_STRCPY */
+}
+  8003f7:	83 c4 20             	add    $0x20,%esp
+  8003fa:	5e                   	pop    %esi
+  8003fb:	5f                   	pop    %edi
+  8003fc:	5d                   	pop    %ebp
+  8003fd:	c3                   	ret    
+
+008003fe <strncpy>:
+ * @len:    maximum number of characters to be copied from @src
+ *
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+  8003fe:	55                   	push   %ebp
+  8003ff:	89 e5                	mov    %esp,%ebp
+  800401:	83 ec 10             	sub    $0x10,%esp
+    char *p = dst;
+  800404:	8b 45 08             	mov    0x8(%ebp),%eax
+  800407:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    while (len > 0) {
+  80040a:	eb 21                	jmp    80042d <strncpy+0x2f>
+        if ((*p = *src) != '\0') {
+  80040c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80040f:	0f b6 10             	movzbl (%eax),%edx
+  800412:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800415:	88 10                	mov    %dl,(%eax)
+  800417:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  80041a:	0f b6 00             	movzbl (%eax),%eax
+  80041d:	84 c0                	test   %al,%al
+  80041f:	74 04                	je     800425 <strncpy+0x27>
+            src ++;
+  800421:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+        }
+        p ++, len --;
+  800425:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800429:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+    char *p = dst;
+    while (len > 0) {
+  80042d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800431:	75 d9                	jne    80040c <strncpy+0xe>
+        if ((*p = *src) != '\0') {
+            src ++;
+        }
+        p ++, len --;
+    }
+    return dst;
+  800433:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800436:	c9                   	leave  
+  800437:	c3                   	ret    
+
+00800438 <strcmp>:
+ * - A value greater than zero indicates that the first character that does
+ *   not match has a greater value in @s1 than in @s2;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+strcmp(const char *s1, const char *s2) {
+  800438:	55                   	push   %ebp
+  800439:	89 e5                	mov    %esp,%ebp
+  80043b:	57                   	push   %edi
+  80043c:	56                   	push   %esi
+  80043d:	83 ec 20             	sub    $0x20,%esp
+  800440:	8b 45 08             	mov    0x8(%ebp),%eax
+  800443:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800446:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800449:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCMP
+#define __HAVE_ARCH_STRCMP
+static inline int
+__strcmp(const char *s1, const char *s2) {
+    int d0, d1, ret;
+    asm volatile (
+  80044c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80044f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800452:	89 d1                	mov    %edx,%ecx
+  800454:	89 c2                	mov    %eax,%edx
+  800456:	89 ce                	mov    %ecx,%esi
+  800458:	89 d7                	mov    %edx,%edi
+  80045a:	ac                   	lods   %ds:(%esi),%al
+  80045b:	ae                   	scas   %es:(%edi),%al
+  80045c:	75 08                	jne    800466 <strcmp+0x2e>
+  80045e:	84 c0                	test   %al,%al
+  800460:	75 f8                	jne    80045a <strcmp+0x22>
+  800462:	31 c0                	xor    %eax,%eax
+  800464:	eb 04                	jmp    80046a <strcmp+0x32>
+  800466:	19 c0                	sbb    %eax,%eax
+  800468:	0c 01                	or     $0x1,%al
+  80046a:	89 fa                	mov    %edi,%edx
+  80046c:	89 f1                	mov    %esi,%ecx
+  80046e:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800471:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  800474:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+        "orb $1, %%al;"
+        "3:"
+        : "=a" (ret), "=&S" (d0), "=&D" (d1)
+        : "1" (s1), "2" (s2)
+        : "memory");
+    return ret;
+  800477:	8b 45 ec             	mov    -0x14(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCMP
+    return __strcmp(s1, s2);
+  80047a:	90                   	nop
+    while (*s1 != '\0' && *s1 == *s2) {
+        s1 ++, s2 ++;
+    }
+    return (int)((unsigned char)*s1 - (unsigned char)*s2);
+#endif /* __HAVE_ARCH_STRCMP */
+}
+  80047b:	83 c4 20             	add    $0x20,%esp
+  80047e:	5e                   	pop    %esi
+  80047f:	5f                   	pop    %edi
+  800480:	5d                   	pop    %ebp
+  800481:	c3                   	ret    
+
+00800482 <strncmp>:
+ * they are equal to each other, it continues with the following pairs until
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+  800482:	55                   	push   %ebp
+  800483:	89 e5                	mov    %esp,%ebp
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  800485:	eb 0c                	jmp    800493 <strncmp+0x11>
+        n --, s1 ++, s2 ++;
+  800487:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  80048b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  80048f:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  800493:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800497:	74 1a                	je     8004b3 <strncmp+0x31>
+  800499:	8b 45 08             	mov    0x8(%ebp),%eax
+  80049c:	0f b6 00             	movzbl (%eax),%eax
+  80049f:	84 c0                	test   %al,%al
+  8004a1:	74 10                	je     8004b3 <strncmp+0x31>
+  8004a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004a6:	0f b6 10             	movzbl (%eax),%edx
+  8004a9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004ac:	0f b6 00             	movzbl (%eax),%eax
+  8004af:	38 c2                	cmp    %al,%dl
+  8004b1:	74 d4                	je     800487 <strncmp+0x5>
+        n --, s1 ++, s2 ++;
+    }
+    return (n == 0) ? 0 : (int)((unsigned char)*s1 - (unsigned char)*s2);
+  8004b3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8004b7:	74 18                	je     8004d1 <strncmp+0x4f>
+  8004b9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004bc:	0f b6 00             	movzbl (%eax),%eax
+  8004bf:	0f b6 d0             	movzbl %al,%edx
+  8004c2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004c5:	0f b6 00             	movzbl (%eax),%eax
+  8004c8:	0f b6 c0             	movzbl %al,%eax
+  8004cb:	29 c2                	sub    %eax,%edx
+  8004cd:	89 d0                	mov    %edx,%eax
+  8004cf:	eb 05                	jmp    8004d6 <strncmp+0x54>
+  8004d1:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  8004d6:	5d                   	pop    %ebp
+  8004d7:	c3                   	ret    
+
+008004d8 <strchr>:
+ *
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+  8004d8:	55                   	push   %ebp
+  8004d9:	89 e5                	mov    %esp,%ebp
+  8004db:	83 ec 04             	sub    $0x4,%esp
+  8004de:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004e1:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  8004e4:	eb 14                	jmp    8004fa <strchr+0x22>
+        if (*s == c) {
+  8004e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004e9:	0f b6 00             	movzbl (%eax),%eax
+  8004ec:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  8004ef:	75 05                	jne    8004f6 <strchr+0x1e>
+            return (char *)s;
+  8004f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004f4:	eb 13                	jmp    800509 <strchr+0x31>
+        }
+        s ++;
+  8004f6:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+    while (*s != '\0') {
+  8004fa:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004fd:	0f b6 00             	movzbl (%eax),%eax
+  800500:	84 c0                	test   %al,%al
+  800502:	75 e2                	jne    8004e6 <strchr+0xe>
+        if (*s == c) {
+            return (char *)s;
+        }
+        s ++;
+    }
+    return NULL;
+  800504:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800509:	c9                   	leave  
+  80050a:	c3                   	ret    
+
+0080050b <strfind>:
+ * The strfind() function is like strchr() except that if @c is
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+  80050b:	55                   	push   %ebp
+  80050c:	89 e5                	mov    %esp,%ebp
+  80050e:	83 ec 04             	sub    $0x4,%esp
+  800511:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800514:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  800517:	eb 0f                	jmp    800528 <strfind+0x1d>
+        if (*s == c) {
+  800519:	8b 45 08             	mov    0x8(%ebp),%eax
+  80051c:	0f b6 00             	movzbl (%eax),%eax
+  80051f:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800522:	74 10                	je     800534 <strfind+0x29>
+            break;
+        }
+        s ++;
+  800524:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+    while (*s != '\0') {
+  800528:	8b 45 08             	mov    0x8(%ebp),%eax
+  80052b:	0f b6 00             	movzbl (%eax),%eax
+  80052e:	84 c0                	test   %al,%al
+  800530:	75 e7                	jne    800519 <strfind+0xe>
+  800532:	eb 01                	jmp    800535 <strfind+0x2a>
+        if (*s == c) {
+            break;
+  800534:	90                   	nop
+        }
+        s ++;
+    }
+    return (char *)s;
+  800535:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800538:	c9                   	leave  
+  800539:	c3                   	ret    
+
+0080053a <strtol>:
+ * an optional "0x" or "0X" prefix.
+ *
+ * The strtol() function returns the converted integral number as a long int value.
+ * */
+long
+strtol(const char *s, char **endptr, int base) {
+  80053a:	55                   	push   %ebp
+  80053b:	89 e5                	mov    %esp,%ebp
+  80053d:	83 ec 10             	sub    $0x10,%esp
+    int neg = 0;
+  800540:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    long val = 0;
+  800547:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  80054e:	eb 04                	jmp    800554 <strtol+0x1a>
+        s ++;
+  800550:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+strtol(const char *s, char **endptr, int base) {
+    int neg = 0;
+    long val = 0;
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  800554:	8b 45 08             	mov    0x8(%ebp),%eax
+  800557:	0f b6 00             	movzbl (%eax),%eax
+  80055a:	3c 20                	cmp    $0x20,%al
+  80055c:	74 f2                	je     800550 <strtol+0x16>
+  80055e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800561:	0f b6 00             	movzbl (%eax),%eax
+  800564:	3c 09                	cmp    $0x9,%al
+  800566:	74 e8                	je     800550 <strtol+0x16>
+        s ++;
+    }
+
+    // plus/minus sign
+    if (*s == '+') {
+  800568:	8b 45 08             	mov    0x8(%ebp),%eax
+  80056b:	0f b6 00             	movzbl (%eax),%eax
+  80056e:	3c 2b                	cmp    $0x2b,%al
+  800570:	75 06                	jne    800578 <strtol+0x3e>
+        s ++;
+  800572:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800576:	eb 15                	jmp    80058d <strtol+0x53>
+    }
+    else if (*s == '-') {
+  800578:	8b 45 08             	mov    0x8(%ebp),%eax
+  80057b:	0f b6 00             	movzbl (%eax),%eax
+  80057e:	3c 2d                	cmp    $0x2d,%al
+  800580:	75 0b                	jne    80058d <strtol+0x53>
+        s ++, neg = 1;
+  800582:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800586:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+    }
+
+    // hex or octal base prefix
+    if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x')) {
+  80058d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800591:	74 06                	je     800599 <strtol+0x5f>
+  800593:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+  800597:	75 24                	jne    8005bd <strtol+0x83>
+  800599:	8b 45 08             	mov    0x8(%ebp),%eax
+  80059c:	0f b6 00             	movzbl (%eax),%eax
+  80059f:	3c 30                	cmp    $0x30,%al
+  8005a1:	75 1a                	jne    8005bd <strtol+0x83>
+  8005a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005a6:	83 c0 01             	add    $0x1,%eax
+  8005a9:	0f b6 00             	movzbl (%eax),%eax
+  8005ac:	3c 78                	cmp    $0x78,%al
+  8005ae:	75 0d                	jne    8005bd <strtol+0x83>
+        s += 2, base = 16;
+  8005b0:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+  8005b4:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+  8005bb:	eb 2a                	jmp    8005e7 <strtol+0xad>
+    }
+    else if (base == 0 && s[0] == '0') {
+  8005bd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8005c1:	75 17                	jne    8005da <strtol+0xa0>
+  8005c3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005c6:	0f b6 00             	movzbl (%eax),%eax
+  8005c9:	3c 30                	cmp    $0x30,%al
+  8005cb:	75 0d                	jne    8005da <strtol+0xa0>
+        s ++, base = 8;
+  8005cd:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  8005d1:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+  8005d8:	eb 0d                	jmp    8005e7 <strtol+0xad>
+    }
+    else if (base == 0) {
+  8005da:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8005de:	75 07                	jne    8005e7 <strtol+0xad>
+        base = 10;
+  8005e0:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+    // digits
+    while (1) {
+        int dig;
+
+        if (*s >= '0' && *s <= '9') {
+  8005e7:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005ea:	0f b6 00             	movzbl (%eax),%eax
+  8005ed:	3c 2f                	cmp    $0x2f,%al
+  8005ef:	7e 1b                	jle    80060c <strtol+0xd2>
+  8005f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005f4:	0f b6 00             	movzbl (%eax),%eax
+  8005f7:	3c 39                	cmp    $0x39,%al
+  8005f9:	7f 11                	jg     80060c <strtol+0xd2>
+            dig = *s - '0';
+  8005fb:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005fe:	0f b6 00             	movzbl (%eax),%eax
+  800601:	0f be c0             	movsbl %al,%eax
+  800604:	83 e8 30             	sub    $0x30,%eax
+  800607:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80060a:	eb 48                	jmp    800654 <strtol+0x11a>
+        }
+        else if (*s >= 'a' && *s <= 'z') {
+  80060c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80060f:	0f b6 00             	movzbl (%eax),%eax
+  800612:	3c 60                	cmp    $0x60,%al
+  800614:	7e 1b                	jle    800631 <strtol+0xf7>
+  800616:	8b 45 08             	mov    0x8(%ebp),%eax
+  800619:	0f b6 00             	movzbl (%eax),%eax
+  80061c:	3c 7a                	cmp    $0x7a,%al
+  80061e:	7f 11                	jg     800631 <strtol+0xf7>
+            dig = *s - 'a' + 10;
+  800620:	8b 45 08             	mov    0x8(%ebp),%eax
+  800623:	0f b6 00             	movzbl (%eax),%eax
+  800626:	0f be c0             	movsbl %al,%eax
+  800629:	83 e8 57             	sub    $0x57,%eax
+  80062c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80062f:	eb 23                	jmp    800654 <strtol+0x11a>
+        }
+        else if (*s >= 'A' && *s <= 'Z') {
+  800631:	8b 45 08             	mov    0x8(%ebp),%eax
+  800634:	0f b6 00             	movzbl (%eax),%eax
+  800637:	3c 40                	cmp    $0x40,%al
+  800639:	7e 3c                	jle    800677 <strtol+0x13d>
+  80063b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80063e:	0f b6 00             	movzbl (%eax),%eax
+  800641:	3c 5a                	cmp    $0x5a,%al
+  800643:	7f 32                	jg     800677 <strtol+0x13d>
+            dig = *s - 'A' + 10;
+  800645:	8b 45 08             	mov    0x8(%ebp),%eax
+  800648:	0f b6 00             	movzbl (%eax),%eax
+  80064b:	0f be c0             	movsbl %al,%eax
+  80064e:	83 e8 37             	sub    $0x37,%eax
+  800651:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+  800654:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800657:	3b 45 10             	cmp    0x10(%ebp),%eax
+  80065a:	7d 1a                	jge    800676 <strtol+0x13c>
+            break;
+        }
+        s ++, val = (val * base) + dig;
+  80065c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800660:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800663:	0f af 45 10          	imul   0x10(%ebp),%eax
+  800667:	89 c2                	mov    %eax,%edx
+  800669:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  80066c:	01 d0                	add    %edx,%eax
+  80066e:	89 45 f8             	mov    %eax,-0x8(%ebp)
+        // we don't properly detect overflow!
+    }
+  800671:	e9 71 ff ff ff       	jmp    8005e7 <strtol+0xad>
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+            break;
+  800676:	90                   	nop
+        }
+        s ++, val = (val * base) + dig;
+        // we don't properly detect overflow!
+    }
+
+    if (endptr) {
+  800677:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  80067b:	74 08                	je     800685 <strtol+0x14b>
+        *endptr = (char *) s;
+  80067d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800680:	8b 55 08             	mov    0x8(%ebp),%edx
+  800683:	89 10                	mov    %edx,(%eax)
+    }
+    return (neg ? -val : val);
+  800685:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+  800689:	74 07                	je     800692 <strtol+0x158>
+  80068b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  80068e:	f7 d8                	neg    %eax
+  800690:	eb 03                	jmp    800695 <strtol+0x15b>
+  800692:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  800695:	c9                   	leave  
+  800696:	c3                   	ret    
+
+00800697 <memset>:
+ * @n:      number of bytes to be set to the value
+ *
+ * The memset() function returns @s.
+ * */
+void *
+memset(void *s, char c, size_t n) {
+  800697:	55                   	push   %ebp
+  800698:	89 e5                	mov    %esp,%ebp
+  80069a:	57                   	push   %edi
+  80069b:	83 ec 24             	sub    $0x24,%esp
+  80069e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006a1:	88 45 d8             	mov    %al,-0x28(%ebp)
+#ifdef __HAVE_ARCH_MEMSET
+    return __memset(s, c, n);
+  8006a4:	0f be 45 d8          	movsbl -0x28(%ebp),%eax
+  8006a8:	8b 55 08             	mov    0x8(%ebp),%edx
+  8006ab:	89 55 f8             	mov    %edx,-0x8(%ebp)
+  8006ae:	88 45 f7             	mov    %al,-0x9(%ebp)
+  8006b1:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_MEMSET
+#define __HAVE_ARCH_MEMSET
+static inline void *
+__memset(void *s, char c, size_t n) {
+    int d0, d1;
+    asm volatile (
+  8006b7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+  8006ba:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
+  8006be:	8b 55 f8             	mov    -0x8(%ebp),%edx
+  8006c1:	89 d7                	mov    %edx,%edi
+  8006c3:	f3 aa                	rep stos %al,%es:(%edi)
+  8006c5:	89 fa                	mov    %edi,%edx
+  8006c7:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  8006ca:	89 55 e8             	mov    %edx,-0x18(%ebp)
+        "rep; stosb;"
+        : "=&c" (d0), "=&D" (d1)
+        : "0" (n), "a" (c), "1" (s)
+        : "memory");
+    return s;
+  8006cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8006d0:	90                   	nop
+    while (n -- > 0) {
+        *p ++ = c;
+    }
+    return s;
+#endif /* __HAVE_ARCH_MEMSET */
+}
+  8006d1:	83 c4 24             	add    $0x24,%esp
+  8006d4:	5f                   	pop    %edi
+  8006d5:	5d                   	pop    %ebp
+  8006d6:	c3                   	ret    
+
+008006d7 <memmove>:
+ * @n:      number of bytes to copy
+ *
+ * The memmove() function returns @dst.
+ * */
+void *
+memmove(void *dst, const void *src, size_t n) {
+  8006d7:	55                   	push   %ebp
+  8006d8:	89 e5                	mov    %esp,%ebp
+  8006da:	57                   	push   %edi
+  8006db:	56                   	push   %esi
+  8006dc:	53                   	push   %ebx
+  8006dd:	83 ec 30             	sub    $0x30,%esp
+  8006e0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8006e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8006e6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  8006ec:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006ef:	89 45 e8             	mov    %eax,-0x18(%ebp)
+
+#ifndef __HAVE_ARCH_MEMMOVE
+#define __HAVE_ARCH_MEMMOVE
+static inline void *
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+  8006f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006f5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  8006f8:	73 42                	jae    80073c <memmove+0x65>
+  8006fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006fd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800700:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800703:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800706:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800709:	89 45 dc             	mov    %eax,-0x24(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  80070c:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  80070f:	c1 e8 02             	shr    $0x2,%eax
+  800712:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  800714:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800717:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80071a:	89 d7                	mov    %edx,%edi
+  80071c:	89 c6                	mov    %eax,%esi
+  80071e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800720:	8b 4d dc             	mov    -0x24(%ebp),%ecx
+  800723:	83 e1 03             	and    $0x3,%ecx
+  800726:	74 02                	je     80072a <memmove+0x53>
+  800728:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  80072a:	89 f0                	mov    %esi,%eax
+  80072c:	89 fa                	mov    %edi,%edx
+  80072e:	89 4d d8             	mov    %ecx,-0x28(%ebp)
+  800731:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  800734:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  800737:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMMOVE
+    return __memmove(dst, src, n);
+  80073a:	eb 36                	jmp    800772 <memmove+0x9b>
+    asm volatile (
+        "std;"
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+  80073c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80073f:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800742:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800745:	01 c2                	add    %eax,%edx
+  800747:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80074a:	8d 48 ff             	lea    -0x1(%eax),%ecx
+  80074d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800750:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+        return __memcpy(dst, src, n);
+    }
+    int d0, d1, d2;
+    asm volatile (
+  800753:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800756:	89 c1                	mov    %eax,%ecx
+  800758:	89 d8                	mov    %ebx,%eax
+  80075a:	89 d6                	mov    %edx,%esi
+  80075c:	89 c7                	mov    %eax,%edi
+  80075e:	fd                   	std    
+  80075f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  800761:	fc                   	cld    
+  800762:	89 f8                	mov    %edi,%eax
+  800764:	89 f2                	mov    %esi,%edx
+  800766:	89 4d cc             	mov    %ecx,-0x34(%ebp)
+  800769:	89 55 c8             	mov    %edx,-0x38(%ebp)
+  80076c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+        : "memory");
+    return dst;
+  80076f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+            *d ++ = *s ++;
+        }
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMMOVE */
+}
+  800772:	83 c4 30             	add    $0x30,%esp
+  800775:	5b                   	pop    %ebx
+  800776:	5e                   	pop    %esi
+  800777:	5f                   	pop    %edi
+  800778:	5d                   	pop    %ebp
+  800779:	c3                   	ret    
+
+0080077a <memcpy>:
+ * it always copies exactly @n bytes. To avoid overflows, the size of arrays pointed
+ * by both @src and @dst, should be at least @n bytes, and should not overlap
+ * (for overlapping memory area, memmove is a safer approach).
+ * */
+void *
+memcpy(void *dst, const void *src, size_t n) {
+  80077a:	55                   	push   %ebp
+  80077b:	89 e5                	mov    %esp,%ebp
+  80077d:	57                   	push   %edi
+  80077e:	56                   	push   %esi
+  80077f:	83 ec 20             	sub    $0x20,%esp
+  800782:	8b 45 08             	mov    0x8(%ebp),%eax
+  800785:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800788:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80078b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80078e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800791:	89 45 ec             	mov    %eax,-0x14(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  800794:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800797:	c1 e8 02             	shr    $0x2,%eax
+  80079a:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  80079c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80079f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8007a2:	89 d7                	mov    %edx,%edi
+  8007a4:	89 c6                	mov    %eax,%esi
+  8007a6:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  8007a8:	8b 4d ec             	mov    -0x14(%ebp),%ecx
+  8007ab:	83 e1 03             	and    $0x3,%ecx
+  8007ae:	74 02                	je     8007b2 <memcpy+0x38>
+  8007b0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  8007b2:	89 f0                	mov    %esi,%eax
+  8007b4:	89 fa                	mov    %edi,%edx
+  8007b6:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  8007b9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  8007bc:	89 45 e0             	mov    %eax,-0x20(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  8007bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMCPY
+    return __memcpy(dst, src, n);
+  8007c2:	90                   	nop
+    while (n -- > 0) {
+        *d ++ = *s ++;
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMCPY */
+}
+  8007c3:	83 c4 20             	add    $0x20,%esp
+  8007c6:	5e                   	pop    %esi
+  8007c7:	5f                   	pop    %edi
+  8007c8:	5d                   	pop    %ebp
+  8007c9:	c3                   	ret    
+
+008007ca <memcmp>:
+ *   match in both memory blocks has a greater value in @v1 than in @v2
+ *   as if evaluated as unsigned char values;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+  8007ca:	55                   	push   %ebp
+  8007cb:	89 e5                	mov    %esp,%ebp
+  8007cd:	83 ec 10             	sub    $0x10,%esp
+    const char *s1 = (const char *)v1;
+  8007d0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8007d3:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    const char *s2 = (const char *)v2;
+  8007d6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8007d9:	89 45 f8             	mov    %eax,-0x8(%ebp)
+    while (n -- > 0) {
+  8007dc:	eb 30                	jmp    80080e <memcmp+0x44>
+        if (*s1 != *s2) {
+  8007de:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8007e1:	0f b6 10             	movzbl (%eax),%edx
+  8007e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8007e7:	0f b6 00             	movzbl (%eax),%eax
+  8007ea:	38 c2                	cmp    %al,%dl
+  8007ec:	74 18                	je     800806 <memcmp+0x3c>
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+  8007ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8007f1:	0f b6 00             	movzbl (%eax),%eax
+  8007f4:	0f b6 d0             	movzbl %al,%edx
+  8007f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8007fa:	0f b6 00             	movzbl (%eax),%eax
+  8007fd:	0f b6 c0             	movzbl %al,%eax
+  800800:	29 c2                	sub    %eax,%edx
+  800802:	89 d0                	mov    %edx,%eax
+  800804:	eb 1a                	jmp    800820 <memcmp+0x56>
+        }
+        s1 ++, s2 ++;
+  800806:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  80080a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+    const char *s1 = (const char *)v1;
+    const char *s2 = (const char *)v2;
+    while (n -- > 0) {
+  80080e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800811:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800814:	89 55 10             	mov    %edx,0x10(%ebp)
+  800817:	85 c0                	test   %eax,%eax
+  800819:	75 c3                	jne    8007de <memcmp+0x14>
+        if (*s1 != *s2) {
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+        }
+        s1 ++, s2 ++;
+    }
+    return 0;
+  80081b:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800820:	c9                   	leave  
+  800821:	c3                   	ret    
+
+00800822 <printnum>:
+ * @width:      maximum number of digits, if the actual width is less than @width, use @padc instead
+ * @padc:       character that padded on the left if the actual width is less than @width
+ * */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+        unsigned long long num, unsigned base, int width, int padc) {
+  800822:	55                   	push   %ebp
+  800823:	89 e5                	mov    %esp,%ebp
+  800825:	83 ec 38             	sub    $0x38,%esp
+  800828:	8b 45 10             	mov    0x10(%ebp),%eax
+  80082b:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  80082e:	8b 45 14             	mov    0x14(%ebp),%eax
+  800831:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+    unsigned long long result = num;
+  800834:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  800837:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  80083a:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  80083d:	89 55 ec             	mov    %edx,-0x14(%ebp)
+    unsigned mod = do_div(result, base);
+  800840:	8b 45 18             	mov    0x18(%ebp),%eax
+  800843:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800846:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800849:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  80084c:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  80084f:	89 55 f0             	mov    %edx,-0x10(%ebp)
+  800852:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800855:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800858:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  80085c:	74 1c                	je     80087a <printnum+0x58>
+  80085e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800861:	ba 00 00 00 00       	mov    $0x0,%edx
+  800866:	f7 75 e4             	divl   -0x1c(%ebp)
+  800869:	89 55 f4             	mov    %edx,-0xc(%ebp)
+  80086c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  80086f:	ba 00 00 00 00       	mov    $0x0,%edx
+  800874:	f7 75 e4             	divl   -0x1c(%ebp)
+  800877:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80087a:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80087d:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800880:	f7 75 e4             	divl   -0x1c(%ebp)
+  800883:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800886:	89 55 dc             	mov    %edx,-0x24(%ebp)
+  800889:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80088c:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  80088f:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800892:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  800895:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  800898:	89 45 d8             	mov    %eax,-0x28(%ebp)
+
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+  80089b:	8b 45 18             	mov    0x18(%ebp),%eax
+  80089e:	ba 00 00 00 00       	mov    $0x0,%edx
+  8008a3:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  8008a6:	77 41                	ja     8008e9 <printnum+0xc7>
+  8008a8:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  8008ab:	72 05                	jb     8008b2 <printnum+0x90>
+  8008ad:	3b 45 d0             	cmp    -0x30(%ebp),%eax
+  8008b0:	77 37                	ja     8008e9 <printnum+0xc7>
+        printnum(putch, putdat, result, base, width - 1, padc);
+  8008b2:	8b 45 1c             	mov    0x1c(%ebp),%eax
+  8008b5:	83 e8 01             	sub    $0x1,%eax
+  8008b8:	83 ec 04             	sub    $0x4,%esp
+  8008bb:	ff 75 20             	pushl  0x20(%ebp)
+  8008be:	50                   	push   %eax
+  8008bf:	ff 75 18             	pushl  0x18(%ebp)
+  8008c2:	ff 75 ec             	pushl  -0x14(%ebp)
+  8008c5:	ff 75 e8             	pushl  -0x18(%ebp)
+  8008c8:	ff 75 0c             	pushl  0xc(%ebp)
+  8008cb:	ff 75 08             	pushl  0x8(%ebp)
+  8008ce:	e8 4f ff ff ff       	call   800822 <printnum>
+  8008d3:	83 c4 20             	add    $0x20,%esp
+  8008d6:	eb 1b                	jmp    8008f3 <printnum+0xd1>
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+            putch(padc, putdat);
+  8008d8:	83 ec 08             	sub    $0x8,%esp
+  8008db:	ff 75 0c             	pushl  0xc(%ebp)
+  8008de:	ff 75 20             	pushl  0x20(%ebp)
+  8008e1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8008e4:	ff d0                	call   *%eax
+  8008e6:	83 c4 10             	add    $0x10,%esp
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+        printnum(putch, putdat, result, base, width - 1, padc);
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+  8008e9:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+  8008ed:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+  8008f1:	7f e5                	jg     8008d8 <printnum+0xb6>
+            putch(padc, putdat);
+    }
+    // then print this (the least significant) digit
+    putch("0123456789abcdef"[mod], putdat);
+  8008f3:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  8008f6:	05 c4 10 80 00       	add    $0x8010c4,%eax
+  8008fb:	0f b6 00             	movzbl (%eax),%eax
+  8008fe:	0f be c0             	movsbl %al,%eax
+  800901:	83 ec 08             	sub    $0x8,%esp
+  800904:	ff 75 0c             	pushl  0xc(%ebp)
+  800907:	50                   	push   %eax
+  800908:	8b 45 08             	mov    0x8(%ebp),%eax
+  80090b:	ff d0                	call   *%eax
+  80090d:	83 c4 10             	add    $0x10,%esp
+}
+  800910:	90                   	nop
+  800911:	c9                   	leave  
+  800912:	c3                   	ret    
+
+00800913 <getuint>:
+ * getuint - get an unsigned int of various possible sizes from a varargs list
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static unsigned long long
+getuint(va_list *ap, int lflag) {
+  800913:	55                   	push   %ebp
+  800914:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  800916:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  80091a:	7e 14                	jle    800930 <getuint+0x1d>
+        return va_arg(*ap, unsigned long long);
+  80091c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80091f:	8b 00                	mov    (%eax),%eax
+  800921:	8d 48 08             	lea    0x8(%eax),%ecx
+  800924:	8b 55 08             	mov    0x8(%ebp),%edx
+  800927:	89 0a                	mov    %ecx,(%edx)
+  800929:	8b 50 04             	mov    0x4(%eax),%edx
+  80092c:	8b 00                	mov    (%eax),%eax
+  80092e:	eb 30                	jmp    800960 <getuint+0x4d>
+    }
+    else if (lflag) {
+  800930:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800934:	74 16                	je     80094c <getuint+0x39>
+        return va_arg(*ap, unsigned long);
+  800936:	8b 45 08             	mov    0x8(%ebp),%eax
+  800939:	8b 00                	mov    (%eax),%eax
+  80093b:	8d 48 04             	lea    0x4(%eax),%ecx
+  80093e:	8b 55 08             	mov    0x8(%ebp),%edx
+  800941:	89 0a                	mov    %ecx,(%edx)
+  800943:	8b 00                	mov    (%eax),%eax
+  800945:	ba 00 00 00 00       	mov    $0x0,%edx
+  80094a:	eb 14                	jmp    800960 <getuint+0x4d>
+    }
+    else {
+        return va_arg(*ap, unsigned int);
+  80094c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80094f:	8b 00                	mov    (%eax),%eax
+  800951:	8d 48 04             	lea    0x4(%eax),%ecx
+  800954:	8b 55 08             	mov    0x8(%ebp),%edx
+  800957:	89 0a                	mov    %ecx,(%edx)
+  800959:	8b 00                	mov    (%eax),%eax
+  80095b:	ba 00 00 00 00       	mov    $0x0,%edx
+    }
+}
+  800960:	5d                   	pop    %ebp
+  800961:	c3                   	ret    
+
+00800962 <getint>:
+ * getint - same as getuint but signed, we can't use getuint because of sign extension
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static long long
+getint(va_list *ap, int lflag) {
+  800962:	55                   	push   %ebp
+  800963:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  800965:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  800969:	7e 14                	jle    80097f <getint+0x1d>
+        return va_arg(*ap, long long);
+  80096b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80096e:	8b 00                	mov    (%eax),%eax
+  800970:	8d 48 08             	lea    0x8(%eax),%ecx
+  800973:	8b 55 08             	mov    0x8(%ebp),%edx
+  800976:	89 0a                	mov    %ecx,(%edx)
+  800978:	8b 50 04             	mov    0x4(%eax),%edx
+  80097b:	8b 00                	mov    (%eax),%eax
+  80097d:	eb 28                	jmp    8009a7 <getint+0x45>
+    }
+    else if (lflag) {
+  80097f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800983:	74 12                	je     800997 <getint+0x35>
+        return va_arg(*ap, long);
+  800985:	8b 45 08             	mov    0x8(%ebp),%eax
+  800988:	8b 00                	mov    (%eax),%eax
+  80098a:	8d 48 04             	lea    0x4(%eax),%ecx
+  80098d:	8b 55 08             	mov    0x8(%ebp),%edx
+  800990:	89 0a                	mov    %ecx,(%edx)
+  800992:	8b 00                	mov    (%eax),%eax
+  800994:	99                   	cltd   
+  800995:	eb 10                	jmp    8009a7 <getint+0x45>
+    }
+    else {
+        return va_arg(*ap, int);
+  800997:	8b 45 08             	mov    0x8(%ebp),%eax
+  80099a:	8b 00                	mov    (%eax),%eax
+  80099c:	8d 48 04             	lea    0x4(%eax),%ecx
+  80099f:	8b 55 08             	mov    0x8(%ebp),%edx
+  8009a2:	89 0a                	mov    %ecx,(%edx)
+  8009a4:	8b 00                	mov    (%eax),%eax
+  8009a6:	99                   	cltd   
+    }
+}
+  8009a7:	5d                   	pop    %ebp
+  8009a8:	c3                   	ret    
+
+008009a9 <printfmt>:
+ * @putch:      specified putch function, print a single character
+ * @putdat:     used by @putch function
+ * @fmt:        the format string to use
+ * */
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...) {
+  8009a9:	55                   	push   %ebp
+  8009aa:	89 e5                	mov    %esp,%ebp
+  8009ac:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  8009af:	8d 45 14             	lea    0x14(%ebp),%eax
+  8009b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    vprintfmt(putch, putdat, fmt, ap);
+  8009b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8009b8:	50                   	push   %eax
+  8009b9:	ff 75 10             	pushl  0x10(%ebp)
+  8009bc:	ff 75 0c             	pushl  0xc(%ebp)
+  8009bf:	ff 75 08             	pushl  0x8(%ebp)
+  8009c2:	e8 06 00 00 00       	call   8009cd <vprintfmt>
+  8009c7:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+  8009ca:	90                   	nop
+  8009cb:	c9                   	leave  
+  8009cc:	c3                   	ret    
+
+008009cd <vprintfmt>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want printfmt() instead.
+ * */
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap) {
+  8009cd:	55                   	push   %ebp
+  8009ce:	89 e5                	mov    %esp,%ebp
+  8009d0:	56                   	push   %esi
+  8009d1:	53                   	push   %ebx
+  8009d2:	83 ec 20             	sub    $0x20,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  8009d5:	eb 17                	jmp    8009ee <vprintfmt+0x21>
+            if (ch == '\0') {
+  8009d7:	85 db                	test   %ebx,%ebx
+  8009d9:	0f 84 8e 03 00 00    	je     800d6d <vprintfmt+0x3a0>
+                return;
+            }
+            putch(ch, putdat);
+  8009df:	83 ec 08             	sub    $0x8,%esp
+  8009e2:	ff 75 0c             	pushl  0xc(%ebp)
+  8009e5:	53                   	push   %ebx
+  8009e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009e9:	ff d0                	call   *%eax
+  8009eb:	83 c4 10             	add    $0x10,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  8009ee:	8b 45 10             	mov    0x10(%ebp),%eax
+  8009f1:	8d 50 01             	lea    0x1(%eax),%edx
+  8009f4:	89 55 10             	mov    %edx,0x10(%ebp)
+  8009f7:	0f b6 00             	movzbl (%eax),%eax
+  8009fa:	0f b6 d8             	movzbl %al,%ebx
+  8009fd:	83 fb 25             	cmp    $0x25,%ebx
+  800a00:	75 d5                	jne    8009d7 <vprintfmt+0xa>
+            }
+            putch(ch, putdat);
+        }
+
+        // Process a %-escape sequence
+        char padc = ' ';
+  800a02:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+        width = precision = -1;
+  800a06:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+  800a0d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800a10:	89 45 e8             	mov    %eax,-0x18(%ebp)
+        lflag = altflag = 0;
+  800a13:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+  800a1a:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  800a1d:	89 45 e0             	mov    %eax,-0x20(%ebp)
+
+    reswitch:
+        switch (ch = *(unsigned char *)fmt ++) {
+  800a20:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a23:	8d 50 01             	lea    0x1(%eax),%edx
+  800a26:	89 55 10             	mov    %edx,0x10(%ebp)
+  800a29:	0f b6 00             	movzbl (%eax),%eax
+  800a2c:	0f b6 d8             	movzbl %al,%ebx
+  800a2f:	8d 43 dd             	lea    -0x23(%ebx),%eax
+  800a32:	83 f8 55             	cmp    $0x55,%eax
+  800a35:	0f 87 05 03 00 00    	ja     800d40 <vprintfmt+0x373>
+  800a3b:	8b 04 85 e8 10 80 00 	mov    0x8010e8(,%eax,4),%eax
+  800a42:	ff e0                	jmp    *%eax
+
+        // flag to pad on the right
+        case '-':
+            padc = '-';
+  800a44:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+            goto reswitch;
+  800a48:	eb d6                	jmp    800a20 <vprintfmt+0x53>
+
+        // flag to pad with 0's instead of spaces
+        case '0':
+            padc = '0';
+  800a4a:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+            goto reswitch;
+  800a4e:	eb d0                	jmp    800a20 <vprintfmt+0x53>
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  800a50:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+                precision = precision * 10 + ch - '0';
+  800a57:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800a5a:	89 d0                	mov    %edx,%eax
+  800a5c:	c1 e0 02             	shl    $0x2,%eax
+  800a5f:	01 d0                	add    %edx,%eax
+  800a61:	01 c0                	add    %eax,%eax
+  800a63:	01 d8                	add    %ebx,%eax
+  800a65:	83 e8 30             	sub    $0x30,%eax
+  800a68:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+                ch = *fmt;
+  800a6b:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a6e:	0f b6 00             	movzbl (%eax),%eax
+  800a71:	0f be d8             	movsbl %al,%ebx
+                if (ch < '0' || ch > '9') {
+  800a74:	83 fb 2f             	cmp    $0x2f,%ebx
+  800a77:	7e 39                	jle    800ab2 <vprintfmt+0xe5>
+  800a79:	83 fb 39             	cmp    $0x39,%ebx
+  800a7c:	7f 34                	jg     800ab2 <vprintfmt+0xe5>
+            padc = '0';
+            goto reswitch;
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  800a7e:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+                precision = precision * 10 + ch - '0';
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+  800a82:	eb d3                	jmp    800a57 <vprintfmt+0x8a>
+            goto process_precision;
+
+        case '*':
+            precision = va_arg(ap, int);
+  800a84:	8b 45 14             	mov    0x14(%ebp),%eax
+  800a87:	8d 50 04             	lea    0x4(%eax),%edx
+  800a8a:	89 55 14             	mov    %edx,0x14(%ebp)
+  800a8d:	8b 00                	mov    (%eax),%eax
+  800a8f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+            goto process_precision;
+  800a92:	eb 1f                	jmp    800ab3 <vprintfmt+0xe6>
+
+        case '.':
+            if (width < 0)
+  800a94:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800a98:	79 86                	jns    800a20 <vprintfmt+0x53>
+                width = 0;
+  800a9a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+            goto reswitch;
+  800aa1:	e9 7a ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        case '#':
+            altflag = 1;
+  800aa6:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+            goto reswitch;
+  800aad:	e9 6e ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+            goto process_precision;
+  800ab2:	90                   	nop
+        case '#':
+            altflag = 1;
+            goto reswitch;
+
+        process_precision:
+            if (width < 0)
+  800ab3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ab7:	0f 89 63 ff ff ff    	jns    800a20 <vprintfmt+0x53>
+                width = precision, precision = -1;
+  800abd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800ac0:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800ac3:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+            goto reswitch;
+  800aca:	e9 51 ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        // long flag (doubled for long long)
+        case 'l':
+            lflag ++;
+  800acf:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
+            goto reswitch;
+  800ad3:	e9 48 ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        // character
+        case 'c':
+            putch(va_arg(ap, int), putdat);
+  800ad8:	8b 45 14             	mov    0x14(%ebp),%eax
+  800adb:	8d 50 04             	lea    0x4(%eax),%edx
+  800ade:	89 55 14             	mov    %edx,0x14(%ebp)
+  800ae1:	8b 00                	mov    (%eax),%eax
+  800ae3:	83 ec 08             	sub    $0x8,%esp
+  800ae6:	ff 75 0c             	pushl  0xc(%ebp)
+  800ae9:	50                   	push   %eax
+  800aea:	8b 45 08             	mov    0x8(%ebp),%eax
+  800aed:	ff d0                	call   *%eax
+  800aef:	83 c4 10             	add    $0x10,%esp
+            break;
+  800af2:	e9 71 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // error message
+        case 'e':
+            err = va_arg(ap, int);
+  800af7:	8b 45 14             	mov    0x14(%ebp),%eax
+  800afa:	8d 50 04             	lea    0x4(%eax),%edx
+  800afd:	89 55 14             	mov    %edx,0x14(%ebp)
+  800b00:	8b 18                	mov    (%eax),%ebx
+            if (err < 0) {
+  800b02:	85 db                	test   %ebx,%ebx
+  800b04:	79 02                	jns    800b08 <vprintfmt+0x13b>
+                err = -err;
+  800b06:	f7 db                	neg    %ebx
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+  800b08:	83 fb 18             	cmp    $0x18,%ebx
+  800b0b:	7f 0b                	jg     800b18 <vprintfmt+0x14b>
+  800b0d:	8b 34 9d 60 10 80 00 	mov    0x801060(,%ebx,4),%esi
+  800b14:	85 f6                	test   %esi,%esi
+  800b16:	75 19                	jne    800b31 <vprintfmt+0x164>
+                printfmt(putch, putdat, "error %d", err);
+  800b18:	53                   	push   %ebx
+  800b19:	68 d5 10 80 00       	push   $0x8010d5
+  800b1e:	ff 75 0c             	pushl  0xc(%ebp)
+  800b21:	ff 75 08             	pushl  0x8(%ebp)
+  800b24:	e8 80 fe ff ff       	call   8009a9 <printfmt>
+  800b29:	83 c4 10             	add    $0x10,%esp
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+            }
+            break;
+  800b2c:	e9 37 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+                printfmt(putch, putdat, "error %d", err);
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+  800b31:	56                   	push   %esi
+  800b32:	68 de 10 80 00       	push   $0x8010de
+  800b37:	ff 75 0c             	pushl  0xc(%ebp)
+  800b3a:	ff 75 08             	pushl  0x8(%ebp)
+  800b3d:	e8 67 fe ff ff       	call   8009a9 <printfmt>
+  800b42:	83 c4 10             	add    $0x10,%esp
+            }
+            break;
+  800b45:	e9 1e 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // string
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+  800b4a:	8b 45 14             	mov    0x14(%ebp),%eax
+  800b4d:	8d 50 04             	lea    0x4(%eax),%edx
+  800b50:	89 55 14             	mov    %edx,0x14(%ebp)
+  800b53:	8b 30                	mov    (%eax),%esi
+  800b55:	85 f6                	test   %esi,%esi
+  800b57:	75 05                	jne    800b5e <vprintfmt+0x191>
+                p = "(null)";
+  800b59:	be e1 10 80 00       	mov    $0x8010e1,%esi
+            }
+            if (width > 0 && padc != '-') {
+  800b5e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800b62:	7e 76                	jle    800bda <vprintfmt+0x20d>
+  800b64:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+  800b68:	74 70                	je     800bda <vprintfmt+0x20d>
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  800b6a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800b6d:	83 ec 08             	sub    $0x8,%esp
+  800b70:	50                   	push   %eax
+  800b71:	56                   	push   %esi
+  800b72:	e8 17 f8 ff ff       	call   80038e <strnlen>
+  800b77:	83 c4 10             	add    $0x10,%esp
+  800b7a:	89 c2                	mov    %eax,%edx
+  800b7c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800b7f:	29 d0                	sub    %edx,%eax
+  800b81:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800b84:	eb 17                	jmp    800b9d <vprintfmt+0x1d0>
+                    putch(padc, putdat);
+  800b86:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+  800b8a:	83 ec 08             	sub    $0x8,%esp
+  800b8d:	ff 75 0c             	pushl  0xc(%ebp)
+  800b90:	50                   	push   %eax
+  800b91:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b94:	ff d0                	call   *%eax
+  800b96:	83 c4 10             	add    $0x10,%esp
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+                p = "(null)";
+            }
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  800b99:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800b9d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ba1:	7f e3                	jg     800b86 <vprintfmt+0x1b9>
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  800ba3:	eb 35                	jmp    800bda <vprintfmt+0x20d>
+                if (altflag && (ch < ' ' || ch > '~')) {
+  800ba5:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+  800ba9:	74 1c                	je     800bc7 <vprintfmt+0x1fa>
+  800bab:	83 fb 1f             	cmp    $0x1f,%ebx
+  800bae:	7e 05                	jle    800bb5 <vprintfmt+0x1e8>
+  800bb0:	83 fb 7e             	cmp    $0x7e,%ebx
+  800bb3:	7e 12                	jle    800bc7 <vprintfmt+0x1fa>
+                    putch('?', putdat);
+  800bb5:	83 ec 08             	sub    $0x8,%esp
+  800bb8:	ff 75 0c             	pushl  0xc(%ebp)
+  800bbb:	6a 3f                	push   $0x3f
+  800bbd:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bc0:	ff d0                	call   *%eax
+  800bc2:	83 c4 10             	add    $0x10,%esp
+  800bc5:	eb 0f                	jmp    800bd6 <vprintfmt+0x209>
+                }
+                else {
+                    putch(ch, putdat);
+  800bc7:	83 ec 08             	sub    $0x8,%esp
+  800bca:	ff 75 0c             	pushl  0xc(%ebp)
+  800bcd:	53                   	push   %ebx
+  800bce:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bd1:	ff d0                	call   *%eax
+  800bd3:	83 c4 10             	add    $0x10,%esp
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  800bd6:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800bda:	89 f0                	mov    %esi,%eax
+  800bdc:	8d 70 01             	lea    0x1(%eax),%esi
+  800bdf:	0f b6 00             	movzbl (%eax),%eax
+  800be2:	0f be d8             	movsbl %al,%ebx
+  800be5:	85 db                	test   %ebx,%ebx
+  800be7:	74 26                	je     800c0f <vprintfmt+0x242>
+  800be9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800bed:	78 b6                	js     800ba5 <vprintfmt+0x1d8>
+  800bef:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800bf3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800bf7:	79 ac                	jns    800ba5 <vprintfmt+0x1d8>
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  800bf9:	eb 14                	jmp    800c0f <vprintfmt+0x242>
+                putch(' ', putdat);
+  800bfb:	83 ec 08             	sub    $0x8,%esp
+  800bfe:	ff 75 0c             	pushl  0xc(%ebp)
+  800c01:	6a 20                	push   $0x20
+  800c03:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c06:	ff d0                	call   *%eax
+  800c08:	83 c4 10             	add    $0x10,%esp
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  800c0b:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800c0f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800c13:	7f e6                	jg     800bfb <vprintfmt+0x22e>
+                putch(' ', putdat);
+            }
+            break;
+  800c15:	e9 4e 01 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // (signed) decimal
+        case 'd':
+            num = getint(&ap, lflag);
+  800c1a:	83 ec 08             	sub    $0x8,%esp
+  800c1d:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c20:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c23:	50                   	push   %eax
+  800c24:	e8 39 fd ff ff       	call   800962 <getint>
+  800c29:	83 c4 10             	add    $0x10,%esp
+  800c2c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c2f:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            if ((long long)num < 0) {
+  800c32:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c35:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800c38:	85 d2                	test   %edx,%edx
+  800c3a:	79 23                	jns    800c5f <vprintfmt+0x292>
+                putch('-', putdat);
+  800c3c:	83 ec 08             	sub    $0x8,%esp
+  800c3f:	ff 75 0c             	pushl  0xc(%ebp)
+  800c42:	6a 2d                	push   $0x2d
+  800c44:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c47:	ff d0                	call   *%eax
+  800c49:	83 c4 10             	add    $0x10,%esp
+                num = -(long long)num;
+  800c4c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c4f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800c52:	f7 d8                	neg    %eax
+  800c54:	83 d2 00             	adc    $0x0,%edx
+  800c57:	f7 da                	neg    %edx
+  800c59:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c5c:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            }
+            base = 10;
+  800c5f:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  800c66:	e9 9f 00 00 00       	jmp    800d0a <vprintfmt+0x33d>
+
+        // unsigned decimal
+        case 'u':
+            num = getuint(&ap, lflag);
+  800c6b:	83 ec 08             	sub    $0x8,%esp
+  800c6e:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c71:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c74:	50                   	push   %eax
+  800c75:	e8 99 fc ff ff       	call   800913 <getuint>
+  800c7a:	83 c4 10             	add    $0x10,%esp
+  800c7d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c80:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 10;
+  800c83:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  800c8a:	eb 7e                	jmp    800d0a <vprintfmt+0x33d>
+
+        // (unsigned) octal
+        case 'o':
+            num = getuint(&ap, lflag);
+  800c8c:	83 ec 08             	sub    $0x8,%esp
+  800c8f:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c92:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c95:	50                   	push   %eax
+  800c96:	e8 78 fc ff ff       	call   800913 <getuint>
+  800c9b:	83 c4 10             	add    $0x10,%esp
+  800c9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800ca1:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 8;
+  800ca4:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+            goto number;
+  800cab:	eb 5d                	jmp    800d0a <vprintfmt+0x33d>
+
+        // pointer
+        case 'p':
+            putch('0', putdat);
+  800cad:	83 ec 08             	sub    $0x8,%esp
+  800cb0:	ff 75 0c             	pushl  0xc(%ebp)
+  800cb3:	6a 30                	push   $0x30
+  800cb5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cb8:	ff d0                	call   *%eax
+  800cba:	83 c4 10             	add    $0x10,%esp
+            putch('x', putdat);
+  800cbd:	83 ec 08             	sub    $0x8,%esp
+  800cc0:	ff 75 0c             	pushl  0xc(%ebp)
+  800cc3:	6a 78                	push   $0x78
+  800cc5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cc8:	ff d0                	call   *%eax
+  800cca:	83 c4 10             	add    $0x10,%esp
+            num = (unsigned long long)(uintptr_t)va_arg(ap, void *);
+  800ccd:	8b 45 14             	mov    0x14(%ebp),%eax
+  800cd0:	8d 50 04             	lea    0x4(%eax),%edx
+  800cd3:	89 55 14             	mov    %edx,0x14(%ebp)
+  800cd6:	8b 00                	mov    (%eax),%eax
+  800cd8:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800cdb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+            base = 16;
+  800ce2:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+            goto number;
+  800ce9:	eb 1f                	jmp    800d0a <vprintfmt+0x33d>
+
+        // (unsigned) hexadecimal
+        case 'x':
+            num = getuint(&ap, lflag);
+  800ceb:	83 ec 08             	sub    $0x8,%esp
+  800cee:	ff 75 e0             	pushl  -0x20(%ebp)
+  800cf1:	8d 45 14             	lea    0x14(%ebp),%eax
+  800cf4:	50                   	push   %eax
+  800cf5:	e8 19 fc ff ff       	call   800913 <getuint>
+  800cfa:	83 c4 10             	add    $0x10,%esp
+  800cfd:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800d00:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 16;
+  800d03:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+        number:
+            printnum(putch, putdat, num, base, width, padc);
+  800d0a:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+  800d0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800d11:	83 ec 04             	sub    $0x4,%esp
+  800d14:	52                   	push   %edx
+  800d15:	ff 75 e8             	pushl  -0x18(%ebp)
+  800d18:	50                   	push   %eax
+  800d19:	ff 75 f4             	pushl  -0xc(%ebp)
+  800d1c:	ff 75 f0             	pushl  -0x10(%ebp)
+  800d1f:	ff 75 0c             	pushl  0xc(%ebp)
+  800d22:	ff 75 08             	pushl  0x8(%ebp)
+  800d25:	e8 f8 fa ff ff       	call   800822 <printnum>
+  800d2a:	83 c4 20             	add    $0x20,%esp
+            break;
+  800d2d:	eb 39                	jmp    800d68 <vprintfmt+0x39b>
+
+        // escaped '%' character
+        case '%':
+            putch(ch, putdat);
+  800d2f:	83 ec 08             	sub    $0x8,%esp
+  800d32:	ff 75 0c             	pushl  0xc(%ebp)
+  800d35:	53                   	push   %ebx
+  800d36:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d39:	ff d0                	call   *%eax
+  800d3b:	83 c4 10             	add    $0x10,%esp
+            break;
+  800d3e:	eb 28                	jmp    800d68 <vprintfmt+0x39b>
+
+        // unrecognized escape sequence - just print it literally
+        default:
+            putch('%', putdat);
+  800d40:	83 ec 08             	sub    $0x8,%esp
+  800d43:	ff 75 0c             	pushl  0xc(%ebp)
+  800d46:	6a 25                	push   $0x25
+  800d48:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d4b:	ff d0                	call   *%eax
+  800d4d:	83 c4 10             	add    $0x10,%esp
+            for (fmt --; fmt[-1] != '%'; fmt --)
+  800d50:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800d54:	eb 04                	jmp    800d5a <vprintfmt+0x38d>
+  800d56:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800d5a:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d5d:	83 e8 01             	sub    $0x1,%eax
+  800d60:	0f b6 00             	movzbl (%eax),%eax
+  800d63:	3c 25                	cmp    $0x25,%al
+  800d65:	75 ef                	jne    800d56 <vprintfmt+0x389>
+                /* do nothing */;
+            break;
+  800d67:	90                   	nop
+        }
+    }
+  800d68:	e9 68 fc ff ff       	jmp    8009d5 <vprintfmt+0x8>
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+            if (ch == '\0') {
+                return;
+  800d6d:	90                   	nop
+            for (fmt --; fmt[-1] != '%'; fmt --)
+                /* do nothing */;
+            break;
+        }
+    }
+}
+  800d6e:	8d 65 f8             	lea    -0x8(%ebp),%esp
+  800d71:	5b                   	pop    %ebx
+  800d72:	5e                   	pop    %esi
+  800d73:	5d                   	pop    %ebp
+  800d74:	c3                   	ret    
+
+00800d75 <sprintputch>:
+ * sprintputch - 'print' a single character in a buffer
+ * @ch:         the character will be printed
+ * @b:          the buffer to place the character @ch
+ * */
+static void
+sprintputch(int ch, struct sprintbuf *b) {
+  800d75:	55                   	push   %ebp
+  800d76:	89 e5                	mov    %esp,%ebp
+    b->cnt ++;
+  800d78:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d7b:	8b 40 08             	mov    0x8(%eax),%eax
+  800d7e:	8d 50 01             	lea    0x1(%eax),%edx
+  800d81:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d84:	89 50 08             	mov    %edx,0x8(%eax)
+    if (b->buf < b->ebuf) {
+  800d87:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8a:	8b 10                	mov    (%eax),%edx
+  800d8c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8f:	8b 40 04             	mov    0x4(%eax),%eax
+  800d92:	39 c2                	cmp    %eax,%edx
+  800d94:	73 12                	jae    800da8 <sprintputch+0x33>
+        *b->buf ++ = ch;
+  800d96:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d99:	8b 00                	mov    (%eax),%eax
+  800d9b:	8d 48 01             	lea    0x1(%eax),%ecx
+  800d9e:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800da1:	89 0a                	mov    %ecx,(%edx)
+  800da3:	8b 55 08             	mov    0x8(%ebp),%edx
+  800da6:	88 10                	mov    %dl,(%eax)
+    }
+}
+  800da8:	90                   	nop
+  800da9:	5d                   	pop    %ebp
+  800daa:	c3                   	ret    
+
+00800dab <snprintf>:
+ * @str:        the buffer to place the result into
+ * @size:       the size of buffer, including the trailing null space
+ * @fmt:        the format string to use
+ * */
+int
+snprintf(char *str, size_t size, const char *fmt, ...) {
+  800dab:	55                   	push   %ebp
+  800dac:	89 e5                	mov    %esp,%ebp
+  800dae:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    int cnt;
+    va_start(ap, fmt);
+  800db1:	8d 45 14             	lea    0x14(%ebp),%eax
+  800db4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    cnt = vsnprintf(str, size, fmt, ap);
+  800db7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800dba:	50                   	push   %eax
+  800dbb:	ff 75 10             	pushl  0x10(%ebp)
+  800dbe:	ff 75 0c             	pushl  0xc(%ebp)
+  800dc1:	ff 75 08             	pushl  0x8(%ebp)
+  800dc4:	e8 0b 00 00 00       	call   800dd4 <vsnprintf>
+  800dc9:	83 c4 10             	add    $0x10,%esp
+  800dcc:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+    return cnt;
+  800dcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800dd2:	c9                   	leave  
+  800dd3:	c3                   	ret    
+
+00800dd4 <vsnprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want snprintf() instead.
+ * */
+int
+vsnprintf(char *str, size_t size, const char *fmt, va_list ap) {
+  800dd4:	55                   	push   %ebp
+  800dd5:	89 e5                	mov    %esp,%ebp
+  800dd7:	83 ec 18             	sub    $0x18,%esp
+    struct sprintbuf b = {str, str + size - 1, 0};
+  800dda:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ddd:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800de0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800de3:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800de6:	8b 45 08             	mov    0x8(%ebp),%eax
+  800de9:	01 d0                	add    %edx,%eax
+  800deb:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800dee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    if (str == NULL || b.buf > b.ebuf) {
+  800df5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  800df9:	74 0a                	je     800e05 <vsnprintf+0x31>
+  800dfb:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  800dfe:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800e01:	39 c2                	cmp    %eax,%edx
+  800e03:	76 07                	jbe    800e0c <vsnprintf+0x38>
+        return -E_INVAL;
+  800e05:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+  800e0a:	eb 20                	jmp    800e2c <vsnprintf+0x58>
+    }
+    // print the string to the buffer
+    vprintfmt((void*)sprintputch, &b, fmt, ap);
+  800e0c:	ff 75 14             	pushl  0x14(%ebp)
+  800e0f:	ff 75 10             	pushl  0x10(%ebp)
+  800e12:	8d 45 ec             	lea    -0x14(%ebp),%eax
+  800e15:	50                   	push   %eax
+  800e16:	68 75 0d 80 00       	push   $0x800d75
+  800e1b:	e8 ad fb ff ff       	call   8009cd <vprintfmt>
+  800e20:	83 c4 10             	add    $0x10,%esp
+    // null terminate the buffer
+    *b.buf = '\0';
+  800e23:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e26:	c6 00 00             	movb   $0x0,(%eax)
+    return b.cnt;
+  800e29:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800e2c:	c9                   	leave  
+  800e2d:	c3                   	ret    
+
+00800e2e <hash32>:
+ * @bits:   the number of bits in a return value
+ *
+ * High bits are more random, so we use them.
+ * */
+uint32_t
+hash32(uint32_t val, unsigned int bits) {
+  800e2e:	55                   	push   %ebp
+  800e2f:	89 e5                	mov    %esp,%ebp
+  800e31:	83 ec 10             	sub    $0x10,%esp
+    uint32_t hash = val * GOLDEN_RATIO_PRIME_32;
+  800e34:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e37:	69 c0 01 00 37 9e    	imul   $0x9e370001,%eax,%eax
+  800e3d:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    return (hash >> (32 - bits));
+  800e40:	b8 20 00 00 00       	mov    $0x20,%eax
+  800e45:	2b 45 0c             	sub    0xc(%ebp),%eax
+  800e48:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  800e4b:	89 c1                	mov    %eax,%ecx
+  800e4d:	d3 ea                	shr    %cl,%edx
+  800e4f:	89 d0                	mov    %edx,%eax
+}
+  800e51:	c9                   	leave  
+  800e52:	c3                   	ret    
+
+00800e53 <rand>:
+ * rand - returns a pseudo-random integer
+ *
+ * The rand() function return a value in the range [0, RAND_MAX].
+ * */
+int
+rand(void) {
+  800e53:	55                   	push   %ebp
+  800e54:	89 e5                	mov    %esp,%ebp
+  800e56:	57                   	push   %edi
+  800e57:	56                   	push   %esi
+  800e58:	53                   	push   %ebx
+  800e59:	83 ec 24             	sub    $0x24,%esp
+    next = (next * 0x5DEECE66DLL + 0xBLL) & ((1LL << 48) - 1);
+  800e5c:	a1 00 20 80 00       	mov    0x802000,%eax
+  800e61:	8b 15 04 20 80 00    	mov    0x802004,%edx
+  800e67:	69 fa 6d e6 ec de    	imul   $0xdeece66d,%edx,%edi
+  800e6d:	6b f0 05             	imul   $0x5,%eax,%esi
+  800e70:	01 fe                	add    %edi,%esi
+  800e72:	bf 6d e6 ec de       	mov    $0xdeece66d,%edi
+  800e77:	f7 e7                	mul    %edi
+  800e79:	01 d6                	add    %edx,%esi
+  800e7b:	89 f2                	mov    %esi,%edx
+  800e7d:	83 c0 0b             	add    $0xb,%eax
+  800e80:	83 d2 00             	adc    $0x0,%edx
+  800e83:	89 c7                	mov    %eax,%edi
+  800e85:	83 e7 ff             	and    $0xffffffff,%edi
+  800e88:	89 f9                	mov    %edi,%ecx
+  800e8a:	0f b7 da             	movzwl %dx,%ebx
+  800e8d:	89 0d 00 20 80 00    	mov    %ecx,0x802000
+  800e93:	89 1d 04 20 80 00    	mov    %ebx,0x802004
+    unsigned long long result = (next >> 12);
+  800e99:	a1 00 20 80 00       	mov    0x802000,%eax
+  800e9e:	8b 15 04 20 80 00    	mov    0x802004,%edx
+  800ea4:	0f ac d0 0c          	shrd   $0xc,%edx,%eax
+  800ea8:	c1 ea 0c             	shr    $0xc,%edx
+  800eab:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800eae:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+    return (int)do_div(result, RAND_MAX + 1);
+  800eb1:	c7 45 dc 00 00 00 80 	movl   $0x80000000,-0x24(%ebp)
+  800eb8:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  800ebb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800ebe:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  800ec1:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  800ec4:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ec7:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800eca:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ece:	74 1c                	je     800eec <rand+0x99>
+  800ed0:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ed3:	ba 00 00 00 00       	mov    $0x0,%edx
+  800ed8:	f7 75 dc             	divl   -0x24(%ebp)
+  800edb:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  800ede:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ee1:	ba 00 00 00 00       	mov    $0x0,%edx
+  800ee6:	f7 75 dc             	divl   -0x24(%ebp)
+  800ee9:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800eec:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  800eef:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  800ef2:	f7 75 dc             	divl   -0x24(%ebp)
+  800ef5:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  800ef8:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  800efb:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  800efe:	8b 55 e8             	mov    -0x18(%ebp),%edx
+  800f01:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800f04:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  800f07:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+}
+  800f0a:	83 c4 24             	add    $0x24,%esp
+  800f0d:	5b                   	pop    %ebx
+  800f0e:	5e                   	pop    %esi
+  800f0f:	5f                   	pop    %edi
+  800f10:	5d                   	pop    %ebp
+  800f11:	c3                   	ret    
+
+00800f12 <srand>:
+/* *
+ * srand - seed the random number generator with the given number
+ * @seed:   the required seed number
+ * */
+void
+srand(unsigned int seed) {
+  800f12:	55                   	push   %ebp
+  800f13:	89 e5                	mov    %esp,%ebp
+    next = seed;
+  800f15:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f18:	ba 00 00 00 00       	mov    $0x0,%edx
+  800f1d:	a3 00 20 80 00       	mov    %eax,0x802000
+  800f22:	89 15 04 20 80 00    	mov    %edx,0x802004
+}
+  800f28:	90                   	nop
+  800f29:	5d                   	pop    %ebp
+  800f2a:	c3                   	ret    
+
+00800f2b <main>:
+#include <stdio.h>
+#include <ulib.h>
+
+int
+main(void) {
+  800f2b:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+  800f2f:	83 e4 f0             	and    $0xfffffff0,%esp
+  800f32:	ff 71 fc             	pushl  -0x4(%ecx)
+  800f35:	55                   	push   %ebp
+  800f36:	89 e5                	mov    %esp,%ebp
+  800f38:	51                   	push   %ecx
+  800f39:	83 ec 04             	sub    $0x4,%esp
+    asm volatile("int $14");
+  800f3c:	cd 0e                	int    $0xe
+    panic("FAIL: T.T\n");
+  800f3e:	83 ec 04             	sub    $0x4,%esp
+  800f41:	68 40 12 80 00       	push   $0x801240
+  800f46:	6a 07                	push   $0x7
+  800f48:	68 4b 12 80 00       	push   $0x80124b
+  800f4d:	e8 ce f0 ff ff       	call   800020 <__panic>
diff -r -u -P lab6_origin/obj/user/softint.d lab6/obj/user/softint.d
--- lab6_origin/obj/user/softint.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/softint.d	2019-05-13 17:39:38.362055200 +0800
@@ -0,0 +1,2 @@
+obj/user/softint.o obj/user/softint.d: user/softint.c libs/stdio.h \
+ libs/defs.h libs/stdarg.h user/libs/ulib.h
Binary files lab6_origin/obj/user/softint.o and lab6/obj/user/softint.o differ
diff -r -u -P lab6_origin/obj/user/softint.sym lab6/obj/user/softint.sym
--- lab6_origin/obj/user/softint.sym	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/softint.sym	2019-05-13 17:39:43.753959600 +0800
@@ -0,0 +1,76 @@
+00800020 .text
+00800f60 .rodata
+00802000 .data
+00200000 .stab_info
+00200010 .stab
+00202c8d .stabstr
+00000000 panic.c
+00000000 syscall.c
+008000b5 syscall
+00000000 ulib.c
+00000000 stdio.c
+0080028c cputch
+00000000 umain.c
+00000000 string.c
+00000000 printfmt.c
+00801060 error_string
+00800822 printnum
+00800913 getuint
+00800962 getint
+00800d75 sprintputch
+00000000 hash.c
+00000000 rand.c
+00802000 next
+00000000 softint.c
+008003be strcpy
+0080021a yield
+00800201 waitpid
+00800141 sys_yield
+008006d7 memmove
+00800dab snprintf
+008009cd vprintfmt
+0080011d sys_fork
+008002d9 cprintf
+0080023e getpid
+0080077a memcpy
+00800266 lab6_set_priority
+00800dd4 vsnprintf
+0080034d umain
+00202c8c __STAB_END__
+00800150 sys_kill
+00202c8d __STABSTR_BEGIN__
+00800020 __panic
+0080053a strtol
+0080038e strnlen
+0080024b print_pgdir
+00800228 kill
+0080050b strfind
+008001ea wait
+0080027d _start
+00800e53 rand
+00800482 strncmp
+00800171 sys_putc
+008003fe strncpy
+008007ca memcmp
+008001dd fork
+00800697 memset
+00800f2b main
+00800f12 srand
+00800e2e hash32
+008009a9 printfmt
+00203a6d __STABSTR_END__
+00800438 strcmp
+00800259 gettime_msec
+00800192 sys_gettime
+008002b0 vcprintf
+0080006e __warn
+008002ff cputs
+008001a1 sys_lab6_set_priority
+008001b7 exit
+0080012c sys_wait
+0080010b sys_exit
+00200010 __STAB_BEGIN__
+00800366 strlen
+00800183 sys_pgdir
+008004d8 strchr
+00800162 sys_getpid
diff -r -u -P lab6_origin/obj/user/spin.asm lab6/obj/user/spin.asm
--- lab6_origin/obj/user/spin.asm	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/spin.asm	2019-05-13 17:39:43.690995900 +0800
@@ -0,0 +1,2661 @@
+
+obj/__user_spin.out:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00800020 <__panic>:
+#include <stdio.h>
+#include <ulib.h>
+#include <error.h>
+
+void
+__panic(const char *file, int line, const char *fmt, ...) {
+  800020:	55                   	push   %ebp
+  800021:	89 e5                	mov    %esp,%ebp
+  800023:	83 ec 18             	sub    $0x18,%esp
+    // print the 'message'
+    va_list ap;
+    va_start(ap, fmt);
+  800026:	8d 45 14             	lea    0x14(%ebp),%eax
+  800029:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("user panic at %s:%d:\n    ", file, line);
+  80002c:	83 ec 04             	sub    $0x4,%esp
+  80002f:	ff 75 0c             	pushl  0xc(%ebp)
+  800032:	ff 75 08             	pushl  0x8(%ebp)
+  800035:	68 40 10 80 00       	push   $0x801040
+  80003a:	e8 9a 02 00 00       	call   8002d9 <cprintf>
+  80003f:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+  800042:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800045:	83 ec 08             	sub    $0x8,%esp
+  800048:	50                   	push   %eax
+  800049:	ff 75 10             	pushl  0x10(%ebp)
+  80004c:	e8 5f 02 00 00       	call   8002b0 <vcprintf>
+  800051:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+  800054:	83 ec 0c             	sub    $0xc,%esp
+  800057:	68 5a 10 80 00       	push   $0x80105a
+  80005c:	e8 78 02 00 00       	call   8002d9 <cprintf>
+  800061:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+    exit(-E_PANIC);
+  800064:	83 ec 0c             	sub    $0xc,%esp
+  800067:	6a f6                	push   $0xfffffff6
+  800069:	e8 49 01 00 00       	call   8001b7 <exit>
+
+0080006e <__warn>:
+}
+
+void
+__warn(const char *file, int line, const char *fmt, ...) {
+  80006e:	55                   	push   %ebp
+  80006f:	89 e5                	mov    %esp,%ebp
+  800071:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    va_start(ap, fmt);
+  800074:	8d 45 14             	lea    0x14(%ebp),%eax
+  800077:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("user warning at %s:%d:\n    ", file, line);
+  80007a:	83 ec 04             	sub    $0x4,%esp
+  80007d:	ff 75 0c             	pushl  0xc(%ebp)
+  800080:	ff 75 08             	pushl  0x8(%ebp)
+  800083:	68 5c 10 80 00       	push   $0x80105c
+  800088:	e8 4c 02 00 00       	call   8002d9 <cprintf>
+  80008d:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+  800090:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800093:	83 ec 08             	sub    $0x8,%esp
+  800096:	50                   	push   %eax
+  800097:	ff 75 10             	pushl  0x10(%ebp)
+  80009a:	e8 11 02 00 00       	call   8002b0 <vcprintf>
+  80009f:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+  8000a2:	83 ec 0c             	sub    $0xc,%esp
+  8000a5:	68 5a 10 80 00       	push   $0x80105a
+  8000aa:	e8 2a 02 00 00       	call   8002d9 <cprintf>
+  8000af:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+  8000b2:	90                   	nop
+  8000b3:	c9                   	leave  
+  8000b4:	c3                   	ret    
+
+008000b5 <syscall>:
+#include <syscall.h>
+
+#define MAX_ARGS            5
+
+static inline int
+syscall(int num, ...) {
+  8000b5:	55                   	push   %ebp
+  8000b6:	89 e5                	mov    %esp,%ebp
+  8000b8:	57                   	push   %edi
+  8000b9:	56                   	push   %esi
+  8000ba:	53                   	push   %ebx
+  8000bb:	83 ec 20             	sub    $0x20,%esp
+    va_list ap;
+    va_start(ap, num);
+  8000be:	8d 45 0c             	lea    0xc(%ebp),%eax
+  8000c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    uint32_t a[MAX_ARGS];
+    int i, ret;
+    for (i = 0; i < MAX_ARGS; i ++) {
+  8000c4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  8000cb:	eb 16                	jmp    8000e3 <syscall+0x2e>
+        a[i] = va_arg(ap, uint32_t);
+  8000cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8000d0:	8d 50 04             	lea    0x4(%eax),%edx
+  8000d3:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  8000d6:	8b 10                	mov    (%eax),%edx
+  8000d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8000db:	89 54 85 d4          	mov    %edx,-0x2c(%ebp,%eax,4)
+syscall(int num, ...) {
+    va_list ap;
+    va_start(ap, num);
+    uint32_t a[MAX_ARGS];
+    int i, ret;
+    for (i = 0; i < MAX_ARGS; i ++) {
+  8000df:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+  8000e3:	83 7d f0 04          	cmpl   $0x4,-0x10(%ebp)
+  8000e7:	7e e4                	jle    8000cd <syscall+0x18>
+    asm volatile (
+        "int %1;"
+        : "=a" (ret)
+        : "i" (T_SYSCALL),
+          "a" (num),
+          "d" (a[0]),
+  8000e9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+          "c" (a[1]),
+  8000ec:	8b 4d d8             	mov    -0x28(%ebp),%ecx
+          "b" (a[2]),
+  8000ef:	8b 5d dc             	mov    -0x24(%ebp),%ebx
+          "D" (a[3]),
+  8000f2:	8b 7d e0             	mov    -0x20(%ebp),%edi
+          "S" (a[4])
+  8000f5:	8b 75 e4             	mov    -0x1c(%ebp),%esi
+    for (i = 0; i < MAX_ARGS; i ++) {
+        a[i] = va_arg(ap, uint32_t);
+    }
+    va_end(ap);
+
+    asm volatile (
+  8000f8:	8b 45 08             	mov    0x8(%ebp),%eax
+  8000fb:	cd 80                	int    $0x80
+  8000fd:	89 45 ec             	mov    %eax,-0x14(%ebp)
+          "c" (a[1]),
+          "b" (a[2]),
+          "D" (a[3]),
+          "S" (a[4])
+        : "cc", "memory");
+    return ret;
+  800100:	8b 45 ec             	mov    -0x14(%ebp),%eax
+}
+  800103:	83 c4 20             	add    $0x20,%esp
+  800106:	5b                   	pop    %ebx
+  800107:	5e                   	pop    %esi
+  800108:	5f                   	pop    %edi
+  800109:	5d                   	pop    %ebp
+  80010a:	c3                   	ret    
+
+0080010b <sys_exit>:
+
+int
+sys_exit(int error_code) {
+  80010b:	55                   	push   %ebp
+  80010c:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_exit, error_code);
+  80010e:	ff 75 08             	pushl  0x8(%ebp)
+  800111:	6a 01                	push   $0x1
+  800113:	e8 9d ff ff ff       	call   8000b5 <syscall>
+  800118:	83 c4 08             	add    $0x8,%esp
+}
+  80011b:	c9                   	leave  
+  80011c:	c3                   	ret    
+
+0080011d <sys_fork>:
+
+int
+sys_fork(void) {
+  80011d:	55                   	push   %ebp
+  80011e:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_fork);
+  800120:	6a 02                	push   $0x2
+  800122:	e8 8e ff ff ff       	call   8000b5 <syscall>
+  800127:	83 c4 04             	add    $0x4,%esp
+}
+  80012a:	c9                   	leave  
+  80012b:	c3                   	ret    
+
+0080012c <sys_wait>:
+
+int
+sys_wait(int pid, int *store) {
+  80012c:	55                   	push   %ebp
+  80012d:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_wait, pid, store);
+  80012f:	ff 75 0c             	pushl  0xc(%ebp)
+  800132:	ff 75 08             	pushl  0x8(%ebp)
+  800135:	6a 03                	push   $0x3
+  800137:	e8 79 ff ff ff       	call   8000b5 <syscall>
+  80013c:	83 c4 0c             	add    $0xc,%esp
+}
+  80013f:	c9                   	leave  
+  800140:	c3                   	ret    
+
+00800141 <sys_yield>:
+
+int
+sys_yield(void) {
+  800141:	55                   	push   %ebp
+  800142:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_yield);
+  800144:	6a 0a                	push   $0xa
+  800146:	e8 6a ff ff ff       	call   8000b5 <syscall>
+  80014b:	83 c4 04             	add    $0x4,%esp
+}
+  80014e:	c9                   	leave  
+  80014f:	c3                   	ret    
+
+00800150 <sys_kill>:
+
+int
+sys_kill(int pid) {
+  800150:	55                   	push   %ebp
+  800151:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_kill, pid);
+  800153:	ff 75 08             	pushl  0x8(%ebp)
+  800156:	6a 0c                	push   $0xc
+  800158:	e8 58 ff ff ff       	call   8000b5 <syscall>
+  80015d:	83 c4 08             	add    $0x8,%esp
+}
+  800160:	c9                   	leave  
+  800161:	c3                   	ret    
+
+00800162 <sys_getpid>:
+
+int
+sys_getpid(void) {
+  800162:	55                   	push   %ebp
+  800163:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_getpid);
+  800165:	6a 12                	push   $0x12
+  800167:	e8 49 ff ff ff       	call   8000b5 <syscall>
+  80016c:	83 c4 04             	add    $0x4,%esp
+}
+  80016f:	c9                   	leave  
+  800170:	c3                   	ret    
+
+00800171 <sys_putc>:
+
+int
+sys_putc(int c) {
+  800171:	55                   	push   %ebp
+  800172:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_putc, c);
+  800174:	ff 75 08             	pushl  0x8(%ebp)
+  800177:	6a 1e                	push   $0x1e
+  800179:	e8 37 ff ff ff       	call   8000b5 <syscall>
+  80017e:	83 c4 08             	add    $0x8,%esp
+}
+  800181:	c9                   	leave  
+  800182:	c3                   	ret    
+
+00800183 <sys_pgdir>:
+
+int
+sys_pgdir(void) {
+  800183:	55                   	push   %ebp
+  800184:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_pgdir);
+  800186:	6a 1f                	push   $0x1f
+  800188:	e8 28 ff ff ff       	call   8000b5 <syscall>
+  80018d:	83 c4 04             	add    $0x4,%esp
+}
+  800190:	c9                   	leave  
+  800191:	c3                   	ret    
+
+00800192 <sys_gettime>:
+
+int
+sys_gettime(void) {
+  800192:	55                   	push   %ebp
+  800193:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_gettime);
+  800195:	6a 11                	push   $0x11
+  800197:	e8 19 ff ff ff       	call   8000b5 <syscall>
+  80019c:	83 c4 04             	add    $0x4,%esp
+}
+  80019f:	c9                   	leave  
+  8001a0:	c3                   	ret    
+
+008001a1 <sys_lab6_set_priority>:
+
+void
+sys_lab6_set_priority(uint32_t priority)
+{
+  8001a1:	55                   	push   %ebp
+  8001a2:	89 e5                	mov    %esp,%ebp
+    syscall(SYS_lab6_set_priority, priority);
+  8001a4:	ff 75 08             	pushl  0x8(%ebp)
+  8001a7:	68 ff 00 00 00       	push   $0xff
+  8001ac:	e8 04 ff ff ff       	call   8000b5 <syscall>
+  8001b1:	83 c4 08             	add    $0x8,%esp
+}
+  8001b4:	90                   	nop
+  8001b5:	c9                   	leave  
+  8001b6:	c3                   	ret    
+
+008001b7 <exit>:
+#include <syscall.h>
+#include <stdio.h>
+#include <ulib.h>
+
+void
+exit(int error_code) {
+  8001b7:	55                   	push   %ebp
+  8001b8:	89 e5                	mov    %esp,%ebp
+  8001ba:	83 ec 08             	sub    $0x8,%esp
+    sys_exit(error_code);
+  8001bd:	83 ec 0c             	sub    $0xc,%esp
+  8001c0:	ff 75 08             	pushl  0x8(%ebp)
+  8001c3:	e8 43 ff ff ff       	call   80010b <sys_exit>
+  8001c8:	83 c4 10             	add    $0x10,%esp
+    cprintf("BUG: exit failed.\n");
+  8001cb:	83 ec 0c             	sub    $0xc,%esp
+  8001ce:	68 78 10 80 00       	push   $0x801078
+  8001d3:	e8 01 01 00 00       	call   8002d9 <cprintf>
+  8001d8:	83 c4 10             	add    $0x10,%esp
+    while (1);
+  8001db:	eb fe                	jmp    8001db <exit+0x24>
+
+008001dd <fork>:
+}
+
+int
+fork(void) {
+  8001dd:	55                   	push   %ebp
+  8001de:	89 e5                	mov    %esp,%ebp
+  8001e0:	83 ec 08             	sub    $0x8,%esp
+    return sys_fork();
+  8001e3:	e8 35 ff ff ff       	call   80011d <sys_fork>
+}
+  8001e8:	c9                   	leave  
+  8001e9:	c3                   	ret    
+
+008001ea <wait>:
+
+int
+wait(void) {
+  8001ea:	55                   	push   %ebp
+  8001eb:	89 e5                	mov    %esp,%ebp
+  8001ed:	83 ec 08             	sub    $0x8,%esp
+    return sys_wait(0, NULL);
+  8001f0:	83 ec 08             	sub    $0x8,%esp
+  8001f3:	6a 00                	push   $0x0
+  8001f5:	6a 00                	push   $0x0
+  8001f7:	e8 30 ff ff ff       	call   80012c <sys_wait>
+  8001fc:	83 c4 10             	add    $0x10,%esp
+}
+  8001ff:	c9                   	leave  
+  800200:	c3                   	ret    
+
+00800201 <waitpid>:
+
+int
+waitpid(int pid, int *store) {
+  800201:	55                   	push   %ebp
+  800202:	89 e5                	mov    %esp,%ebp
+  800204:	83 ec 08             	sub    $0x8,%esp
+    return sys_wait(pid, store);
+  800207:	83 ec 08             	sub    $0x8,%esp
+  80020a:	ff 75 0c             	pushl  0xc(%ebp)
+  80020d:	ff 75 08             	pushl  0x8(%ebp)
+  800210:	e8 17 ff ff ff       	call   80012c <sys_wait>
+  800215:	83 c4 10             	add    $0x10,%esp
+}
+  800218:	c9                   	leave  
+  800219:	c3                   	ret    
+
+0080021a <yield>:
+
+void
+yield(void) {
+  80021a:	55                   	push   %ebp
+  80021b:	89 e5                	mov    %esp,%ebp
+  80021d:	83 ec 08             	sub    $0x8,%esp
+    sys_yield();
+  800220:	e8 1c ff ff ff       	call   800141 <sys_yield>
+}
+  800225:	90                   	nop
+  800226:	c9                   	leave  
+  800227:	c3                   	ret    
+
+00800228 <kill>:
+
+int
+kill(int pid) {
+  800228:	55                   	push   %ebp
+  800229:	89 e5                	mov    %esp,%ebp
+  80022b:	83 ec 08             	sub    $0x8,%esp
+    return sys_kill(pid);
+  80022e:	83 ec 0c             	sub    $0xc,%esp
+  800231:	ff 75 08             	pushl  0x8(%ebp)
+  800234:	e8 17 ff ff ff       	call   800150 <sys_kill>
+  800239:	83 c4 10             	add    $0x10,%esp
+}
+  80023c:	c9                   	leave  
+  80023d:	c3                   	ret    
+
+0080023e <getpid>:
+
+int
+getpid(void) {
+  80023e:	55                   	push   %ebp
+  80023f:	89 e5                	mov    %esp,%ebp
+  800241:	83 ec 08             	sub    $0x8,%esp
+    return sys_getpid();
+  800244:	e8 19 ff ff ff       	call   800162 <sys_getpid>
+}
+  800249:	c9                   	leave  
+  80024a:	c3                   	ret    
+
+0080024b <print_pgdir>:
+
+//print_pgdir - print the PDT&PT
+void
+print_pgdir(void) {
+  80024b:	55                   	push   %ebp
+  80024c:	89 e5                	mov    %esp,%ebp
+  80024e:	83 ec 08             	sub    $0x8,%esp
+    sys_pgdir();
+  800251:	e8 2d ff ff ff       	call   800183 <sys_pgdir>
+}
+  800256:	90                   	nop
+  800257:	c9                   	leave  
+  800258:	c3                   	ret    
+
+00800259 <gettime_msec>:
+
+unsigned int
+gettime_msec(void) {
+  800259:	55                   	push   %ebp
+  80025a:	89 e5                	mov    %esp,%ebp
+  80025c:	83 ec 08             	sub    $0x8,%esp
+    return (unsigned int)sys_gettime();
+  80025f:	e8 2e ff ff ff       	call   800192 <sys_gettime>
+}
+  800264:	c9                   	leave  
+  800265:	c3                   	ret    
+
+00800266 <lab6_set_priority>:
+
+void
+lab6_set_priority(uint32_t priority)
+{
+  800266:	55                   	push   %ebp
+  800267:	89 e5                	mov    %esp,%ebp
+  800269:	83 ec 08             	sub    $0x8,%esp
+    sys_lab6_set_priority(priority);
+  80026c:	83 ec 0c             	sub    $0xc,%esp
+  80026f:	ff 75 08             	pushl  0x8(%ebp)
+  800272:	e8 2a ff ff ff       	call   8001a1 <sys_lab6_set_priority>
+  800277:	83 c4 10             	add    $0x10,%esp
+}
+  80027a:	90                   	nop
+  80027b:	c9                   	leave  
+  80027c:	c3                   	ret    
+
+0080027d <_start>:
+.text
+.globl _start
+_start:
+    # set ebp for backtrace
+    movl $0x0, %ebp
+  80027d:	bd 00 00 00 00       	mov    $0x0,%ebp
+
+    # move down the esp register
+    # since it may cause page fault in backtrace
+    subl $0x20, %esp
+  800282:	83 ec 20             	sub    $0x20,%esp
+
+    # call user-program function
+    call umain
+  800285:	e8 c3 00 00 00       	call   80034d <umain>
+1:  jmp 1b
+  80028a:	eb fe                	jmp    80028a <_start+0xd>
+
+0080028c <cputch>:
+/* *
+ * cputch - writes a single character @c to stdout, and it will
+ * increace the value of counter pointed by @cnt.
+ * */
+static void
+cputch(int c, int *cnt) {
+  80028c:	55                   	push   %ebp
+  80028d:	89 e5                	mov    %esp,%ebp
+  80028f:	83 ec 08             	sub    $0x8,%esp
+    sys_putc(c);
+  800292:	83 ec 0c             	sub    $0xc,%esp
+  800295:	ff 75 08             	pushl  0x8(%ebp)
+  800298:	e8 d4 fe ff ff       	call   800171 <sys_putc>
+  80029d:	83 c4 10             	add    $0x10,%esp
+    (*cnt) ++;
+  8002a0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002a3:	8b 00                	mov    (%eax),%eax
+  8002a5:	8d 50 01             	lea    0x1(%eax),%edx
+  8002a8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002ab:	89 10                	mov    %edx,(%eax)
+}
+  8002ad:	90                   	nop
+  8002ae:	c9                   	leave  
+  8002af:	c3                   	ret    
+
+008002b0 <vcprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want cprintf() instead.
+ * */
+int
+vcprintf(const char *fmt, va_list ap) {
+  8002b0:	55                   	push   %ebp
+  8002b1:	89 e5                	mov    %esp,%ebp
+  8002b3:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+  8002b6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    vprintfmt((void*)cputch, &cnt, fmt, ap);
+  8002bd:	ff 75 0c             	pushl  0xc(%ebp)
+  8002c0:	ff 75 08             	pushl  0x8(%ebp)
+  8002c3:	8d 45 f4             	lea    -0xc(%ebp),%eax
+  8002c6:	50                   	push   %eax
+  8002c7:	68 8c 02 80 00       	push   $0x80028c
+  8002cc:	e8 fc 06 00 00       	call   8009cd <vprintfmt>
+  8002d1:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+  8002d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8002d7:	c9                   	leave  
+  8002d8:	c3                   	ret    
+
+008002d9 <cprintf>:
+ *
+ * The return value is the number of characters which would be
+ * written to stdout.
+ * */
+int
+cprintf(const char *fmt, ...) {
+  8002d9:	55                   	push   %ebp
+  8002da:	89 e5                	mov    %esp,%ebp
+  8002dc:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  8002df:	8d 45 0c             	lea    0xc(%ebp),%eax
+  8002e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    int cnt = vcprintf(fmt, ap);
+  8002e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8002e8:	83 ec 08             	sub    $0x8,%esp
+  8002eb:	50                   	push   %eax
+  8002ec:	ff 75 08             	pushl  0x8(%ebp)
+  8002ef:	e8 bc ff ff ff       	call   8002b0 <vcprintf>
+  8002f4:	83 c4 10             	add    $0x10,%esp
+  8002f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+
+    return cnt;
+  8002fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8002fd:	c9                   	leave  
+  8002fe:	c3                   	ret    
+
+008002ff <cputs>:
+/* *
+ * cputs- writes the string pointed by @str to stdout and
+ * appends a newline character.
+ * */
+int
+cputs(const char *str) {
+  8002ff:	55                   	push   %ebp
+  800300:	89 e5                	mov    %esp,%ebp
+  800302:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+  800305:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    char c;
+    while ((c = *str ++) != '\0') {
+  80030c:	eb 14                	jmp    800322 <cputs+0x23>
+        cputch(c, &cnt);
+  80030e:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
+  800312:	83 ec 08             	sub    $0x8,%esp
+  800315:	8d 55 f0             	lea    -0x10(%ebp),%edx
+  800318:	52                   	push   %edx
+  800319:	50                   	push   %eax
+  80031a:	e8 6d ff ff ff       	call   80028c <cputch>
+  80031f:	83 c4 10             	add    $0x10,%esp
+ * */
+int
+cputs(const char *str) {
+    int cnt = 0;
+    char c;
+    while ((c = *str ++) != '\0') {
+  800322:	8b 45 08             	mov    0x8(%ebp),%eax
+  800325:	8d 50 01             	lea    0x1(%eax),%edx
+  800328:	89 55 08             	mov    %edx,0x8(%ebp)
+  80032b:	0f b6 00             	movzbl (%eax),%eax
+  80032e:	88 45 f7             	mov    %al,-0x9(%ebp)
+  800331:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
+  800335:	75 d7                	jne    80030e <cputs+0xf>
+        cputch(c, &cnt);
+    }
+    cputch('\n', &cnt);
+  800337:	83 ec 08             	sub    $0x8,%esp
+  80033a:	8d 45 f0             	lea    -0x10(%ebp),%eax
+  80033d:	50                   	push   %eax
+  80033e:	6a 0a                	push   $0xa
+  800340:	e8 47 ff ff ff       	call   80028c <cputch>
+  800345:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+  800348:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+  80034b:	c9                   	leave  
+  80034c:	c3                   	ret    
+
+0080034d <umain>:
+#include <ulib.h>
+
+int main(void);
+
+void
+umain(void) {
+  80034d:	55                   	push   %ebp
+  80034e:	89 e5                	mov    %esp,%ebp
+  800350:	83 ec 18             	sub    $0x18,%esp
+    int ret = main();
+  800353:	e8 d3 0b 00 00       	call   800f2b <main>
+  800358:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    exit(ret);
+  80035b:	83 ec 0c             	sub    $0xc,%esp
+  80035e:	ff 75 f4             	pushl  -0xc(%ebp)
+  800361:	e8 51 fe ff ff       	call   8001b7 <exit>
+
+00800366 <strlen>:
+ * @s:      the input string
+ *
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+  800366:	55                   	push   %ebp
+  800367:	89 e5                	mov    %esp,%ebp
+  800369:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  80036c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (*s ++ != '\0') {
+  800373:	eb 04                	jmp    800379 <strlen+0x13>
+        cnt ++;
+  800375:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+    size_t cnt = 0;
+    while (*s ++ != '\0') {
+  800379:	8b 45 08             	mov    0x8(%ebp),%eax
+  80037c:	8d 50 01             	lea    0x1(%eax),%edx
+  80037f:	89 55 08             	mov    %edx,0x8(%ebp)
+  800382:	0f b6 00             	movzbl (%eax),%eax
+  800385:	84 c0                	test   %al,%al
+  800387:	75 ec                	jne    800375 <strlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  800389:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  80038c:	c9                   	leave  
+  80038d:	c3                   	ret    
+
+0080038e <strnlen>:
+ * The return value is strlen(s), if that is less than @len, or
+ * @len if there is no '\0' character among the first @len characters
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+  80038e:	55                   	push   %ebp
+  80038f:	89 e5                	mov    %esp,%ebp
+  800391:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  800394:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (cnt < len && *s ++ != '\0') {
+  80039b:	eb 04                	jmp    8003a1 <strnlen+0x13>
+        cnt ++;
+  80039d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+    size_t cnt = 0;
+    while (cnt < len && *s ++ != '\0') {
+  8003a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8003a4:	3b 45 0c             	cmp    0xc(%ebp),%eax
+  8003a7:	73 10                	jae    8003b9 <strnlen+0x2b>
+  8003a9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003ac:	8d 50 01             	lea    0x1(%eax),%edx
+  8003af:	89 55 08             	mov    %edx,0x8(%ebp)
+  8003b2:	0f b6 00             	movzbl (%eax),%eax
+  8003b5:	84 c0                	test   %al,%al
+  8003b7:	75 e4                	jne    80039d <strnlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  8003b9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  8003bc:	c9                   	leave  
+  8003bd:	c3                   	ret    
+
+008003be <strcpy>:
+ * To avoid overflows, the size of array pointed by @dst should be long enough to
+ * contain the same string as @src (including the terminating null character), and
+ * should not overlap in memory with @src.
+ * */
+char *
+strcpy(char *dst, const char *src) {
+  8003be:	55                   	push   %ebp
+  8003bf:	89 e5                	mov    %esp,%ebp
+  8003c1:	57                   	push   %edi
+  8003c2:	56                   	push   %esi
+  8003c3:	83 ec 20             	sub    $0x20,%esp
+  8003c6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  8003cc:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8003cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCPY
+#define __HAVE_ARCH_STRCPY
+static inline char *
+__strcpy(char *dst, const char *src) {
+    int d0, d1, d2;
+    asm volatile (
+  8003d2:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  8003d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8003d8:	89 d1                	mov    %edx,%ecx
+  8003da:	89 c2                	mov    %eax,%edx
+  8003dc:	89 ce                	mov    %ecx,%esi
+  8003de:	89 d7                	mov    %edx,%edi
+  8003e0:	ac                   	lods   %ds:(%esi),%al
+  8003e1:	aa                   	stos   %al,%es:(%edi)
+  8003e2:	84 c0                	test   %al,%al
+  8003e4:	75 fa                	jne    8003e0 <strcpy+0x22>
+  8003e6:	89 fa                	mov    %edi,%edx
+  8003e8:	89 f1                	mov    %esi,%ecx
+  8003ea:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  8003ed:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  8003f0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+        "stosb;"
+        "testb %%al, %%al;"
+        "jne 1b;"
+        : "=&S" (d0), "=&D" (d1), "=&a" (d2)
+        : "0" (src), "1" (dst) : "memory");
+    return dst;
+  8003f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCPY
+    return __strcpy(dst, src);
+  8003f6:	90                   	nop
+    char *p = dst;
+    while ((*p ++ = *src ++) != '\0')
+        /* nothing */;
+    return dst;
+#endif /* __HAVE_ARCH_STRCPY */
+}
+  8003f7:	83 c4 20             	add    $0x20,%esp
+  8003fa:	5e                   	pop    %esi
+  8003fb:	5f                   	pop    %edi
+  8003fc:	5d                   	pop    %ebp
+  8003fd:	c3                   	ret    
+
+008003fe <strncpy>:
+ * @len:    maximum number of characters to be copied from @src
+ *
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+  8003fe:	55                   	push   %ebp
+  8003ff:	89 e5                	mov    %esp,%ebp
+  800401:	83 ec 10             	sub    $0x10,%esp
+    char *p = dst;
+  800404:	8b 45 08             	mov    0x8(%ebp),%eax
+  800407:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    while (len > 0) {
+  80040a:	eb 21                	jmp    80042d <strncpy+0x2f>
+        if ((*p = *src) != '\0') {
+  80040c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80040f:	0f b6 10             	movzbl (%eax),%edx
+  800412:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800415:	88 10                	mov    %dl,(%eax)
+  800417:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  80041a:	0f b6 00             	movzbl (%eax),%eax
+  80041d:	84 c0                	test   %al,%al
+  80041f:	74 04                	je     800425 <strncpy+0x27>
+            src ++;
+  800421:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+        }
+        p ++, len --;
+  800425:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800429:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+    char *p = dst;
+    while (len > 0) {
+  80042d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800431:	75 d9                	jne    80040c <strncpy+0xe>
+        if ((*p = *src) != '\0') {
+            src ++;
+        }
+        p ++, len --;
+    }
+    return dst;
+  800433:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800436:	c9                   	leave  
+  800437:	c3                   	ret    
+
+00800438 <strcmp>:
+ * - A value greater than zero indicates that the first character that does
+ *   not match has a greater value in @s1 than in @s2;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+strcmp(const char *s1, const char *s2) {
+  800438:	55                   	push   %ebp
+  800439:	89 e5                	mov    %esp,%ebp
+  80043b:	57                   	push   %edi
+  80043c:	56                   	push   %esi
+  80043d:	83 ec 20             	sub    $0x20,%esp
+  800440:	8b 45 08             	mov    0x8(%ebp),%eax
+  800443:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800446:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800449:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCMP
+#define __HAVE_ARCH_STRCMP
+static inline int
+__strcmp(const char *s1, const char *s2) {
+    int d0, d1, ret;
+    asm volatile (
+  80044c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80044f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800452:	89 d1                	mov    %edx,%ecx
+  800454:	89 c2                	mov    %eax,%edx
+  800456:	89 ce                	mov    %ecx,%esi
+  800458:	89 d7                	mov    %edx,%edi
+  80045a:	ac                   	lods   %ds:(%esi),%al
+  80045b:	ae                   	scas   %es:(%edi),%al
+  80045c:	75 08                	jne    800466 <strcmp+0x2e>
+  80045e:	84 c0                	test   %al,%al
+  800460:	75 f8                	jne    80045a <strcmp+0x22>
+  800462:	31 c0                	xor    %eax,%eax
+  800464:	eb 04                	jmp    80046a <strcmp+0x32>
+  800466:	19 c0                	sbb    %eax,%eax
+  800468:	0c 01                	or     $0x1,%al
+  80046a:	89 fa                	mov    %edi,%edx
+  80046c:	89 f1                	mov    %esi,%ecx
+  80046e:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800471:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  800474:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+        "orb $1, %%al;"
+        "3:"
+        : "=a" (ret), "=&S" (d0), "=&D" (d1)
+        : "1" (s1), "2" (s2)
+        : "memory");
+    return ret;
+  800477:	8b 45 ec             	mov    -0x14(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCMP
+    return __strcmp(s1, s2);
+  80047a:	90                   	nop
+    while (*s1 != '\0' && *s1 == *s2) {
+        s1 ++, s2 ++;
+    }
+    return (int)((unsigned char)*s1 - (unsigned char)*s2);
+#endif /* __HAVE_ARCH_STRCMP */
+}
+  80047b:	83 c4 20             	add    $0x20,%esp
+  80047e:	5e                   	pop    %esi
+  80047f:	5f                   	pop    %edi
+  800480:	5d                   	pop    %ebp
+  800481:	c3                   	ret    
+
+00800482 <strncmp>:
+ * they are equal to each other, it continues with the following pairs until
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+  800482:	55                   	push   %ebp
+  800483:	89 e5                	mov    %esp,%ebp
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  800485:	eb 0c                	jmp    800493 <strncmp+0x11>
+        n --, s1 ++, s2 ++;
+  800487:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  80048b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  80048f:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  800493:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800497:	74 1a                	je     8004b3 <strncmp+0x31>
+  800499:	8b 45 08             	mov    0x8(%ebp),%eax
+  80049c:	0f b6 00             	movzbl (%eax),%eax
+  80049f:	84 c0                	test   %al,%al
+  8004a1:	74 10                	je     8004b3 <strncmp+0x31>
+  8004a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004a6:	0f b6 10             	movzbl (%eax),%edx
+  8004a9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004ac:	0f b6 00             	movzbl (%eax),%eax
+  8004af:	38 c2                	cmp    %al,%dl
+  8004b1:	74 d4                	je     800487 <strncmp+0x5>
+        n --, s1 ++, s2 ++;
+    }
+    return (n == 0) ? 0 : (int)((unsigned char)*s1 - (unsigned char)*s2);
+  8004b3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8004b7:	74 18                	je     8004d1 <strncmp+0x4f>
+  8004b9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004bc:	0f b6 00             	movzbl (%eax),%eax
+  8004bf:	0f b6 d0             	movzbl %al,%edx
+  8004c2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004c5:	0f b6 00             	movzbl (%eax),%eax
+  8004c8:	0f b6 c0             	movzbl %al,%eax
+  8004cb:	29 c2                	sub    %eax,%edx
+  8004cd:	89 d0                	mov    %edx,%eax
+  8004cf:	eb 05                	jmp    8004d6 <strncmp+0x54>
+  8004d1:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  8004d6:	5d                   	pop    %ebp
+  8004d7:	c3                   	ret    
+
+008004d8 <strchr>:
+ *
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+  8004d8:	55                   	push   %ebp
+  8004d9:	89 e5                	mov    %esp,%ebp
+  8004db:	83 ec 04             	sub    $0x4,%esp
+  8004de:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004e1:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  8004e4:	eb 14                	jmp    8004fa <strchr+0x22>
+        if (*s == c) {
+  8004e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004e9:	0f b6 00             	movzbl (%eax),%eax
+  8004ec:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  8004ef:	75 05                	jne    8004f6 <strchr+0x1e>
+            return (char *)s;
+  8004f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004f4:	eb 13                	jmp    800509 <strchr+0x31>
+        }
+        s ++;
+  8004f6:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+    while (*s != '\0') {
+  8004fa:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004fd:	0f b6 00             	movzbl (%eax),%eax
+  800500:	84 c0                	test   %al,%al
+  800502:	75 e2                	jne    8004e6 <strchr+0xe>
+        if (*s == c) {
+            return (char *)s;
+        }
+        s ++;
+    }
+    return NULL;
+  800504:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800509:	c9                   	leave  
+  80050a:	c3                   	ret    
+
+0080050b <strfind>:
+ * The strfind() function is like strchr() except that if @c is
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+  80050b:	55                   	push   %ebp
+  80050c:	89 e5                	mov    %esp,%ebp
+  80050e:	83 ec 04             	sub    $0x4,%esp
+  800511:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800514:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  800517:	eb 0f                	jmp    800528 <strfind+0x1d>
+        if (*s == c) {
+  800519:	8b 45 08             	mov    0x8(%ebp),%eax
+  80051c:	0f b6 00             	movzbl (%eax),%eax
+  80051f:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800522:	74 10                	je     800534 <strfind+0x29>
+            break;
+        }
+        s ++;
+  800524:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+    while (*s != '\0') {
+  800528:	8b 45 08             	mov    0x8(%ebp),%eax
+  80052b:	0f b6 00             	movzbl (%eax),%eax
+  80052e:	84 c0                	test   %al,%al
+  800530:	75 e7                	jne    800519 <strfind+0xe>
+  800532:	eb 01                	jmp    800535 <strfind+0x2a>
+        if (*s == c) {
+            break;
+  800534:	90                   	nop
+        }
+        s ++;
+    }
+    return (char *)s;
+  800535:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800538:	c9                   	leave  
+  800539:	c3                   	ret    
+
+0080053a <strtol>:
+ * an optional "0x" or "0X" prefix.
+ *
+ * The strtol() function returns the converted integral number as a long int value.
+ * */
+long
+strtol(const char *s, char **endptr, int base) {
+  80053a:	55                   	push   %ebp
+  80053b:	89 e5                	mov    %esp,%ebp
+  80053d:	83 ec 10             	sub    $0x10,%esp
+    int neg = 0;
+  800540:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    long val = 0;
+  800547:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  80054e:	eb 04                	jmp    800554 <strtol+0x1a>
+        s ++;
+  800550:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+strtol(const char *s, char **endptr, int base) {
+    int neg = 0;
+    long val = 0;
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  800554:	8b 45 08             	mov    0x8(%ebp),%eax
+  800557:	0f b6 00             	movzbl (%eax),%eax
+  80055a:	3c 20                	cmp    $0x20,%al
+  80055c:	74 f2                	je     800550 <strtol+0x16>
+  80055e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800561:	0f b6 00             	movzbl (%eax),%eax
+  800564:	3c 09                	cmp    $0x9,%al
+  800566:	74 e8                	je     800550 <strtol+0x16>
+        s ++;
+    }
+
+    // plus/minus sign
+    if (*s == '+') {
+  800568:	8b 45 08             	mov    0x8(%ebp),%eax
+  80056b:	0f b6 00             	movzbl (%eax),%eax
+  80056e:	3c 2b                	cmp    $0x2b,%al
+  800570:	75 06                	jne    800578 <strtol+0x3e>
+        s ++;
+  800572:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800576:	eb 15                	jmp    80058d <strtol+0x53>
+    }
+    else if (*s == '-') {
+  800578:	8b 45 08             	mov    0x8(%ebp),%eax
+  80057b:	0f b6 00             	movzbl (%eax),%eax
+  80057e:	3c 2d                	cmp    $0x2d,%al
+  800580:	75 0b                	jne    80058d <strtol+0x53>
+        s ++, neg = 1;
+  800582:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800586:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+    }
+
+    // hex or octal base prefix
+    if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x')) {
+  80058d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800591:	74 06                	je     800599 <strtol+0x5f>
+  800593:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+  800597:	75 24                	jne    8005bd <strtol+0x83>
+  800599:	8b 45 08             	mov    0x8(%ebp),%eax
+  80059c:	0f b6 00             	movzbl (%eax),%eax
+  80059f:	3c 30                	cmp    $0x30,%al
+  8005a1:	75 1a                	jne    8005bd <strtol+0x83>
+  8005a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005a6:	83 c0 01             	add    $0x1,%eax
+  8005a9:	0f b6 00             	movzbl (%eax),%eax
+  8005ac:	3c 78                	cmp    $0x78,%al
+  8005ae:	75 0d                	jne    8005bd <strtol+0x83>
+        s += 2, base = 16;
+  8005b0:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+  8005b4:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+  8005bb:	eb 2a                	jmp    8005e7 <strtol+0xad>
+    }
+    else if (base == 0 && s[0] == '0') {
+  8005bd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8005c1:	75 17                	jne    8005da <strtol+0xa0>
+  8005c3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005c6:	0f b6 00             	movzbl (%eax),%eax
+  8005c9:	3c 30                	cmp    $0x30,%al
+  8005cb:	75 0d                	jne    8005da <strtol+0xa0>
+        s ++, base = 8;
+  8005cd:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  8005d1:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+  8005d8:	eb 0d                	jmp    8005e7 <strtol+0xad>
+    }
+    else if (base == 0) {
+  8005da:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8005de:	75 07                	jne    8005e7 <strtol+0xad>
+        base = 10;
+  8005e0:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+    // digits
+    while (1) {
+        int dig;
+
+        if (*s >= '0' && *s <= '9') {
+  8005e7:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005ea:	0f b6 00             	movzbl (%eax),%eax
+  8005ed:	3c 2f                	cmp    $0x2f,%al
+  8005ef:	7e 1b                	jle    80060c <strtol+0xd2>
+  8005f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005f4:	0f b6 00             	movzbl (%eax),%eax
+  8005f7:	3c 39                	cmp    $0x39,%al
+  8005f9:	7f 11                	jg     80060c <strtol+0xd2>
+            dig = *s - '0';
+  8005fb:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005fe:	0f b6 00             	movzbl (%eax),%eax
+  800601:	0f be c0             	movsbl %al,%eax
+  800604:	83 e8 30             	sub    $0x30,%eax
+  800607:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80060a:	eb 48                	jmp    800654 <strtol+0x11a>
+        }
+        else if (*s >= 'a' && *s <= 'z') {
+  80060c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80060f:	0f b6 00             	movzbl (%eax),%eax
+  800612:	3c 60                	cmp    $0x60,%al
+  800614:	7e 1b                	jle    800631 <strtol+0xf7>
+  800616:	8b 45 08             	mov    0x8(%ebp),%eax
+  800619:	0f b6 00             	movzbl (%eax),%eax
+  80061c:	3c 7a                	cmp    $0x7a,%al
+  80061e:	7f 11                	jg     800631 <strtol+0xf7>
+            dig = *s - 'a' + 10;
+  800620:	8b 45 08             	mov    0x8(%ebp),%eax
+  800623:	0f b6 00             	movzbl (%eax),%eax
+  800626:	0f be c0             	movsbl %al,%eax
+  800629:	83 e8 57             	sub    $0x57,%eax
+  80062c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80062f:	eb 23                	jmp    800654 <strtol+0x11a>
+        }
+        else if (*s >= 'A' && *s <= 'Z') {
+  800631:	8b 45 08             	mov    0x8(%ebp),%eax
+  800634:	0f b6 00             	movzbl (%eax),%eax
+  800637:	3c 40                	cmp    $0x40,%al
+  800639:	7e 3c                	jle    800677 <strtol+0x13d>
+  80063b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80063e:	0f b6 00             	movzbl (%eax),%eax
+  800641:	3c 5a                	cmp    $0x5a,%al
+  800643:	7f 32                	jg     800677 <strtol+0x13d>
+            dig = *s - 'A' + 10;
+  800645:	8b 45 08             	mov    0x8(%ebp),%eax
+  800648:	0f b6 00             	movzbl (%eax),%eax
+  80064b:	0f be c0             	movsbl %al,%eax
+  80064e:	83 e8 37             	sub    $0x37,%eax
+  800651:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+  800654:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800657:	3b 45 10             	cmp    0x10(%ebp),%eax
+  80065a:	7d 1a                	jge    800676 <strtol+0x13c>
+            break;
+        }
+        s ++, val = (val * base) + dig;
+  80065c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800660:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800663:	0f af 45 10          	imul   0x10(%ebp),%eax
+  800667:	89 c2                	mov    %eax,%edx
+  800669:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  80066c:	01 d0                	add    %edx,%eax
+  80066e:	89 45 f8             	mov    %eax,-0x8(%ebp)
+        // we don't properly detect overflow!
+    }
+  800671:	e9 71 ff ff ff       	jmp    8005e7 <strtol+0xad>
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+            break;
+  800676:	90                   	nop
+        }
+        s ++, val = (val * base) + dig;
+        // we don't properly detect overflow!
+    }
+
+    if (endptr) {
+  800677:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  80067b:	74 08                	je     800685 <strtol+0x14b>
+        *endptr = (char *) s;
+  80067d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800680:	8b 55 08             	mov    0x8(%ebp),%edx
+  800683:	89 10                	mov    %edx,(%eax)
+    }
+    return (neg ? -val : val);
+  800685:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+  800689:	74 07                	je     800692 <strtol+0x158>
+  80068b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  80068e:	f7 d8                	neg    %eax
+  800690:	eb 03                	jmp    800695 <strtol+0x15b>
+  800692:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  800695:	c9                   	leave  
+  800696:	c3                   	ret    
+
+00800697 <memset>:
+ * @n:      number of bytes to be set to the value
+ *
+ * The memset() function returns @s.
+ * */
+void *
+memset(void *s, char c, size_t n) {
+  800697:	55                   	push   %ebp
+  800698:	89 e5                	mov    %esp,%ebp
+  80069a:	57                   	push   %edi
+  80069b:	83 ec 24             	sub    $0x24,%esp
+  80069e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006a1:	88 45 d8             	mov    %al,-0x28(%ebp)
+#ifdef __HAVE_ARCH_MEMSET
+    return __memset(s, c, n);
+  8006a4:	0f be 45 d8          	movsbl -0x28(%ebp),%eax
+  8006a8:	8b 55 08             	mov    0x8(%ebp),%edx
+  8006ab:	89 55 f8             	mov    %edx,-0x8(%ebp)
+  8006ae:	88 45 f7             	mov    %al,-0x9(%ebp)
+  8006b1:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_MEMSET
+#define __HAVE_ARCH_MEMSET
+static inline void *
+__memset(void *s, char c, size_t n) {
+    int d0, d1;
+    asm volatile (
+  8006b7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+  8006ba:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
+  8006be:	8b 55 f8             	mov    -0x8(%ebp),%edx
+  8006c1:	89 d7                	mov    %edx,%edi
+  8006c3:	f3 aa                	rep stos %al,%es:(%edi)
+  8006c5:	89 fa                	mov    %edi,%edx
+  8006c7:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  8006ca:	89 55 e8             	mov    %edx,-0x18(%ebp)
+        "rep; stosb;"
+        : "=&c" (d0), "=&D" (d1)
+        : "0" (n), "a" (c), "1" (s)
+        : "memory");
+    return s;
+  8006cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8006d0:	90                   	nop
+    while (n -- > 0) {
+        *p ++ = c;
+    }
+    return s;
+#endif /* __HAVE_ARCH_MEMSET */
+}
+  8006d1:	83 c4 24             	add    $0x24,%esp
+  8006d4:	5f                   	pop    %edi
+  8006d5:	5d                   	pop    %ebp
+  8006d6:	c3                   	ret    
+
+008006d7 <memmove>:
+ * @n:      number of bytes to copy
+ *
+ * The memmove() function returns @dst.
+ * */
+void *
+memmove(void *dst, const void *src, size_t n) {
+  8006d7:	55                   	push   %ebp
+  8006d8:	89 e5                	mov    %esp,%ebp
+  8006da:	57                   	push   %edi
+  8006db:	56                   	push   %esi
+  8006dc:	53                   	push   %ebx
+  8006dd:	83 ec 30             	sub    $0x30,%esp
+  8006e0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8006e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8006e6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  8006ec:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006ef:	89 45 e8             	mov    %eax,-0x18(%ebp)
+
+#ifndef __HAVE_ARCH_MEMMOVE
+#define __HAVE_ARCH_MEMMOVE
+static inline void *
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+  8006f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006f5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  8006f8:	73 42                	jae    80073c <memmove+0x65>
+  8006fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006fd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800700:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800703:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800706:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800709:	89 45 dc             	mov    %eax,-0x24(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  80070c:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  80070f:	c1 e8 02             	shr    $0x2,%eax
+  800712:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  800714:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800717:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80071a:	89 d7                	mov    %edx,%edi
+  80071c:	89 c6                	mov    %eax,%esi
+  80071e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800720:	8b 4d dc             	mov    -0x24(%ebp),%ecx
+  800723:	83 e1 03             	and    $0x3,%ecx
+  800726:	74 02                	je     80072a <memmove+0x53>
+  800728:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  80072a:	89 f0                	mov    %esi,%eax
+  80072c:	89 fa                	mov    %edi,%edx
+  80072e:	89 4d d8             	mov    %ecx,-0x28(%ebp)
+  800731:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  800734:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  800737:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMMOVE
+    return __memmove(dst, src, n);
+  80073a:	eb 36                	jmp    800772 <memmove+0x9b>
+    asm volatile (
+        "std;"
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+  80073c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80073f:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800742:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800745:	01 c2                	add    %eax,%edx
+  800747:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80074a:	8d 48 ff             	lea    -0x1(%eax),%ecx
+  80074d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800750:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+        return __memcpy(dst, src, n);
+    }
+    int d0, d1, d2;
+    asm volatile (
+  800753:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800756:	89 c1                	mov    %eax,%ecx
+  800758:	89 d8                	mov    %ebx,%eax
+  80075a:	89 d6                	mov    %edx,%esi
+  80075c:	89 c7                	mov    %eax,%edi
+  80075e:	fd                   	std    
+  80075f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  800761:	fc                   	cld    
+  800762:	89 f8                	mov    %edi,%eax
+  800764:	89 f2                	mov    %esi,%edx
+  800766:	89 4d cc             	mov    %ecx,-0x34(%ebp)
+  800769:	89 55 c8             	mov    %edx,-0x38(%ebp)
+  80076c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+        : "memory");
+    return dst;
+  80076f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+            *d ++ = *s ++;
+        }
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMMOVE */
+}
+  800772:	83 c4 30             	add    $0x30,%esp
+  800775:	5b                   	pop    %ebx
+  800776:	5e                   	pop    %esi
+  800777:	5f                   	pop    %edi
+  800778:	5d                   	pop    %ebp
+  800779:	c3                   	ret    
+
+0080077a <memcpy>:
+ * it always copies exactly @n bytes. To avoid overflows, the size of arrays pointed
+ * by both @src and @dst, should be at least @n bytes, and should not overlap
+ * (for overlapping memory area, memmove is a safer approach).
+ * */
+void *
+memcpy(void *dst, const void *src, size_t n) {
+  80077a:	55                   	push   %ebp
+  80077b:	89 e5                	mov    %esp,%ebp
+  80077d:	57                   	push   %edi
+  80077e:	56                   	push   %esi
+  80077f:	83 ec 20             	sub    $0x20,%esp
+  800782:	8b 45 08             	mov    0x8(%ebp),%eax
+  800785:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800788:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80078b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80078e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800791:	89 45 ec             	mov    %eax,-0x14(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  800794:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800797:	c1 e8 02             	shr    $0x2,%eax
+  80079a:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  80079c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80079f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8007a2:	89 d7                	mov    %edx,%edi
+  8007a4:	89 c6                	mov    %eax,%esi
+  8007a6:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  8007a8:	8b 4d ec             	mov    -0x14(%ebp),%ecx
+  8007ab:	83 e1 03             	and    $0x3,%ecx
+  8007ae:	74 02                	je     8007b2 <memcpy+0x38>
+  8007b0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  8007b2:	89 f0                	mov    %esi,%eax
+  8007b4:	89 fa                	mov    %edi,%edx
+  8007b6:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  8007b9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  8007bc:	89 45 e0             	mov    %eax,-0x20(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  8007bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMCPY
+    return __memcpy(dst, src, n);
+  8007c2:	90                   	nop
+    while (n -- > 0) {
+        *d ++ = *s ++;
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMCPY */
+}
+  8007c3:	83 c4 20             	add    $0x20,%esp
+  8007c6:	5e                   	pop    %esi
+  8007c7:	5f                   	pop    %edi
+  8007c8:	5d                   	pop    %ebp
+  8007c9:	c3                   	ret    
+
+008007ca <memcmp>:
+ *   match in both memory blocks has a greater value in @v1 than in @v2
+ *   as if evaluated as unsigned char values;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+  8007ca:	55                   	push   %ebp
+  8007cb:	89 e5                	mov    %esp,%ebp
+  8007cd:	83 ec 10             	sub    $0x10,%esp
+    const char *s1 = (const char *)v1;
+  8007d0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8007d3:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    const char *s2 = (const char *)v2;
+  8007d6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8007d9:	89 45 f8             	mov    %eax,-0x8(%ebp)
+    while (n -- > 0) {
+  8007dc:	eb 30                	jmp    80080e <memcmp+0x44>
+        if (*s1 != *s2) {
+  8007de:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8007e1:	0f b6 10             	movzbl (%eax),%edx
+  8007e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8007e7:	0f b6 00             	movzbl (%eax),%eax
+  8007ea:	38 c2                	cmp    %al,%dl
+  8007ec:	74 18                	je     800806 <memcmp+0x3c>
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+  8007ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8007f1:	0f b6 00             	movzbl (%eax),%eax
+  8007f4:	0f b6 d0             	movzbl %al,%edx
+  8007f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8007fa:	0f b6 00             	movzbl (%eax),%eax
+  8007fd:	0f b6 c0             	movzbl %al,%eax
+  800800:	29 c2                	sub    %eax,%edx
+  800802:	89 d0                	mov    %edx,%eax
+  800804:	eb 1a                	jmp    800820 <memcmp+0x56>
+        }
+        s1 ++, s2 ++;
+  800806:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  80080a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+    const char *s1 = (const char *)v1;
+    const char *s2 = (const char *)v2;
+    while (n -- > 0) {
+  80080e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800811:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800814:	89 55 10             	mov    %edx,0x10(%ebp)
+  800817:	85 c0                	test   %eax,%eax
+  800819:	75 c3                	jne    8007de <memcmp+0x14>
+        if (*s1 != *s2) {
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+        }
+        s1 ++, s2 ++;
+    }
+    return 0;
+  80081b:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800820:	c9                   	leave  
+  800821:	c3                   	ret    
+
+00800822 <printnum>:
+ * @width:      maximum number of digits, if the actual width is less than @width, use @padc instead
+ * @padc:       character that padded on the left if the actual width is less than @width
+ * */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+        unsigned long long num, unsigned base, int width, int padc) {
+  800822:	55                   	push   %ebp
+  800823:	89 e5                	mov    %esp,%ebp
+  800825:	83 ec 38             	sub    $0x38,%esp
+  800828:	8b 45 10             	mov    0x10(%ebp),%eax
+  80082b:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  80082e:	8b 45 14             	mov    0x14(%ebp),%eax
+  800831:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+    unsigned long long result = num;
+  800834:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  800837:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  80083a:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  80083d:	89 55 ec             	mov    %edx,-0x14(%ebp)
+    unsigned mod = do_div(result, base);
+  800840:	8b 45 18             	mov    0x18(%ebp),%eax
+  800843:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800846:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800849:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  80084c:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  80084f:	89 55 f0             	mov    %edx,-0x10(%ebp)
+  800852:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800855:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800858:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  80085c:	74 1c                	je     80087a <printnum+0x58>
+  80085e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800861:	ba 00 00 00 00       	mov    $0x0,%edx
+  800866:	f7 75 e4             	divl   -0x1c(%ebp)
+  800869:	89 55 f4             	mov    %edx,-0xc(%ebp)
+  80086c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  80086f:	ba 00 00 00 00       	mov    $0x0,%edx
+  800874:	f7 75 e4             	divl   -0x1c(%ebp)
+  800877:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80087a:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80087d:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800880:	f7 75 e4             	divl   -0x1c(%ebp)
+  800883:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800886:	89 55 dc             	mov    %edx,-0x24(%ebp)
+  800889:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80088c:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  80088f:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800892:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  800895:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  800898:	89 45 d8             	mov    %eax,-0x28(%ebp)
+
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+  80089b:	8b 45 18             	mov    0x18(%ebp),%eax
+  80089e:	ba 00 00 00 00       	mov    $0x0,%edx
+  8008a3:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  8008a6:	77 41                	ja     8008e9 <printnum+0xc7>
+  8008a8:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  8008ab:	72 05                	jb     8008b2 <printnum+0x90>
+  8008ad:	3b 45 d0             	cmp    -0x30(%ebp),%eax
+  8008b0:	77 37                	ja     8008e9 <printnum+0xc7>
+        printnum(putch, putdat, result, base, width - 1, padc);
+  8008b2:	8b 45 1c             	mov    0x1c(%ebp),%eax
+  8008b5:	83 e8 01             	sub    $0x1,%eax
+  8008b8:	83 ec 04             	sub    $0x4,%esp
+  8008bb:	ff 75 20             	pushl  0x20(%ebp)
+  8008be:	50                   	push   %eax
+  8008bf:	ff 75 18             	pushl  0x18(%ebp)
+  8008c2:	ff 75 ec             	pushl  -0x14(%ebp)
+  8008c5:	ff 75 e8             	pushl  -0x18(%ebp)
+  8008c8:	ff 75 0c             	pushl  0xc(%ebp)
+  8008cb:	ff 75 08             	pushl  0x8(%ebp)
+  8008ce:	e8 4f ff ff ff       	call   800822 <printnum>
+  8008d3:	83 c4 20             	add    $0x20,%esp
+  8008d6:	eb 1b                	jmp    8008f3 <printnum+0xd1>
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+            putch(padc, putdat);
+  8008d8:	83 ec 08             	sub    $0x8,%esp
+  8008db:	ff 75 0c             	pushl  0xc(%ebp)
+  8008de:	ff 75 20             	pushl  0x20(%ebp)
+  8008e1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8008e4:	ff d0                	call   *%eax
+  8008e6:	83 c4 10             	add    $0x10,%esp
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+        printnum(putch, putdat, result, base, width - 1, padc);
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+  8008e9:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+  8008ed:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+  8008f1:	7f e5                	jg     8008d8 <printnum+0xb6>
+            putch(padc, putdat);
+    }
+    // then print this (the least significant) digit
+    putch("0123456789abcdef"[mod], putdat);
+  8008f3:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  8008f6:	05 a4 11 80 00       	add    $0x8011a4,%eax
+  8008fb:	0f b6 00             	movzbl (%eax),%eax
+  8008fe:	0f be c0             	movsbl %al,%eax
+  800901:	83 ec 08             	sub    $0x8,%esp
+  800904:	ff 75 0c             	pushl  0xc(%ebp)
+  800907:	50                   	push   %eax
+  800908:	8b 45 08             	mov    0x8(%ebp),%eax
+  80090b:	ff d0                	call   *%eax
+  80090d:	83 c4 10             	add    $0x10,%esp
+}
+  800910:	90                   	nop
+  800911:	c9                   	leave  
+  800912:	c3                   	ret    
+
+00800913 <getuint>:
+ * getuint - get an unsigned int of various possible sizes from a varargs list
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static unsigned long long
+getuint(va_list *ap, int lflag) {
+  800913:	55                   	push   %ebp
+  800914:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  800916:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  80091a:	7e 14                	jle    800930 <getuint+0x1d>
+        return va_arg(*ap, unsigned long long);
+  80091c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80091f:	8b 00                	mov    (%eax),%eax
+  800921:	8d 48 08             	lea    0x8(%eax),%ecx
+  800924:	8b 55 08             	mov    0x8(%ebp),%edx
+  800927:	89 0a                	mov    %ecx,(%edx)
+  800929:	8b 50 04             	mov    0x4(%eax),%edx
+  80092c:	8b 00                	mov    (%eax),%eax
+  80092e:	eb 30                	jmp    800960 <getuint+0x4d>
+    }
+    else if (lflag) {
+  800930:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800934:	74 16                	je     80094c <getuint+0x39>
+        return va_arg(*ap, unsigned long);
+  800936:	8b 45 08             	mov    0x8(%ebp),%eax
+  800939:	8b 00                	mov    (%eax),%eax
+  80093b:	8d 48 04             	lea    0x4(%eax),%ecx
+  80093e:	8b 55 08             	mov    0x8(%ebp),%edx
+  800941:	89 0a                	mov    %ecx,(%edx)
+  800943:	8b 00                	mov    (%eax),%eax
+  800945:	ba 00 00 00 00       	mov    $0x0,%edx
+  80094a:	eb 14                	jmp    800960 <getuint+0x4d>
+    }
+    else {
+        return va_arg(*ap, unsigned int);
+  80094c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80094f:	8b 00                	mov    (%eax),%eax
+  800951:	8d 48 04             	lea    0x4(%eax),%ecx
+  800954:	8b 55 08             	mov    0x8(%ebp),%edx
+  800957:	89 0a                	mov    %ecx,(%edx)
+  800959:	8b 00                	mov    (%eax),%eax
+  80095b:	ba 00 00 00 00       	mov    $0x0,%edx
+    }
+}
+  800960:	5d                   	pop    %ebp
+  800961:	c3                   	ret    
+
+00800962 <getint>:
+ * getint - same as getuint but signed, we can't use getuint because of sign extension
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static long long
+getint(va_list *ap, int lflag) {
+  800962:	55                   	push   %ebp
+  800963:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  800965:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  800969:	7e 14                	jle    80097f <getint+0x1d>
+        return va_arg(*ap, long long);
+  80096b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80096e:	8b 00                	mov    (%eax),%eax
+  800970:	8d 48 08             	lea    0x8(%eax),%ecx
+  800973:	8b 55 08             	mov    0x8(%ebp),%edx
+  800976:	89 0a                	mov    %ecx,(%edx)
+  800978:	8b 50 04             	mov    0x4(%eax),%edx
+  80097b:	8b 00                	mov    (%eax),%eax
+  80097d:	eb 28                	jmp    8009a7 <getint+0x45>
+    }
+    else if (lflag) {
+  80097f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800983:	74 12                	je     800997 <getint+0x35>
+        return va_arg(*ap, long);
+  800985:	8b 45 08             	mov    0x8(%ebp),%eax
+  800988:	8b 00                	mov    (%eax),%eax
+  80098a:	8d 48 04             	lea    0x4(%eax),%ecx
+  80098d:	8b 55 08             	mov    0x8(%ebp),%edx
+  800990:	89 0a                	mov    %ecx,(%edx)
+  800992:	8b 00                	mov    (%eax),%eax
+  800994:	99                   	cltd   
+  800995:	eb 10                	jmp    8009a7 <getint+0x45>
+    }
+    else {
+        return va_arg(*ap, int);
+  800997:	8b 45 08             	mov    0x8(%ebp),%eax
+  80099a:	8b 00                	mov    (%eax),%eax
+  80099c:	8d 48 04             	lea    0x4(%eax),%ecx
+  80099f:	8b 55 08             	mov    0x8(%ebp),%edx
+  8009a2:	89 0a                	mov    %ecx,(%edx)
+  8009a4:	8b 00                	mov    (%eax),%eax
+  8009a6:	99                   	cltd   
+    }
+}
+  8009a7:	5d                   	pop    %ebp
+  8009a8:	c3                   	ret    
+
+008009a9 <printfmt>:
+ * @putch:      specified putch function, print a single character
+ * @putdat:     used by @putch function
+ * @fmt:        the format string to use
+ * */
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...) {
+  8009a9:	55                   	push   %ebp
+  8009aa:	89 e5                	mov    %esp,%ebp
+  8009ac:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  8009af:	8d 45 14             	lea    0x14(%ebp),%eax
+  8009b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    vprintfmt(putch, putdat, fmt, ap);
+  8009b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8009b8:	50                   	push   %eax
+  8009b9:	ff 75 10             	pushl  0x10(%ebp)
+  8009bc:	ff 75 0c             	pushl  0xc(%ebp)
+  8009bf:	ff 75 08             	pushl  0x8(%ebp)
+  8009c2:	e8 06 00 00 00       	call   8009cd <vprintfmt>
+  8009c7:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+  8009ca:	90                   	nop
+  8009cb:	c9                   	leave  
+  8009cc:	c3                   	ret    
+
+008009cd <vprintfmt>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want printfmt() instead.
+ * */
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap) {
+  8009cd:	55                   	push   %ebp
+  8009ce:	89 e5                	mov    %esp,%ebp
+  8009d0:	56                   	push   %esi
+  8009d1:	53                   	push   %ebx
+  8009d2:	83 ec 20             	sub    $0x20,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  8009d5:	eb 17                	jmp    8009ee <vprintfmt+0x21>
+            if (ch == '\0') {
+  8009d7:	85 db                	test   %ebx,%ebx
+  8009d9:	0f 84 8e 03 00 00    	je     800d6d <vprintfmt+0x3a0>
+                return;
+            }
+            putch(ch, putdat);
+  8009df:	83 ec 08             	sub    $0x8,%esp
+  8009e2:	ff 75 0c             	pushl  0xc(%ebp)
+  8009e5:	53                   	push   %ebx
+  8009e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009e9:	ff d0                	call   *%eax
+  8009eb:	83 c4 10             	add    $0x10,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  8009ee:	8b 45 10             	mov    0x10(%ebp),%eax
+  8009f1:	8d 50 01             	lea    0x1(%eax),%edx
+  8009f4:	89 55 10             	mov    %edx,0x10(%ebp)
+  8009f7:	0f b6 00             	movzbl (%eax),%eax
+  8009fa:	0f b6 d8             	movzbl %al,%ebx
+  8009fd:	83 fb 25             	cmp    $0x25,%ebx
+  800a00:	75 d5                	jne    8009d7 <vprintfmt+0xa>
+            }
+            putch(ch, putdat);
+        }
+
+        // Process a %-escape sequence
+        char padc = ' ';
+  800a02:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+        width = precision = -1;
+  800a06:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+  800a0d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800a10:	89 45 e8             	mov    %eax,-0x18(%ebp)
+        lflag = altflag = 0;
+  800a13:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+  800a1a:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  800a1d:	89 45 e0             	mov    %eax,-0x20(%ebp)
+
+    reswitch:
+        switch (ch = *(unsigned char *)fmt ++) {
+  800a20:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a23:	8d 50 01             	lea    0x1(%eax),%edx
+  800a26:	89 55 10             	mov    %edx,0x10(%ebp)
+  800a29:	0f b6 00             	movzbl (%eax),%eax
+  800a2c:	0f b6 d8             	movzbl %al,%ebx
+  800a2f:	8d 43 dd             	lea    -0x23(%ebx),%eax
+  800a32:	83 f8 55             	cmp    $0x55,%eax
+  800a35:	0f 87 05 03 00 00    	ja     800d40 <vprintfmt+0x373>
+  800a3b:	8b 04 85 c8 11 80 00 	mov    0x8011c8(,%eax,4),%eax
+  800a42:	ff e0                	jmp    *%eax
+
+        // flag to pad on the right
+        case '-':
+            padc = '-';
+  800a44:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+            goto reswitch;
+  800a48:	eb d6                	jmp    800a20 <vprintfmt+0x53>
+
+        // flag to pad with 0's instead of spaces
+        case '0':
+            padc = '0';
+  800a4a:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+            goto reswitch;
+  800a4e:	eb d0                	jmp    800a20 <vprintfmt+0x53>
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  800a50:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+                precision = precision * 10 + ch - '0';
+  800a57:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800a5a:	89 d0                	mov    %edx,%eax
+  800a5c:	c1 e0 02             	shl    $0x2,%eax
+  800a5f:	01 d0                	add    %edx,%eax
+  800a61:	01 c0                	add    %eax,%eax
+  800a63:	01 d8                	add    %ebx,%eax
+  800a65:	83 e8 30             	sub    $0x30,%eax
+  800a68:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+                ch = *fmt;
+  800a6b:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a6e:	0f b6 00             	movzbl (%eax),%eax
+  800a71:	0f be d8             	movsbl %al,%ebx
+                if (ch < '0' || ch > '9') {
+  800a74:	83 fb 2f             	cmp    $0x2f,%ebx
+  800a77:	7e 39                	jle    800ab2 <vprintfmt+0xe5>
+  800a79:	83 fb 39             	cmp    $0x39,%ebx
+  800a7c:	7f 34                	jg     800ab2 <vprintfmt+0xe5>
+            padc = '0';
+            goto reswitch;
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  800a7e:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+                precision = precision * 10 + ch - '0';
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+  800a82:	eb d3                	jmp    800a57 <vprintfmt+0x8a>
+            goto process_precision;
+
+        case '*':
+            precision = va_arg(ap, int);
+  800a84:	8b 45 14             	mov    0x14(%ebp),%eax
+  800a87:	8d 50 04             	lea    0x4(%eax),%edx
+  800a8a:	89 55 14             	mov    %edx,0x14(%ebp)
+  800a8d:	8b 00                	mov    (%eax),%eax
+  800a8f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+            goto process_precision;
+  800a92:	eb 1f                	jmp    800ab3 <vprintfmt+0xe6>
+
+        case '.':
+            if (width < 0)
+  800a94:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800a98:	79 86                	jns    800a20 <vprintfmt+0x53>
+                width = 0;
+  800a9a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+            goto reswitch;
+  800aa1:	e9 7a ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        case '#':
+            altflag = 1;
+  800aa6:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+            goto reswitch;
+  800aad:	e9 6e ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+            goto process_precision;
+  800ab2:	90                   	nop
+        case '#':
+            altflag = 1;
+            goto reswitch;
+
+        process_precision:
+            if (width < 0)
+  800ab3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ab7:	0f 89 63 ff ff ff    	jns    800a20 <vprintfmt+0x53>
+                width = precision, precision = -1;
+  800abd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800ac0:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800ac3:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+            goto reswitch;
+  800aca:	e9 51 ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        // long flag (doubled for long long)
+        case 'l':
+            lflag ++;
+  800acf:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
+            goto reswitch;
+  800ad3:	e9 48 ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        // character
+        case 'c':
+            putch(va_arg(ap, int), putdat);
+  800ad8:	8b 45 14             	mov    0x14(%ebp),%eax
+  800adb:	8d 50 04             	lea    0x4(%eax),%edx
+  800ade:	89 55 14             	mov    %edx,0x14(%ebp)
+  800ae1:	8b 00                	mov    (%eax),%eax
+  800ae3:	83 ec 08             	sub    $0x8,%esp
+  800ae6:	ff 75 0c             	pushl  0xc(%ebp)
+  800ae9:	50                   	push   %eax
+  800aea:	8b 45 08             	mov    0x8(%ebp),%eax
+  800aed:	ff d0                	call   *%eax
+  800aef:	83 c4 10             	add    $0x10,%esp
+            break;
+  800af2:	e9 71 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // error message
+        case 'e':
+            err = va_arg(ap, int);
+  800af7:	8b 45 14             	mov    0x14(%ebp),%eax
+  800afa:	8d 50 04             	lea    0x4(%eax),%edx
+  800afd:	89 55 14             	mov    %edx,0x14(%ebp)
+  800b00:	8b 18                	mov    (%eax),%ebx
+            if (err < 0) {
+  800b02:	85 db                	test   %ebx,%ebx
+  800b04:	79 02                	jns    800b08 <vprintfmt+0x13b>
+                err = -err;
+  800b06:	f7 db                	neg    %ebx
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+  800b08:	83 fb 18             	cmp    $0x18,%ebx
+  800b0b:	7f 0b                	jg     800b18 <vprintfmt+0x14b>
+  800b0d:	8b 34 9d 40 11 80 00 	mov    0x801140(,%ebx,4),%esi
+  800b14:	85 f6                	test   %esi,%esi
+  800b16:	75 19                	jne    800b31 <vprintfmt+0x164>
+                printfmt(putch, putdat, "error %d", err);
+  800b18:	53                   	push   %ebx
+  800b19:	68 b5 11 80 00       	push   $0x8011b5
+  800b1e:	ff 75 0c             	pushl  0xc(%ebp)
+  800b21:	ff 75 08             	pushl  0x8(%ebp)
+  800b24:	e8 80 fe ff ff       	call   8009a9 <printfmt>
+  800b29:	83 c4 10             	add    $0x10,%esp
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+            }
+            break;
+  800b2c:	e9 37 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+                printfmt(putch, putdat, "error %d", err);
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+  800b31:	56                   	push   %esi
+  800b32:	68 be 11 80 00       	push   $0x8011be
+  800b37:	ff 75 0c             	pushl  0xc(%ebp)
+  800b3a:	ff 75 08             	pushl  0x8(%ebp)
+  800b3d:	e8 67 fe ff ff       	call   8009a9 <printfmt>
+  800b42:	83 c4 10             	add    $0x10,%esp
+            }
+            break;
+  800b45:	e9 1e 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // string
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+  800b4a:	8b 45 14             	mov    0x14(%ebp),%eax
+  800b4d:	8d 50 04             	lea    0x4(%eax),%edx
+  800b50:	89 55 14             	mov    %edx,0x14(%ebp)
+  800b53:	8b 30                	mov    (%eax),%esi
+  800b55:	85 f6                	test   %esi,%esi
+  800b57:	75 05                	jne    800b5e <vprintfmt+0x191>
+                p = "(null)";
+  800b59:	be c1 11 80 00       	mov    $0x8011c1,%esi
+            }
+            if (width > 0 && padc != '-') {
+  800b5e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800b62:	7e 76                	jle    800bda <vprintfmt+0x20d>
+  800b64:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+  800b68:	74 70                	je     800bda <vprintfmt+0x20d>
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  800b6a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800b6d:	83 ec 08             	sub    $0x8,%esp
+  800b70:	50                   	push   %eax
+  800b71:	56                   	push   %esi
+  800b72:	e8 17 f8 ff ff       	call   80038e <strnlen>
+  800b77:	83 c4 10             	add    $0x10,%esp
+  800b7a:	89 c2                	mov    %eax,%edx
+  800b7c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800b7f:	29 d0                	sub    %edx,%eax
+  800b81:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800b84:	eb 17                	jmp    800b9d <vprintfmt+0x1d0>
+                    putch(padc, putdat);
+  800b86:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+  800b8a:	83 ec 08             	sub    $0x8,%esp
+  800b8d:	ff 75 0c             	pushl  0xc(%ebp)
+  800b90:	50                   	push   %eax
+  800b91:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b94:	ff d0                	call   *%eax
+  800b96:	83 c4 10             	add    $0x10,%esp
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+                p = "(null)";
+            }
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  800b99:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800b9d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ba1:	7f e3                	jg     800b86 <vprintfmt+0x1b9>
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  800ba3:	eb 35                	jmp    800bda <vprintfmt+0x20d>
+                if (altflag && (ch < ' ' || ch > '~')) {
+  800ba5:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+  800ba9:	74 1c                	je     800bc7 <vprintfmt+0x1fa>
+  800bab:	83 fb 1f             	cmp    $0x1f,%ebx
+  800bae:	7e 05                	jle    800bb5 <vprintfmt+0x1e8>
+  800bb0:	83 fb 7e             	cmp    $0x7e,%ebx
+  800bb3:	7e 12                	jle    800bc7 <vprintfmt+0x1fa>
+                    putch('?', putdat);
+  800bb5:	83 ec 08             	sub    $0x8,%esp
+  800bb8:	ff 75 0c             	pushl  0xc(%ebp)
+  800bbb:	6a 3f                	push   $0x3f
+  800bbd:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bc0:	ff d0                	call   *%eax
+  800bc2:	83 c4 10             	add    $0x10,%esp
+  800bc5:	eb 0f                	jmp    800bd6 <vprintfmt+0x209>
+                }
+                else {
+                    putch(ch, putdat);
+  800bc7:	83 ec 08             	sub    $0x8,%esp
+  800bca:	ff 75 0c             	pushl  0xc(%ebp)
+  800bcd:	53                   	push   %ebx
+  800bce:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bd1:	ff d0                	call   *%eax
+  800bd3:	83 c4 10             	add    $0x10,%esp
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  800bd6:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800bda:	89 f0                	mov    %esi,%eax
+  800bdc:	8d 70 01             	lea    0x1(%eax),%esi
+  800bdf:	0f b6 00             	movzbl (%eax),%eax
+  800be2:	0f be d8             	movsbl %al,%ebx
+  800be5:	85 db                	test   %ebx,%ebx
+  800be7:	74 26                	je     800c0f <vprintfmt+0x242>
+  800be9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800bed:	78 b6                	js     800ba5 <vprintfmt+0x1d8>
+  800bef:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800bf3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800bf7:	79 ac                	jns    800ba5 <vprintfmt+0x1d8>
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  800bf9:	eb 14                	jmp    800c0f <vprintfmt+0x242>
+                putch(' ', putdat);
+  800bfb:	83 ec 08             	sub    $0x8,%esp
+  800bfe:	ff 75 0c             	pushl  0xc(%ebp)
+  800c01:	6a 20                	push   $0x20
+  800c03:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c06:	ff d0                	call   *%eax
+  800c08:	83 c4 10             	add    $0x10,%esp
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  800c0b:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800c0f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800c13:	7f e6                	jg     800bfb <vprintfmt+0x22e>
+                putch(' ', putdat);
+            }
+            break;
+  800c15:	e9 4e 01 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // (signed) decimal
+        case 'd':
+            num = getint(&ap, lflag);
+  800c1a:	83 ec 08             	sub    $0x8,%esp
+  800c1d:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c20:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c23:	50                   	push   %eax
+  800c24:	e8 39 fd ff ff       	call   800962 <getint>
+  800c29:	83 c4 10             	add    $0x10,%esp
+  800c2c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c2f:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            if ((long long)num < 0) {
+  800c32:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c35:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800c38:	85 d2                	test   %edx,%edx
+  800c3a:	79 23                	jns    800c5f <vprintfmt+0x292>
+                putch('-', putdat);
+  800c3c:	83 ec 08             	sub    $0x8,%esp
+  800c3f:	ff 75 0c             	pushl  0xc(%ebp)
+  800c42:	6a 2d                	push   $0x2d
+  800c44:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c47:	ff d0                	call   *%eax
+  800c49:	83 c4 10             	add    $0x10,%esp
+                num = -(long long)num;
+  800c4c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c4f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800c52:	f7 d8                	neg    %eax
+  800c54:	83 d2 00             	adc    $0x0,%edx
+  800c57:	f7 da                	neg    %edx
+  800c59:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c5c:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            }
+            base = 10;
+  800c5f:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  800c66:	e9 9f 00 00 00       	jmp    800d0a <vprintfmt+0x33d>
+
+        // unsigned decimal
+        case 'u':
+            num = getuint(&ap, lflag);
+  800c6b:	83 ec 08             	sub    $0x8,%esp
+  800c6e:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c71:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c74:	50                   	push   %eax
+  800c75:	e8 99 fc ff ff       	call   800913 <getuint>
+  800c7a:	83 c4 10             	add    $0x10,%esp
+  800c7d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c80:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 10;
+  800c83:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  800c8a:	eb 7e                	jmp    800d0a <vprintfmt+0x33d>
+
+        // (unsigned) octal
+        case 'o':
+            num = getuint(&ap, lflag);
+  800c8c:	83 ec 08             	sub    $0x8,%esp
+  800c8f:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c92:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c95:	50                   	push   %eax
+  800c96:	e8 78 fc ff ff       	call   800913 <getuint>
+  800c9b:	83 c4 10             	add    $0x10,%esp
+  800c9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800ca1:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 8;
+  800ca4:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+            goto number;
+  800cab:	eb 5d                	jmp    800d0a <vprintfmt+0x33d>
+
+        // pointer
+        case 'p':
+            putch('0', putdat);
+  800cad:	83 ec 08             	sub    $0x8,%esp
+  800cb0:	ff 75 0c             	pushl  0xc(%ebp)
+  800cb3:	6a 30                	push   $0x30
+  800cb5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cb8:	ff d0                	call   *%eax
+  800cba:	83 c4 10             	add    $0x10,%esp
+            putch('x', putdat);
+  800cbd:	83 ec 08             	sub    $0x8,%esp
+  800cc0:	ff 75 0c             	pushl  0xc(%ebp)
+  800cc3:	6a 78                	push   $0x78
+  800cc5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cc8:	ff d0                	call   *%eax
+  800cca:	83 c4 10             	add    $0x10,%esp
+            num = (unsigned long long)(uintptr_t)va_arg(ap, void *);
+  800ccd:	8b 45 14             	mov    0x14(%ebp),%eax
+  800cd0:	8d 50 04             	lea    0x4(%eax),%edx
+  800cd3:	89 55 14             	mov    %edx,0x14(%ebp)
+  800cd6:	8b 00                	mov    (%eax),%eax
+  800cd8:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800cdb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+            base = 16;
+  800ce2:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+            goto number;
+  800ce9:	eb 1f                	jmp    800d0a <vprintfmt+0x33d>
+
+        // (unsigned) hexadecimal
+        case 'x':
+            num = getuint(&ap, lflag);
+  800ceb:	83 ec 08             	sub    $0x8,%esp
+  800cee:	ff 75 e0             	pushl  -0x20(%ebp)
+  800cf1:	8d 45 14             	lea    0x14(%ebp),%eax
+  800cf4:	50                   	push   %eax
+  800cf5:	e8 19 fc ff ff       	call   800913 <getuint>
+  800cfa:	83 c4 10             	add    $0x10,%esp
+  800cfd:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800d00:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 16;
+  800d03:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+        number:
+            printnum(putch, putdat, num, base, width, padc);
+  800d0a:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+  800d0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800d11:	83 ec 04             	sub    $0x4,%esp
+  800d14:	52                   	push   %edx
+  800d15:	ff 75 e8             	pushl  -0x18(%ebp)
+  800d18:	50                   	push   %eax
+  800d19:	ff 75 f4             	pushl  -0xc(%ebp)
+  800d1c:	ff 75 f0             	pushl  -0x10(%ebp)
+  800d1f:	ff 75 0c             	pushl  0xc(%ebp)
+  800d22:	ff 75 08             	pushl  0x8(%ebp)
+  800d25:	e8 f8 fa ff ff       	call   800822 <printnum>
+  800d2a:	83 c4 20             	add    $0x20,%esp
+            break;
+  800d2d:	eb 39                	jmp    800d68 <vprintfmt+0x39b>
+
+        // escaped '%' character
+        case '%':
+            putch(ch, putdat);
+  800d2f:	83 ec 08             	sub    $0x8,%esp
+  800d32:	ff 75 0c             	pushl  0xc(%ebp)
+  800d35:	53                   	push   %ebx
+  800d36:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d39:	ff d0                	call   *%eax
+  800d3b:	83 c4 10             	add    $0x10,%esp
+            break;
+  800d3e:	eb 28                	jmp    800d68 <vprintfmt+0x39b>
+
+        // unrecognized escape sequence - just print it literally
+        default:
+            putch('%', putdat);
+  800d40:	83 ec 08             	sub    $0x8,%esp
+  800d43:	ff 75 0c             	pushl  0xc(%ebp)
+  800d46:	6a 25                	push   $0x25
+  800d48:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d4b:	ff d0                	call   *%eax
+  800d4d:	83 c4 10             	add    $0x10,%esp
+            for (fmt --; fmt[-1] != '%'; fmt --)
+  800d50:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800d54:	eb 04                	jmp    800d5a <vprintfmt+0x38d>
+  800d56:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800d5a:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d5d:	83 e8 01             	sub    $0x1,%eax
+  800d60:	0f b6 00             	movzbl (%eax),%eax
+  800d63:	3c 25                	cmp    $0x25,%al
+  800d65:	75 ef                	jne    800d56 <vprintfmt+0x389>
+                /* do nothing */;
+            break;
+  800d67:	90                   	nop
+        }
+    }
+  800d68:	e9 68 fc ff ff       	jmp    8009d5 <vprintfmt+0x8>
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+            if (ch == '\0') {
+                return;
+  800d6d:	90                   	nop
+            for (fmt --; fmt[-1] != '%'; fmt --)
+                /* do nothing */;
+            break;
+        }
+    }
+}
+  800d6e:	8d 65 f8             	lea    -0x8(%ebp),%esp
+  800d71:	5b                   	pop    %ebx
+  800d72:	5e                   	pop    %esi
+  800d73:	5d                   	pop    %ebp
+  800d74:	c3                   	ret    
+
+00800d75 <sprintputch>:
+ * sprintputch - 'print' a single character in a buffer
+ * @ch:         the character will be printed
+ * @b:          the buffer to place the character @ch
+ * */
+static void
+sprintputch(int ch, struct sprintbuf *b) {
+  800d75:	55                   	push   %ebp
+  800d76:	89 e5                	mov    %esp,%ebp
+    b->cnt ++;
+  800d78:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d7b:	8b 40 08             	mov    0x8(%eax),%eax
+  800d7e:	8d 50 01             	lea    0x1(%eax),%edx
+  800d81:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d84:	89 50 08             	mov    %edx,0x8(%eax)
+    if (b->buf < b->ebuf) {
+  800d87:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8a:	8b 10                	mov    (%eax),%edx
+  800d8c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8f:	8b 40 04             	mov    0x4(%eax),%eax
+  800d92:	39 c2                	cmp    %eax,%edx
+  800d94:	73 12                	jae    800da8 <sprintputch+0x33>
+        *b->buf ++ = ch;
+  800d96:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d99:	8b 00                	mov    (%eax),%eax
+  800d9b:	8d 48 01             	lea    0x1(%eax),%ecx
+  800d9e:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800da1:	89 0a                	mov    %ecx,(%edx)
+  800da3:	8b 55 08             	mov    0x8(%ebp),%edx
+  800da6:	88 10                	mov    %dl,(%eax)
+    }
+}
+  800da8:	90                   	nop
+  800da9:	5d                   	pop    %ebp
+  800daa:	c3                   	ret    
+
+00800dab <snprintf>:
+ * @str:        the buffer to place the result into
+ * @size:       the size of buffer, including the trailing null space
+ * @fmt:        the format string to use
+ * */
+int
+snprintf(char *str, size_t size, const char *fmt, ...) {
+  800dab:	55                   	push   %ebp
+  800dac:	89 e5                	mov    %esp,%ebp
+  800dae:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    int cnt;
+    va_start(ap, fmt);
+  800db1:	8d 45 14             	lea    0x14(%ebp),%eax
+  800db4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    cnt = vsnprintf(str, size, fmt, ap);
+  800db7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800dba:	50                   	push   %eax
+  800dbb:	ff 75 10             	pushl  0x10(%ebp)
+  800dbe:	ff 75 0c             	pushl  0xc(%ebp)
+  800dc1:	ff 75 08             	pushl  0x8(%ebp)
+  800dc4:	e8 0b 00 00 00       	call   800dd4 <vsnprintf>
+  800dc9:	83 c4 10             	add    $0x10,%esp
+  800dcc:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+    return cnt;
+  800dcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800dd2:	c9                   	leave  
+  800dd3:	c3                   	ret    
+
+00800dd4 <vsnprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want snprintf() instead.
+ * */
+int
+vsnprintf(char *str, size_t size, const char *fmt, va_list ap) {
+  800dd4:	55                   	push   %ebp
+  800dd5:	89 e5                	mov    %esp,%ebp
+  800dd7:	83 ec 18             	sub    $0x18,%esp
+    struct sprintbuf b = {str, str + size - 1, 0};
+  800dda:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ddd:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800de0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800de3:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800de6:	8b 45 08             	mov    0x8(%ebp),%eax
+  800de9:	01 d0                	add    %edx,%eax
+  800deb:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800dee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    if (str == NULL || b.buf > b.ebuf) {
+  800df5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  800df9:	74 0a                	je     800e05 <vsnprintf+0x31>
+  800dfb:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  800dfe:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800e01:	39 c2                	cmp    %eax,%edx
+  800e03:	76 07                	jbe    800e0c <vsnprintf+0x38>
+        return -E_INVAL;
+  800e05:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+  800e0a:	eb 20                	jmp    800e2c <vsnprintf+0x58>
+    }
+    // print the string to the buffer
+    vprintfmt((void*)sprintputch, &b, fmt, ap);
+  800e0c:	ff 75 14             	pushl  0x14(%ebp)
+  800e0f:	ff 75 10             	pushl  0x10(%ebp)
+  800e12:	8d 45 ec             	lea    -0x14(%ebp),%eax
+  800e15:	50                   	push   %eax
+  800e16:	68 75 0d 80 00       	push   $0x800d75
+  800e1b:	e8 ad fb ff ff       	call   8009cd <vprintfmt>
+  800e20:	83 c4 10             	add    $0x10,%esp
+    // null terminate the buffer
+    *b.buf = '\0';
+  800e23:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e26:	c6 00 00             	movb   $0x0,(%eax)
+    return b.cnt;
+  800e29:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800e2c:	c9                   	leave  
+  800e2d:	c3                   	ret    
+
+00800e2e <hash32>:
+ * @bits:   the number of bits in a return value
+ *
+ * High bits are more random, so we use them.
+ * */
+uint32_t
+hash32(uint32_t val, unsigned int bits) {
+  800e2e:	55                   	push   %ebp
+  800e2f:	89 e5                	mov    %esp,%ebp
+  800e31:	83 ec 10             	sub    $0x10,%esp
+    uint32_t hash = val * GOLDEN_RATIO_PRIME_32;
+  800e34:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e37:	69 c0 01 00 37 9e    	imul   $0x9e370001,%eax,%eax
+  800e3d:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    return (hash >> (32 - bits));
+  800e40:	b8 20 00 00 00       	mov    $0x20,%eax
+  800e45:	2b 45 0c             	sub    0xc(%ebp),%eax
+  800e48:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  800e4b:	89 c1                	mov    %eax,%ecx
+  800e4d:	d3 ea                	shr    %cl,%edx
+  800e4f:	89 d0                	mov    %edx,%eax
+}
+  800e51:	c9                   	leave  
+  800e52:	c3                   	ret    
+
+00800e53 <rand>:
+ * rand - returns a pseudo-random integer
+ *
+ * The rand() function return a value in the range [0, RAND_MAX].
+ * */
+int
+rand(void) {
+  800e53:	55                   	push   %ebp
+  800e54:	89 e5                	mov    %esp,%ebp
+  800e56:	57                   	push   %edi
+  800e57:	56                   	push   %esi
+  800e58:	53                   	push   %ebx
+  800e59:	83 ec 24             	sub    $0x24,%esp
+    next = (next * 0x5DEECE66DLL + 0xBLL) & ((1LL << 48) - 1);
+  800e5c:	a1 00 20 80 00       	mov    0x802000,%eax
+  800e61:	8b 15 04 20 80 00    	mov    0x802004,%edx
+  800e67:	69 fa 6d e6 ec de    	imul   $0xdeece66d,%edx,%edi
+  800e6d:	6b f0 05             	imul   $0x5,%eax,%esi
+  800e70:	01 fe                	add    %edi,%esi
+  800e72:	bf 6d e6 ec de       	mov    $0xdeece66d,%edi
+  800e77:	f7 e7                	mul    %edi
+  800e79:	01 d6                	add    %edx,%esi
+  800e7b:	89 f2                	mov    %esi,%edx
+  800e7d:	83 c0 0b             	add    $0xb,%eax
+  800e80:	83 d2 00             	adc    $0x0,%edx
+  800e83:	89 c7                	mov    %eax,%edi
+  800e85:	83 e7 ff             	and    $0xffffffff,%edi
+  800e88:	89 f9                	mov    %edi,%ecx
+  800e8a:	0f b7 da             	movzwl %dx,%ebx
+  800e8d:	89 0d 00 20 80 00    	mov    %ecx,0x802000
+  800e93:	89 1d 04 20 80 00    	mov    %ebx,0x802004
+    unsigned long long result = (next >> 12);
+  800e99:	a1 00 20 80 00       	mov    0x802000,%eax
+  800e9e:	8b 15 04 20 80 00    	mov    0x802004,%edx
+  800ea4:	0f ac d0 0c          	shrd   $0xc,%edx,%eax
+  800ea8:	c1 ea 0c             	shr    $0xc,%edx
+  800eab:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800eae:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+    return (int)do_div(result, RAND_MAX + 1);
+  800eb1:	c7 45 dc 00 00 00 80 	movl   $0x80000000,-0x24(%ebp)
+  800eb8:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  800ebb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800ebe:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  800ec1:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  800ec4:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ec7:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800eca:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ece:	74 1c                	je     800eec <rand+0x99>
+  800ed0:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ed3:	ba 00 00 00 00       	mov    $0x0,%edx
+  800ed8:	f7 75 dc             	divl   -0x24(%ebp)
+  800edb:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  800ede:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ee1:	ba 00 00 00 00       	mov    $0x0,%edx
+  800ee6:	f7 75 dc             	divl   -0x24(%ebp)
+  800ee9:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800eec:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  800eef:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  800ef2:	f7 75 dc             	divl   -0x24(%ebp)
+  800ef5:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  800ef8:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  800efb:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  800efe:	8b 55 e8             	mov    -0x18(%ebp),%edx
+  800f01:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800f04:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  800f07:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+}
+  800f0a:	83 c4 24             	add    $0x24,%esp
+  800f0d:	5b                   	pop    %ebx
+  800f0e:	5e                   	pop    %esi
+  800f0f:	5f                   	pop    %edi
+  800f10:	5d                   	pop    %ebp
+  800f11:	c3                   	ret    
+
+00800f12 <srand>:
+/* *
+ * srand - seed the random number generator with the given number
+ * @seed:   the required seed number
+ * */
+void
+srand(unsigned int seed) {
+  800f12:	55                   	push   %ebp
+  800f13:	89 e5                	mov    %esp,%ebp
+    next = seed;
+  800f15:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f18:	ba 00 00 00 00       	mov    $0x0,%edx
+  800f1d:	a3 00 20 80 00       	mov    %eax,0x802000
+  800f22:	89 15 04 20 80 00    	mov    %edx,0x802004
+}
+  800f28:	90                   	nop
+  800f29:	5d                   	pop    %ebp
+  800f2a:	c3                   	ret    
+
+00800f2b <main>:
+#include <stdio.h>
+#include <ulib.h>
+
+int
+main(void) {
+  800f2b:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+  800f2f:	83 e4 f0             	and    $0xfffffff0,%esp
+  800f32:	ff 71 fc             	pushl  -0x4(%ecx)
+  800f35:	55                   	push   %ebp
+  800f36:	89 e5                	mov    %esp,%ebp
+  800f38:	51                   	push   %ecx
+  800f39:	83 ec 14             	sub    $0x14,%esp
+    int pid, ret;
+    cprintf("I am the parent. Forking the child...\n");
+  800f3c:	83 ec 0c             	sub    $0xc,%esp
+  800f3f:	68 20 13 80 00       	push   $0x801320
+  800f44:	e8 90 f3 ff ff       	call   8002d9 <cprintf>
+  800f49:	83 c4 10             	add    $0x10,%esp
+    if ((pid = fork()) == 0) {
+  800f4c:	e8 8c f2 ff ff       	call   8001dd <fork>
+  800f51:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800f54:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  800f58:	75 12                	jne    800f6c <main+0x41>
+        cprintf("I am the child. spinning ...\n");
+  800f5a:	83 ec 0c             	sub    $0xc,%esp
+  800f5d:	68 47 13 80 00       	push   $0x801347
+  800f62:	e8 72 f3 ff ff       	call   8002d9 <cprintf>
+  800f67:	83 c4 10             	add    $0x10,%esp
+        while (1);
+  800f6a:	eb fe                	jmp    800f6a <main+0x3f>
+    }
+    cprintf("I am the parent. Running the child...\n");
+  800f6c:	83 ec 0c             	sub    $0xc,%esp
+  800f6f:	68 68 13 80 00       	push   $0x801368
+  800f74:	e8 60 f3 ff ff       	call   8002d9 <cprintf>
+  800f79:	83 c4 10             	add    $0x10,%esp
+
+    yield();
+  800f7c:	e8 99 f2 ff ff       	call   80021a <yield>
+    yield();
+  800f81:	e8 94 f2 ff ff       	call   80021a <yield>
+    yield();
+  800f86:	e8 8f f2 ff ff       	call   80021a <yield>
+
+    cprintf("I am the parent.  Killing the child...\n");
+  800f8b:	83 ec 0c             	sub    $0xc,%esp
+  800f8e:	68 90 13 80 00       	push   $0x801390
+  800f93:	e8 41 f3 ff ff       	call   8002d9 <cprintf>
+  800f98:	83 c4 10             	add    $0x10,%esp
+
+    assert((ret = kill(pid)) == 0);
+  800f9b:	83 ec 0c             	sub    $0xc,%esp
+  800f9e:	ff 75 f4             	pushl  -0xc(%ebp)
+  800fa1:	e8 82 f2 ff ff       	call   800228 <kill>
+  800fa6:	83 c4 10             	add    $0x10,%esp
+  800fa9:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800fac:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  800fb0:	74 16                	je     800fc8 <main+0x9d>
+  800fb2:	68 b8 13 80 00       	push   $0x8013b8
+  800fb7:	68 cf 13 80 00       	push   $0x8013cf
+  800fbc:	6a 14                	push   $0x14
+  800fbe:	68 e4 13 80 00       	push   $0x8013e4
+  800fc3:	e8 58 f0 ff ff       	call   800020 <__panic>
+    cprintf("kill returns %d\n", ret);
+  800fc8:	83 ec 08             	sub    $0x8,%esp
+  800fcb:	ff 75 f0             	pushl  -0x10(%ebp)
+  800fce:	68 f0 13 80 00       	push   $0x8013f0
+  800fd3:	e8 01 f3 ff ff       	call   8002d9 <cprintf>
+  800fd8:	83 c4 10             	add    $0x10,%esp
+
+    assert((ret = waitpid(pid, NULL)) == 0);
+  800fdb:	83 ec 08             	sub    $0x8,%esp
+  800fde:	6a 00                	push   $0x0
+  800fe0:	ff 75 f4             	pushl  -0xc(%ebp)
+  800fe3:	e8 19 f2 ff ff       	call   800201 <waitpid>
+  800fe8:	83 c4 10             	add    $0x10,%esp
+  800feb:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800fee:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  800ff2:	74 16                	je     80100a <main+0xdf>
+  800ff4:	68 04 14 80 00       	push   $0x801404
+  800ff9:	68 cf 13 80 00       	push   $0x8013cf
+  800ffe:	6a 17                	push   $0x17
+  801000:	68 e4 13 80 00       	push   $0x8013e4
+  801005:	e8 16 f0 ff ff       	call   800020 <__panic>
+    cprintf("wait returns %d\n", ret);
+  80100a:	83 ec 08             	sub    $0x8,%esp
+  80100d:	ff 75 f0             	pushl  -0x10(%ebp)
+  801010:	68 24 14 80 00       	push   $0x801424
+  801015:	e8 bf f2 ff ff       	call   8002d9 <cprintf>
+  80101a:	83 c4 10             	add    $0x10,%esp
+
+    cprintf("spin may pass.\n");
+  80101d:	83 ec 0c             	sub    $0xc,%esp
+  801020:	68 35 14 80 00       	push   $0x801435
+  801025:	e8 af f2 ff ff       	call   8002d9 <cprintf>
+  80102a:	83 c4 10             	add    $0x10,%esp
+    return 0;
+  80102d:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  801032:	8b 4d fc             	mov    -0x4(%ebp),%ecx
+  801035:	c9                   	leave  
+  801036:	8d 61 fc             	lea    -0x4(%ecx),%esp
+  801039:	c3                   	ret    
diff -r -u -P lab6_origin/obj/user/spin.d lab6/obj/user/spin.d
--- lab6_origin/obj/user/spin.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/spin.d	2019-05-13 17:39:38.533956200 +0800
@@ -0,0 +1,2 @@
+obj/user/spin.o obj/user/spin.d: user/spin.c libs/stdio.h libs/defs.h \
+ libs/stdarg.h user/libs/ulib.h
Binary files lab6_origin/obj/user/spin.o and lab6/obj/user/spin.o differ
diff -r -u -P lab6_origin/obj/user/spin.sym lab6/obj/user/spin.sym
--- lab6_origin/obj/user/spin.sym	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/spin.sym	2019-05-13 17:39:43.856900800 +0800
@@ -0,0 +1,76 @@
+00800020 .text
+00801040 .rodata
+00802000 .data
+00200000 .stab_info
+00200010 .stab
+00202d7d .stabstr
+00000000 panic.c
+00000000 syscall.c
+008000b5 syscall
+00000000 ulib.c
+00000000 stdio.c
+0080028c cputch
+00000000 umain.c
+00000000 string.c
+00000000 printfmt.c
+00801140 error_string
+00800822 printnum
+00800913 getuint
+00800962 getint
+00800d75 sprintputch
+00000000 hash.c
+00000000 rand.c
+00802000 next
+00000000 spin.c
+008003be strcpy
+0080021a yield
+00800201 waitpid
+00800141 sys_yield
+008006d7 memmove
+00800dab snprintf
+008009cd vprintfmt
+0080011d sys_fork
+008002d9 cprintf
+0080023e getpid
+0080077a memcpy
+00800266 lab6_set_priority
+00800dd4 vsnprintf
+0080034d umain
+00202d7c __STAB_END__
+00800150 sys_kill
+00202d7d __STABSTR_BEGIN__
+00800020 __panic
+0080053a strtol
+0080038e strnlen
+0080024b print_pgdir
+00800228 kill
+0080050b strfind
+008001ea wait
+0080027d _start
+00800e53 rand
+00800482 strncmp
+00800171 sys_putc
+008003fe strncpy
+008007ca memcmp
+008001dd fork
+00800697 memset
+00800f2b main
+00800f12 srand
+00800e2e hash32
+008009a9 printfmt
+00203b64 __STABSTR_END__
+00800438 strcmp
+00800259 gettime_msec
+00800192 sys_gettime
+008002b0 vcprintf
+0080006e __warn
+008002ff cputs
+008001a1 sys_lab6_set_priority
+008001b7 exit
+0080012c sys_wait
+0080010b sys_exit
+00200010 __STAB_BEGIN__
+00800366 strlen
+00800183 sys_pgdir
+008004d8 strchr
+00800162 sys_getpid
diff -r -u -P lab6_origin/obj/user/testbss.asm lab6/obj/user/testbss.asm
--- lab6_origin/obj/user/testbss.asm	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/testbss.asm	2019-05-13 17:39:43.404161200 +0800
@@ -0,0 +1,2673 @@
+
+obj/__user_testbss.out:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00800020 <__panic>:
+#include <stdio.h>
+#include <ulib.h>
+#include <error.h>
+
+void
+__panic(const char *file, int line, const char *fmt, ...) {
+  800020:	55                   	push   %ebp
+  800021:	89 e5                	mov    %esp,%ebp
+  800023:	83 ec 18             	sub    $0x18,%esp
+    // print the 'message'
+    va_list ap;
+    va_start(ap, fmt);
+  800026:	8d 45 14             	lea    0x14(%ebp),%eax
+  800029:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("user panic at %s:%d:\n    ", file, line);
+  80002c:	83 ec 04             	sub    $0x4,%esp
+  80002f:	ff 75 0c             	pushl  0xc(%ebp)
+  800032:	ff 75 08             	pushl  0x8(%ebp)
+  800035:	68 40 10 80 00       	push   $0x801040
+  80003a:	e8 9a 02 00 00       	call   8002d9 <cprintf>
+  80003f:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+  800042:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800045:	83 ec 08             	sub    $0x8,%esp
+  800048:	50                   	push   %eax
+  800049:	ff 75 10             	pushl  0x10(%ebp)
+  80004c:	e8 5f 02 00 00       	call   8002b0 <vcprintf>
+  800051:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+  800054:	83 ec 0c             	sub    $0xc,%esp
+  800057:	68 5a 10 80 00       	push   $0x80105a
+  80005c:	e8 78 02 00 00       	call   8002d9 <cprintf>
+  800061:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+    exit(-E_PANIC);
+  800064:	83 ec 0c             	sub    $0xc,%esp
+  800067:	6a f6                	push   $0xfffffff6
+  800069:	e8 49 01 00 00       	call   8001b7 <exit>
+
+0080006e <__warn>:
+}
+
+void
+__warn(const char *file, int line, const char *fmt, ...) {
+  80006e:	55                   	push   %ebp
+  80006f:	89 e5                	mov    %esp,%ebp
+  800071:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    va_start(ap, fmt);
+  800074:	8d 45 14             	lea    0x14(%ebp),%eax
+  800077:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("user warning at %s:%d:\n    ", file, line);
+  80007a:	83 ec 04             	sub    $0x4,%esp
+  80007d:	ff 75 0c             	pushl  0xc(%ebp)
+  800080:	ff 75 08             	pushl  0x8(%ebp)
+  800083:	68 5c 10 80 00       	push   $0x80105c
+  800088:	e8 4c 02 00 00       	call   8002d9 <cprintf>
+  80008d:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+  800090:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800093:	83 ec 08             	sub    $0x8,%esp
+  800096:	50                   	push   %eax
+  800097:	ff 75 10             	pushl  0x10(%ebp)
+  80009a:	e8 11 02 00 00       	call   8002b0 <vcprintf>
+  80009f:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+  8000a2:	83 ec 0c             	sub    $0xc,%esp
+  8000a5:	68 5a 10 80 00       	push   $0x80105a
+  8000aa:	e8 2a 02 00 00       	call   8002d9 <cprintf>
+  8000af:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+  8000b2:	90                   	nop
+  8000b3:	c9                   	leave  
+  8000b4:	c3                   	ret    
+
+008000b5 <syscall>:
+#include <syscall.h>
+
+#define MAX_ARGS            5
+
+static inline int
+syscall(int num, ...) {
+  8000b5:	55                   	push   %ebp
+  8000b6:	89 e5                	mov    %esp,%ebp
+  8000b8:	57                   	push   %edi
+  8000b9:	56                   	push   %esi
+  8000ba:	53                   	push   %ebx
+  8000bb:	83 ec 20             	sub    $0x20,%esp
+    va_list ap;
+    va_start(ap, num);
+  8000be:	8d 45 0c             	lea    0xc(%ebp),%eax
+  8000c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    uint32_t a[MAX_ARGS];
+    int i, ret;
+    for (i = 0; i < MAX_ARGS; i ++) {
+  8000c4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  8000cb:	eb 16                	jmp    8000e3 <syscall+0x2e>
+        a[i] = va_arg(ap, uint32_t);
+  8000cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8000d0:	8d 50 04             	lea    0x4(%eax),%edx
+  8000d3:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  8000d6:	8b 10                	mov    (%eax),%edx
+  8000d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8000db:	89 54 85 d4          	mov    %edx,-0x2c(%ebp,%eax,4)
+syscall(int num, ...) {
+    va_list ap;
+    va_start(ap, num);
+    uint32_t a[MAX_ARGS];
+    int i, ret;
+    for (i = 0; i < MAX_ARGS; i ++) {
+  8000df:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+  8000e3:	83 7d f0 04          	cmpl   $0x4,-0x10(%ebp)
+  8000e7:	7e e4                	jle    8000cd <syscall+0x18>
+    asm volatile (
+        "int %1;"
+        : "=a" (ret)
+        : "i" (T_SYSCALL),
+          "a" (num),
+          "d" (a[0]),
+  8000e9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+          "c" (a[1]),
+  8000ec:	8b 4d d8             	mov    -0x28(%ebp),%ecx
+          "b" (a[2]),
+  8000ef:	8b 5d dc             	mov    -0x24(%ebp),%ebx
+          "D" (a[3]),
+  8000f2:	8b 7d e0             	mov    -0x20(%ebp),%edi
+          "S" (a[4])
+  8000f5:	8b 75 e4             	mov    -0x1c(%ebp),%esi
+    for (i = 0; i < MAX_ARGS; i ++) {
+        a[i] = va_arg(ap, uint32_t);
+    }
+    va_end(ap);
+
+    asm volatile (
+  8000f8:	8b 45 08             	mov    0x8(%ebp),%eax
+  8000fb:	cd 80                	int    $0x80
+  8000fd:	89 45 ec             	mov    %eax,-0x14(%ebp)
+          "c" (a[1]),
+          "b" (a[2]),
+          "D" (a[3]),
+          "S" (a[4])
+        : "cc", "memory");
+    return ret;
+  800100:	8b 45 ec             	mov    -0x14(%ebp),%eax
+}
+  800103:	83 c4 20             	add    $0x20,%esp
+  800106:	5b                   	pop    %ebx
+  800107:	5e                   	pop    %esi
+  800108:	5f                   	pop    %edi
+  800109:	5d                   	pop    %ebp
+  80010a:	c3                   	ret    
+
+0080010b <sys_exit>:
+
+int
+sys_exit(int error_code) {
+  80010b:	55                   	push   %ebp
+  80010c:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_exit, error_code);
+  80010e:	ff 75 08             	pushl  0x8(%ebp)
+  800111:	6a 01                	push   $0x1
+  800113:	e8 9d ff ff ff       	call   8000b5 <syscall>
+  800118:	83 c4 08             	add    $0x8,%esp
+}
+  80011b:	c9                   	leave  
+  80011c:	c3                   	ret    
+
+0080011d <sys_fork>:
+
+int
+sys_fork(void) {
+  80011d:	55                   	push   %ebp
+  80011e:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_fork);
+  800120:	6a 02                	push   $0x2
+  800122:	e8 8e ff ff ff       	call   8000b5 <syscall>
+  800127:	83 c4 04             	add    $0x4,%esp
+}
+  80012a:	c9                   	leave  
+  80012b:	c3                   	ret    
+
+0080012c <sys_wait>:
+
+int
+sys_wait(int pid, int *store) {
+  80012c:	55                   	push   %ebp
+  80012d:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_wait, pid, store);
+  80012f:	ff 75 0c             	pushl  0xc(%ebp)
+  800132:	ff 75 08             	pushl  0x8(%ebp)
+  800135:	6a 03                	push   $0x3
+  800137:	e8 79 ff ff ff       	call   8000b5 <syscall>
+  80013c:	83 c4 0c             	add    $0xc,%esp
+}
+  80013f:	c9                   	leave  
+  800140:	c3                   	ret    
+
+00800141 <sys_yield>:
+
+int
+sys_yield(void) {
+  800141:	55                   	push   %ebp
+  800142:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_yield);
+  800144:	6a 0a                	push   $0xa
+  800146:	e8 6a ff ff ff       	call   8000b5 <syscall>
+  80014b:	83 c4 04             	add    $0x4,%esp
+}
+  80014e:	c9                   	leave  
+  80014f:	c3                   	ret    
+
+00800150 <sys_kill>:
+
+int
+sys_kill(int pid) {
+  800150:	55                   	push   %ebp
+  800151:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_kill, pid);
+  800153:	ff 75 08             	pushl  0x8(%ebp)
+  800156:	6a 0c                	push   $0xc
+  800158:	e8 58 ff ff ff       	call   8000b5 <syscall>
+  80015d:	83 c4 08             	add    $0x8,%esp
+}
+  800160:	c9                   	leave  
+  800161:	c3                   	ret    
+
+00800162 <sys_getpid>:
+
+int
+sys_getpid(void) {
+  800162:	55                   	push   %ebp
+  800163:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_getpid);
+  800165:	6a 12                	push   $0x12
+  800167:	e8 49 ff ff ff       	call   8000b5 <syscall>
+  80016c:	83 c4 04             	add    $0x4,%esp
+}
+  80016f:	c9                   	leave  
+  800170:	c3                   	ret    
+
+00800171 <sys_putc>:
+
+int
+sys_putc(int c) {
+  800171:	55                   	push   %ebp
+  800172:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_putc, c);
+  800174:	ff 75 08             	pushl  0x8(%ebp)
+  800177:	6a 1e                	push   $0x1e
+  800179:	e8 37 ff ff ff       	call   8000b5 <syscall>
+  80017e:	83 c4 08             	add    $0x8,%esp
+}
+  800181:	c9                   	leave  
+  800182:	c3                   	ret    
+
+00800183 <sys_pgdir>:
+
+int
+sys_pgdir(void) {
+  800183:	55                   	push   %ebp
+  800184:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_pgdir);
+  800186:	6a 1f                	push   $0x1f
+  800188:	e8 28 ff ff ff       	call   8000b5 <syscall>
+  80018d:	83 c4 04             	add    $0x4,%esp
+}
+  800190:	c9                   	leave  
+  800191:	c3                   	ret    
+
+00800192 <sys_gettime>:
+
+int
+sys_gettime(void) {
+  800192:	55                   	push   %ebp
+  800193:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_gettime);
+  800195:	6a 11                	push   $0x11
+  800197:	e8 19 ff ff ff       	call   8000b5 <syscall>
+  80019c:	83 c4 04             	add    $0x4,%esp
+}
+  80019f:	c9                   	leave  
+  8001a0:	c3                   	ret    
+
+008001a1 <sys_lab6_set_priority>:
+
+void
+sys_lab6_set_priority(uint32_t priority)
+{
+  8001a1:	55                   	push   %ebp
+  8001a2:	89 e5                	mov    %esp,%ebp
+    syscall(SYS_lab6_set_priority, priority);
+  8001a4:	ff 75 08             	pushl  0x8(%ebp)
+  8001a7:	68 ff 00 00 00       	push   $0xff
+  8001ac:	e8 04 ff ff ff       	call   8000b5 <syscall>
+  8001b1:	83 c4 08             	add    $0x8,%esp
+}
+  8001b4:	90                   	nop
+  8001b5:	c9                   	leave  
+  8001b6:	c3                   	ret    
+
+008001b7 <exit>:
+#include <syscall.h>
+#include <stdio.h>
+#include <ulib.h>
+
+void
+exit(int error_code) {
+  8001b7:	55                   	push   %ebp
+  8001b8:	89 e5                	mov    %esp,%ebp
+  8001ba:	83 ec 08             	sub    $0x8,%esp
+    sys_exit(error_code);
+  8001bd:	83 ec 0c             	sub    $0xc,%esp
+  8001c0:	ff 75 08             	pushl  0x8(%ebp)
+  8001c3:	e8 43 ff ff ff       	call   80010b <sys_exit>
+  8001c8:	83 c4 10             	add    $0x10,%esp
+    cprintf("BUG: exit failed.\n");
+  8001cb:	83 ec 0c             	sub    $0xc,%esp
+  8001ce:	68 78 10 80 00       	push   $0x801078
+  8001d3:	e8 01 01 00 00       	call   8002d9 <cprintf>
+  8001d8:	83 c4 10             	add    $0x10,%esp
+    while (1);
+  8001db:	eb fe                	jmp    8001db <exit+0x24>
+
+008001dd <fork>:
+}
+
+int
+fork(void) {
+  8001dd:	55                   	push   %ebp
+  8001de:	89 e5                	mov    %esp,%ebp
+  8001e0:	83 ec 08             	sub    $0x8,%esp
+    return sys_fork();
+  8001e3:	e8 35 ff ff ff       	call   80011d <sys_fork>
+}
+  8001e8:	c9                   	leave  
+  8001e9:	c3                   	ret    
+
+008001ea <wait>:
+
+int
+wait(void) {
+  8001ea:	55                   	push   %ebp
+  8001eb:	89 e5                	mov    %esp,%ebp
+  8001ed:	83 ec 08             	sub    $0x8,%esp
+    return sys_wait(0, NULL);
+  8001f0:	83 ec 08             	sub    $0x8,%esp
+  8001f3:	6a 00                	push   $0x0
+  8001f5:	6a 00                	push   $0x0
+  8001f7:	e8 30 ff ff ff       	call   80012c <sys_wait>
+  8001fc:	83 c4 10             	add    $0x10,%esp
+}
+  8001ff:	c9                   	leave  
+  800200:	c3                   	ret    
+
+00800201 <waitpid>:
+
+int
+waitpid(int pid, int *store) {
+  800201:	55                   	push   %ebp
+  800202:	89 e5                	mov    %esp,%ebp
+  800204:	83 ec 08             	sub    $0x8,%esp
+    return sys_wait(pid, store);
+  800207:	83 ec 08             	sub    $0x8,%esp
+  80020a:	ff 75 0c             	pushl  0xc(%ebp)
+  80020d:	ff 75 08             	pushl  0x8(%ebp)
+  800210:	e8 17 ff ff ff       	call   80012c <sys_wait>
+  800215:	83 c4 10             	add    $0x10,%esp
+}
+  800218:	c9                   	leave  
+  800219:	c3                   	ret    
+
+0080021a <yield>:
+
+void
+yield(void) {
+  80021a:	55                   	push   %ebp
+  80021b:	89 e5                	mov    %esp,%ebp
+  80021d:	83 ec 08             	sub    $0x8,%esp
+    sys_yield();
+  800220:	e8 1c ff ff ff       	call   800141 <sys_yield>
+}
+  800225:	90                   	nop
+  800226:	c9                   	leave  
+  800227:	c3                   	ret    
+
+00800228 <kill>:
+
+int
+kill(int pid) {
+  800228:	55                   	push   %ebp
+  800229:	89 e5                	mov    %esp,%ebp
+  80022b:	83 ec 08             	sub    $0x8,%esp
+    return sys_kill(pid);
+  80022e:	83 ec 0c             	sub    $0xc,%esp
+  800231:	ff 75 08             	pushl  0x8(%ebp)
+  800234:	e8 17 ff ff ff       	call   800150 <sys_kill>
+  800239:	83 c4 10             	add    $0x10,%esp
+}
+  80023c:	c9                   	leave  
+  80023d:	c3                   	ret    
+
+0080023e <getpid>:
+
+int
+getpid(void) {
+  80023e:	55                   	push   %ebp
+  80023f:	89 e5                	mov    %esp,%ebp
+  800241:	83 ec 08             	sub    $0x8,%esp
+    return sys_getpid();
+  800244:	e8 19 ff ff ff       	call   800162 <sys_getpid>
+}
+  800249:	c9                   	leave  
+  80024a:	c3                   	ret    
+
+0080024b <print_pgdir>:
+
+//print_pgdir - print the PDT&PT
+void
+print_pgdir(void) {
+  80024b:	55                   	push   %ebp
+  80024c:	89 e5                	mov    %esp,%ebp
+  80024e:	83 ec 08             	sub    $0x8,%esp
+    sys_pgdir();
+  800251:	e8 2d ff ff ff       	call   800183 <sys_pgdir>
+}
+  800256:	90                   	nop
+  800257:	c9                   	leave  
+  800258:	c3                   	ret    
+
+00800259 <gettime_msec>:
+
+unsigned int
+gettime_msec(void) {
+  800259:	55                   	push   %ebp
+  80025a:	89 e5                	mov    %esp,%ebp
+  80025c:	83 ec 08             	sub    $0x8,%esp
+    return (unsigned int)sys_gettime();
+  80025f:	e8 2e ff ff ff       	call   800192 <sys_gettime>
+}
+  800264:	c9                   	leave  
+  800265:	c3                   	ret    
+
+00800266 <lab6_set_priority>:
+
+void
+lab6_set_priority(uint32_t priority)
+{
+  800266:	55                   	push   %ebp
+  800267:	89 e5                	mov    %esp,%ebp
+  800269:	83 ec 08             	sub    $0x8,%esp
+    sys_lab6_set_priority(priority);
+  80026c:	83 ec 0c             	sub    $0xc,%esp
+  80026f:	ff 75 08             	pushl  0x8(%ebp)
+  800272:	e8 2a ff ff ff       	call   8001a1 <sys_lab6_set_priority>
+  800277:	83 c4 10             	add    $0x10,%esp
+}
+  80027a:	90                   	nop
+  80027b:	c9                   	leave  
+  80027c:	c3                   	ret    
+
+0080027d <_start>:
+.text
+.globl _start
+_start:
+    # set ebp for backtrace
+    movl $0x0, %ebp
+  80027d:	bd 00 00 00 00       	mov    $0x0,%ebp
+
+    # move down the esp register
+    # since it may cause page fault in backtrace
+    subl $0x20, %esp
+  800282:	83 ec 20             	sub    $0x20,%esp
+
+    # call user-program function
+    call umain
+  800285:	e8 c3 00 00 00       	call   80034d <umain>
+1:  jmp 1b
+  80028a:	eb fe                	jmp    80028a <_start+0xd>
+
+0080028c <cputch>:
+/* *
+ * cputch - writes a single character @c to stdout, and it will
+ * increace the value of counter pointed by @cnt.
+ * */
+static void
+cputch(int c, int *cnt) {
+  80028c:	55                   	push   %ebp
+  80028d:	89 e5                	mov    %esp,%ebp
+  80028f:	83 ec 08             	sub    $0x8,%esp
+    sys_putc(c);
+  800292:	83 ec 0c             	sub    $0xc,%esp
+  800295:	ff 75 08             	pushl  0x8(%ebp)
+  800298:	e8 d4 fe ff ff       	call   800171 <sys_putc>
+  80029d:	83 c4 10             	add    $0x10,%esp
+    (*cnt) ++;
+  8002a0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002a3:	8b 00                	mov    (%eax),%eax
+  8002a5:	8d 50 01             	lea    0x1(%eax),%edx
+  8002a8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002ab:	89 10                	mov    %edx,(%eax)
+}
+  8002ad:	90                   	nop
+  8002ae:	c9                   	leave  
+  8002af:	c3                   	ret    
+
+008002b0 <vcprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want cprintf() instead.
+ * */
+int
+vcprintf(const char *fmt, va_list ap) {
+  8002b0:	55                   	push   %ebp
+  8002b1:	89 e5                	mov    %esp,%ebp
+  8002b3:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+  8002b6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    vprintfmt((void*)cputch, &cnt, fmt, ap);
+  8002bd:	ff 75 0c             	pushl  0xc(%ebp)
+  8002c0:	ff 75 08             	pushl  0x8(%ebp)
+  8002c3:	8d 45 f4             	lea    -0xc(%ebp),%eax
+  8002c6:	50                   	push   %eax
+  8002c7:	68 8c 02 80 00       	push   $0x80028c
+  8002cc:	e8 fc 06 00 00       	call   8009cd <vprintfmt>
+  8002d1:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+  8002d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8002d7:	c9                   	leave  
+  8002d8:	c3                   	ret    
+
+008002d9 <cprintf>:
+ *
+ * The return value is the number of characters which would be
+ * written to stdout.
+ * */
+int
+cprintf(const char *fmt, ...) {
+  8002d9:	55                   	push   %ebp
+  8002da:	89 e5                	mov    %esp,%ebp
+  8002dc:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  8002df:	8d 45 0c             	lea    0xc(%ebp),%eax
+  8002e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    int cnt = vcprintf(fmt, ap);
+  8002e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8002e8:	83 ec 08             	sub    $0x8,%esp
+  8002eb:	50                   	push   %eax
+  8002ec:	ff 75 08             	pushl  0x8(%ebp)
+  8002ef:	e8 bc ff ff ff       	call   8002b0 <vcprintf>
+  8002f4:	83 c4 10             	add    $0x10,%esp
+  8002f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+
+    return cnt;
+  8002fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8002fd:	c9                   	leave  
+  8002fe:	c3                   	ret    
+
+008002ff <cputs>:
+/* *
+ * cputs- writes the string pointed by @str to stdout and
+ * appends a newline character.
+ * */
+int
+cputs(const char *str) {
+  8002ff:	55                   	push   %ebp
+  800300:	89 e5                	mov    %esp,%ebp
+  800302:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+  800305:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    char c;
+    while ((c = *str ++) != '\0') {
+  80030c:	eb 14                	jmp    800322 <cputs+0x23>
+        cputch(c, &cnt);
+  80030e:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
+  800312:	83 ec 08             	sub    $0x8,%esp
+  800315:	8d 55 f0             	lea    -0x10(%ebp),%edx
+  800318:	52                   	push   %edx
+  800319:	50                   	push   %eax
+  80031a:	e8 6d ff ff ff       	call   80028c <cputch>
+  80031f:	83 c4 10             	add    $0x10,%esp
+ * */
+int
+cputs(const char *str) {
+    int cnt = 0;
+    char c;
+    while ((c = *str ++) != '\0') {
+  800322:	8b 45 08             	mov    0x8(%ebp),%eax
+  800325:	8d 50 01             	lea    0x1(%eax),%edx
+  800328:	89 55 08             	mov    %edx,0x8(%ebp)
+  80032b:	0f b6 00             	movzbl (%eax),%eax
+  80032e:	88 45 f7             	mov    %al,-0x9(%ebp)
+  800331:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
+  800335:	75 d7                	jne    80030e <cputs+0xf>
+        cputch(c, &cnt);
+    }
+    cputch('\n', &cnt);
+  800337:	83 ec 08             	sub    $0x8,%esp
+  80033a:	8d 45 f0             	lea    -0x10(%ebp),%eax
+  80033d:	50                   	push   %eax
+  80033e:	6a 0a                	push   $0xa
+  800340:	e8 47 ff ff ff       	call   80028c <cputch>
+  800345:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+  800348:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+  80034b:	c9                   	leave  
+  80034c:	c3                   	ret    
+
+0080034d <umain>:
+#include <ulib.h>
+
+int main(void);
+
+void
+umain(void) {
+  80034d:	55                   	push   %ebp
+  80034e:	89 e5                	mov    %esp,%ebp
+  800350:	83 ec 18             	sub    $0x18,%esp
+    int ret = main();
+  800353:	e8 d3 0b 00 00       	call   800f2b <main>
+  800358:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    exit(ret);
+  80035b:	83 ec 0c             	sub    $0xc,%esp
+  80035e:	ff 75 f4             	pushl  -0xc(%ebp)
+  800361:	e8 51 fe ff ff       	call   8001b7 <exit>
+
+00800366 <strlen>:
+ * @s:      the input string
+ *
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+  800366:	55                   	push   %ebp
+  800367:	89 e5                	mov    %esp,%ebp
+  800369:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  80036c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (*s ++ != '\0') {
+  800373:	eb 04                	jmp    800379 <strlen+0x13>
+        cnt ++;
+  800375:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+    size_t cnt = 0;
+    while (*s ++ != '\0') {
+  800379:	8b 45 08             	mov    0x8(%ebp),%eax
+  80037c:	8d 50 01             	lea    0x1(%eax),%edx
+  80037f:	89 55 08             	mov    %edx,0x8(%ebp)
+  800382:	0f b6 00             	movzbl (%eax),%eax
+  800385:	84 c0                	test   %al,%al
+  800387:	75 ec                	jne    800375 <strlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  800389:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  80038c:	c9                   	leave  
+  80038d:	c3                   	ret    
+
+0080038e <strnlen>:
+ * The return value is strlen(s), if that is less than @len, or
+ * @len if there is no '\0' character among the first @len characters
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+  80038e:	55                   	push   %ebp
+  80038f:	89 e5                	mov    %esp,%ebp
+  800391:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  800394:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (cnt < len && *s ++ != '\0') {
+  80039b:	eb 04                	jmp    8003a1 <strnlen+0x13>
+        cnt ++;
+  80039d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+    size_t cnt = 0;
+    while (cnt < len && *s ++ != '\0') {
+  8003a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8003a4:	3b 45 0c             	cmp    0xc(%ebp),%eax
+  8003a7:	73 10                	jae    8003b9 <strnlen+0x2b>
+  8003a9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003ac:	8d 50 01             	lea    0x1(%eax),%edx
+  8003af:	89 55 08             	mov    %edx,0x8(%ebp)
+  8003b2:	0f b6 00             	movzbl (%eax),%eax
+  8003b5:	84 c0                	test   %al,%al
+  8003b7:	75 e4                	jne    80039d <strnlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  8003b9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  8003bc:	c9                   	leave  
+  8003bd:	c3                   	ret    
+
+008003be <strcpy>:
+ * To avoid overflows, the size of array pointed by @dst should be long enough to
+ * contain the same string as @src (including the terminating null character), and
+ * should not overlap in memory with @src.
+ * */
+char *
+strcpy(char *dst, const char *src) {
+  8003be:	55                   	push   %ebp
+  8003bf:	89 e5                	mov    %esp,%ebp
+  8003c1:	57                   	push   %edi
+  8003c2:	56                   	push   %esi
+  8003c3:	83 ec 20             	sub    $0x20,%esp
+  8003c6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  8003cc:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8003cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCPY
+#define __HAVE_ARCH_STRCPY
+static inline char *
+__strcpy(char *dst, const char *src) {
+    int d0, d1, d2;
+    asm volatile (
+  8003d2:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  8003d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8003d8:	89 d1                	mov    %edx,%ecx
+  8003da:	89 c2                	mov    %eax,%edx
+  8003dc:	89 ce                	mov    %ecx,%esi
+  8003de:	89 d7                	mov    %edx,%edi
+  8003e0:	ac                   	lods   %ds:(%esi),%al
+  8003e1:	aa                   	stos   %al,%es:(%edi)
+  8003e2:	84 c0                	test   %al,%al
+  8003e4:	75 fa                	jne    8003e0 <strcpy+0x22>
+  8003e6:	89 fa                	mov    %edi,%edx
+  8003e8:	89 f1                	mov    %esi,%ecx
+  8003ea:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  8003ed:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  8003f0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+        "stosb;"
+        "testb %%al, %%al;"
+        "jne 1b;"
+        : "=&S" (d0), "=&D" (d1), "=&a" (d2)
+        : "0" (src), "1" (dst) : "memory");
+    return dst;
+  8003f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCPY
+    return __strcpy(dst, src);
+  8003f6:	90                   	nop
+    char *p = dst;
+    while ((*p ++ = *src ++) != '\0')
+        /* nothing */;
+    return dst;
+#endif /* __HAVE_ARCH_STRCPY */
+}
+  8003f7:	83 c4 20             	add    $0x20,%esp
+  8003fa:	5e                   	pop    %esi
+  8003fb:	5f                   	pop    %edi
+  8003fc:	5d                   	pop    %ebp
+  8003fd:	c3                   	ret    
+
+008003fe <strncpy>:
+ * @len:    maximum number of characters to be copied from @src
+ *
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+  8003fe:	55                   	push   %ebp
+  8003ff:	89 e5                	mov    %esp,%ebp
+  800401:	83 ec 10             	sub    $0x10,%esp
+    char *p = dst;
+  800404:	8b 45 08             	mov    0x8(%ebp),%eax
+  800407:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    while (len > 0) {
+  80040a:	eb 21                	jmp    80042d <strncpy+0x2f>
+        if ((*p = *src) != '\0') {
+  80040c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80040f:	0f b6 10             	movzbl (%eax),%edx
+  800412:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800415:	88 10                	mov    %dl,(%eax)
+  800417:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  80041a:	0f b6 00             	movzbl (%eax),%eax
+  80041d:	84 c0                	test   %al,%al
+  80041f:	74 04                	je     800425 <strncpy+0x27>
+            src ++;
+  800421:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+        }
+        p ++, len --;
+  800425:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800429:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+    char *p = dst;
+    while (len > 0) {
+  80042d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800431:	75 d9                	jne    80040c <strncpy+0xe>
+        if ((*p = *src) != '\0') {
+            src ++;
+        }
+        p ++, len --;
+    }
+    return dst;
+  800433:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800436:	c9                   	leave  
+  800437:	c3                   	ret    
+
+00800438 <strcmp>:
+ * - A value greater than zero indicates that the first character that does
+ *   not match has a greater value in @s1 than in @s2;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+strcmp(const char *s1, const char *s2) {
+  800438:	55                   	push   %ebp
+  800439:	89 e5                	mov    %esp,%ebp
+  80043b:	57                   	push   %edi
+  80043c:	56                   	push   %esi
+  80043d:	83 ec 20             	sub    $0x20,%esp
+  800440:	8b 45 08             	mov    0x8(%ebp),%eax
+  800443:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800446:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800449:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCMP
+#define __HAVE_ARCH_STRCMP
+static inline int
+__strcmp(const char *s1, const char *s2) {
+    int d0, d1, ret;
+    asm volatile (
+  80044c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80044f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800452:	89 d1                	mov    %edx,%ecx
+  800454:	89 c2                	mov    %eax,%edx
+  800456:	89 ce                	mov    %ecx,%esi
+  800458:	89 d7                	mov    %edx,%edi
+  80045a:	ac                   	lods   %ds:(%esi),%al
+  80045b:	ae                   	scas   %es:(%edi),%al
+  80045c:	75 08                	jne    800466 <strcmp+0x2e>
+  80045e:	84 c0                	test   %al,%al
+  800460:	75 f8                	jne    80045a <strcmp+0x22>
+  800462:	31 c0                	xor    %eax,%eax
+  800464:	eb 04                	jmp    80046a <strcmp+0x32>
+  800466:	19 c0                	sbb    %eax,%eax
+  800468:	0c 01                	or     $0x1,%al
+  80046a:	89 fa                	mov    %edi,%edx
+  80046c:	89 f1                	mov    %esi,%ecx
+  80046e:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800471:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  800474:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+        "orb $1, %%al;"
+        "3:"
+        : "=a" (ret), "=&S" (d0), "=&D" (d1)
+        : "1" (s1), "2" (s2)
+        : "memory");
+    return ret;
+  800477:	8b 45 ec             	mov    -0x14(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCMP
+    return __strcmp(s1, s2);
+  80047a:	90                   	nop
+    while (*s1 != '\0' && *s1 == *s2) {
+        s1 ++, s2 ++;
+    }
+    return (int)((unsigned char)*s1 - (unsigned char)*s2);
+#endif /* __HAVE_ARCH_STRCMP */
+}
+  80047b:	83 c4 20             	add    $0x20,%esp
+  80047e:	5e                   	pop    %esi
+  80047f:	5f                   	pop    %edi
+  800480:	5d                   	pop    %ebp
+  800481:	c3                   	ret    
+
+00800482 <strncmp>:
+ * they are equal to each other, it continues with the following pairs until
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+  800482:	55                   	push   %ebp
+  800483:	89 e5                	mov    %esp,%ebp
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  800485:	eb 0c                	jmp    800493 <strncmp+0x11>
+        n --, s1 ++, s2 ++;
+  800487:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  80048b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  80048f:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  800493:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800497:	74 1a                	je     8004b3 <strncmp+0x31>
+  800499:	8b 45 08             	mov    0x8(%ebp),%eax
+  80049c:	0f b6 00             	movzbl (%eax),%eax
+  80049f:	84 c0                	test   %al,%al
+  8004a1:	74 10                	je     8004b3 <strncmp+0x31>
+  8004a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004a6:	0f b6 10             	movzbl (%eax),%edx
+  8004a9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004ac:	0f b6 00             	movzbl (%eax),%eax
+  8004af:	38 c2                	cmp    %al,%dl
+  8004b1:	74 d4                	je     800487 <strncmp+0x5>
+        n --, s1 ++, s2 ++;
+    }
+    return (n == 0) ? 0 : (int)((unsigned char)*s1 - (unsigned char)*s2);
+  8004b3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8004b7:	74 18                	je     8004d1 <strncmp+0x4f>
+  8004b9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004bc:	0f b6 00             	movzbl (%eax),%eax
+  8004bf:	0f b6 d0             	movzbl %al,%edx
+  8004c2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004c5:	0f b6 00             	movzbl (%eax),%eax
+  8004c8:	0f b6 c0             	movzbl %al,%eax
+  8004cb:	29 c2                	sub    %eax,%edx
+  8004cd:	89 d0                	mov    %edx,%eax
+  8004cf:	eb 05                	jmp    8004d6 <strncmp+0x54>
+  8004d1:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  8004d6:	5d                   	pop    %ebp
+  8004d7:	c3                   	ret    
+
+008004d8 <strchr>:
+ *
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+  8004d8:	55                   	push   %ebp
+  8004d9:	89 e5                	mov    %esp,%ebp
+  8004db:	83 ec 04             	sub    $0x4,%esp
+  8004de:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004e1:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  8004e4:	eb 14                	jmp    8004fa <strchr+0x22>
+        if (*s == c) {
+  8004e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004e9:	0f b6 00             	movzbl (%eax),%eax
+  8004ec:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  8004ef:	75 05                	jne    8004f6 <strchr+0x1e>
+            return (char *)s;
+  8004f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004f4:	eb 13                	jmp    800509 <strchr+0x31>
+        }
+        s ++;
+  8004f6:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+    while (*s != '\0') {
+  8004fa:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004fd:	0f b6 00             	movzbl (%eax),%eax
+  800500:	84 c0                	test   %al,%al
+  800502:	75 e2                	jne    8004e6 <strchr+0xe>
+        if (*s == c) {
+            return (char *)s;
+        }
+        s ++;
+    }
+    return NULL;
+  800504:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800509:	c9                   	leave  
+  80050a:	c3                   	ret    
+
+0080050b <strfind>:
+ * The strfind() function is like strchr() except that if @c is
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+  80050b:	55                   	push   %ebp
+  80050c:	89 e5                	mov    %esp,%ebp
+  80050e:	83 ec 04             	sub    $0x4,%esp
+  800511:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800514:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  800517:	eb 0f                	jmp    800528 <strfind+0x1d>
+        if (*s == c) {
+  800519:	8b 45 08             	mov    0x8(%ebp),%eax
+  80051c:	0f b6 00             	movzbl (%eax),%eax
+  80051f:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800522:	74 10                	je     800534 <strfind+0x29>
+            break;
+        }
+        s ++;
+  800524:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+    while (*s != '\0') {
+  800528:	8b 45 08             	mov    0x8(%ebp),%eax
+  80052b:	0f b6 00             	movzbl (%eax),%eax
+  80052e:	84 c0                	test   %al,%al
+  800530:	75 e7                	jne    800519 <strfind+0xe>
+  800532:	eb 01                	jmp    800535 <strfind+0x2a>
+        if (*s == c) {
+            break;
+  800534:	90                   	nop
+        }
+        s ++;
+    }
+    return (char *)s;
+  800535:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800538:	c9                   	leave  
+  800539:	c3                   	ret    
+
+0080053a <strtol>:
+ * an optional "0x" or "0X" prefix.
+ *
+ * The strtol() function returns the converted integral number as a long int value.
+ * */
+long
+strtol(const char *s, char **endptr, int base) {
+  80053a:	55                   	push   %ebp
+  80053b:	89 e5                	mov    %esp,%ebp
+  80053d:	83 ec 10             	sub    $0x10,%esp
+    int neg = 0;
+  800540:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    long val = 0;
+  800547:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  80054e:	eb 04                	jmp    800554 <strtol+0x1a>
+        s ++;
+  800550:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+strtol(const char *s, char **endptr, int base) {
+    int neg = 0;
+    long val = 0;
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  800554:	8b 45 08             	mov    0x8(%ebp),%eax
+  800557:	0f b6 00             	movzbl (%eax),%eax
+  80055a:	3c 20                	cmp    $0x20,%al
+  80055c:	74 f2                	je     800550 <strtol+0x16>
+  80055e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800561:	0f b6 00             	movzbl (%eax),%eax
+  800564:	3c 09                	cmp    $0x9,%al
+  800566:	74 e8                	je     800550 <strtol+0x16>
+        s ++;
+    }
+
+    // plus/minus sign
+    if (*s == '+') {
+  800568:	8b 45 08             	mov    0x8(%ebp),%eax
+  80056b:	0f b6 00             	movzbl (%eax),%eax
+  80056e:	3c 2b                	cmp    $0x2b,%al
+  800570:	75 06                	jne    800578 <strtol+0x3e>
+        s ++;
+  800572:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800576:	eb 15                	jmp    80058d <strtol+0x53>
+    }
+    else if (*s == '-') {
+  800578:	8b 45 08             	mov    0x8(%ebp),%eax
+  80057b:	0f b6 00             	movzbl (%eax),%eax
+  80057e:	3c 2d                	cmp    $0x2d,%al
+  800580:	75 0b                	jne    80058d <strtol+0x53>
+        s ++, neg = 1;
+  800582:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800586:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+    }
+
+    // hex or octal base prefix
+    if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x')) {
+  80058d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800591:	74 06                	je     800599 <strtol+0x5f>
+  800593:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+  800597:	75 24                	jne    8005bd <strtol+0x83>
+  800599:	8b 45 08             	mov    0x8(%ebp),%eax
+  80059c:	0f b6 00             	movzbl (%eax),%eax
+  80059f:	3c 30                	cmp    $0x30,%al
+  8005a1:	75 1a                	jne    8005bd <strtol+0x83>
+  8005a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005a6:	83 c0 01             	add    $0x1,%eax
+  8005a9:	0f b6 00             	movzbl (%eax),%eax
+  8005ac:	3c 78                	cmp    $0x78,%al
+  8005ae:	75 0d                	jne    8005bd <strtol+0x83>
+        s += 2, base = 16;
+  8005b0:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+  8005b4:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+  8005bb:	eb 2a                	jmp    8005e7 <strtol+0xad>
+    }
+    else if (base == 0 && s[0] == '0') {
+  8005bd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8005c1:	75 17                	jne    8005da <strtol+0xa0>
+  8005c3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005c6:	0f b6 00             	movzbl (%eax),%eax
+  8005c9:	3c 30                	cmp    $0x30,%al
+  8005cb:	75 0d                	jne    8005da <strtol+0xa0>
+        s ++, base = 8;
+  8005cd:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  8005d1:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+  8005d8:	eb 0d                	jmp    8005e7 <strtol+0xad>
+    }
+    else if (base == 0) {
+  8005da:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8005de:	75 07                	jne    8005e7 <strtol+0xad>
+        base = 10;
+  8005e0:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+    // digits
+    while (1) {
+        int dig;
+
+        if (*s >= '0' && *s <= '9') {
+  8005e7:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005ea:	0f b6 00             	movzbl (%eax),%eax
+  8005ed:	3c 2f                	cmp    $0x2f,%al
+  8005ef:	7e 1b                	jle    80060c <strtol+0xd2>
+  8005f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005f4:	0f b6 00             	movzbl (%eax),%eax
+  8005f7:	3c 39                	cmp    $0x39,%al
+  8005f9:	7f 11                	jg     80060c <strtol+0xd2>
+            dig = *s - '0';
+  8005fb:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005fe:	0f b6 00             	movzbl (%eax),%eax
+  800601:	0f be c0             	movsbl %al,%eax
+  800604:	83 e8 30             	sub    $0x30,%eax
+  800607:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80060a:	eb 48                	jmp    800654 <strtol+0x11a>
+        }
+        else if (*s >= 'a' && *s <= 'z') {
+  80060c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80060f:	0f b6 00             	movzbl (%eax),%eax
+  800612:	3c 60                	cmp    $0x60,%al
+  800614:	7e 1b                	jle    800631 <strtol+0xf7>
+  800616:	8b 45 08             	mov    0x8(%ebp),%eax
+  800619:	0f b6 00             	movzbl (%eax),%eax
+  80061c:	3c 7a                	cmp    $0x7a,%al
+  80061e:	7f 11                	jg     800631 <strtol+0xf7>
+            dig = *s - 'a' + 10;
+  800620:	8b 45 08             	mov    0x8(%ebp),%eax
+  800623:	0f b6 00             	movzbl (%eax),%eax
+  800626:	0f be c0             	movsbl %al,%eax
+  800629:	83 e8 57             	sub    $0x57,%eax
+  80062c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80062f:	eb 23                	jmp    800654 <strtol+0x11a>
+        }
+        else if (*s >= 'A' && *s <= 'Z') {
+  800631:	8b 45 08             	mov    0x8(%ebp),%eax
+  800634:	0f b6 00             	movzbl (%eax),%eax
+  800637:	3c 40                	cmp    $0x40,%al
+  800639:	7e 3c                	jle    800677 <strtol+0x13d>
+  80063b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80063e:	0f b6 00             	movzbl (%eax),%eax
+  800641:	3c 5a                	cmp    $0x5a,%al
+  800643:	7f 32                	jg     800677 <strtol+0x13d>
+            dig = *s - 'A' + 10;
+  800645:	8b 45 08             	mov    0x8(%ebp),%eax
+  800648:	0f b6 00             	movzbl (%eax),%eax
+  80064b:	0f be c0             	movsbl %al,%eax
+  80064e:	83 e8 37             	sub    $0x37,%eax
+  800651:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+  800654:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800657:	3b 45 10             	cmp    0x10(%ebp),%eax
+  80065a:	7d 1a                	jge    800676 <strtol+0x13c>
+            break;
+        }
+        s ++, val = (val * base) + dig;
+  80065c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800660:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800663:	0f af 45 10          	imul   0x10(%ebp),%eax
+  800667:	89 c2                	mov    %eax,%edx
+  800669:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  80066c:	01 d0                	add    %edx,%eax
+  80066e:	89 45 f8             	mov    %eax,-0x8(%ebp)
+        // we don't properly detect overflow!
+    }
+  800671:	e9 71 ff ff ff       	jmp    8005e7 <strtol+0xad>
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+            break;
+  800676:	90                   	nop
+        }
+        s ++, val = (val * base) + dig;
+        // we don't properly detect overflow!
+    }
+
+    if (endptr) {
+  800677:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  80067b:	74 08                	je     800685 <strtol+0x14b>
+        *endptr = (char *) s;
+  80067d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800680:	8b 55 08             	mov    0x8(%ebp),%edx
+  800683:	89 10                	mov    %edx,(%eax)
+    }
+    return (neg ? -val : val);
+  800685:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+  800689:	74 07                	je     800692 <strtol+0x158>
+  80068b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  80068e:	f7 d8                	neg    %eax
+  800690:	eb 03                	jmp    800695 <strtol+0x15b>
+  800692:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  800695:	c9                   	leave  
+  800696:	c3                   	ret    
+
+00800697 <memset>:
+ * @n:      number of bytes to be set to the value
+ *
+ * The memset() function returns @s.
+ * */
+void *
+memset(void *s, char c, size_t n) {
+  800697:	55                   	push   %ebp
+  800698:	89 e5                	mov    %esp,%ebp
+  80069a:	57                   	push   %edi
+  80069b:	83 ec 24             	sub    $0x24,%esp
+  80069e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006a1:	88 45 d8             	mov    %al,-0x28(%ebp)
+#ifdef __HAVE_ARCH_MEMSET
+    return __memset(s, c, n);
+  8006a4:	0f be 45 d8          	movsbl -0x28(%ebp),%eax
+  8006a8:	8b 55 08             	mov    0x8(%ebp),%edx
+  8006ab:	89 55 f8             	mov    %edx,-0x8(%ebp)
+  8006ae:	88 45 f7             	mov    %al,-0x9(%ebp)
+  8006b1:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_MEMSET
+#define __HAVE_ARCH_MEMSET
+static inline void *
+__memset(void *s, char c, size_t n) {
+    int d0, d1;
+    asm volatile (
+  8006b7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+  8006ba:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
+  8006be:	8b 55 f8             	mov    -0x8(%ebp),%edx
+  8006c1:	89 d7                	mov    %edx,%edi
+  8006c3:	f3 aa                	rep stos %al,%es:(%edi)
+  8006c5:	89 fa                	mov    %edi,%edx
+  8006c7:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  8006ca:	89 55 e8             	mov    %edx,-0x18(%ebp)
+        "rep; stosb;"
+        : "=&c" (d0), "=&D" (d1)
+        : "0" (n), "a" (c), "1" (s)
+        : "memory");
+    return s;
+  8006cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8006d0:	90                   	nop
+    while (n -- > 0) {
+        *p ++ = c;
+    }
+    return s;
+#endif /* __HAVE_ARCH_MEMSET */
+}
+  8006d1:	83 c4 24             	add    $0x24,%esp
+  8006d4:	5f                   	pop    %edi
+  8006d5:	5d                   	pop    %ebp
+  8006d6:	c3                   	ret    
+
+008006d7 <memmove>:
+ * @n:      number of bytes to copy
+ *
+ * The memmove() function returns @dst.
+ * */
+void *
+memmove(void *dst, const void *src, size_t n) {
+  8006d7:	55                   	push   %ebp
+  8006d8:	89 e5                	mov    %esp,%ebp
+  8006da:	57                   	push   %edi
+  8006db:	56                   	push   %esi
+  8006dc:	53                   	push   %ebx
+  8006dd:	83 ec 30             	sub    $0x30,%esp
+  8006e0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8006e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8006e6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  8006ec:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006ef:	89 45 e8             	mov    %eax,-0x18(%ebp)
+
+#ifndef __HAVE_ARCH_MEMMOVE
+#define __HAVE_ARCH_MEMMOVE
+static inline void *
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+  8006f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006f5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  8006f8:	73 42                	jae    80073c <memmove+0x65>
+  8006fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006fd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800700:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800703:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800706:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800709:	89 45 dc             	mov    %eax,-0x24(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  80070c:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  80070f:	c1 e8 02             	shr    $0x2,%eax
+  800712:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  800714:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800717:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80071a:	89 d7                	mov    %edx,%edi
+  80071c:	89 c6                	mov    %eax,%esi
+  80071e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800720:	8b 4d dc             	mov    -0x24(%ebp),%ecx
+  800723:	83 e1 03             	and    $0x3,%ecx
+  800726:	74 02                	je     80072a <memmove+0x53>
+  800728:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  80072a:	89 f0                	mov    %esi,%eax
+  80072c:	89 fa                	mov    %edi,%edx
+  80072e:	89 4d d8             	mov    %ecx,-0x28(%ebp)
+  800731:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  800734:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  800737:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMMOVE
+    return __memmove(dst, src, n);
+  80073a:	eb 36                	jmp    800772 <memmove+0x9b>
+    asm volatile (
+        "std;"
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+  80073c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80073f:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800742:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800745:	01 c2                	add    %eax,%edx
+  800747:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80074a:	8d 48 ff             	lea    -0x1(%eax),%ecx
+  80074d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800750:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+        return __memcpy(dst, src, n);
+    }
+    int d0, d1, d2;
+    asm volatile (
+  800753:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800756:	89 c1                	mov    %eax,%ecx
+  800758:	89 d8                	mov    %ebx,%eax
+  80075a:	89 d6                	mov    %edx,%esi
+  80075c:	89 c7                	mov    %eax,%edi
+  80075e:	fd                   	std    
+  80075f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  800761:	fc                   	cld    
+  800762:	89 f8                	mov    %edi,%eax
+  800764:	89 f2                	mov    %esi,%edx
+  800766:	89 4d cc             	mov    %ecx,-0x34(%ebp)
+  800769:	89 55 c8             	mov    %edx,-0x38(%ebp)
+  80076c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+        : "memory");
+    return dst;
+  80076f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+            *d ++ = *s ++;
+        }
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMMOVE */
+}
+  800772:	83 c4 30             	add    $0x30,%esp
+  800775:	5b                   	pop    %ebx
+  800776:	5e                   	pop    %esi
+  800777:	5f                   	pop    %edi
+  800778:	5d                   	pop    %ebp
+  800779:	c3                   	ret    
+
+0080077a <memcpy>:
+ * it always copies exactly @n bytes. To avoid overflows, the size of arrays pointed
+ * by both @src and @dst, should be at least @n bytes, and should not overlap
+ * (for overlapping memory area, memmove is a safer approach).
+ * */
+void *
+memcpy(void *dst, const void *src, size_t n) {
+  80077a:	55                   	push   %ebp
+  80077b:	89 e5                	mov    %esp,%ebp
+  80077d:	57                   	push   %edi
+  80077e:	56                   	push   %esi
+  80077f:	83 ec 20             	sub    $0x20,%esp
+  800782:	8b 45 08             	mov    0x8(%ebp),%eax
+  800785:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800788:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80078b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80078e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800791:	89 45 ec             	mov    %eax,-0x14(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  800794:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800797:	c1 e8 02             	shr    $0x2,%eax
+  80079a:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  80079c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80079f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8007a2:	89 d7                	mov    %edx,%edi
+  8007a4:	89 c6                	mov    %eax,%esi
+  8007a6:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  8007a8:	8b 4d ec             	mov    -0x14(%ebp),%ecx
+  8007ab:	83 e1 03             	and    $0x3,%ecx
+  8007ae:	74 02                	je     8007b2 <memcpy+0x38>
+  8007b0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  8007b2:	89 f0                	mov    %esi,%eax
+  8007b4:	89 fa                	mov    %edi,%edx
+  8007b6:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  8007b9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  8007bc:	89 45 e0             	mov    %eax,-0x20(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  8007bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMCPY
+    return __memcpy(dst, src, n);
+  8007c2:	90                   	nop
+    while (n -- > 0) {
+        *d ++ = *s ++;
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMCPY */
+}
+  8007c3:	83 c4 20             	add    $0x20,%esp
+  8007c6:	5e                   	pop    %esi
+  8007c7:	5f                   	pop    %edi
+  8007c8:	5d                   	pop    %ebp
+  8007c9:	c3                   	ret    
+
+008007ca <memcmp>:
+ *   match in both memory blocks has a greater value in @v1 than in @v2
+ *   as if evaluated as unsigned char values;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+  8007ca:	55                   	push   %ebp
+  8007cb:	89 e5                	mov    %esp,%ebp
+  8007cd:	83 ec 10             	sub    $0x10,%esp
+    const char *s1 = (const char *)v1;
+  8007d0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8007d3:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    const char *s2 = (const char *)v2;
+  8007d6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8007d9:	89 45 f8             	mov    %eax,-0x8(%ebp)
+    while (n -- > 0) {
+  8007dc:	eb 30                	jmp    80080e <memcmp+0x44>
+        if (*s1 != *s2) {
+  8007de:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8007e1:	0f b6 10             	movzbl (%eax),%edx
+  8007e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8007e7:	0f b6 00             	movzbl (%eax),%eax
+  8007ea:	38 c2                	cmp    %al,%dl
+  8007ec:	74 18                	je     800806 <memcmp+0x3c>
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+  8007ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8007f1:	0f b6 00             	movzbl (%eax),%eax
+  8007f4:	0f b6 d0             	movzbl %al,%edx
+  8007f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8007fa:	0f b6 00             	movzbl (%eax),%eax
+  8007fd:	0f b6 c0             	movzbl %al,%eax
+  800800:	29 c2                	sub    %eax,%edx
+  800802:	89 d0                	mov    %edx,%eax
+  800804:	eb 1a                	jmp    800820 <memcmp+0x56>
+        }
+        s1 ++, s2 ++;
+  800806:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  80080a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+    const char *s1 = (const char *)v1;
+    const char *s2 = (const char *)v2;
+    while (n -- > 0) {
+  80080e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800811:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800814:	89 55 10             	mov    %edx,0x10(%ebp)
+  800817:	85 c0                	test   %eax,%eax
+  800819:	75 c3                	jne    8007de <memcmp+0x14>
+        if (*s1 != *s2) {
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+        }
+        s1 ++, s2 ++;
+    }
+    return 0;
+  80081b:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800820:	c9                   	leave  
+  800821:	c3                   	ret    
+
+00800822 <printnum>:
+ * @width:      maximum number of digits, if the actual width is less than @width, use @padc instead
+ * @padc:       character that padded on the left if the actual width is less than @width
+ * */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+        unsigned long long num, unsigned base, int width, int padc) {
+  800822:	55                   	push   %ebp
+  800823:	89 e5                	mov    %esp,%ebp
+  800825:	83 ec 38             	sub    $0x38,%esp
+  800828:	8b 45 10             	mov    0x10(%ebp),%eax
+  80082b:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  80082e:	8b 45 14             	mov    0x14(%ebp),%eax
+  800831:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+    unsigned long long result = num;
+  800834:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  800837:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  80083a:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  80083d:	89 55 ec             	mov    %edx,-0x14(%ebp)
+    unsigned mod = do_div(result, base);
+  800840:	8b 45 18             	mov    0x18(%ebp),%eax
+  800843:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800846:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800849:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  80084c:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  80084f:	89 55 f0             	mov    %edx,-0x10(%ebp)
+  800852:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800855:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800858:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  80085c:	74 1c                	je     80087a <printnum+0x58>
+  80085e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800861:	ba 00 00 00 00       	mov    $0x0,%edx
+  800866:	f7 75 e4             	divl   -0x1c(%ebp)
+  800869:	89 55 f4             	mov    %edx,-0xc(%ebp)
+  80086c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  80086f:	ba 00 00 00 00       	mov    $0x0,%edx
+  800874:	f7 75 e4             	divl   -0x1c(%ebp)
+  800877:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80087a:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80087d:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800880:	f7 75 e4             	divl   -0x1c(%ebp)
+  800883:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800886:	89 55 dc             	mov    %edx,-0x24(%ebp)
+  800889:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80088c:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  80088f:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800892:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  800895:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  800898:	89 45 d8             	mov    %eax,-0x28(%ebp)
+
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+  80089b:	8b 45 18             	mov    0x18(%ebp),%eax
+  80089e:	ba 00 00 00 00       	mov    $0x0,%edx
+  8008a3:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  8008a6:	77 41                	ja     8008e9 <printnum+0xc7>
+  8008a8:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  8008ab:	72 05                	jb     8008b2 <printnum+0x90>
+  8008ad:	3b 45 d0             	cmp    -0x30(%ebp),%eax
+  8008b0:	77 37                	ja     8008e9 <printnum+0xc7>
+        printnum(putch, putdat, result, base, width - 1, padc);
+  8008b2:	8b 45 1c             	mov    0x1c(%ebp),%eax
+  8008b5:	83 e8 01             	sub    $0x1,%eax
+  8008b8:	83 ec 04             	sub    $0x4,%esp
+  8008bb:	ff 75 20             	pushl  0x20(%ebp)
+  8008be:	50                   	push   %eax
+  8008bf:	ff 75 18             	pushl  0x18(%ebp)
+  8008c2:	ff 75 ec             	pushl  -0x14(%ebp)
+  8008c5:	ff 75 e8             	pushl  -0x18(%ebp)
+  8008c8:	ff 75 0c             	pushl  0xc(%ebp)
+  8008cb:	ff 75 08             	pushl  0x8(%ebp)
+  8008ce:	e8 4f ff ff ff       	call   800822 <printnum>
+  8008d3:	83 c4 20             	add    $0x20,%esp
+  8008d6:	eb 1b                	jmp    8008f3 <printnum+0xd1>
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+            putch(padc, putdat);
+  8008d8:	83 ec 08             	sub    $0x8,%esp
+  8008db:	ff 75 0c             	pushl  0xc(%ebp)
+  8008de:	ff 75 20             	pushl  0x20(%ebp)
+  8008e1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8008e4:	ff d0                	call   *%eax
+  8008e6:	83 c4 10             	add    $0x10,%esp
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+        printnum(putch, putdat, result, base, width - 1, padc);
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+  8008e9:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+  8008ed:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+  8008f1:	7f e5                	jg     8008d8 <printnum+0xb6>
+            putch(padc, putdat);
+    }
+    // then print this (the least significant) digit
+    putch("0123456789abcdef"[mod], putdat);
+  8008f3:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  8008f6:	05 a4 11 80 00       	add    $0x8011a4,%eax
+  8008fb:	0f b6 00             	movzbl (%eax),%eax
+  8008fe:	0f be c0             	movsbl %al,%eax
+  800901:	83 ec 08             	sub    $0x8,%esp
+  800904:	ff 75 0c             	pushl  0xc(%ebp)
+  800907:	50                   	push   %eax
+  800908:	8b 45 08             	mov    0x8(%ebp),%eax
+  80090b:	ff d0                	call   *%eax
+  80090d:	83 c4 10             	add    $0x10,%esp
+}
+  800910:	90                   	nop
+  800911:	c9                   	leave  
+  800912:	c3                   	ret    
+
+00800913 <getuint>:
+ * getuint - get an unsigned int of various possible sizes from a varargs list
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static unsigned long long
+getuint(va_list *ap, int lflag) {
+  800913:	55                   	push   %ebp
+  800914:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  800916:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  80091a:	7e 14                	jle    800930 <getuint+0x1d>
+        return va_arg(*ap, unsigned long long);
+  80091c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80091f:	8b 00                	mov    (%eax),%eax
+  800921:	8d 48 08             	lea    0x8(%eax),%ecx
+  800924:	8b 55 08             	mov    0x8(%ebp),%edx
+  800927:	89 0a                	mov    %ecx,(%edx)
+  800929:	8b 50 04             	mov    0x4(%eax),%edx
+  80092c:	8b 00                	mov    (%eax),%eax
+  80092e:	eb 30                	jmp    800960 <getuint+0x4d>
+    }
+    else if (lflag) {
+  800930:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800934:	74 16                	je     80094c <getuint+0x39>
+        return va_arg(*ap, unsigned long);
+  800936:	8b 45 08             	mov    0x8(%ebp),%eax
+  800939:	8b 00                	mov    (%eax),%eax
+  80093b:	8d 48 04             	lea    0x4(%eax),%ecx
+  80093e:	8b 55 08             	mov    0x8(%ebp),%edx
+  800941:	89 0a                	mov    %ecx,(%edx)
+  800943:	8b 00                	mov    (%eax),%eax
+  800945:	ba 00 00 00 00       	mov    $0x0,%edx
+  80094a:	eb 14                	jmp    800960 <getuint+0x4d>
+    }
+    else {
+        return va_arg(*ap, unsigned int);
+  80094c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80094f:	8b 00                	mov    (%eax),%eax
+  800951:	8d 48 04             	lea    0x4(%eax),%ecx
+  800954:	8b 55 08             	mov    0x8(%ebp),%edx
+  800957:	89 0a                	mov    %ecx,(%edx)
+  800959:	8b 00                	mov    (%eax),%eax
+  80095b:	ba 00 00 00 00       	mov    $0x0,%edx
+    }
+}
+  800960:	5d                   	pop    %ebp
+  800961:	c3                   	ret    
+
+00800962 <getint>:
+ * getint - same as getuint but signed, we can't use getuint because of sign extension
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static long long
+getint(va_list *ap, int lflag) {
+  800962:	55                   	push   %ebp
+  800963:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  800965:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  800969:	7e 14                	jle    80097f <getint+0x1d>
+        return va_arg(*ap, long long);
+  80096b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80096e:	8b 00                	mov    (%eax),%eax
+  800970:	8d 48 08             	lea    0x8(%eax),%ecx
+  800973:	8b 55 08             	mov    0x8(%ebp),%edx
+  800976:	89 0a                	mov    %ecx,(%edx)
+  800978:	8b 50 04             	mov    0x4(%eax),%edx
+  80097b:	8b 00                	mov    (%eax),%eax
+  80097d:	eb 28                	jmp    8009a7 <getint+0x45>
+    }
+    else if (lflag) {
+  80097f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800983:	74 12                	je     800997 <getint+0x35>
+        return va_arg(*ap, long);
+  800985:	8b 45 08             	mov    0x8(%ebp),%eax
+  800988:	8b 00                	mov    (%eax),%eax
+  80098a:	8d 48 04             	lea    0x4(%eax),%ecx
+  80098d:	8b 55 08             	mov    0x8(%ebp),%edx
+  800990:	89 0a                	mov    %ecx,(%edx)
+  800992:	8b 00                	mov    (%eax),%eax
+  800994:	99                   	cltd   
+  800995:	eb 10                	jmp    8009a7 <getint+0x45>
+    }
+    else {
+        return va_arg(*ap, int);
+  800997:	8b 45 08             	mov    0x8(%ebp),%eax
+  80099a:	8b 00                	mov    (%eax),%eax
+  80099c:	8d 48 04             	lea    0x4(%eax),%ecx
+  80099f:	8b 55 08             	mov    0x8(%ebp),%edx
+  8009a2:	89 0a                	mov    %ecx,(%edx)
+  8009a4:	8b 00                	mov    (%eax),%eax
+  8009a6:	99                   	cltd   
+    }
+}
+  8009a7:	5d                   	pop    %ebp
+  8009a8:	c3                   	ret    
+
+008009a9 <printfmt>:
+ * @putch:      specified putch function, print a single character
+ * @putdat:     used by @putch function
+ * @fmt:        the format string to use
+ * */
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...) {
+  8009a9:	55                   	push   %ebp
+  8009aa:	89 e5                	mov    %esp,%ebp
+  8009ac:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  8009af:	8d 45 14             	lea    0x14(%ebp),%eax
+  8009b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    vprintfmt(putch, putdat, fmt, ap);
+  8009b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8009b8:	50                   	push   %eax
+  8009b9:	ff 75 10             	pushl  0x10(%ebp)
+  8009bc:	ff 75 0c             	pushl  0xc(%ebp)
+  8009bf:	ff 75 08             	pushl  0x8(%ebp)
+  8009c2:	e8 06 00 00 00       	call   8009cd <vprintfmt>
+  8009c7:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+  8009ca:	90                   	nop
+  8009cb:	c9                   	leave  
+  8009cc:	c3                   	ret    
+
+008009cd <vprintfmt>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want printfmt() instead.
+ * */
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap) {
+  8009cd:	55                   	push   %ebp
+  8009ce:	89 e5                	mov    %esp,%ebp
+  8009d0:	56                   	push   %esi
+  8009d1:	53                   	push   %ebx
+  8009d2:	83 ec 20             	sub    $0x20,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  8009d5:	eb 17                	jmp    8009ee <vprintfmt+0x21>
+            if (ch == '\0') {
+  8009d7:	85 db                	test   %ebx,%ebx
+  8009d9:	0f 84 8e 03 00 00    	je     800d6d <vprintfmt+0x3a0>
+                return;
+            }
+            putch(ch, putdat);
+  8009df:	83 ec 08             	sub    $0x8,%esp
+  8009e2:	ff 75 0c             	pushl  0xc(%ebp)
+  8009e5:	53                   	push   %ebx
+  8009e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009e9:	ff d0                	call   *%eax
+  8009eb:	83 c4 10             	add    $0x10,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  8009ee:	8b 45 10             	mov    0x10(%ebp),%eax
+  8009f1:	8d 50 01             	lea    0x1(%eax),%edx
+  8009f4:	89 55 10             	mov    %edx,0x10(%ebp)
+  8009f7:	0f b6 00             	movzbl (%eax),%eax
+  8009fa:	0f b6 d8             	movzbl %al,%ebx
+  8009fd:	83 fb 25             	cmp    $0x25,%ebx
+  800a00:	75 d5                	jne    8009d7 <vprintfmt+0xa>
+            }
+            putch(ch, putdat);
+        }
+
+        // Process a %-escape sequence
+        char padc = ' ';
+  800a02:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+        width = precision = -1;
+  800a06:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+  800a0d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800a10:	89 45 e8             	mov    %eax,-0x18(%ebp)
+        lflag = altflag = 0;
+  800a13:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+  800a1a:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  800a1d:	89 45 e0             	mov    %eax,-0x20(%ebp)
+
+    reswitch:
+        switch (ch = *(unsigned char *)fmt ++) {
+  800a20:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a23:	8d 50 01             	lea    0x1(%eax),%edx
+  800a26:	89 55 10             	mov    %edx,0x10(%ebp)
+  800a29:	0f b6 00             	movzbl (%eax),%eax
+  800a2c:	0f b6 d8             	movzbl %al,%ebx
+  800a2f:	8d 43 dd             	lea    -0x23(%ebx),%eax
+  800a32:	83 f8 55             	cmp    $0x55,%eax
+  800a35:	0f 87 05 03 00 00    	ja     800d40 <vprintfmt+0x373>
+  800a3b:	8b 04 85 c8 11 80 00 	mov    0x8011c8(,%eax,4),%eax
+  800a42:	ff e0                	jmp    *%eax
+
+        // flag to pad on the right
+        case '-':
+            padc = '-';
+  800a44:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+            goto reswitch;
+  800a48:	eb d6                	jmp    800a20 <vprintfmt+0x53>
+
+        // flag to pad with 0's instead of spaces
+        case '0':
+            padc = '0';
+  800a4a:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+            goto reswitch;
+  800a4e:	eb d0                	jmp    800a20 <vprintfmt+0x53>
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  800a50:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+                precision = precision * 10 + ch - '0';
+  800a57:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800a5a:	89 d0                	mov    %edx,%eax
+  800a5c:	c1 e0 02             	shl    $0x2,%eax
+  800a5f:	01 d0                	add    %edx,%eax
+  800a61:	01 c0                	add    %eax,%eax
+  800a63:	01 d8                	add    %ebx,%eax
+  800a65:	83 e8 30             	sub    $0x30,%eax
+  800a68:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+                ch = *fmt;
+  800a6b:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a6e:	0f b6 00             	movzbl (%eax),%eax
+  800a71:	0f be d8             	movsbl %al,%ebx
+                if (ch < '0' || ch > '9') {
+  800a74:	83 fb 2f             	cmp    $0x2f,%ebx
+  800a77:	7e 39                	jle    800ab2 <vprintfmt+0xe5>
+  800a79:	83 fb 39             	cmp    $0x39,%ebx
+  800a7c:	7f 34                	jg     800ab2 <vprintfmt+0xe5>
+            padc = '0';
+            goto reswitch;
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  800a7e:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+                precision = precision * 10 + ch - '0';
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+  800a82:	eb d3                	jmp    800a57 <vprintfmt+0x8a>
+            goto process_precision;
+
+        case '*':
+            precision = va_arg(ap, int);
+  800a84:	8b 45 14             	mov    0x14(%ebp),%eax
+  800a87:	8d 50 04             	lea    0x4(%eax),%edx
+  800a8a:	89 55 14             	mov    %edx,0x14(%ebp)
+  800a8d:	8b 00                	mov    (%eax),%eax
+  800a8f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+            goto process_precision;
+  800a92:	eb 1f                	jmp    800ab3 <vprintfmt+0xe6>
+
+        case '.':
+            if (width < 0)
+  800a94:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800a98:	79 86                	jns    800a20 <vprintfmt+0x53>
+                width = 0;
+  800a9a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+            goto reswitch;
+  800aa1:	e9 7a ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        case '#':
+            altflag = 1;
+  800aa6:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+            goto reswitch;
+  800aad:	e9 6e ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+            goto process_precision;
+  800ab2:	90                   	nop
+        case '#':
+            altflag = 1;
+            goto reswitch;
+
+        process_precision:
+            if (width < 0)
+  800ab3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ab7:	0f 89 63 ff ff ff    	jns    800a20 <vprintfmt+0x53>
+                width = precision, precision = -1;
+  800abd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800ac0:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800ac3:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+            goto reswitch;
+  800aca:	e9 51 ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        // long flag (doubled for long long)
+        case 'l':
+            lflag ++;
+  800acf:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
+            goto reswitch;
+  800ad3:	e9 48 ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        // character
+        case 'c':
+            putch(va_arg(ap, int), putdat);
+  800ad8:	8b 45 14             	mov    0x14(%ebp),%eax
+  800adb:	8d 50 04             	lea    0x4(%eax),%edx
+  800ade:	89 55 14             	mov    %edx,0x14(%ebp)
+  800ae1:	8b 00                	mov    (%eax),%eax
+  800ae3:	83 ec 08             	sub    $0x8,%esp
+  800ae6:	ff 75 0c             	pushl  0xc(%ebp)
+  800ae9:	50                   	push   %eax
+  800aea:	8b 45 08             	mov    0x8(%ebp),%eax
+  800aed:	ff d0                	call   *%eax
+  800aef:	83 c4 10             	add    $0x10,%esp
+            break;
+  800af2:	e9 71 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // error message
+        case 'e':
+            err = va_arg(ap, int);
+  800af7:	8b 45 14             	mov    0x14(%ebp),%eax
+  800afa:	8d 50 04             	lea    0x4(%eax),%edx
+  800afd:	89 55 14             	mov    %edx,0x14(%ebp)
+  800b00:	8b 18                	mov    (%eax),%ebx
+            if (err < 0) {
+  800b02:	85 db                	test   %ebx,%ebx
+  800b04:	79 02                	jns    800b08 <vprintfmt+0x13b>
+                err = -err;
+  800b06:	f7 db                	neg    %ebx
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+  800b08:	83 fb 18             	cmp    $0x18,%ebx
+  800b0b:	7f 0b                	jg     800b18 <vprintfmt+0x14b>
+  800b0d:	8b 34 9d 40 11 80 00 	mov    0x801140(,%ebx,4),%esi
+  800b14:	85 f6                	test   %esi,%esi
+  800b16:	75 19                	jne    800b31 <vprintfmt+0x164>
+                printfmt(putch, putdat, "error %d", err);
+  800b18:	53                   	push   %ebx
+  800b19:	68 b5 11 80 00       	push   $0x8011b5
+  800b1e:	ff 75 0c             	pushl  0xc(%ebp)
+  800b21:	ff 75 08             	pushl  0x8(%ebp)
+  800b24:	e8 80 fe ff ff       	call   8009a9 <printfmt>
+  800b29:	83 c4 10             	add    $0x10,%esp
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+            }
+            break;
+  800b2c:	e9 37 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+                printfmt(putch, putdat, "error %d", err);
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+  800b31:	56                   	push   %esi
+  800b32:	68 be 11 80 00       	push   $0x8011be
+  800b37:	ff 75 0c             	pushl  0xc(%ebp)
+  800b3a:	ff 75 08             	pushl  0x8(%ebp)
+  800b3d:	e8 67 fe ff ff       	call   8009a9 <printfmt>
+  800b42:	83 c4 10             	add    $0x10,%esp
+            }
+            break;
+  800b45:	e9 1e 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // string
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+  800b4a:	8b 45 14             	mov    0x14(%ebp),%eax
+  800b4d:	8d 50 04             	lea    0x4(%eax),%edx
+  800b50:	89 55 14             	mov    %edx,0x14(%ebp)
+  800b53:	8b 30                	mov    (%eax),%esi
+  800b55:	85 f6                	test   %esi,%esi
+  800b57:	75 05                	jne    800b5e <vprintfmt+0x191>
+                p = "(null)";
+  800b59:	be c1 11 80 00       	mov    $0x8011c1,%esi
+            }
+            if (width > 0 && padc != '-') {
+  800b5e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800b62:	7e 76                	jle    800bda <vprintfmt+0x20d>
+  800b64:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+  800b68:	74 70                	je     800bda <vprintfmt+0x20d>
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  800b6a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800b6d:	83 ec 08             	sub    $0x8,%esp
+  800b70:	50                   	push   %eax
+  800b71:	56                   	push   %esi
+  800b72:	e8 17 f8 ff ff       	call   80038e <strnlen>
+  800b77:	83 c4 10             	add    $0x10,%esp
+  800b7a:	89 c2                	mov    %eax,%edx
+  800b7c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800b7f:	29 d0                	sub    %edx,%eax
+  800b81:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800b84:	eb 17                	jmp    800b9d <vprintfmt+0x1d0>
+                    putch(padc, putdat);
+  800b86:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+  800b8a:	83 ec 08             	sub    $0x8,%esp
+  800b8d:	ff 75 0c             	pushl  0xc(%ebp)
+  800b90:	50                   	push   %eax
+  800b91:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b94:	ff d0                	call   *%eax
+  800b96:	83 c4 10             	add    $0x10,%esp
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+                p = "(null)";
+            }
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  800b99:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800b9d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ba1:	7f e3                	jg     800b86 <vprintfmt+0x1b9>
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  800ba3:	eb 35                	jmp    800bda <vprintfmt+0x20d>
+                if (altflag && (ch < ' ' || ch > '~')) {
+  800ba5:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+  800ba9:	74 1c                	je     800bc7 <vprintfmt+0x1fa>
+  800bab:	83 fb 1f             	cmp    $0x1f,%ebx
+  800bae:	7e 05                	jle    800bb5 <vprintfmt+0x1e8>
+  800bb0:	83 fb 7e             	cmp    $0x7e,%ebx
+  800bb3:	7e 12                	jle    800bc7 <vprintfmt+0x1fa>
+                    putch('?', putdat);
+  800bb5:	83 ec 08             	sub    $0x8,%esp
+  800bb8:	ff 75 0c             	pushl  0xc(%ebp)
+  800bbb:	6a 3f                	push   $0x3f
+  800bbd:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bc0:	ff d0                	call   *%eax
+  800bc2:	83 c4 10             	add    $0x10,%esp
+  800bc5:	eb 0f                	jmp    800bd6 <vprintfmt+0x209>
+                }
+                else {
+                    putch(ch, putdat);
+  800bc7:	83 ec 08             	sub    $0x8,%esp
+  800bca:	ff 75 0c             	pushl  0xc(%ebp)
+  800bcd:	53                   	push   %ebx
+  800bce:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bd1:	ff d0                	call   *%eax
+  800bd3:	83 c4 10             	add    $0x10,%esp
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  800bd6:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800bda:	89 f0                	mov    %esi,%eax
+  800bdc:	8d 70 01             	lea    0x1(%eax),%esi
+  800bdf:	0f b6 00             	movzbl (%eax),%eax
+  800be2:	0f be d8             	movsbl %al,%ebx
+  800be5:	85 db                	test   %ebx,%ebx
+  800be7:	74 26                	je     800c0f <vprintfmt+0x242>
+  800be9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800bed:	78 b6                	js     800ba5 <vprintfmt+0x1d8>
+  800bef:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800bf3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800bf7:	79 ac                	jns    800ba5 <vprintfmt+0x1d8>
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  800bf9:	eb 14                	jmp    800c0f <vprintfmt+0x242>
+                putch(' ', putdat);
+  800bfb:	83 ec 08             	sub    $0x8,%esp
+  800bfe:	ff 75 0c             	pushl  0xc(%ebp)
+  800c01:	6a 20                	push   $0x20
+  800c03:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c06:	ff d0                	call   *%eax
+  800c08:	83 c4 10             	add    $0x10,%esp
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  800c0b:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800c0f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800c13:	7f e6                	jg     800bfb <vprintfmt+0x22e>
+                putch(' ', putdat);
+            }
+            break;
+  800c15:	e9 4e 01 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // (signed) decimal
+        case 'd':
+            num = getint(&ap, lflag);
+  800c1a:	83 ec 08             	sub    $0x8,%esp
+  800c1d:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c20:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c23:	50                   	push   %eax
+  800c24:	e8 39 fd ff ff       	call   800962 <getint>
+  800c29:	83 c4 10             	add    $0x10,%esp
+  800c2c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c2f:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            if ((long long)num < 0) {
+  800c32:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c35:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800c38:	85 d2                	test   %edx,%edx
+  800c3a:	79 23                	jns    800c5f <vprintfmt+0x292>
+                putch('-', putdat);
+  800c3c:	83 ec 08             	sub    $0x8,%esp
+  800c3f:	ff 75 0c             	pushl  0xc(%ebp)
+  800c42:	6a 2d                	push   $0x2d
+  800c44:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c47:	ff d0                	call   *%eax
+  800c49:	83 c4 10             	add    $0x10,%esp
+                num = -(long long)num;
+  800c4c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c4f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800c52:	f7 d8                	neg    %eax
+  800c54:	83 d2 00             	adc    $0x0,%edx
+  800c57:	f7 da                	neg    %edx
+  800c59:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c5c:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            }
+            base = 10;
+  800c5f:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  800c66:	e9 9f 00 00 00       	jmp    800d0a <vprintfmt+0x33d>
+
+        // unsigned decimal
+        case 'u':
+            num = getuint(&ap, lflag);
+  800c6b:	83 ec 08             	sub    $0x8,%esp
+  800c6e:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c71:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c74:	50                   	push   %eax
+  800c75:	e8 99 fc ff ff       	call   800913 <getuint>
+  800c7a:	83 c4 10             	add    $0x10,%esp
+  800c7d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c80:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 10;
+  800c83:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  800c8a:	eb 7e                	jmp    800d0a <vprintfmt+0x33d>
+
+        // (unsigned) octal
+        case 'o':
+            num = getuint(&ap, lflag);
+  800c8c:	83 ec 08             	sub    $0x8,%esp
+  800c8f:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c92:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c95:	50                   	push   %eax
+  800c96:	e8 78 fc ff ff       	call   800913 <getuint>
+  800c9b:	83 c4 10             	add    $0x10,%esp
+  800c9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800ca1:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 8;
+  800ca4:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+            goto number;
+  800cab:	eb 5d                	jmp    800d0a <vprintfmt+0x33d>
+
+        // pointer
+        case 'p':
+            putch('0', putdat);
+  800cad:	83 ec 08             	sub    $0x8,%esp
+  800cb0:	ff 75 0c             	pushl  0xc(%ebp)
+  800cb3:	6a 30                	push   $0x30
+  800cb5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cb8:	ff d0                	call   *%eax
+  800cba:	83 c4 10             	add    $0x10,%esp
+            putch('x', putdat);
+  800cbd:	83 ec 08             	sub    $0x8,%esp
+  800cc0:	ff 75 0c             	pushl  0xc(%ebp)
+  800cc3:	6a 78                	push   $0x78
+  800cc5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cc8:	ff d0                	call   *%eax
+  800cca:	83 c4 10             	add    $0x10,%esp
+            num = (unsigned long long)(uintptr_t)va_arg(ap, void *);
+  800ccd:	8b 45 14             	mov    0x14(%ebp),%eax
+  800cd0:	8d 50 04             	lea    0x4(%eax),%edx
+  800cd3:	89 55 14             	mov    %edx,0x14(%ebp)
+  800cd6:	8b 00                	mov    (%eax),%eax
+  800cd8:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800cdb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+            base = 16;
+  800ce2:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+            goto number;
+  800ce9:	eb 1f                	jmp    800d0a <vprintfmt+0x33d>
+
+        // (unsigned) hexadecimal
+        case 'x':
+            num = getuint(&ap, lflag);
+  800ceb:	83 ec 08             	sub    $0x8,%esp
+  800cee:	ff 75 e0             	pushl  -0x20(%ebp)
+  800cf1:	8d 45 14             	lea    0x14(%ebp),%eax
+  800cf4:	50                   	push   %eax
+  800cf5:	e8 19 fc ff ff       	call   800913 <getuint>
+  800cfa:	83 c4 10             	add    $0x10,%esp
+  800cfd:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800d00:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 16;
+  800d03:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+        number:
+            printnum(putch, putdat, num, base, width, padc);
+  800d0a:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+  800d0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800d11:	83 ec 04             	sub    $0x4,%esp
+  800d14:	52                   	push   %edx
+  800d15:	ff 75 e8             	pushl  -0x18(%ebp)
+  800d18:	50                   	push   %eax
+  800d19:	ff 75 f4             	pushl  -0xc(%ebp)
+  800d1c:	ff 75 f0             	pushl  -0x10(%ebp)
+  800d1f:	ff 75 0c             	pushl  0xc(%ebp)
+  800d22:	ff 75 08             	pushl  0x8(%ebp)
+  800d25:	e8 f8 fa ff ff       	call   800822 <printnum>
+  800d2a:	83 c4 20             	add    $0x20,%esp
+            break;
+  800d2d:	eb 39                	jmp    800d68 <vprintfmt+0x39b>
+
+        // escaped '%' character
+        case '%':
+            putch(ch, putdat);
+  800d2f:	83 ec 08             	sub    $0x8,%esp
+  800d32:	ff 75 0c             	pushl  0xc(%ebp)
+  800d35:	53                   	push   %ebx
+  800d36:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d39:	ff d0                	call   *%eax
+  800d3b:	83 c4 10             	add    $0x10,%esp
+            break;
+  800d3e:	eb 28                	jmp    800d68 <vprintfmt+0x39b>
+
+        // unrecognized escape sequence - just print it literally
+        default:
+            putch('%', putdat);
+  800d40:	83 ec 08             	sub    $0x8,%esp
+  800d43:	ff 75 0c             	pushl  0xc(%ebp)
+  800d46:	6a 25                	push   $0x25
+  800d48:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d4b:	ff d0                	call   *%eax
+  800d4d:	83 c4 10             	add    $0x10,%esp
+            for (fmt --; fmt[-1] != '%'; fmt --)
+  800d50:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800d54:	eb 04                	jmp    800d5a <vprintfmt+0x38d>
+  800d56:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800d5a:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d5d:	83 e8 01             	sub    $0x1,%eax
+  800d60:	0f b6 00             	movzbl (%eax),%eax
+  800d63:	3c 25                	cmp    $0x25,%al
+  800d65:	75 ef                	jne    800d56 <vprintfmt+0x389>
+                /* do nothing */;
+            break;
+  800d67:	90                   	nop
+        }
+    }
+  800d68:	e9 68 fc ff ff       	jmp    8009d5 <vprintfmt+0x8>
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+            if (ch == '\0') {
+                return;
+  800d6d:	90                   	nop
+            for (fmt --; fmt[-1] != '%'; fmt --)
+                /* do nothing */;
+            break;
+        }
+    }
+}
+  800d6e:	8d 65 f8             	lea    -0x8(%ebp),%esp
+  800d71:	5b                   	pop    %ebx
+  800d72:	5e                   	pop    %esi
+  800d73:	5d                   	pop    %ebp
+  800d74:	c3                   	ret    
+
+00800d75 <sprintputch>:
+ * sprintputch - 'print' a single character in a buffer
+ * @ch:         the character will be printed
+ * @b:          the buffer to place the character @ch
+ * */
+static void
+sprintputch(int ch, struct sprintbuf *b) {
+  800d75:	55                   	push   %ebp
+  800d76:	89 e5                	mov    %esp,%ebp
+    b->cnt ++;
+  800d78:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d7b:	8b 40 08             	mov    0x8(%eax),%eax
+  800d7e:	8d 50 01             	lea    0x1(%eax),%edx
+  800d81:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d84:	89 50 08             	mov    %edx,0x8(%eax)
+    if (b->buf < b->ebuf) {
+  800d87:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8a:	8b 10                	mov    (%eax),%edx
+  800d8c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8f:	8b 40 04             	mov    0x4(%eax),%eax
+  800d92:	39 c2                	cmp    %eax,%edx
+  800d94:	73 12                	jae    800da8 <sprintputch+0x33>
+        *b->buf ++ = ch;
+  800d96:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d99:	8b 00                	mov    (%eax),%eax
+  800d9b:	8d 48 01             	lea    0x1(%eax),%ecx
+  800d9e:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800da1:	89 0a                	mov    %ecx,(%edx)
+  800da3:	8b 55 08             	mov    0x8(%ebp),%edx
+  800da6:	88 10                	mov    %dl,(%eax)
+    }
+}
+  800da8:	90                   	nop
+  800da9:	5d                   	pop    %ebp
+  800daa:	c3                   	ret    
+
+00800dab <snprintf>:
+ * @str:        the buffer to place the result into
+ * @size:       the size of buffer, including the trailing null space
+ * @fmt:        the format string to use
+ * */
+int
+snprintf(char *str, size_t size, const char *fmt, ...) {
+  800dab:	55                   	push   %ebp
+  800dac:	89 e5                	mov    %esp,%ebp
+  800dae:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    int cnt;
+    va_start(ap, fmt);
+  800db1:	8d 45 14             	lea    0x14(%ebp),%eax
+  800db4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    cnt = vsnprintf(str, size, fmt, ap);
+  800db7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800dba:	50                   	push   %eax
+  800dbb:	ff 75 10             	pushl  0x10(%ebp)
+  800dbe:	ff 75 0c             	pushl  0xc(%ebp)
+  800dc1:	ff 75 08             	pushl  0x8(%ebp)
+  800dc4:	e8 0b 00 00 00       	call   800dd4 <vsnprintf>
+  800dc9:	83 c4 10             	add    $0x10,%esp
+  800dcc:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+    return cnt;
+  800dcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800dd2:	c9                   	leave  
+  800dd3:	c3                   	ret    
+
+00800dd4 <vsnprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want snprintf() instead.
+ * */
+int
+vsnprintf(char *str, size_t size, const char *fmt, va_list ap) {
+  800dd4:	55                   	push   %ebp
+  800dd5:	89 e5                	mov    %esp,%ebp
+  800dd7:	83 ec 18             	sub    $0x18,%esp
+    struct sprintbuf b = {str, str + size - 1, 0};
+  800dda:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ddd:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800de0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800de3:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800de6:	8b 45 08             	mov    0x8(%ebp),%eax
+  800de9:	01 d0                	add    %edx,%eax
+  800deb:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800dee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    if (str == NULL || b.buf > b.ebuf) {
+  800df5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  800df9:	74 0a                	je     800e05 <vsnprintf+0x31>
+  800dfb:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  800dfe:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800e01:	39 c2                	cmp    %eax,%edx
+  800e03:	76 07                	jbe    800e0c <vsnprintf+0x38>
+        return -E_INVAL;
+  800e05:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+  800e0a:	eb 20                	jmp    800e2c <vsnprintf+0x58>
+    }
+    // print the string to the buffer
+    vprintfmt((void*)sprintputch, &b, fmt, ap);
+  800e0c:	ff 75 14             	pushl  0x14(%ebp)
+  800e0f:	ff 75 10             	pushl  0x10(%ebp)
+  800e12:	8d 45 ec             	lea    -0x14(%ebp),%eax
+  800e15:	50                   	push   %eax
+  800e16:	68 75 0d 80 00       	push   $0x800d75
+  800e1b:	e8 ad fb ff ff       	call   8009cd <vprintfmt>
+  800e20:	83 c4 10             	add    $0x10,%esp
+    // null terminate the buffer
+    *b.buf = '\0';
+  800e23:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e26:	c6 00 00             	movb   $0x0,(%eax)
+    return b.cnt;
+  800e29:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800e2c:	c9                   	leave  
+  800e2d:	c3                   	ret    
+
+00800e2e <hash32>:
+ * @bits:   the number of bits in a return value
+ *
+ * High bits are more random, so we use them.
+ * */
+uint32_t
+hash32(uint32_t val, unsigned int bits) {
+  800e2e:	55                   	push   %ebp
+  800e2f:	89 e5                	mov    %esp,%ebp
+  800e31:	83 ec 10             	sub    $0x10,%esp
+    uint32_t hash = val * GOLDEN_RATIO_PRIME_32;
+  800e34:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e37:	69 c0 01 00 37 9e    	imul   $0x9e370001,%eax,%eax
+  800e3d:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    return (hash >> (32 - bits));
+  800e40:	b8 20 00 00 00       	mov    $0x20,%eax
+  800e45:	2b 45 0c             	sub    0xc(%ebp),%eax
+  800e48:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  800e4b:	89 c1                	mov    %eax,%ecx
+  800e4d:	d3 ea                	shr    %cl,%edx
+  800e4f:	89 d0                	mov    %edx,%eax
+}
+  800e51:	c9                   	leave  
+  800e52:	c3                   	ret    
+
+00800e53 <rand>:
+ * rand - returns a pseudo-random integer
+ *
+ * The rand() function return a value in the range [0, RAND_MAX].
+ * */
+int
+rand(void) {
+  800e53:	55                   	push   %ebp
+  800e54:	89 e5                	mov    %esp,%ebp
+  800e56:	57                   	push   %edi
+  800e57:	56                   	push   %esi
+  800e58:	53                   	push   %ebx
+  800e59:	83 ec 24             	sub    $0x24,%esp
+    next = (next * 0x5DEECE66DLL + 0xBLL) & ((1LL << 48) - 1);
+  800e5c:	a1 00 20 80 00       	mov    0x802000,%eax
+  800e61:	8b 15 04 20 80 00    	mov    0x802004,%edx
+  800e67:	69 fa 6d e6 ec de    	imul   $0xdeece66d,%edx,%edi
+  800e6d:	6b f0 05             	imul   $0x5,%eax,%esi
+  800e70:	01 fe                	add    %edi,%esi
+  800e72:	bf 6d e6 ec de       	mov    $0xdeece66d,%edi
+  800e77:	f7 e7                	mul    %edi
+  800e79:	01 d6                	add    %edx,%esi
+  800e7b:	89 f2                	mov    %esi,%edx
+  800e7d:	83 c0 0b             	add    $0xb,%eax
+  800e80:	83 d2 00             	adc    $0x0,%edx
+  800e83:	89 c7                	mov    %eax,%edi
+  800e85:	83 e7 ff             	and    $0xffffffff,%edi
+  800e88:	89 f9                	mov    %edi,%ecx
+  800e8a:	0f b7 da             	movzwl %dx,%ebx
+  800e8d:	89 0d 00 20 80 00    	mov    %ecx,0x802000
+  800e93:	89 1d 04 20 80 00    	mov    %ebx,0x802004
+    unsigned long long result = (next >> 12);
+  800e99:	a1 00 20 80 00       	mov    0x802000,%eax
+  800e9e:	8b 15 04 20 80 00    	mov    0x802004,%edx
+  800ea4:	0f ac d0 0c          	shrd   $0xc,%edx,%eax
+  800ea8:	c1 ea 0c             	shr    $0xc,%edx
+  800eab:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800eae:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+    return (int)do_div(result, RAND_MAX + 1);
+  800eb1:	c7 45 dc 00 00 00 80 	movl   $0x80000000,-0x24(%ebp)
+  800eb8:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  800ebb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800ebe:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  800ec1:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  800ec4:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ec7:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800eca:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ece:	74 1c                	je     800eec <rand+0x99>
+  800ed0:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ed3:	ba 00 00 00 00       	mov    $0x0,%edx
+  800ed8:	f7 75 dc             	divl   -0x24(%ebp)
+  800edb:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  800ede:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ee1:	ba 00 00 00 00       	mov    $0x0,%edx
+  800ee6:	f7 75 dc             	divl   -0x24(%ebp)
+  800ee9:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800eec:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  800eef:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  800ef2:	f7 75 dc             	divl   -0x24(%ebp)
+  800ef5:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  800ef8:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  800efb:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  800efe:	8b 55 e8             	mov    -0x18(%ebp),%edx
+  800f01:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800f04:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  800f07:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+}
+  800f0a:	83 c4 24             	add    $0x24,%esp
+  800f0d:	5b                   	pop    %ebx
+  800f0e:	5e                   	pop    %esi
+  800f0f:	5f                   	pop    %edi
+  800f10:	5d                   	pop    %ebp
+  800f11:	c3                   	ret    
+
+00800f12 <srand>:
+/* *
+ * srand - seed the random number generator with the given number
+ * @seed:   the required seed number
+ * */
+void
+srand(unsigned int seed) {
+  800f12:	55                   	push   %ebp
+  800f13:	89 e5                	mov    %esp,%ebp
+    next = seed;
+  800f15:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f18:	ba 00 00 00 00       	mov    $0x0,%edx
+  800f1d:	a3 00 20 80 00       	mov    %eax,0x802000
+  800f22:	89 15 04 20 80 00    	mov    %edx,0x802004
+}
+  800f28:	90                   	nop
+  800f29:	5d                   	pop    %ebp
+  800f2a:	c3                   	ret    
+
+00800f2b <main>:
+#define ARRAYSIZE (1024*1024)
+
+uint32_t bigarray[ARRAYSIZE];
+
+int
+main(void) {
+  800f2b:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+  800f2f:	83 e4 f0             	and    $0xfffffff0,%esp
+  800f32:	ff 71 fc             	pushl  -0x4(%ecx)
+  800f35:	55                   	push   %ebp
+  800f36:	89 e5                	mov    %esp,%ebp
+  800f38:	51                   	push   %ecx
+  800f39:	83 ec 14             	sub    $0x14,%esp
+    cprintf("Making sure bss works right...\n");
+  800f3c:	83 ec 0c             	sub    $0xc,%esp
+  800f3f:	68 20 13 80 00       	push   $0x801320
+  800f44:	e8 90 f3 ff ff       	call   8002d9 <cprintf>
+  800f49:	83 c4 10             	add    $0x10,%esp
+    int i;
+    for (i = 0; i < ARRAYSIZE; i ++) {
+  800f4c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  800f53:	eb 26                	jmp    800f7b <main+0x50>
+        if (bigarray[i] != 0) {
+  800f55:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800f58:	8b 04 85 20 20 80 00 	mov    0x802020(,%eax,4),%eax
+  800f5f:	85 c0                	test   %eax,%eax
+  800f61:	74 14                	je     800f77 <main+0x4c>
+            panic("bigarray[%d] isn't cleared!\n", i);
+  800f63:	ff 75 f4             	pushl  -0xc(%ebp)
+  800f66:	68 40 13 80 00       	push   $0x801340
+  800f6b:	6a 0e                	push   $0xe
+  800f6d:	68 5d 13 80 00       	push   $0x80135d
+  800f72:	e8 a9 f0 ff ff       	call   800020 <__panic>
+
+int
+main(void) {
+    cprintf("Making sure bss works right...\n");
+    int i;
+    for (i = 0; i < ARRAYSIZE; i ++) {
+  800f77:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  800f7b:	81 7d f4 ff ff 0f 00 	cmpl   $0xfffff,-0xc(%ebp)
+  800f82:	7e d1                	jle    800f55 <main+0x2a>
+        if (bigarray[i] != 0) {
+            panic("bigarray[%d] isn't cleared!\n", i);
+        }
+    }
+    for (i = 0; i < ARRAYSIZE; i ++) {
+  800f84:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  800f8b:	eb 11                	jmp    800f9e <main+0x73>
+        bigarray[i] = i;
+  800f8d:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800f90:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800f93:	89 14 85 20 20 80 00 	mov    %edx,0x802020(,%eax,4)
+    for (i = 0; i < ARRAYSIZE; i ++) {
+        if (bigarray[i] != 0) {
+            panic("bigarray[%d] isn't cleared!\n", i);
+        }
+    }
+    for (i = 0; i < ARRAYSIZE; i ++) {
+  800f9a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  800f9e:	81 7d f4 ff ff 0f 00 	cmpl   $0xfffff,-0xc(%ebp)
+  800fa5:	7e e6                	jle    800f8d <main+0x62>
+        bigarray[i] = i;
+    }
+    for (i = 0; i < ARRAYSIZE; i ++) {
+  800fa7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  800fae:	eb 29                	jmp    800fd9 <main+0xae>
+        if (bigarray[i] != i) {
+  800fb0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800fb3:	8b 14 85 20 20 80 00 	mov    0x802020(,%eax,4),%edx
+  800fba:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800fbd:	39 c2                	cmp    %eax,%edx
+  800fbf:	74 14                	je     800fd5 <main+0xaa>
+            panic("bigarray[%d] didn't hold its value!\n", i);
+  800fc1:	ff 75 f4             	pushl  -0xc(%ebp)
+  800fc4:	68 6c 13 80 00       	push   $0x80136c
+  800fc9:	6a 16                	push   $0x16
+  800fcb:	68 5d 13 80 00       	push   $0x80135d
+  800fd0:	e8 4b f0 ff ff       	call   800020 <__panic>
+        }
+    }
+    for (i = 0; i < ARRAYSIZE; i ++) {
+        bigarray[i] = i;
+    }
+    for (i = 0; i < ARRAYSIZE; i ++) {
+  800fd5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  800fd9:	81 7d f4 ff ff 0f 00 	cmpl   $0xfffff,-0xc(%ebp)
+  800fe0:	7e ce                	jle    800fb0 <main+0x85>
+        if (bigarray[i] != i) {
+            panic("bigarray[%d] didn't hold its value!\n", i);
+        }
+    }
+
+    cprintf("Yes, good.  Now doing a wild write off the end...\n");
+  800fe2:	83 ec 0c             	sub    $0xc,%esp
+  800fe5:	68 94 13 80 00       	push   $0x801394
+  800fea:	e8 ea f2 ff ff       	call   8002d9 <cprintf>
+  800fef:	83 c4 10             	add    $0x10,%esp
+    cprintf("testbss may pass.\n");
+  800ff2:	83 ec 0c             	sub    $0xc,%esp
+  800ff5:	68 c7 13 80 00       	push   $0x8013c7
+  800ffa:	e8 da f2 ff ff       	call   8002d9 <cprintf>
+  800fff:	83 c4 10             	add    $0x10,%esp
+
+    bigarray[ARRAYSIZE + 1024] = 0;
+  801002:	c7 05 20 30 c0 00 00 	movl   $0x0,0xc03020
+  801009:	00 00 00 
+    asm volatile ("int $0x14");
+  80100c:	cd 14                	int    $0x14
+    panic("FAIL: T.T\n");
+  80100e:	83 ec 04             	sub    $0x4,%esp
+  801011:	68 da 13 80 00       	push   $0x8013da
+  801016:	6a 1f                	push   $0x1f
+  801018:	68 5d 13 80 00       	push   $0x80135d
+  80101d:	e8 fe ef ff ff       	call   800020 <__panic>
diff -r -u -P lab6_origin/obj/user/testbss.d lab6/obj/user/testbss.d
--- lab6_origin/obj/user/testbss.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/testbss.d	2019-05-13 17:39:38.123192500 +0800
@@ -0,0 +1,2 @@
+obj/user/testbss.o obj/user/testbss.d: user/testbss.c libs/stdio.h \
+ libs/defs.h libs/stdarg.h user/libs/ulib.h
Binary files lab6_origin/obj/user/testbss.o and lab6/obj/user/testbss.o differ
diff -r -u -P lab6_origin/obj/user/testbss.sym lab6/obj/user/testbss.sym
--- lab6_origin/obj/user/testbss.sym	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/testbss.sym	2019-05-13 17:39:43.816923300 +0800
@@ -0,0 +1,78 @@
+00800020 .text
+00801040 .rodata
+00802000 .data
+00802020 .bss
+00200000 .stab_info
+00200010 .stab
+00202d95 .stabstr
+00000000 panic.c
+00000000 syscall.c
+008000b5 syscall
+00000000 ulib.c
+00000000 stdio.c
+0080028c cputch
+00000000 umain.c
+00000000 string.c
+00000000 printfmt.c
+00801140 error_string
+00800822 printnum
+00800913 getuint
+00800962 getint
+00800d75 sprintputch
+00000000 hash.c
+00000000 rand.c
+00802000 next
+00000000 testbss.c
+008003be strcpy
+0080021a yield
+00800201 waitpid
+00800141 sys_yield
+008006d7 memmove
+00800dab snprintf
+008009cd vprintfmt
+0080011d sys_fork
+008002d9 cprintf
+0080023e getpid
+0080077a memcpy
+00800266 lab6_set_priority
+00800dd4 vsnprintf
+0080034d umain
+00202d94 __STAB_END__
+00800150 sys_kill
+00202d95 __STABSTR_BEGIN__
+00800020 __panic
+0080053a strtol
+0080038e strnlen
+00802020 bigarray
+0080024b print_pgdir
+00800228 kill
+0080050b strfind
+008001ea wait
+0080027d _start
+00800e53 rand
+00800482 strncmp
+00800171 sys_putc
+008003fe strncpy
+008007ca memcmp
+008001dd fork
+00800697 memset
+00800f2b main
+00800f12 srand
+00800e2e hash32
+008009a9 printfmt
+00203bb5 __STABSTR_END__
+00800438 strcmp
+00800259 gettime_msec
+00800192 sys_gettime
+008002b0 vcprintf
+0080006e __warn
+008002ff cputs
+008001a1 sys_lab6_set_priority
+008001b7 exit
+0080012c sys_wait
+0080010b sys_exit
+00200010 __STAB_BEGIN__
+00800366 strlen
+00800183 sys_pgdir
+008004d8 strchr
+00800162 sys_getpid
diff -r -u -P lab6_origin/obj/user/waitkill.asm lab6/obj/user/waitkill.asm
--- lab6_origin/obj/user/waitkill.asm	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/waitkill.asm	2019-05-13 17:39:43.399164600 +0800
@@ -0,0 +1,2736 @@
+
+obj/__user_waitkill.out:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00800020 <__panic>:
+#include <stdio.h>
+#include <ulib.h>
+#include <error.h>
+
+void
+__panic(const char *file, int line, const char *fmt, ...) {
+  800020:	55                   	push   %ebp
+  800021:	89 e5                	mov    %esp,%ebp
+  800023:	83 ec 18             	sub    $0x18,%esp
+    // print the 'message'
+    va_list ap;
+    va_start(ap, fmt);
+  800026:	8d 45 14             	lea    0x14(%ebp),%eax
+  800029:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("user panic at %s:%d:\n    ", file, line);
+  80002c:	83 ec 04             	sub    $0x4,%esp
+  80002f:	ff 75 0c             	pushl  0xc(%ebp)
+  800032:	ff 75 08             	pushl  0x8(%ebp)
+  800035:	68 c0 10 80 00       	push   $0x8010c0
+  80003a:	e8 9a 02 00 00       	call   8002d9 <cprintf>
+  80003f:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+  800042:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800045:	83 ec 08             	sub    $0x8,%esp
+  800048:	50                   	push   %eax
+  800049:	ff 75 10             	pushl  0x10(%ebp)
+  80004c:	e8 5f 02 00 00       	call   8002b0 <vcprintf>
+  800051:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+  800054:	83 ec 0c             	sub    $0xc,%esp
+  800057:	68 da 10 80 00       	push   $0x8010da
+  80005c:	e8 78 02 00 00       	call   8002d9 <cprintf>
+  800061:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+    exit(-E_PANIC);
+  800064:	83 ec 0c             	sub    $0xc,%esp
+  800067:	6a f6                	push   $0xfffffff6
+  800069:	e8 49 01 00 00       	call   8001b7 <exit>
+
+0080006e <__warn>:
+}
+
+void
+__warn(const char *file, int line, const char *fmt, ...) {
+  80006e:	55                   	push   %ebp
+  80006f:	89 e5                	mov    %esp,%ebp
+  800071:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    va_start(ap, fmt);
+  800074:	8d 45 14             	lea    0x14(%ebp),%eax
+  800077:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("user warning at %s:%d:\n    ", file, line);
+  80007a:	83 ec 04             	sub    $0x4,%esp
+  80007d:	ff 75 0c             	pushl  0xc(%ebp)
+  800080:	ff 75 08             	pushl  0x8(%ebp)
+  800083:	68 dc 10 80 00       	push   $0x8010dc
+  800088:	e8 4c 02 00 00       	call   8002d9 <cprintf>
+  80008d:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+  800090:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800093:	83 ec 08             	sub    $0x8,%esp
+  800096:	50                   	push   %eax
+  800097:	ff 75 10             	pushl  0x10(%ebp)
+  80009a:	e8 11 02 00 00       	call   8002b0 <vcprintf>
+  80009f:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+  8000a2:	83 ec 0c             	sub    $0xc,%esp
+  8000a5:	68 da 10 80 00       	push   $0x8010da
+  8000aa:	e8 2a 02 00 00       	call   8002d9 <cprintf>
+  8000af:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+  8000b2:	90                   	nop
+  8000b3:	c9                   	leave  
+  8000b4:	c3                   	ret    
+
+008000b5 <syscall>:
+#include <syscall.h>
+
+#define MAX_ARGS            5
+
+static inline int
+syscall(int num, ...) {
+  8000b5:	55                   	push   %ebp
+  8000b6:	89 e5                	mov    %esp,%ebp
+  8000b8:	57                   	push   %edi
+  8000b9:	56                   	push   %esi
+  8000ba:	53                   	push   %ebx
+  8000bb:	83 ec 20             	sub    $0x20,%esp
+    va_list ap;
+    va_start(ap, num);
+  8000be:	8d 45 0c             	lea    0xc(%ebp),%eax
+  8000c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    uint32_t a[MAX_ARGS];
+    int i, ret;
+    for (i = 0; i < MAX_ARGS; i ++) {
+  8000c4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  8000cb:	eb 16                	jmp    8000e3 <syscall+0x2e>
+        a[i] = va_arg(ap, uint32_t);
+  8000cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8000d0:	8d 50 04             	lea    0x4(%eax),%edx
+  8000d3:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  8000d6:	8b 10                	mov    (%eax),%edx
+  8000d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8000db:	89 54 85 d4          	mov    %edx,-0x2c(%ebp,%eax,4)
+syscall(int num, ...) {
+    va_list ap;
+    va_start(ap, num);
+    uint32_t a[MAX_ARGS];
+    int i, ret;
+    for (i = 0; i < MAX_ARGS; i ++) {
+  8000df:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+  8000e3:	83 7d f0 04          	cmpl   $0x4,-0x10(%ebp)
+  8000e7:	7e e4                	jle    8000cd <syscall+0x18>
+    asm volatile (
+        "int %1;"
+        : "=a" (ret)
+        : "i" (T_SYSCALL),
+          "a" (num),
+          "d" (a[0]),
+  8000e9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+          "c" (a[1]),
+  8000ec:	8b 4d d8             	mov    -0x28(%ebp),%ecx
+          "b" (a[2]),
+  8000ef:	8b 5d dc             	mov    -0x24(%ebp),%ebx
+          "D" (a[3]),
+  8000f2:	8b 7d e0             	mov    -0x20(%ebp),%edi
+          "S" (a[4])
+  8000f5:	8b 75 e4             	mov    -0x1c(%ebp),%esi
+    for (i = 0; i < MAX_ARGS; i ++) {
+        a[i] = va_arg(ap, uint32_t);
+    }
+    va_end(ap);
+
+    asm volatile (
+  8000f8:	8b 45 08             	mov    0x8(%ebp),%eax
+  8000fb:	cd 80                	int    $0x80
+  8000fd:	89 45 ec             	mov    %eax,-0x14(%ebp)
+          "c" (a[1]),
+          "b" (a[2]),
+          "D" (a[3]),
+          "S" (a[4])
+        : "cc", "memory");
+    return ret;
+  800100:	8b 45 ec             	mov    -0x14(%ebp),%eax
+}
+  800103:	83 c4 20             	add    $0x20,%esp
+  800106:	5b                   	pop    %ebx
+  800107:	5e                   	pop    %esi
+  800108:	5f                   	pop    %edi
+  800109:	5d                   	pop    %ebp
+  80010a:	c3                   	ret    
+
+0080010b <sys_exit>:
+
+int
+sys_exit(int error_code) {
+  80010b:	55                   	push   %ebp
+  80010c:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_exit, error_code);
+  80010e:	ff 75 08             	pushl  0x8(%ebp)
+  800111:	6a 01                	push   $0x1
+  800113:	e8 9d ff ff ff       	call   8000b5 <syscall>
+  800118:	83 c4 08             	add    $0x8,%esp
+}
+  80011b:	c9                   	leave  
+  80011c:	c3                   	ret    
+
+0080011d <sys_fork>:
+
+int
+sys_fork(void) {
+  80011d:	55                   	push   %ebp
+  80011e:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_fork);
+  800120:	6a 02                	push   $0x2
+  800122:	e8 8e ff ff ff       	call   8000b5 <syscall>
+  800127:	83 c4 04             	add    $0x4,%esp
+}
+  80012a:	c9                   	leave  
+  80012b:	c3                   	ret    
+
+0080012c <sys_wait>:
+
+int
+sys_wait(int pid, int *store) {
+  80012c:	55                   	push   %ebp
+  80012d:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_wait, pid, store);
+  80012f:	ff 75 0c             	pushl  0xc(%ebp)
+  800132:	ff 75 08             	pushl  0x8(%ebp)
+  800135:	6a 03                	push   $0x3
+  800137:	e8 79 ff ff ff       	call   8000b5 <syscall>
+  80013c:	83 c4 0c             	add    $0xc,%esp
+}
+  80013f:	c9                   	leave  
+  800140:	c3                   	ret    
+
+00800141 <sys_yield>:
+
+int
+sys_yield(void) {
+  800141:	55                   	push   %ebp
+  800142:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_yield);
+  800144:	6a 0a                	push   $0xa
+  800146:	e8 6a ff ff ff       	call   8000b5 <syscall>
+  80014b:	83 c4 04             	add    $0x4,%esp
+}
+  80014e:	c9                   	leave  
+  80014f:	c3                   	ret    
+
+00800150 <sys_kill>:
+
+int
+sys_kill(int pid) {
+  800150:	55                   	push   %ebp
+  800151:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_kill, pid);
+  800153:	ff 75 08             	pushl  0x8(%ebp)
+  800156:	6a 0c                	push   $0xc
+  800158:	e8 58 ff ff ff       	call   8000b5 <syscall>
+  80015d:	83 c4 08             	add    $0x8,%esp
+}
+  800160:	c9                   	leave  
+  800161:	c3                   	ret    
+
+00800162 <sys_getpid>:
+
+int
+sys_getpid(void) {
+  800162:	55                   	push   %ebp
+  800163:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_getpid);
+  800165:	6a 12                	push   $0x12
+  800167:	e8 49 ff ff ff       	call   8000b5 <syscall>
+  80016c:	83 c4 04             	add    $0x4,%esp
+}
+  80016f:	c9                   	leave  
+  800170:	c3                   	ret    
+
+00800171 <sys_putc>:
+
+int
+sys_putc(int c) {
+  800171:	55                   	push   %ebp
+  800172:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_putc, c);
+  800174:	ff 75 08             	pushl  0x8(%ebp)
+  800177:	6a 1e                	push   $0x1e
+  800179:	e8 37 ff ff ff       	call   8000b5 <syscall>
+  80017e:	83 c4 08             	add    $0x8,%esp
+}
+  800181:	c9                   	leave  
+  800182:	c3                   	ret    
+
+00800183 <sys_pgdir>:
+
+int
+sys_pgdir(void) {
+  800183:	55                   	push   %ebp
+  800184:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_pgdir);
+  800186:	6a 1f                	push   $0x1f
+  800188:	e8 28 ff ff ff       	call   8000b5 <syscall>
+  80018d:	83 c4 04             	add    $0x4,%esp
+}
+  800190:	c9                   	leave  
+  800191:	c3                   	ret    
+
+00800192 <sys_gettime>:
+
+int
+sys_gettime(void) {
+  800192:	55                   	push   %ebp
+  800193:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_gettime);
+  800195:	6a 11                	push   $0x11
+  800197:	e8 19 ff ff ff       	call   8000b5 <syscall>
+  80019c:	83 c4 04             	add    $0x4,%esp
+}
+  80019f:	c9                   	leave  
+  8001a0:	c3                   	ret    
+
+008001a1 <sys_lab6_set_priority>:
+
+void
+sys_lab6_set_priority(uint32_t priority)
+{
+  8001a1:	55                   	push   %ebp
+  8001a2:	89 e5                	mov    %esp,%ebp
+    syscall(SYS_lab6_set_priority, priority);
+  8001a4:	ff 75 08             	pushl  0x8(%ebp)
+  8001a7:	68 ff 00 00 00       	push   $0xff
+  8001ac:	e8 04 ff ff ff       	call   8000b5 <syscall>
+  8001b1:	83 c4 08             	add    $0x8,%esp
+}
+  8001b4:	90                   	nop
+  8001b5:	c9                   	leave  
+  8001b6:	c3                   	ret    
+
+008001b7 <exit>:
+#include <syscall.h>
+#include <stdio.h>
+#include <ulib.h>
+
+void
+exit(int error_code) {
+  8001b7:	55                   	push   %ebp
+  8001b8:	89 e5                	mov    %esp,%ebp
+  8001ba:	83 ec 08             	sub    $0x8,%esp
+    sys_exit(error_code);
+  8001bd:	83 ec 0c             	sub    $0xc,%esp
+  8001c0:	ff 75 08             	pushl  0x8(%ebp)
+  8001c3:	e8 43 ff ff ff       	call   80010b <sys_exit>
+  8001c8:	83 c4 10             	add    $0x10,%esp
+    cprintf("BUG: exit failed.\n");
+  8001cb:	83 ec 0c             	sub    $0xc,%esp
+  8001ce:	68 f8 10 80 00       	push   $0x8010f8
+  8001d3:	e8 01 01 00 00       	call   8002d9 <cprintf>
+  8001d8:	83 c4 10             	add    $0x10,%esp
+    while (1);
+  8001db:	eb fe                	jmp    8001db <exit+0x24>
+
+008001dd <fork>:
+}
+
+int
+fork(void) {
+  8001dd:	55                   	push   %ebp
+  8001de:	89 e5                	mov    %esp,%ebp
+  8001e0:	83 ec 08             	sub    $0x8,%esp
+    return sys_fork();
+  8001e3:	e8 35 ff ff ff       	call   80011d <sys_fork>
+}
+  8001e8:	c9                   	leave  
+  8001e9:	c3                   	ret    
+
+008001ea <wait>:
+
+int
+wait(void) {
+  8001ea:	55                   	push   %ebp
+  8001eb:	89 e5                	mov    %esp,%ebp
+  8001ed:	83 ec 08             	sub    $0x8,%esp
+    return sys_wait(0, NULL);
+  8001f0:	83 ec 08             	sub    $0x8,%esp
+  8001f3:	6a 00                	push   $0x0
+  8001f5:	6a 00                	push   $0x0
+  8001f7:	e8 30 ff ff ff       	call   80012c <sys_wait>
+  8001fc:	83 c4 10             	add    $0x10,%esp
+}
+  8001ff:	c9                   	leave  
+  800200:	c3                   	ret    
+
+00800201 <waitpid>:
+
+int
+waitpid(int pid, int *store) {
+  800201:	55                   	push   %ebp
+  800202:	89 e5                	mov    %esp,%ebp
+  800204:	83 ec 08             	sub    $0x8,%esp
+    return sys_wait(pid, store);
+  800207:	83 ec 08             	sub    $0x8,%esp
+  80020a:	ff 75 0c             	pushl  0xc(%ebp)
+  80020d:	ff 75 08             	pushl  0x8(%ebp)
+  800210:	e8 17 ff ff ff       	call   80012c <sys_wait>
+  800215:	83 c4 10             	add    $0x10,%esp
+}
+  800218:	c9                   	leave  
+  800219:	c3                   	ret    
+
+0080021a <yield>:
+
+void
+yield(void) {
+  80021a:	55                   	push   %ebp
+  80021b:	89 e5                	mov    %esp,%ebp
+  80021d:	83 ec 08             	sub    $0x8,%esp
+    sys_yield();
+  800220:	e8 1c ff ff ff       	call   800141 <sys_yield>
+}
+  800225:	90                   	nop
+  800226:	c9                   	leave  
+  800227:	c3                   	ret    
+
+00800228 <kill>:
+
+int
+kill(int pid) {
+  800228:	55                   	push   %ebp
+  800229:	89 e5                	mov    %esp,%ebp
+  80022b:	83 ec 08             	sub    $0x8,%esp
+    return sys_kill(pid);
+  80022e:	83 ec 0c             	sub    $0xc,%esp
+  800231:	ff 75 08             	pushl  0x8(%ebp)
+  800234:	e8 17 ff ff ff       	call   800150 <sys_kill>
+  800239:	83 c4 10             	add    $0x10,%esp
+}
+  80023c:	c9                   	leave  
+  80023d:	c3                   	ret    
+
+0080023e <getpid>:
+
+int
+getpid(void) {
+  80023e:	55                   	push   %ebp
+  80023f:	89 e5                	mov    %esp,%ebp
+  800241:	83 ec 08             	sub    $0x8,%esp
+    return sys_getpid();
+  800244:	e8 19 ff ff ff       	call   800162 <sys_getpid>
+}
+  800249:	c9                   	leave  
+  80024a:	c3                   	ret    
+
+0080024b <print_pgdir>:
+
+//print_pgdir - print the PDT&PT
+void
+print_pgdir(void) {
+  80024b:	55                   	push   %ebp
+  80024c:	89 e5                	mov    %esp,%ebp
+  80024e:	83 ec 08             	sub    $0x8,%esp
+    sys_pgdir();
+  800251:	e8 2d ff ff ff       	call   800183 <sys_pgdir>
+}
+  800256:	90                   	nop
+  800257:	c9                   	leave  
+  800258:	c3                   	ret    
+
+00800259 <gettime_msec>:
+
+unsigned int
+gettime_msec(void) {
+  800259:	55                   	push   %ebp
+  80025a:	89 e5                	mov    %esp,%ebp
+  80025c:	83 ec 08             	sub    $0x8,%esp
+    return (unsigned int)sys_gettime();
+  80025f:	e8 2e ff ff ff       	call   800192 <sys_gettime>
+}
+  800264:	c9                   	leave  
+  800265:	c3                   	ret    
+
+00800266 <lab6_set_priority>:
+
+void
+lab6_set_priority(uint32_t priority)
+{
+  800266:	55                   	push   %ebp
+  800267:	89 e5                	mov    %esp,%ebp
+  800269:	83 ec 08             	sub    $0x8,%esp
+    sys_lab6_set_priority(priority);
+  80026c:	83 ec 0c             	sub    $0xc,%esp
+  80026f:	ff 75 08             	pushl  0x8(%ebp)
+  800272:	e8 2a ff ff ff       	call   8001a1 <sys_lab6_set_priority>
+  800277:	83 c4 10             	add    $0x10,%esp
+}
+  80027a:	90                   	nop
+  80027b:	c9                   	leave  
+  80027c:	c3                   	ret    
+
+0080027d <_start>:
+.text
+.globl _start
+_start:
+    # set ebp for backtrace
+    movl $0x0, %ebp
+  80027d:	bd 00 00 00 00       	mov    $0x0,%ebp
+
+    # move down the esp register
+    # since it may cause page fault in backtrace
+    subl $0x20, %esp
+  800282:	83 ec 20             	sub    $0x20,%esp
+
+    # call user-program function
+    call umain
+  800285:	e8 c3 00 00 00       	call   80034d <umain>
+1:  jmp 1b
+  80028a:	eb fe                	jmp    80028a <_start+0xd>
+
+0080028c <cputch>:
+/* *
+ * cputch - writes a single character @c to stdout, and it will
+ * increace the value of counter pointed by @cnt.
+ * */
+static void
+cputch(int c, int *cnt) {
+  80028c:	55                   	push   %ebp
+  80028d:	89 e5                	mov    %esp,%ebp
+  80028f:	83 ec 08             	sub    $0x8,%esp
+    sys_putc(c);
+  800292:	83 ec 0c             	sub    $0xc,%esp
+  800295:	ff 75 08             	pushl  0x8(%ebp)
+  800298:	e8 d4 fe ff ff       	call   800171 <sys_putc>
+  80029d:	83 c4 10             	add    $0x10,%esp
+    (*cnt) ++;
+  8002a0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002a3:	8b 00                	mov    (%eax),%eax
+  8002a5:	8d 50 01             	lea    0x1(%eax),%edx
+  8002a8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002ab:	89 10                	mov    %edx,(%eax)
+}
+  8002ad:	90                   	nop
+  8002ae:	c9                   	leave  
+  8002af:	c3                   	ret    
+
+008002b0 <vcprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want cprintf() instead.
+ * */
+int
+vcprintf(const char *fmt, va_list ap) {
+  8002b0:	55                   	push   %ebp
+  8002b1:	89 e5                	mov    %esp,%ebp
+  8002b3:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+  8002b6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    vprintfmt((void*)cputch, &cnt, fmt, ap);
+  8002bd:	ff 75 0c             	pushl  0xc(%ebp)
+  8002c0:	ff 75 08             	pushl  0x8(%ebp)
+  8002c3:	8d 45 f4             	lea    -0xc(%ebp),%eax
+  8002c6:	50                   	push   %eax
+  8002c7:	68 8c 02 80 00       	push   $0x80028c
+  8002cc:	e8 fc 06 00 00       	call   8009cd <vprintfmt>
+  8002d1:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+  8002d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8002d7:	c9                   	leave  
+  8002d8:	c3                   	ret    
+
+008002d9 <cprintf>:
+ *
+ * The return value is the number of characters which would be
+ * written to stdout.
+ * */
+int
+cprintf(const char *fmt, ...) {
+  8002d9:	55                   	push   %ebp
+  8002da:	89 e5                	mov    %esp,%ebp
+  8002dc:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  8002df:	8d 45 0c             	lea    0xc(%ebp),%eax
+  8002e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    int cnt = vcprintf(fmt, ap);
+  8002e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8002e8:	83 ec 08             	sub    $0x8,%esp
+  8002eb:	50                   	push   %eax
+  8002ec:	ff 75 08             	pushl  0x8(%ebp)
+  8002ef:	e8 bc ff ff ff       	call   8002b0 <vcprintf>
+  8002f4:	83 c4 10             	add    $0x10,%esp
+  8002f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+
+    return cnt;
+  8002fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8002fd:	c9                   	leave  
+  8002fe:	c3                   	ret    
+
+008002ff <cputs>:
+/* *
+ * cputs- writes the string pointed by @str to stdout and
+ * appends a newline character.
+ * */
+int
+cputs(const char *str) {
+  8002ff:	55                   	push   %ebp
+  800300:	89 e5                	mov    %esp,%ebp
+  800302:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+  800305:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    char c;
+    while ((c = *str ++) != '\0') {
+  80030c:	eb 14                	jmp    800322 <cputs+0x23>
+        cputch(c, &cnt);
+  80030e:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
+  800312:	83 ec 08             	sub    $0x8,%esp
+  800315:	8d 55 f0             	lea    -0x10(%ebp),%edx
+  800318:	52                   	push   %edx
+  800319:	50                   	push   %eax
+  80031a:	e8 6d ff ff ff       	call   80028c <cputch>
+  80031f:	83 c4 10             	add    $0x10,%esp
+ * */
+int
+cputs(const char *str) {
+    int cnt = 0;
+    char c;
+    while ((c = *str ++) != '\0') {
+  800322:	8b 45 08             	mov    0x8(%ebp),%eax
+  800325:	8d 50 01             	lea    0x1(%eax),%edx
+  800328:	89 55 08             	mov    %edx,0x8(%ebp)
+  80032b:	0f b6 00             	movzbl (%eax),%eax
+  80032e:	88 45 f7             	mov    %al,-0x9(%ebp)
+  800331:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
+  800335:	75 d7                	jne    80030e <cputs+0xf>
+        cputch(c, &cnt);
+    }
+    cputch('\n', &cnt);
+  800337:	83 ec 08             	sub    $0x8,%esp
+  80033a:	8d 45 f0             	lea    -0x10(%ebp),%eax
+  80033d:	50                   	push   %eax
+  80033e:	6a 0a                	push   $0xa
+  800340:	e8 47 ff ff ff       	call   80028c <cputch>
+  800345:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+  800348:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+  80034b:	c9                   	leave  
+  80034c:	c3                   	ret    
+
+0080034d <umain>:
+#include <ulib.h>
+
+int main(void);
+
+void
+umain(void) {
+  80034d:	55                   	push   %ebp
+  80034e:	89 e5                	mov    %esp,%ebp
+  800350:	83 ec 18             	sub    $0x18,%esp
+    int ret = main();
+  800353:	e8 90 0c 00 00       	call   800fe8 <main>
+  800358:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    exit(ret);
+  80035b:	83 ec 0c             	sub    $0xc,%esp
+  80035e:	ff 75 f4             	pushl  -0xc(%ebp)
+  800361:	e8 51 fe ff ff       	call   8001b7 <exit>
+
+00800366 <strlen>:
+ * @s:      the input string
+ *
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+  800366:	55                   	push   %ebp
+  800367:	89 e5                	mov    %esp,%ebp
+  800369:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  80036c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (*s ++ != '\0') {
+  800373:	eb 04                	jmp    800379 <strlen+0x13>
+        cnt ++;
+  800375:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+    size_t cnt = 0;
+    while (*s ++ != '\0') {
+  800379:	8b 45 08             	mov    0x8(%ebp),%eax
+  80037c:	8d 50 01             	lea    0x1(%eax),%edx
+  80037f:	89 55 08             	mov    %edx,0x8(%ebp)
+  800382:	0f b6 00             	movzbl (%eax),%eax
+  800385:	84 c0                	test   %al,%al
+  800387:	75 ec                	jne    800375 <strlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  800389:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  80038c:	c9                   	leave  
+  80038d:	c3                   	ret    
+
+0080038e <strnlen>:
+ * The return value is strlen(s), if that is less than @len, or
+ * @len if there is no '\0' character among the first @len characters
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+  80038e:	55                   	push   %ebp
+  80038f:	89 e5                	mov    %esp,%ebp
+  800391:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  800394:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (cnt < len && *s ++ != '\0') {
+  80039b:	eb 04                	jmp    8003a1 <strnlen+0x13>
+        cnt ++;
+  80039d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+    size_t cnt = 0;
+    while (cnt < len && *s ++ != '\0') {
+  8003a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8003a4:	3b 45 0c             	cmp    0xc(%ebp),%eax
+  8003a7:	73 10                	jae    8003b9 <strnlen+0x2b>
+  8003a9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003ac:	8d 50 01             	lea    0x1(%eax),%edx
+  8003af:	89 55 08             	mov    %edx,0x8(%ebp)
+  8003b2:	0f b6 00             	movzbl (%eax),%eax
+  8003b5:	84 c0                	test   %al,%al
+  8003b7:	75 e4                	jne    80039d <strnlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  8003b9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  8003bc:	c9                   	leave  
+  8003bd:	c3                   	ret    
+
+008003be <strcpy>:
+ * To avoid overflows, the size of array pointed by @dst should be long enough to
+ * contain the same string as @src (including the terminating null character), and
+ * should not overlap in memory with @src.
+ * */
+char *
+strcpy(char *dst, const char *src) {
+  8003be:	55                   	push   %ebp
+  8003bf:	89 e5                	mov    %esp,%ebp
+  8003c1:	57                   	push   %edi
+  8003c2:	56                   	push   %esi
+  8003c3:	83 ec 20             	sub    $0x20,%esp
+  8003c6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  8003cc:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8003cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCPY
+#define __HAVE_ARCH_STRCPY
+static inline char *
+__strcpy(char *dst, const char *src) {
+    int d0, d1, d2;
+    asm volatile (
+  8003d2:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  8003d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8003d8:	89 d1                	mov    %edx,%ecx
+  8003da:	89 c2                	mov    %eax,%edx
+  8003dc:	89 ce                	mov    %ecx,%esi
+  8003de:	89 d7                	mov    %edx,%edi
+  8003e0:	ac                   	lods   %ds:(%esi),%al
+  8003e1:	aa                   	stos   %al,%es:(%edi)
+  8003e2:	84 c0                	test   %al,%al
+  8003e4:	75 fa                	jne    8003e0 <strcpy+0x22>
+  8003e6:	89 fa                	mov    %edi,%edx
+  8003e8:	89 f1                	mov    %esi,%ecx
+  8003ea:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  8003ed:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  8003f0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+        "stosb;"
+        "testb %%al, %%al;"
+        "jne 1b;"
+        : "=&S" (d0), "=&D" (d1), "=&a" (d2)
+        : "0" (src), "1" (dst) : "memory");
+    return dst;
+  8003f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCPY
+    return __strcpy(dst, src);
+  8003f6:	90                   	nop
+    char *p = dst;
+    while ((*p ++ = *src ++) != '\0')
+        /* nothing */;
+    return dst;
+#endif /* __HAVE_ARCH_STRCPY */
+}
+  8003f7:	83 c4 20             	add    $0x20,%esp
+  8003fa:	5e                   	pop    %esi
+  8003fb:	5f                   	pop    %edi
+  8003fc:	5d                   	pop    %ebp
+  8003fd:	c3                   	ret    
+
+008003fe <strncpy>:
+ * @len:    maximum number of characters to be copied from @src
+ *
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+  8003fe:	55                   	push   %ebp
+  8003ff:	89 e5                	mov    %esp,%ebp
+  800401:	83 ec 10             	sub    $0x10,%esp
+    char *p = dst;
+  800404:	8b 45 08             	mov    0x8(%ebp),%eax
+  800407:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    while (len > 0) {
+  80040a:	eb 21                	jmp    80042d <strncpy+0x2f>
+        if ((*p = *src) != '\0') {
+  80040c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80040f:	0f b6 10             	movzbl (%eax),%edx
+  800412:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800415:	88 10                	mov    %dl,(%eax)
+  800417:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  80041a:	0f b6 00             	movzbl (%eax),%eax
+  80041d:	84 c0                	test   %al,%al
+  80041f:	74 04                	je     800425 <strncpy+0x27>
+            src ++;
+  800421:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+        }
+        p ++, len --;
+  800425:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800429:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+    char *p = dst;
+    while (len > 0) {
+  80042d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800431:	75 d9                	jne    80040c <strncpy+0xe>
+        if ((*p = *src) != '\0') {
+            src ++;
+        }
+        p ++, len --;
+    }
+    return dst;
+  800433:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800436:	c9                   	leave  
+  800437:	c3                   	ret    
+
+00800438 <strcmp>:
+ * - A value greater than zero indicates that the first character that does
+ *   not match has a greater value in @s1 than in @s2;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+strcmp(const char *s1, const char *s2) {
+  800438:	55                   	push   %ebp
+  800439:	89 e5                	mov    %esp,%ebp
+  80043b:	57                   	push   %edi
+  80043c:	56                   	push   %esi
+  80043d:	83 ec 20             	sub    $0x20,%esp
+  800440:	8b 45 08             	mov    0x8(%ebp),%eax
+  800443:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800446:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800449:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCMP
+#define __HAVE_ARCH_STRCMP
+static inline int
+__strcmp(const char *s1, const char *s2) {
+    int d0, d1, ret;
+    asm volatile (
+  80044c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80044f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800452:	89 d1                	mov    %edx,%ecx
+  800454:	89 c2                	mov    %eax,%edx
+  800456:	89 ce                	mov    %ecx,%esi
+  800458:	89 d7                	mov    %edx,%edi
+  80045a:	ac                   	lods   %ds:(%esi),%al
+  80045b:	ae                   	scas   %es:(%edi),%al
+  80045c:	75 08                	jne    800466 <strcmp+0x2e>
+  80045e:	84 c0                	test   %al,%al
+  800460:	75 f8                	jne    80045a <strcmp+0x22>
+  800462:	31 c0                	xor    %eax,%eax
+  800464:	eb 04                	jmp    80046a <strcmp+0x32>
+  800466:	19 c0                	sbb    %eax,%eax
+  800468:	0c 01                	or     $0x1,%al
+  80046a:	89 fa                	mov    %edi,%edx
+  80046c:	89 f1                	mov    %esi,%ecx
+  80046e:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800471:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  800474:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+        "orb $1, %%al;"
+        "3:"
+        : "=a" (ret), "=&S" (d0), "=&D" (d1)
+        : "1" (s1), "2" (s2)
+        : "memory");
+    return ret;
+  800477:	8b 45 ec             	mov    -0x14(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCMP
+    return __strcmp(s1, s2);
+  80047a:	90                   	nop
+    while (*s1 != '\0' && *s1 == *s2) {
+        s1 ++, s2 ++;
+    }
+    return (int)((unsigned char)*s1 - (unsigned char)*s2);
+#endif /* __HAVE_ARCH_STRCMP */
+}
+  80047b:	83 c4 20             	add    $0x20,%esp
+  80047e:	5e                   	pop    %esi
+  80047f:	5f                   	pop    %edi
+  800480:	5d                   	pop    %ebp
+  800481:	c3                   	ret    
+
+00800482 <strncmp>:
+ * they are equal to each other, it continues with the following pairs until
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+  800482:	55                   	push   %ebp
+  800483:	89 e5                	mov    %esp,%ebp
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  800485:	eb 0c                	jmp    800493 <strncmp+0x11>
+        n --, s1 ++, s2 ++;
+  800487:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  80048b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  80048f:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  800493:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800497:	74 1a                	je     8004b3 <strncmp+0x31>
+  800499:	8b 45 08             	mov    0x8(%ebp),%eax
+  80049c:	0f b6 00             	movzbl (%eax),%eax
+  80049f:	84 c0                	test   %al,%al
+  8004a1:	74 10                	je     8004b3 <strncmp+0x31>
+  8004a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004a6:	0f b6 10             	movzbl (%eax),%edx
+  8004a9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004ac:	0f b6 00             	movzbl (%eax),%eax
+  8004af:	38 c2                	cmp    %al,%dl
+  8004b1:	74 d4                	je     800487 <strncmp+0x5>
+        n --, s1 ++, s2 ++;
+    }
+    return (n == 0) ? 0 : (int)((unsigned char)*s1 - (unsigned char)*s2);
+  8004b3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8004b7:	74 18                	je     8004d1 <strncmp+0x4f>
+  8004b9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004bc:	0f b6 00             	movzbl (%eax),%eax
+  8004bf:	0f b6 d0             	movzbl %al,%edx
+  8004c2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004c5:	0f b6 00             	movzbl (%eax),%eax
+  8004c8:	0f b6 c0             	movzbl %al,%eax
+  8004cb:	29 c2                	sub    %eax,%edx
+  8004cd:	89 d0                	mov    %edx,%eax
+  8004cf:	eb 05                	jmp    8004d6 <strncmp+0x54>
+  8004d1:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  8004d6:	5d                   	pop    %ebp
+  8004d7:	c3                   	ret    
+
+008004d8 <strchr>:
+ *
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+  8004d8:	55                   	push   %ebp
+  8004d9:	89 e5                	mov    %esp,%ebp
+  8004db:	83 ec 04             	sub    $0x4,%esp
+  8004de:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004e1:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  8004e4:	eb 14                	jmp    8004fa <strchr+0x22>
+        if (*s == c) {
+  8004e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004e9:	0f b6 00             	movzbl (%eax),%eax
+  8004ec:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  8004ef:	75 05                	jne    8004f6 <strchr+0x1e>
+            return (char *)s;
+  8004f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004f4:	eb 13                	jmp    800509 <strchr+0x31>
+        }
+        s ++;
+  8004f6:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+    while (*s != '\0') {
+  8004fa:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004fd:	0f b6 00             	movzbl (%eax),%eax
+  800500:	84 c0                	test   %al,%al
+  800502:	75 e2                	jne    8004e6 <strchr+0xe>
+        if (*s == c) {
+            return (char *)s;
+        }
+        s ++;
+    }
+    return NULL;
+  800504:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800509:	c9                   	leave  
+  80050a:	c3                   	ret    
+
+0080050b <strfind>:
+ * The strfind() function is like strchr() except that if @c is
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+  80050b:	55                   	push   %ebp
+  80050c:	89 e5                	mov    %esp,%ebp
+  80050e:	83 ec 04             	sub    $0x4,%esp
+  800511:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800514:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  800517:	eb 0f                	jmp    800528 <strfind+0x1d>
+        if (*s == c) {
+  800519:	8b 45 08             	mov    0x8(%ebp),%eax
+  80051c:	0f b6 00             	movzbl (%eax),%eax
+  80051f:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800522:	74 10                	je     800534 <strfind+0x29>
+            break;
+        }
+        s ++;
+  800524:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+    while (*s != '\0') {
+  800528:	8b 45 08             	mov    0x8(%ebp),%eax
+  80052b:	0f b6 00             	movzbl (%eax),%eax
+  80052e:	84 c0                	test   %al,%al
+  800530:	75 e7                	jne    800519 <strfind+0xe>
+  800532:	eb 01                	jmp    800535 <strfind+0x2a>
+        if (*s == c) {
+            break;
+  800534:	90                   	nop
+        }
+        s ++;
+    }
+    return (char *)s;
+  800535:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800538:	c9                   	leave  
+  800539:	c3                   	ret    
+
+0080053a <strtol>:
+ * an optional "0x" or "0X" prefix.
+ *
+ * The strtol() function returns the converted integral number as a long int value.
+ * */
+long
+strtol(const char *s, char **endptr, int base) {
+  80053a:	55                   	push   %ebp
+  80053b:	89 e5                	mov    %esp,%ebp
+  80053d:	83 ec 10             	sub    $0x10,%esp
+    int neg = 0;
+  800540:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    long val = 0;
+  800547:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  80054e:	eb 04                	jmp    800554 <strtol+0x1a>
+        s ++;
+  800550:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+strtol(const char *s, char **endptr, int base) {
+    int neg = 0;
+    long val = 0;
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  800554:	8b 45 08             	mov    0x8(%ebp),%eax
+  800557:	0f b6 00             	movzbl (%eax),%eax
+  80055a:	3c 20                	cmp    $0x20,%al
+  80055c:	74 f2                	je     800550 <strtol+0x16>
+  80055e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800561:	0f b6 00             	movzbl (%eax),%eax
+  800564:	3c 09                	cmp    $0x9,%al
+  800566:	74 e8                	je     800550 <strtol+0x16>
+        s ++;
+    }
+
+    // plus/minus sign
+    if (*s == '+') {
+  800568:	8b 45 08             	mov    0x8(%ebp),%eax
+  80056b:	0f b6 00             	movzbl (%eax),%eax
+  80056e:	3c 2b                	cmp    $0x2b,%al
+  800570:	75 06                	jne    800578 <strtol+0x3e>
+        s ++;
+  800572:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800576:	eb 15                	jmp    80058d <strtol+0x53>
+    }
+    else if (*s == '-') {
+  800578:	8b 45 08             	mov    0x8(%ebp),%eax
+  80057b:	0f b6 00             	movzbl (%eax),%eax
+  80057e:	3c 2d                	cmp    $0x2d,%al
+  800580:	75 0b                	jne    80058d <strtol+0x53>
+        s ++, neg = 1;
+  800582:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800586:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+    }
+
+    // hex or octal base prefix
+    if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x')) {
+  80058d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800591:	74 06                	je     800599 <strtol+0x5f>
+  800593:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+  800597:	75 24                	jne    8005bd <strtol+0x83>
+  800599:	8b 45 08             	mov    0x8(%ebp),%eax
+  80059c:	0f b6 00             	movzbl (%eax),%eax
+  80059f:	3c 30                	cmp    $0x30,%al
+  8005a1:	75 1a                	jne    8005bd <strtol+0x83>
+  8005a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005a6:	83 c0 01             	add    $0x1,%eax
+  8005a9:	0f b6 00             	movzbl (%eax),%eax
+  8005ac:	3c 78                	cmp    $0x78,%al
+  8005ae:	75 0d                	jne    8005bd <strtol+0x83>
+        s += 2, base = 16;
+  8005b0:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+  8005b4:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+  8005bb:	eb 2a                	jmp    8005e7 <strtol+0xad>
+    }
+    else if (base == 0 && s[0] == '0') {
+  8005bd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8005c1:	75 17                	jne    8005da <strtol+0xa0>
+  8005c3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005c6:	0f b6 00             	movzbl (%eax),%eax
+  8005c9:	3c 30                	cmp    $0x30,%al
+  8005cb:	75 0d                	jne    8005da <strtol+0xa0>
+        s ++, base = 8;
+  8005cd:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  8005d1:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+  8005d8:	eb 0d                	jmp    8005e7 <strtol+0xad>
+    }
+    else if (base == 0) {
+  8005da:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8005de:	75 07                	jne    8005e7 <strtol+0xad>
+        base = 10;
+  8005e0:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+    // digits
+    while (1) {
+        int dig;
+
+        if (*s >= '0' && *s <= '9') {
+  8005e7:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005ea:	0f b6 00             	movzbl (%eax),%eax
+  8005ed:	3c 2f                	cmp    $0x2f,%al
+  8005ef:	7e 1b                	jle    80060c <strtol+0xd2>
+  8005f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005f4:	0f b6 00             	movzbl (%eax),%eax
+  8005f7:	3c 39                	cmp    $0x39,%al
+  8005f9:	7f 11                	jg     80060c <strtol+0xd2>
+            dig = *s - '0';
+  8005fb:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005fe:	0f b6 00             	movzbl (%eax),%eax
+  800601:	0f be c0             	movsbl %al,%eax
+  800604:	83 e8 30             	sub    $0x30,%eax
+  800607:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80060a:	eb 48                	jmp    800654 <strtol+0x11a>
+        }
+        else if (*s >= 'a' && *s <= 'z') {
+  80060c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80060f:	0f b6 00             	movzbl (%eax),%eax
+  800612:	3c 60                	cmp    $0x60,%al
+  800614:	7e 1b                	jle    800631 <strtol+0xf7>
+  800616:	8b 45 08             	mov    0x8(%ebp),%eax
+  800619:	0f b6 00             	movzbl (%eax),%eax
+  80061c:	3c 7a                	cmp    $0x7a,%al
+  80061e:	7f 11                	jg     800631 <strtol+0xf7>
+            dig = *s - 'a' + 10;
+  800620:	8b 45 08             	mov    0x8(%ebp),%eax
+  800623:	0f b6 00             	movzbl (%eax),%eax
+  800626:	0f be c0             	movsbl %al,%eax
+  800629:	83 e8 57             	sub    $0x57,%eax
+  80062c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80062f:	eb 23                	jmp    800654 <strtol+0x11a>
+        }
+        else if (*s >= 'A' && *s <= 'Z') {
+  800631:	8b 45 08             	mov    0x8(%ebp),%eax
+  800634:	0f b6 00             	movzbl (%eax),%eax
+  800637:	3c 40                	cmp    $0x40,%al
+  800639:	7e 3c                	jle    800677 <strtol+0x13d>
+  80063b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80063e:	0f b6 00             	movzbl (%eax),%eax
+  800641:	3c 5a                	cmp    $0x5a,%al
+  800643:	7f 32                	jg     800677 <strtol+0x13d>
+            dig = *s - 'A' + 10;
+  800645:	8b 45 08             	mov    0x8(%ebp),%eax
+  800648:	0f b6 00             	movzbl (%eax),%eax
+  80064b:	0f be c0             	movsbl %al,%eax
+  80064e:	83 e8 37             	sub    $0x37,%eax
+  800651:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+  800654:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800657:	3b 45 10             	cmp    0x10(%ebp),%eax
+  80065a:	7d 1a                	jge    800676 <strtol+0x13c>
+            break;
+        }
+        s ++, val = (val * base) + dig;
+  80065c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800660:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800663:	0f af 45 10          	imul   0x10(%ebp),%eax
+  800667:	89 c2                	mov    %eax,%edx
+  800669:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  80066c:	01 d0                	add    %edx,%eax
+  80066e:	89 45 f8             	mov    %eax,-0x8(%ebp)
+        // we don't properly detect overflow!
+    }
+  800671:	e9 71 ff ff ff       	jmp    8005e7 <strtol+0xad>
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+            break;
+  800676:	90                   	nop
+        }
+        s ++, val = (val * base) + dig;
+        // we don't properly detect overflow!
+    }
+
+    if (endptr) {
+  800677:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  80067b:	74 08                	je     800685 <strtol+0x14b>
+        *endptr = (char *) s;
+  80067d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800680:	8b 55 08             	mov    0x8(%ebp),%edx
+  800683:	89 10                	mov    %edx,(%eax)
+    }
+    return (neg ? -val : val);
+  800685:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+  800689:	74 07                	je     800692 <strtol+0x158>
+  80068b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  80068e:	f7 d8                	neg    %eax
+  800690:	eb 03                	jmp    800695 <strtol+0x15b>
+  800692:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  800695:	c9                   	leave  
+  800696:	c3                   	ret    
+
+00800697 <memset>:
+ * @n:      number of bytes to be set to the value
+ *
+ * The memset() function returns @s.
+ * */
+void *
+memset(void *s, char c, size_t n) {
+  800697:	55                   	push   %ebp
+  800698:	89 e5                	mov    %esp,%ebp
+  80069a:	57                   	push   %edi
+  80069b:	83 ec 24             	sub    $0x24,%esp
+  80069e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006a1:	88 45 d8             	mov    %al,-0x28(%ebp)
+#ifdef __HAVE_ARCH_MEMSET
+    return __memset(s, c, n);
+  8006a4:	0f be 45 d8          	movsbl -0x28(%ebp),%eax
+  8006a8:	8b 55 08             	mov    0x8(%ebp),%edx
+  8006ab:	89 55 f8             	mov    %edx,-0x8(%ebp)
+  8006ae:	88 45 f7             	mov    %al,-0x9(%ebp)
+  8006b1:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_MEMSET
+#define __HAVE_ARCH_MEMSET
+static inline void *
+__memset(void *s, char c, size_t n) {
+    int d0, d1;
+    asm volatile (
+  8006b7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+  8006ba:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
+  8006be:	8b 55 f8             	mov    -0x8(%ebp),%edx
+  8006c1:	89 d7                	mov    %edx,%edi
+  8006c3:	f3 aa                	rep stos %al,%es:(%edi)
+  8006c5:	89 fa                	mov    %edi,%edx
+  8006c7:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  8006ca:	89 55 e8             	mov    %edx,-0x18(%ebp)
+        "rep; stosb;"
+        : "=&c" (d0), "=&D" (d1)
+        : "0" (n), "a" (c), "1" (s)
+        : "memory");
+    return s;
+  8006cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8006d0:	90                   	nop
+    while (n -- > 0) {
+        *p ++ = c;
+    }
+    return s;
+#endif /* __HAVE_ARCH_MEMSET */
+}
+  8006d1:	83 c4 24             	add    $0x24,%esp
+  8006d4:	5f                   	pop    %edi
+  8006d5:	5d                   	pop    %ebp
+  8006d6:	c3                   	ret    
+
+008006d7 <memmove>:
+ * @n:      number of bytes to copy
+ *
+ * The memmove() function returns @dst.
+ * */
+void *
+memmove(void *dst, const void *src, size_t n) {
+  8006d7:	55                   	push   %ebp
+  8006d8:	89 e5                	mov    %esp,%ebp
+  8006da:	57                   	push   %edi
+  8006db:	56                   	push   %esi
+  8006dc:	53                   	push   %ebx
+  8006dd:	83 ec 30             	sub    $0x30,%esp
+  8006e0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8006e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8006e6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  8006ec:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006ef:	89 45 e8             	mov    %eax,-0x18(%ebp)
+
+#ifndef __HAVE_ARCH_MEMMOVE
+#define __HAVE_ARCH_MEMMOVE
+static inline void *
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+  8006f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006f5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  8006f8:	73 42                	jae    80073c <memmove+0x65>
+  8006fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006fd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800700:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800703:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800706:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800709:	89 45 dc             	mov    %eax,-0x24(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  80070c:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  80070f:	c1 e8 02             	shr    $0x2,%eax
+  800712:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  800714:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800717:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80071a:	89 d7                	mov    %edx,%edi
+  80071c:	89 c6                	mov    %eax,%esi
+  80071e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800720:	8b 4d dc             	mov    -0x24(%ebp),%ecx
+  800723:	83 e1 03             	and    $0x3,%ecx
+  800726:	74 02                	je     80072a <memmove+0x53>
+  800728:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  80072a:	89 f0                	mov    %esi,%eax
+  80072c:	89 fa                	mov    %edi,%edx
+  80072e:	89 4d d8             	mov    %ecx,-0x28(%ebp)
+  800731:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  800734:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  800737:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMMOVE
+    return __memmove(dst, src, n);
+  80073a:	eb 36                	jmp    800772 <memmove+0x9b>
+    asm volatile (
+        "std;"
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+  80073c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80073f:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800742:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800745:	01 c2                	add    %eax,%edx
+  800747:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80074a:	8d 48 ff             	lea    -0x1(%eax),%ecx
+  80074d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800750:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+        return __memcpy(dst, src, n);
+    }
+    int d0, d1, d2;
+    asm volatile (
+  800753:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800756:	89 c1                	mov    %eax,%ecx
+  800758:	89 d8                	mov    %ebx,%eax
+  80075a:	89 d6                	mov    %edx,%esi
+  80075c:	89 c7                	mov    %eax,%edi
+  80075e:	fd                   	std    
+  80075f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  800761:	fc                   	cld    
+  800762:	89 f8                	mov    %edi,%eax
+  800764:	89 f2                	mov    %esi,%edx
+  800766:	89 4d cc             	mov    %ecx,-0x34(%ebp)
+  800769:	89 55 c8             	mov    %edx,-0x38(%ebp)
+  80076c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+        : "memory");
+    return dst;
+  80076f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+            *d ++ = *s ++;
+        }
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMMOVE */
+}
+  800772:	83 c4 30             	add    $0x30,%esp
+  800775:	5b                   	pop    %ebx
+  800776:	5e                   	pop    %esi
+  800777:	5f                   	pop    %edi
+  800778:	5d                   	pop    %ebp
+  800779:	c3                   	ret    
+
+0080077a <memcpy>:
+ * it always copies exactly @n bytes. To avoid overflows, the size of arrays pointed
+ * by both @src and @dst, should be at least @n bytes, and should not overlap
+ * (for overlapping memory area, memmove is a safer approach).
+ * */
+void *
+memcpy(void *dst, const void *src, size_t n) {
+  80077a:	55                   	push   %ebp
+  80077b:	89 e5                	mov    %esp,%ebp
+  80077d:	57                   	push   %edi
+  80077e:	56                   	push   %esi
+  80077f:	83 ec 20             	sub    $0x20,%esp
+  800782:	8b 45 08             	mov    0x8(%ebp),%eax
+  800785:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800788:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80078b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80078e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800791:	89 45 ec             	mov    %eax,-0x14(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  800794:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800797:	c1 e8 02             	shr    $0x2,%eax
+  80079a:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  80079c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80079f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8007a2:	89 d7                	mov    %edx,%edi
+  8007a4:	89 c6                	mov    %eax,%esi
+  8007a6:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  8007a8:	8b 4d ec             	mov    -0x14(%ebp),%ecx
+  8007ab:	83 e1 03             	and    $0x3,%ecx
+  8007ae:	74 02                	je     8007b2 <memcpy+0x38>
+  8007b0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  8007b2:	89 f0                	mov    %esi,%eax
+  8007b4:	89 fa                	mov    %edi,%edx
+  8007b6:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  8007b9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  8007bc:	89 45 e0             	mov    %eax,-0x20(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  8007bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMCPY
+    return __memcpy(dst, src, n);
+  8007c2:	90                   	nop
+    while (n -- > 0) {
+        *d ++ = *s ++;
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMCPY */
+}
+  8007c3:	83 c4 20             	add    $0x20,%esp
+  8007c6:	5e                   	pop    %esi
+  8007c7:	5f                   	pop    %edi
+  8007c8:	5d                   	pop    %ebp
+  8007c9:	c3                   	ret    
+
+008007ca <memcmp>:
+ *   match in both memory blocks has a greater value in @v1 than in @v2
+ *   as if evaluated as unsigned char values;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+  8007ca:	55                   	push   %ebp
+  8007cb:	89 e5                	mov    %esp,%ebp
+  8007cd:	83 ec 10             	sub    $0x10,%esp
+    const char *s1 = (const char *)v1;
+  8007d0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8007d3:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    const char *s2 = (const char *)v2;
+  8007d6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8007d9:	89 45 f8             	mov    %eax,-0x8(%ebp)
+    while (n -- > 0) {
+  8007dc:	eb 30                	jmp    80080e <memcmp+0x44>
+        if (*s1 != *s2) {
+  8007de:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8007e1:	0f b6 10             	movzbl (%eax),%edx
+  8007e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8007e7:	0f b6 00             	movzbl (%eax),%eax
+  8007ea:	38 c2                	cmp    %al,%dl
+  8007ec:	74 18                	je     800806 <memcmp+0x3c>
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+  8007ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8007f1:	0f b6 00             	movzbl (%eax),%eax
+  8007f4:	0f b6 d0             	movzbl %al,%edx
+  8007f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8007fa:	0f b6 00             	movzbl (%eax),%eax
+  8007fd:	0f b6 c0             	movzbl %al,%eax
+  800800:	29 c2                	sub    %eax,%edx
+  800802:	89 d0                	mov    %edx,%eax
+  800804:	eb 1a                	jmp    800820 <memcmp+0x56>
+        }
+        s1 ++, s2 ++;
+  800806:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  80080a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+    const char *s1 = (const char *)v1;
+    const char *s2 = (const char *)v2;
+    while (n -- > 0) {
+  80080e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800811:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800814:	89 55 10             	mov    %edx,0x10(%ebp)
+  800817:	85 c0                	test   %eax,%eax
+  800819:	75 c3                	jne    8007de <memcmp+0x14>
+        if (*s1 != *s2) {
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+        }
+        s1 ++, s2 ++;
+    }
+    return 0;
+  80081b:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800820:	c9                   	leave  
+  800821:	c3                   	ret    
+
+00800822 <printnum>:
+ * @width:      maximum number of digits, if the actual width is less than @width, use @padc instead
+ * @padc:       character that padded on the left if the actual width is less than @width
+ * */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+        unsigned long long num, unsigned base, int width, int padc) {
+  800822:	55                   	push   %ebp
+  800823:	89 e5                	mov    %esp,%ebp
+  800825:	83 ec 38             	sub    $0x38,%esp
+  800828:	8b 45 10             	mov    0x10(%ebp),%eax
+  80082b:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  80082e:	8b 45 14             	mov    0x14(%ebp),%eax
+  800831:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+    unsigned long long result = num;
+  800834:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  800837:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  80083a:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  80083d:	89 55 ec             	mov    %edx,-0x14(%ebp)
+    unsigned mod = do_div(result, base);
+  800840:	8b 45 18             	mov    0x18(%ebp),%eax
+  800843:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800846:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800849:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  80084c:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  80084f:	89 55 f0             	mov    %edx,-0x10(%ebp)
+  800852:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800855:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800858:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  80085c:	74 1c                	je     80087a <printnum+0x58>
+  80085e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800861:	ba 00 00 00 00       	mov    $0x0,%edx
+  800866:	f7 75 e4             	divl   -0x1c(%ebp)
+  800869:	89 55 f4             	mov    %edx,-0xc(%ebp)
+  80086c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  80086f:	ba 00 00 00 00       	mov    $0x0,%edx
+  800874:	f7 75 e4             	divl   -0x1c(%ebp)
+  800877:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80087a:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80087d:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800880:	f7 75 e4             	divl   -0x1c(%ebp)
+  800883:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800886:	89 55 dc             	mov    %edx,-0x24(%ebp)
+  800889:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80088c:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  80088f:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800892:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  800895:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  800898:	89 45 d8             	mov    %eax,-0x28(%ebp)
+
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+  80089b:	8b 45 18             	mov    0x18(%ebp),%eax
+  80089e:	ba 00 00 00 00       	mov    $0x0,%edx
+  8008a3:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  8008a6:	77 41                	ja     8008e9 <printnum+0xc7>
+  8008a8:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  8008ab:	72 05                	jb     8008b2 <printnum+0x90>
+  8008ad:	3b 45 d0             	cmp    -0x30(%ebp),%eax
+  8008b0:	77 37                	ja     8008e9 <printnum+0xc7>
+        printnum(putch, putdat, result, base, width - 1, padc);
+  8008b2:	8b 45 1c             	mov    0x1c(%ebp),%eax
+  8008b5:	83 e8 01             	sub    $0x1,%eax
+  8008b8:	83 ec 04             	sub    $0x4,%esp
+  8008bb:	ff 75 20             	pushl  0x20(%ebp)
+  8008be:	50                   	push   %eax
+  8008bf:	ff 75 18             	pushl  0x18(%ebp)
+  8008c2:	ff 75 ec             	pushl  -0x14(%ebp)
+  8008c5:	ff 75 e8             	pushl  -0x18(%ebp)
+  8008c8:	ff 75 0c             	pushl  0xc(%ebp)
+  8008cb:	ff 75 08             	pushl  0x8(%ebp)
+  8008ce:	e8 4f ff ff ff       	call   800822 <printnum>
+  8008d3:	83 c4 20             	add    $0x20,%esp
+  8008d6:	eb 1b                	jmp    8008f3 <printnum+0xd1>
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+            putch(padc, putdat);
+  8008d8:	83 ec 08             	sub    $0x8,%esp
+  8008db:	ff 75 0c             	pushl  0xc(%ebp)
+  8008de:	ff 75 20             	pushl  0x20(%ebp)
+  8008e1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8008e4:	ff d0                	call   *%eax
+  8008e6:	83 c4 10             	add    $0x10,%esp
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+        printnum(putch, putdat, result, base, width - 1, padc);
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+  8008e9:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+  8008ed:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+  8008f1:	7f e5                	jg     8008d8 <printnum+0xb6>
+            putch(padc, putdat);
+    }
+    // then print this (the least significant) digit
+    putch("0123456789abcdef"[mod], putdat);
+  8008f3:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  8008f6:	05 24 12 80 00       	add    $0x801224,%eax
+  8008fb:	0f b6 00             	movzbl (%eax),%eax
+  8008fe:	0f be c0             	movsbl %al,%eax
+  800901:	83 ec 08             	sub    $0x8,%esp
+  800904:	ff 75 0c             	pushl  0xc(%ebp)
+  800907:	50                   	push   %eax
+  800908:	8b 45 08             	mov    0x8(%ebp),%eax
+  80090b:	ff d0                	call   *%eax
+  80090d:	83 c4 10             	add    $0x10,%esp
+}
+  800910:	90                   	nop
+  800911:	c9                   	leave  
+  800912:	c3                   	ret    
+
+00800913 <getuint>:
+ * getuint - get an unsigned int of various possible sizes from a varargs list
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static unsigned long long
+getuint(va_list *ap, int lflag) {
+  800913:	55                   	push   %ebp
+  800914:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  800916:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  80091a:	7e 14                	jle    800930 <getuint+0x1d>
+        return va_arg(*ap, unsigned long long);
+  80091c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80091f:	8b 00                	mov    (%eax),%eax
+  800921:	8d 48 08             	lea    0x8(%eax),%ecx
+  800924:	8b 55 08             	mov    0x8(%ebp),%edx
+  800927:	89 0a                	mov    %ecx,(%edx)
+  800929:	8b 50 04             	mov    0x4(%eax),%edx
+  80092c:	8b 00                	mov    (%eax),%eax
+  80092e:	eb 30                	jmp    800960 <getuint+0x4d>
+    }
+    else if (lflag) {
+  800930:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800934:	74 16                	je     80094c <getuint+0x39>
+        return va_arg(*ap, unsigned long);
+  800936:	8b 45 08             	mov    0x8(%ebp),%eax
+  800939:	8b 00                	mov    (%eax),%eax
+  80093b:	8d 48 04             	lea    0x4(%eax),%ecx
+  80093e:	8b 55 08             	mov    0x8(%ebp),%edx
+  800941:	89 0a                	mov    %ecx,(%edx)
+  800943:	8b 00                	mov    (%eax),%eax
+  800945:	ba 00 00 00 00       	mov    $0x0,%edx
+  80094a:	eb 14                	jmp    800960 <getuint+0x4d>
+    }
+    else {
+        return va_arg(*ap, unsigned int);
+  80094c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80094f:	8b 00                	mov    (%eax),%eax
+  800951:	8d 48 04             	lea    0x4(%eax),%ecx
+  800954:	8b 55 08             	mov    0x8(%ebp),%edx
+  800957:	89 0a                	mov    %ecx,(%edx)
+  800959:	8b 00                	mov    (%eax),%eax
+  80095b:	ba 00 00 00 00       	mov    $0x0,%edx
+    }
+}
+  800960:	5d                   	pop    %ebp
+  800961:	c3                   	ret    
+
+00800962 <getint>:
+ * getint - same as getuint but signed, we can't use getuint because of sign extension
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static long long
+getint(va_list *ap, int lflag) {
+  800962:	55                   	push   %ebp
+  800963:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  800965:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  800969:	7e 14                	jle    80097f <getint+0x1d>
+        return va_arg(*ap, long long);
+  80096b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80096e:	8b 00                	mov    (%eax),%eax
+  800970:	8d 48 08             	lea    0x8(%eax),%ecx
+  800973:	8b 55 08             	mov    0x8(%ebp),%edx
+  800976:	89 0a                	mov    %ecx,(%edx)
+  800978:	8b 50 04             	mov    0x4(%eax),%edx
+  80097b:	8b 00                	mov    (%eax),%eax
+  80097d:	eb 28                	jmp    8009a7 <getint+0x45>
+    }
+    else if (lflag) {
+  80097f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800983:	74 12                	je     800997 <getint+0x35>
+        return va_arg(*ap, long);
+  800985:	8b 45 08             	mov    0x8(%ebp),%eax
+  800988:	8b 00                	mov    (%eax),%eax
+  80098a:	8d 48 04             	lea    0x4(%eax),%ecx
+  80098d:	8b 55 08             	mov    0x8(%ebp),%edx
+  800990:	89 0a                	mov    %ecx,(%edx)
+  800992:	8b 00                	mov    (%eax),%eax
+  800994:	99                   	cltd   
+  800995:	eb 10                	jmp    8009a7 <getint+0x45>
+    }
+    else {
+        return va_arg(*ap, int);
+  800997:	8b 45 08             	mov    0x8(%ebp),%eax
+  80099a:	8b 00                	mov    (%eax),%eax
+  80099c:	8d 48 04             	lea    0x4(%eax),%ecx
+  80099f:	8b 55 08             	mov    0x8(%ebp),%edx
+  8009a2:	89 0a                	mov    %ecx,(%edx)
+  8009a4:	8b 00                	mov    (%eax),%eax
+  8009a6:	99                   	cltd   
+    }
+}
+  8009a7:	5d                   	pop    %ebp
+  8009a8:	c3                   	ret    
+
+008009a9 <printfmt>:
+ * @putch:      specified putch function, print a single character
+ * @putdat:     used by @putch function
+ * @fmt:        the format string to use
+ * */
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...) {
+  8009a9:	55                   	push   %ebp
+  8009aa:	89 e5                	mov    %esp,%ebp
+  8009ac:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  8009af:	8d 45 14             	lea    0x14(%ebp),%eax
+  8009b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    vprintfmt(putch, putdat, fmt, ap);
+  8009b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8009b8:	50                   	push   %eax
+  8009b9:	ff 75 10             	pushl  0x10(%ebp)
+  8009bc:	ff 75 0c             	pushl  0xc(%ebp)
+  8009bf:	ff 75 08             	pushl  0x8(%ebp)
+  8009c2:	e8 06 00 00 00       	call   8009cd <vprintfmt>
+  8009c7:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+  8009ca:	90                   	nop
+  8009cb:	c9                   	leave  
+  8009cc:	c3                   	ret    
+
+008009cd <vprintfmt>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want printfmt() instead.
+ * */
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap) {
+  8009cd:	55                   	push   %ebp
+  8009ce:	89 e5                	mov    %esp,%ebp
+  8009d0:	56                   	push   %esi
+  8009d1:	53                   	push   %ebx
+  8009d2:	83 ec 20             	sub    $0x20,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  8009d5:	eb 17                	jmp    8009ee <vprintfmt+0x21>
+            if (ch == '\0') {
+  8009d7:	85 db                	test   %ebx,%ebx
+  8009d9:	0f 84 8e 03 00 00    	je     800d6d <vprintfmt+0x3a0>
+                return;
+            }
+            putch(ch, putdat);
+  8009df:	83 ec 08             	sub    $0x8,%esp
+  8009e2:	ff 75 0c             	pushl  0xc(%ebp)
+  8009e5:	53                   	push   %ebx
+  8009e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009e9:	ff d0                	call   *%eax
+  8009eb:	83 c4 10             	add    $0x10,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  8009ee:	8b 45 10             	mov    0x10(%ebp),%eax
+  8009f1:	8d 50 01             	lea    0x1(%eax),%edx
+  8009f4:	89 55 10             	mov    %edx,0x10(%ebp)
+  8009f7:	0f b6 00             	movzbl (%eax),%eax
+  8009fa:	0f b6 d8             	movzbl %al,%ebx
+  8009fd:	83 fb 25             	cmp    $0x25,%ebx
+  800a00:	75 d5                	jne    8009d7 <vprintfmt+0xa>
+            }
+            putch(ch, putdat);
+        }
+
+        // Process a %-escape sequence
+        char padc = ' ';
+  800a02:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+        width = precision = -1;
+  800a06:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+  800a0d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800a10:	89 45 e8             	mov    %eax,-0x18(%ebp)
+        lflag = altflag = 0;
+  800a13:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+  800a1a:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  800a1d:	89 45 e0             	mov    %eax,-0x20(%ebp)
+
+    reswitch:
+        switch (ch = *(unsigned char *)fmt ++) {
+  800a20:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a23:	8d 50 01             	lea    0x1(%eax),%edx
+  800a26:	89 55 10             	mov    %edx,0x10(%ebp)
+  800a29:	0f b6 00             	movzbl (%eax),%eax
+  800a2c:	0f b6 d8             	movzbl %al,%ebx
+  800a2f:	8d 43 dd             	lea    -0x23(%ebx),%eax
+  800a32:	83 f8 55             	cmp    $0x55,%eax
+  800a35:	0f 87 05 03 00 00    	ja     800d40 <vprintfmt+0x373>
+  800a3b:	8b 04 85 48 12 80 00 	mov    0x801248(,%eax,4),%eax
+  800a42:	ff e0                	jmp    *%eax
+
+        // flag to pad on the right
+        case '-':
+            padc = '-';
+  800a44:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+            goto reswitch;
+  800a48:	eb d6                	jmp    800a20 <vprintfmt+0x53>
+
+        // flag to pad with 0's instead of spaces
+        case '0':
+            padc = '0';
+  800a4a:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+            goto reswitch;
+  800a4e:	eb d0                	jmp    800a20 <vprintfmt+0x53>
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  800a50:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+                precision = precision * 10 + ch - '0';
+  800a57:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800a5a:	89 d0                	mov    %edx,%eax
+  800a5c:	c1 e0 02             	shl    $0x2,%eax
+  800a5f:	01 d0                	add    %edx,%eax
+  800a61:	01 c0                	add    %eax,%eax
+  800a63:	01 d8                	add    %ebx,%eax
+  800a65:	83 e8 30             	sub    $0x30,%eax
+  800a68:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+                ch = *fmt;
+  800a6b:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a6e:	0f b6 00             	movzbl (%eax),%eax
+  800a71:	0f be d8             	movsbl %al,%ebx
+                if (ch < '0' || ch > '9') {
+  800a74:	83 fb 2f             	cmp    $0x2f,%ebx
+  800a77:	7e 39                	jle    800ab2 <vprintfmt+0xe5>
+  800a79:	83 fb 39             	cmp    $0x39,%ebx
+  800a7c:	7f 34                	jg     800ab2 <vprintfmt+0xe5>
+            padc = '0';
+            goto reswitch;
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  800a7e:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+                precision = precision * 10 + ch - '0';
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+  800a82:	eb d3                	jmp    800a57 <vprintfmt+0x8a>
+            goto process_precision;
+
+        case '*':
+            precision = va_arg(ap, int);
+  800a84:	8b 45 14             	mov    0x14(%ebp),%eax
+  800a87:	8d 50 04             	lea    0x4(%eax),%edx
+  800a8a:	89 55 14             	mov    %edx,0x14(%ebp)
+  800a8d:	8b 00                	mov    (%eax),%eax
+  800a8f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+            goto process_precision;
+  800a92:	eb 1f                	jmp    800ab3 <vprintfmt+0xe6>
+
+        case '.':
+            if (width < 0)
+  800a94:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800a98:	79 86                	jns    800a20 <vprintfmt+0x53>
+                width = 0;
+  800a9a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+            goto reswitch;
+  800aa1:	e9 7a ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        case '#':
+            altflag = 1;
+  800aa6:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+            goto reswitch;
+  800aad:	e9 6e ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+            goto process_precision;
+  800ab2:	90                   	nop
+        case '#':
+            altflag = 1;
+            goto reswitch;
+
+        process_precision:
+            if (width < 0)
+  800ab3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ab7:	0f 89 63 ff ff ff    	jns    800a20 <vprintfmt+0x53>
+                width = precision, precision = -1;
+  800abd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800ac0:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800ac3:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+            goto reswitch;
+  800aca:	e9 51 ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        // long flag (doubled for long long)
+        case 'l':
+            lflag ++;
+  800acf:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
+            goto reswitch;
+  800ad3:	e9 48 ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        // character
+        case 'c':
+            putch(va_arg(ap, int), putdat);
+  800ad8:	8b 45 14             	mov    0x14(%ebp),%eax
+  800adb:	8d 50 04             	lea    0x4(%eax),%edx
+  800ade:	89 55 14             	mov    %edx,0x14(%ebp)
+  800ae1:	8b 00                	mov    (%eax),%eax
+  800ae3:	83 ec 08             	sub    $0x8,%esp
+  800ae6:	ff 75 0c             	pushl  0xc(%ebp)
+  800ae9:	50                   	push   %eax
+  800aea:	8b 45 08             	mov    0x8(%ebp),%eax
+  800aed:	ff d0                	call   *%eax
+  800aef:	83 c4 10             	add    $0x10,%esp
+            break;
+  800af2:	e9 71 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // error message
+        case 'e':
+            err = va_arg(ap, int);
+  800af7:	8b 45 14             	mov    0x14(%ebp),%eax
+  800afa:	8d 50 04             	lea    0x4(%eax),%edx
+  800afd:	89 55 14             	mov    %edx,0x14(%ebp)
+  800b00:	8b 18                	mov    (%eax),%ebx
+            if (err < 0) {
+  800b02:	85 db                	test   %ebx,%ebx
+  800b04:	79 02                	jns    800b08 <vprintfmt+0x13b>
+                err = -err;
+  800b06:	f7 db                	neg    %ebx
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+  800b08:	83 fb 18             	cmp    $0x18,%ebx
+  800b0b:	7f 0b                	jg     800b18 <vprintfmt+0x14b>
+  800b0d:	8b 34 9d c0 11 80 00 	mov    0x8011c0(,%ebx,4),%esi
+  800b14:	85 f6                	test   %esi,%esi
+  800b16:	75 19                	jne    800b31 <vprintfmt+0x164>
+                printfmt(putch, putdat, "error %d", err);
+  800b18:	53                   	push   %ebx
+  800b19:	68 35 12 80 00       	push   $0x801235
+  800b1e:	ff 75 0c             	pushl  0xc(%ebp)
+  800b21:	ff 75 08             	pushl  0x8(%ebp)
+  800b24:	e8 80 fe ff ff       	call   8009a9 <printfmt>
+  800b29:	83 c4 10             	add    $0x10,%esp
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+            }
+            break;
+  800b2c:	e9 37 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+                printfmt(putch, putdat, "error %d", err);
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+  800b31:	56                   	push   %esi
+  800b32:	68 3e 12 80 00       	push   $0x80123e
+  800b37:	ff 75 0c             	pushl  0xc(%ebp)
+  800b3a:	ff 75 08             	pushl  0x8(%ebp)
+  800b3d:	e8 67 fe ff ff       	call   8009a9 <printfmt>
+  800b42:	83 c4 10             	add    $0x10,%esp
+            }
+            break;
+  800b45:	e9 1e 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // string
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+  800b4a:	8b 45 14             	mov    0x14(%ebp),%eax
+  800b4d:	8d 50 04             	lea    0x4(%eax),%edx
+  800b50:	89 55 14             	mov    %edx,0x14(%ebp)
+  800b53:	8b 30                	mov    (%eax),%esi
+  800b55:	85 f6                	test   %esi,%esi
+  800b57:	75 05                	jne    800b5e <vprintfmt+0x191>
+                p = "(null)";
+  800b59:	be 41 12 80 00       	mov    $0x801241,%esi
+            }
+            if (width > 0 && padc != '-') {
+  800b5e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800b62:	7e 76                	jle    800bda <vprintfmt+0x20d>
+  800b64:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+  800b68:	74 70                	je     800bda <vprintfmt+0x20d>
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  800b6a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800b6d:	83 ec 08             	sub    $0x8,%esp
+  800b70:	50                   	push   %eax
+  800b71:	56                   	push   %esi
+  800b72:	e8 17 f8 ff ff       	call   80038e <strnlen>
+  800b77:	83 c4 10             	add    $0x10,%esp
+  800b7a:	89 c2                	mov    %eax,%edx
+  800b7c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800b7f:	29 d0                	sub    %edx,%eax
+  800b81:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800b84:	eb 17                	jmp    800b9d <vprintfmt+0x1d0>
+                    putch(padc, putdat);
+  800b86:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+  800b8a:	83 ec 08             	sub    $0x8,%esp
+  800b8d:	ff 75 0c             	pushl  0xc(%ebp)
+  800b90:	50                   	push   %eax
+  800b91:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b94:	ff d0                	call   *%eax
+  800b96:	83 c4 10             	add    $0x10,%esp
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+                p = "(null)";
+            }
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  800b99:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800b9d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ba1:	7f e3                	jg     800b86 <vprintfmt+0x1b9>
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  800ba3:	eb 35                	jmp    800bda <vprintfmt+0x20d>
+                if (altflag && (ch < ' ' || ch > '~')) {
+  800ba5:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+  800ba9:	74 1c                	je     800bc7 <vprintfmt+0x1fa>
+  800bab:	83 fb 1f             	cmp    $0x1f,%ebx
+  800bae:	7e 05                	jle    800bb5 <vprintfmt+0x1e8>
+  800bb0:	83 fb 7e             	cmp    $0x7e,%ebx
+  800bb3:	7e 12                	jle    800bc7 <vprintfmt+0x1fa>
+                    putch('?', putdat);
+  800bb5:	83 ec 08             	sub    $0x8,%esp
+  800bb8:	ff 75 0c             	pushl  0xc(%ebp)
+  800bbb:	6a 3f                	push   $0x3f
+  800bbd:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bc0:	ff d0                	call   *%eax
+  800bc2:	83 c4 10             	add    $0x10,%esp
+  800bc5:	eb 0f                	jmp    800bd6 <vprintfmt+0x209>
+                }
+                else {
+                    putch(ch, putdat);
+  800bc7:	83 ec 08             	sub    $0x8,%esp
+  800bca:	ff 75 0c             	pushl  0xc(%ebp)
+  800bcd:	53                   	push   %ebx
+  800bce:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bd1:	ff d0                	call   *%eax
+  800bd3:	83 c4 10             	add    $0x10,%esp
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  800bd6:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800bda:	89 f0                	mov    %esi,%eax
+  800bdc:	8d 70 01             	lea    0x1(%eax),%esi
+  800bdf:	0f b6 00             	movzbl (%eax),%eax
+  800be2:	0f be d8             	movsbl %al,%ebx
+  800be5:	85 db                	test   %ebx,%ebx
+  800be7:	74 26                	je     800c0f <vprintfmt+0x242>
+  800be9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800bed:	78 b6                	js     800ba5 <vprintfmt+0x1d8>
+  800bef:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800bf3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800bf7:	79 ac                	jns    800ba5 <vprintfmt+0x1d8>
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  800bf9:	eb 14                	jmp    800c0f <vprintfmt+0x242>
+                putch(' ', putdat);
+  800bfb:	83 ec 08             	sub    $0x8,%esp
+  800bfe:	ff 75 0c             	pushl  0xc(%ebp)
+  800c01:	6a 20                	push   $0x20
+  800c03:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c06:	ff d0                	call   *%eax
+  800c08:	83 c4 10             	add    $0x10,%esp
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  800c0b:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800c0f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800c13:	7f e6                	jg     800bfb <vprintfmt+0x22e>
+                putch(' ', putdat);
+            }
+            break;
+  800c15:	e9 4e 01 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // (signed) decimal
+        case 'd':
+            num = getint(&ap, lflag);
+  800c1a:	83 ec 08             	sub    $0x8,%esp
+  800c1d:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c20:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c23:	50                   	push   %eax
+  800c24:	e8 39 fd ff ff       	call   800962 <getint>
+  800c29:	83 c4 10             	add    $0x10,%esp
+  800c2c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c2f:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            if ((long long)num < 0) {
+  800c32:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c35:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800c38:	85 d2                	test   %edx,%edx
+  800c3a:	79 23                	jns    800c5f <vprintfmt+0x292>
+                putch('-', putdat);
+  800c3c:	83 ec 08             	sub    $0x8,%esp
+  800c3f:	ff 75 0c             	pushl  0xc(%ebp)
+  800c42:	6a 2d                	push   $0x2d
+  800c44:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c47:	ff d0                	call   *%eax
+  800c49:	83 c4 10             	add    $0x10,%esp
+                num = -(long long)num;
+  800c4c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c4f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800c52:	f7 d8                	neg    %eax
+  800c54:	83 d2 00             	adc    $0x0,%edx
+  800c57:	f7 da                	neg    %edx
+  800c59:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c5c:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            }
+            base = 10;
+  800c5f:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  800c66:	e9 9f 00 00 00       	jmp    800d0a <vprintfmt+0x33d>
+
+        // unsigned decimal
+        case 'u':
+            num = getuint(&ap, lflag);
+  800c6b:	83 ec 08             	sub    $0x8,%esp
+  800c6e:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c71:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c74:	50                   	push   %eax
+  800c75:	e8 99 fc ff ff       	call   800913 <getuint>
+  800c7a:	83 c4 10             	add    $0x10,%esp
+  800c7d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c80:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 10;
+  800c83:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  800c8a:	eb 7e                	jmp    800d0a <vprintfmt+0x33d>
+
+        // (unsigned) octal
+        case 'o':
+            num = getuint(&ap, lflag);
+  800c8c:	83 ec 08             	sub    $0x8,%esp
+  800c8f:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c92:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c95:	50                   	push   %eax
+  800c96:	e8 78 fc ff ff       	call   800913 <getuint>
+  800c9b:	83 c4 10             	add    $0x10,%esp
+  800c9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800ca1:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 8;
+  800ca4:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+            goto number;
+  800cab:	eb 5d                	jmp    800d0a <vprintfmt+0x33d>
+
+        // pointer
+        case 'p':
+            putch('0', putdat);
+  800cad:	83 ec 08             	sub    $0x8,%esp
+  800cb0:	ff 75 0c             	pushl  0xc(%ebp)
+  800cb3:	6a 30                	push   $0x30
+  800cb5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cb8:	ff d0                	call   *%eax
+  800cba:	83 c4 10             	add    $0x10,%esp
+            putch('x', putdat);
+  800cbd:	83 ec 08             	sub    $0x8,%esp
+  800cc0:	ff 75 0c             	pushl  0xc(%ebp)
+  800cc3:	6a 78                	push   $0x78
+  800cc5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cc8:	ff d0                	call   *%eax
+  800cca:	83 c4 10             	add    $0x10,%esp
+            num = (unsigned long long)(uintptr_t)va_arg(ap, void *);
+  800ccd:	8b 45 14             	mov    0x14(%ebp),%eax
+  800cd0:	8d 50 04             	lea    0x4(%eax),%edx
+  800cd3:	89 55 14             	mov    %edx,0x14(%ebp)
+  800cd6:	8b 00                	mov    (%eax),%eax
+  800cd8:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800cdb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+            base = 16;
+  800ce2:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+            goto number;
+  800ce9:	eb 1f                	jmp    800d0a <vprintfmt+0x33d>
+
+        // (unsigned) hexadecimal
+        case 'x':
+            num = getuint(&ap, lflag);
+  800ceb:	83 ec 08             	sub    $0x8,%esp
+  800cee:	ff 75 e0             	pushl  -0x20(%ebp)
+  800cf1:	8d 45 14             	lea    0x14(%ebp),%eax
+  800cf4:	50                   	push   %eax
+  800cf5:	e8 19 fc ff ff       	call   800913 <getuint>
+  800cfa:	83 c4 10             	add    $0x10,%esp
+  800cfd:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800d00:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 16;
+  800d03:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+        number:
+            printnum(putch, putdat, num, base, width, padc);
+  800d0a:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+  800d0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800d11:	83 ec 04             	sub    $0x4,%esp
+  800d14:	52                   	push   %edx
+  800d15:	ff 75 e8             	pushl  -0x18(%ebp)
+  800d18:	50                   	push   %eax
+  800d19:	ff 75 f4             	pushl  -0xc(%ebp)
+  800d1c:	ff 75 f0             	pushl  -0x10(%ebp)
+  800d1f:	ff 75 0c             	pushl  0xc(%ebp)
+  800d22:	ff 75 08             	pushl  0x8(%ebp)
+  800d25:	e8 f8 fa ff ff       	call   800822 <printnum>
+  800d2a:	83 c4 20             	add    $0x20,%esp
+            break;
+  800d2d:	eb 39                	jmp    800d68 <vprintfmt+0x39b>
+
+        // escaped '%' character
+        case '%':
+            putch(ch, putdat);
+  800d2f:	83 ec 08             	sub    $0x8,%esp
+  800d32:	ff 75 0c             	pushl  0xc(%ebp)
+  800d35:	53                   	push   %ebx
+  800d36:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d39:	ff d0                	call   *%eax
+  800d3b:	83 c4 10             	add    $0x10,%esp
+            break;
+  800d3e:	eb 28                	jmp    800d68 <vprintfmt+0x39b>
+
+        // unrecognized escape sequence - just print it literally
+        default:
+            putch('%', putdat);
+  800d40:	83 ec 08             	sub    $0x8,%esp
+  800d43:	ff 75 0c             	pushl  0xc(%ebp)
+  800d46:	6a 25                	push   $0x25
+  800d48:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d4b:	ff d0                	call   *%eax
+  800d4d:	83 c4 10             	add    $0x10,%esp
+            for (fmt --; fmt[-1] != '%'; fmt --)
+  800d50:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800d54:	eb 04                	jmp    800d5a <vprintfmt+0x38d>
+  800d56:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800d5a:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d5d:	83 e8 01             	sub    $0x1,%eax
+  800d60:	0f b6 00             	movzbl (%eax),%eax
+  800d63:	3c 25                	cmp    $0x25,%al
+  800d65:	75 ef                	jne    800d56 <vprintfmt+0x389>
+                /* do nothing */;
+            break;
+  800d67:	90                   	nop
+        }
+    }
+  800d68:	e9 68 fc ff ff       	jmp    8009d5 <vprintfmt+0x8>
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+            if (ch == '\0') {
+                return;
+  800d6d:	90                   	nop
+            for (fmt --; fmt[-1] != '%'; fmt --)
+                /* do nothing */;
+            break;
+        }
+    }
+}
+  800d6e:	8d 65 f8             	lea    -0x8(%ebp),%esp
+  800d71:	5b                   	pop    %ebx
+  800d72:	5e                   	pop    %esi
+  800d73:	5d                   	pop    %ebp
+  800d74:	c3                   	ret    
+
+00800d75 <sprintputch>:
+ * sprintputch - 'print' a single character in a buffer
+ * @ch:         the character will be printed
+ * @b:          the buffer to place the character @ch
+ * */
+static void
+sprintputch(int ch, struct sprintbuf *b) {
+  800d75:	55                   	push   %ebp
+  800d76:	89 e5                	mov    %esp,%ebp
+    b->cnt ++;
+  800d78:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d7b:	8b 40 08             	mov    0x8(%eax),%eax
+  800d7e:	8d 50 01             	lea    0x1(%eax),%edx
+  800d81:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d84:	89 50 08             	mov    %edx,0x8(%eax)
+    if (b->buf < b->ebuf) {
+  800d87:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8a:	8b 10                	mov    (%eax),%edx
+  800d8c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8f:	8b 40 04             	mov    0x4(%eax),%eax
+  800d92:	39 c2                	cmp    %eax,%edx
+  800d94:	73 12                	jae    800da8 <sprintputch+0x33>
+        *b->buf ++ = ch;
+  800d96:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d99:	8b 00                	mov    (%eax),%eax
+  800d9b:	8d 48 01             	lea    0x1(%eax),%ecx
+  800d9e:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800da1:	89 0a                	mov    %ecx,(%edx)
+  800da3:	8b 55 08             	mov    0x8(%ebp),%edx
+  800da6:	88 10                	mov    %dl,(%eax)
+    }
+}
+  800da8:	90                   	nop
+  800da9:	5d                   	pop    %ebp
+  800daa:	c3                   	ret    
+
+00800dab <snprintf>:
+ * @str:        the buffer to place the result into
+ * @size:       the size of buffer, including the trailing null space
+ * @fmt:        the format string to use
+ * */
+int
+snprintf(char *str, size_t size, const char *fmt, ...) {
+  800dab:	55                   	push   %ebp
+  800dac:	89 e5                	mov    %esp,%ebp
+  800dae:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    int cnt;
+    va_start(ap, fmt);
+  800db1:	8d 45 14             	lea    0x14(%ebp),%eax
+  800db4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    cnt = vsnprintf(str, size, fmt, ap);
+  800db7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800dba:	50                   	push   %eax
+  800dbb:	ff 75 10             	pushl  0x10(%ebp)
+  800dbe:	ff 75 0c             	pushl  0xc(%ebp)
+  800dc1:	ff 75 08             	pushl  0x8(%ebp)
+  800dc4:	e8 0b 00 00 00       	call   800dd4 <vsnprintf>
+  800dc9:	83 c4 10             	add    $0x10,%esp
+  800dcc:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+    return cnt;
+  800dcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800dd2:	c9                   	leave  
+  800dd3:	c3                   	ret    
+
+00800dd4 <vsnprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want snprintf() instead.
+ * */
+int
+vsnprintf(char *str, size_t size, const char *fmt, va_list ap) {
+  800dd4:	55                   	push   %ebp
+  800dd5:	89 e5                	mov    %esp,%ebp
+  800dd7:	83 ec 18             	sub    $0x18,%esp
+    struct sprintbuf b = {str, str + size - 1, 0};
+  800dda:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ddd:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800de0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800de3:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800de6:	8b 45 08             	mov    0x8(%ebp),%eax
+  800de9:	01 d0                	add    %edx,%eax
+  800deb:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800dee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    if (str == NULL || b.buf > b.ebuf) {
+  800df5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  800df9:	74 0a                	je     800e05 <vsnprintf+0x31>
+  800dfb:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  800dfe:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800e01:	39 c2                	cmp    %eax,%edx
+  800e03:	76 07                	jbe    800e0c <vsnprintf+0x38>
+        return -E_INVAL;
+  800e05:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+  800e0a:	eb 20                	jmp    800e2c <vsnprintf+0x58>
+    }
+    // print the string to the buffer
+    vprintfmt((void*)sprintputch, &b, fmt, ap);
+  800e0c:	ff 75 14             	pushl  0x14(%ebp)
+  800e0f:	ff 75 10             	pushl  0x10(%ebp)
+  800e12:	8d 45 ec             	lea    -0x14(%ebp),%eax
+  800e15:	50                   	push   %eax
+  800e16:	68 75 0d 80 00       	push   $0x800d75
+  800e1b:	e8 ad fb ff ff       	call   8009cd <vprintfmt>
+  800e20:	83 c4 10             	add    $0x10,%esp
+    // null terminate the buffer
+    *b.buf = '\0';
+  800e23:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e26:	c6 00 00             	movb   $0x0,(%eax)
+    return b.cnt;
+  800e29:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800e2c:	c9                   	leave  
+  800e2d:	c3                   	ret    
+
+00800e2e <hash32>:
+ * @bits:   the number of bits in a return value
+ *
+ * High bits are more random, so we use them.
+ * */
+uint32_t
+hash32(uint32_t val, unsigned int bits) {
+  800e2e:	55                   	push   %ebp
+  800e2f:	89 e5                	mov    %esp,%ebp
+  800e31:	83 ec 10             	sub    $0x10,%esp
+    uint32_t hash = val * GOLDEN_RATIO_PRIME_32;
+  800e34:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e37:	69 c0 01 00 37 9e    	imul   $0x9e370001,%eax,%eax
+  800e3d:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    return (hash >> (32 - bits));
+  800e40:	b8 20 00 00 00       	mov    $0x20,%eax
+  800e45:	2b 45 0c             	sub    0xc(%ebp),%eax
+  800e48:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  800e4b:	89 c1                	mov    %eax,%ecx
+  800e4d:	d3 ea                	shr    %cl,%edx
+  800e4f:	89 d0                	mov    %edx,%eax
+}
+  800e51:	c9                   	leave  
+  800e52:	c3                   	ret    
+
+00800e53 <rand>:
+ * rand - returns a pseudo-random integer
+ *
+ * The rand() function return a value in the range [0, RAND_MAX].
+ * */
+int
+rand(void) {
+  800e53:	55                   	push   %ebp
+  800e54:	89 e5                	mov    %esp,%ebp
+  800e56:	57                   	push   %edi
+  800e57:	56                   	push   %esi
+  800e58:	53                   	push   %ebx
+  800e59:	83 ec 24             	sub    $0x24,%esp
+    next = (next * 0x5DEECE66DLL + 0xBLL) & ((1LL << 48) - 1);
+  800e5c:	a1 00 20 80 00       	mov    0x802000,%eax
+  800e61:	8b 15 04 20 80 00    	mov    0x802004,%edx
+  800e67:	69 fa 6d e6 ec de    	imul   $0xdeece66d,%edx,%edi
+  800e6d:	6b f0 05             	imul   $0x5,%eax,%esi
+  800e70:	01 fe                	add    %edi,%esi
+  800e72:	bf 6d e6 ec de       	mov    $0xdeece66d,%edi
+  800e77:	f7 e7                	mul    %edi
+  800e79:	01 d6                	add    %edx,%esi
+  800e7b:	89 f2                	mov    %esi,%edx
+  800e7d:	83 c0 0b             	add    $0xb,%eax
+  800e80:	83 d2 00             	adc    $0x0,%edx
+  800e83:	89 c7                	mov    %eax,%edi
+  800e85:	83 e7 ff             	and    $0xffffffff,%edi
+  800e88:	89 f9                	mov    %edi,%ecx
+  800e8a:	0f b7 da             	movzwl %dx,%ebx
+  800e8d:	89 0d 00 20 80 00    	mov    %ecx,0x802000
+  800e93:	89 1d 04 20 80 00    	mov    %ebx,0x802004
+    unsigned long long result = (next >> 12);
+  800e99:	a1 00 20 80 00       	mov    0x802000,%eax
+  800e9e:	8b 15 04 20 80 00    	mov    0x802004,%edx
+  800ea4:	0f ac d0 0c          	shrd   $0xc,%edx,%eax
+  800ea8:	c1 ea 0c             	shr    $0xc,%edx
+  800eab:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800eae:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+    return (int)do_div(result, RAND_MAX + 1);
+  800eb1:	c7 45 dc 00 00 00 80 	movl   $0x80000000,-0x24(%ebp)
+  800eb8:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  800ebb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800ebe:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  800ec1:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  800ec4:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ec7:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800eca:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ece:	74 1c                	je     800eec <rand+0x99>
+  800ed0:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ed3:	ba 00 00 00 00       	mov    $0x0,%edx
+  800ed8:	f7 75 dc             	divl   -0x24(%ebp)
+  800edb:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  800ede:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ee1:	ba 00 00 00 00       	mov    $0x0,%edx
+  800ee6:	f7 75 dc             	divl   -0x24(%ebp)
+  800ee9:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800eec:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  800eef:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  800ef2:	f7 75 dc             	divl   -0x24(%ebp)
+  800ef5:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  800ef8:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  800efb:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  800efe:	8b 55 e8             	mov    -0x18(%ebp),%edx
+  800f01:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800f04:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  800f07:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+}
+  800f0a:	83 c4 24             	add    $0x24,%esp
+  800f0d:	5b                   	pop    %ebx
+  800f0e:	5e                   	pop    %esi
+  800f0f:	5f                   	pop    %edi
+  800f10:	5d                   	pop    %ebp
+  800f11:	c3                   	ret    
+
+00800f12 <srand>:
+/* *
+ * srand - seed the random number generator with the given number
+ * @seed:   the required seed number
+ * */
+void
+srand(unsigned int seed) {
+  800f12:	55                   	push   %ebp
+  800f13:	89 e5                	mov    %esp,%ebp
+    next = seed;
+  800f15:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f18:	ba 00 00 00 00       	mov    $0x0,%edx
+  800f1d:	a3 00 20 80 00       	mov    %eax,0x802000
+  800f22:	89 15 04 20 80 00    	mov    %edx,0x802004
+}
+  800f28:	90                   	nop
+  800f29:	5d                   	pop    %ebp
+  800f2a:	c3                   	ret    
+
+00800f2b <do_yield>:
+#include <ulib.h>
+#include <stdio.h>
+
+void
+do_yield(void) {
+  800f2b:	55                   	push   %ebp
+  800f2c:	89 e5                	mov    %esp,%ebp
+  800f2e:	83 ec 08             	sub    $0x8,%esp
+    yield();
+  800f31:	e8 e4 f2 ff ff       	call   80021a <yield>
+    yield();
+  800f36:	e8 df f2 ff ff       	call   80021a <yield>
+    yield();
+  800f3b:	e8 da f2 ff ff       	call   80021a <yield>
+    yield();
+  800f40:	e8 d5 f2 ff ff       	call   80021a <yield>
+    yield();
+  800f45:	e8 d0 f2 ff ff       	call   80021a <yield>
+    yield();
+  800f4a:	e8 cb f2 ff ff       	call   80021a <yield>
+}
+  800f4f:	90                   	nop
+  800f50:	c9                   	leave  
+  800f51:	c3                   	ret    
+
+00800f52 <loop>:
+
+int parent, pid1, pid2;
+
+void
+loop(void) {
+  800f52:	55                   	push   %ebp
+  800f53:	89 e5                	mov    %esp,%ebp
+  800f55:	83 ec 08             	sub    $0x8,%esp
+    cprintf("child 1.\n");
+  800f58:	83 ec 0c             	sub    $0xc,%esp
+  800f5b:	68 a0 13 80 00       	push   $0x8013a0
+  800f60:	e8 74 f3 ff ff       	call   8002d9 <cprintf>
+  800f65:	83 c4 10             	add    $0x10,%esp
+    while (1);
+  800f68:	eb fe                	jmp    800f68 <loop+0x16>
+
+00800f6a <work>:
+}
+
+void
+work(void) {
+  800f6a:	55                   	push   %ebp
+  800f6b:	89 e5                	mov    %esp,%ebp
+  800f6d:	83 ec 08             	sub    $0x8,%esp
+    cprintf("child 2.\n");
+  800f70:	83 ec 0c             	sub    $0xc,%esp
+  800f73:	68 aa 13 80 00       	push   $0x8013aa
+  800f78:	e8 5c f3 ff ff       	call   8002d9 <cprintf>
+  800f7d:	83 c4 10             	add    $0x10,%esp
+    do_yield();
+  800f80:	e8 a6 ff ff ff       	call   800f2b <do_yield>
+    if (kill(parent) == 0) {
+  800f85:	a1 08 20 80 00       	mov    0x802008,%eax
+  800f8a:	83 ec 0c             	sub    $0xc,%esp
+  800f8d:	50                   	push   %eax
+  800f8e:	e8 95 f2 ff ff       	call   800228 <kill>
+  800f93:	83 c4 10             	add    $0x10,%esp
+  800f96:	85 c0                	test   %eax,%eax
+  800f98:	75 44                	jne    800fde <work+0x74>
+        cprintf("kill parent ok.\n");
+  800f9a:	83 ec 0c             	sub    $0xc,%esp
+  800f9d:	68 b4 13 80 00       	push   $0x8013b4
+  800fa2:	e8 32 f3 ff ff       	call   8002d9 <cprintf>
+  800fa7:	83 c4 10             	add    $0x10,%esp
+        do_yield();
+  800faa:	e8 7c ff ff ff       	call   800f2b <do_yield>
+        if (kill(pid1) == 0) {
+  800faf:	a1 10 20 80 00       	mov    0x802010,%eax
+  800fb4:	83 ec 0c             	sub    $0xc,%esp
+  800fb7:	50                   	push   %eax
+  800fb8:	e8 6b f2 ff ff       	call   800228 <kill>
+  800fbd:	83 c4 10             	add    $0x10,%esp
+  800fc0:	85 c0                	test   %eax,%eax
+  800fc2:	75 1a                	jne    800fde <work+0x74>
+            cprintf("kill child1 ok.\n");
+  800fc4:	83 ec 0c             	sub    $0xc,%esp
+  800fc7:	68 c5 13 80 00       	push   $0x8013c5
+  800fcc:	e8 08 f3 ff ff       	call   8002d9 <cprintf>
+  800fd1:	83 c4 10             	add    $0x10,%esp
+            exit(0);
+  800fd4:	83 ec 0c             	sub    $0xc,%esp
+  800fd7:	6a 00                	push   $0x0
+  800fd9:	e8 d9 f1 ff ff       	call   8001b7 <exit>
+        }
+    }
+    exit(-1);
+  800fde:	83 ec 0c             	sub    $0xc,%esp
+  800fe1:	6a ff                	push   $0xffffffff
+  800fe3:	e8 cf f1 ff ff       	call   8001b7 <exit>
+
+00800fe8 <main>:
+}
+
+int
+main(void) {
+  800fe8:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+  800fec:	83 e4 f0             	and    $0xfffffff0,%esp
+  800fef:	ff 71 fc             	pushl  -0x4(%ecx)
+  800ff2:	55                   	push   %ebp
+  800ff3:	89 e5                	mov    %esp,%ebp
+  800ff5:	51                   	push   %ecx
+  800ff6:	83 ec 04             	sub    $0x4,%esp
+    parent = getpid();
+  800ff9:	e8 40 f2 ff ff       	call   80023e <getpid>
+  800ffe:	a3 08 20 80 00       	mov    %eax,0x802008
+    if ((pid1 = fork()) == 0) {
+  801003:	e8 d5 f1 ff ff       	call   8001dd <fork>
+  801008:	a3 10 20 80 00       	mov    %eax,0x802010
+  80100d:	a1 10 20 80 00       	mov    0x802010,%eax
+  801012:	85 c0                	test   %eax,%eax
+  801014:	75 05                	jne    80101b <main+0x33>
+        loop();
+  801016:	e8 37 ff ff ff       	call   800f52 <loop>
+    }
+
+    assert(pid1 > 0);
+  80101b:	a1 10 20 80 00       	mov    0x802010,%eax
+  801020:	85 c0                	test   %eax,%eax
+  801022:	7f 16                	jg     80103a <main+0x52>
+  801024:	68 d6 13 80 00       	push   $0x8013d6
+  801029:	68 df 13 80 00       	push   $0x8013df
+  80102e:	6a 2c                	push   $0x2c
+  801030:	68 f4 13 80 00       	push   $0x8013f4
+  801035:	e8 e6 ef ff ff       	call   800020 <__panic>
+
+    if ((pid2 = fork()) == 0) {
+  80103a:	e8 9e f1 ff ff       	call   8001dd <fork>
+  80103f:	a3 0c 20 80 00       	mov    %eax,0x80200c
+  801044:	a1 0c 20 80 00       	mov    0x80200c,%eax
+  801049:	85 c0                	test   %eax,%eax
+  80104b:	75 05                	jne    801052 <main+0x6a>
+        work();
+  80104d:	e8 18 ff ff ff       	call   800f6a <work>
+    }
+    if (pid2 > 0) {
+  801052:	a1 0c 20 80 00       	mov    0x80200c,%eax
+  801057:	85 c0                	test   %eax,%eax
+  801059:	7e 3a                	jle    801095 <main+0xad>
+        cprintf("wait child 1.\n");
+  80105b:	83 ec 0c             	sub    $0xc,%esp
+  80105e:	68 04 14 80 00       	push   $0x801404
+  801063:	e8 71 f2 ff ff       	call   8002d9 <cprintf>
+  801068:	83 c4 10             	add    $0x10,%esp
+        waitpid(pid1, NULL);
+  80106b:	a1 10 20 80 00       	mov    0x802010,%eax
+  801070:	83 ec 08             	sub    $0x8,%esp
+  801073:	6a 00                	push   $0x0
+  801075:	50                   	push   %eax
+  801076:	e8 86 f1 ff ff       	call   800201 <waitpid>
+  80107b:	83 c4 10             	add    $0x10,%esp
+        panic("waitpid %d returns\n", pid1);
+  80107e:	a1 10 20 80 00       	mov    0x802010,%eax
+  801083:	50                   	push   %eax
+  801084:	68 13 14 80 00       	push   $0x801413
+  801089:	6a 34                	push   $0x34
+  80108b:	68 f4 13 80 00       	push   $0x8013f4
+  801090:	e8 8b ef ff ff       	call   800020 <__panic>
+    }
+    else {
+        kill(pid1);
+  801095:	a1 10 20 80 00       	mov    0x802010,%eax
+  80109a:	83 ec 0c             	sub    $0xc,%esp
+  80109d:	50                   	push   %eax
+  80109e:	e8 85 f1 ff ff       	call   800228 <kill>
+  8010a3:	83 c4 10             	add    $0x10,%esp
+    }
+    panic("FAIL: T.T\n");
+  8010a6:	83 ec 04             	sub    $0x4,%esp
+  8010a9:	68 27 14 80 00       	push   $0x801427
+  8010ae:	6a 39                	push   $0x39
+  8010b0:	68 f4 13 80 00       	push   $0x8013f4
+  8010b5:	e8 66 ef ff ff       	call   800020 <__panic>
diff -r -u -P lab6_origin/obj/user/waitkill.d lab6/obj/user/waitkill.d
--- lab6_origin/obj/user/waitkill.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/waitkill.d	2019-05-13 17:39:38.490981700 +0800
@@ -0,0 +1,2 @@
+obj/user/waitkill.o obj/user/waitkill.d: user/waitkill.c user/libs/ulib.h \
+ libs/defs.h libs/stdio.h libs/stdarg.h
Binary files lab6_origin/obj/user/waitkill.o and lab6/obj/user/waitkill.o differ
diff -r -u -P lab6_origin/obj/user/waitkill.sym lab6/obj/user/waitkill.sym
--- lab6_origin/obj/user/waitkill.sym	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/waitkill.sym	2019-05-13 17:39:43.887882800 +0800
@@ -0,0 +1,83 @@
+00800020 .text
+008010c0 .rodata
+00802000 .data
+00802008 .bss
+00200000 .stab_info
+00200010 .stab
+00202e61 .stabstr
+00000000 panic.c
+00000000 syscall.c
+008000b5 syscall
+00000000 ulib.c
+00000000 stdio.c
+0080028c cputch
+00000000 umain.c
+00000000 string.c
+00000000 printfmt.c
+008011c0 error_string
+00800822 printnum
+00800913 getuint
+00800962 getint
+00800d75 sprintputch
+00000000 hash.c
+00000000 rand.c
+00802000 next
+00000000 waitkill.c
+008003be strcpy
+0080021a yield
+00800201 waitpid
+00800141 sys_yield
+008006d7 memmove
+00800dab snprintf
+008009cd vprintfmt
+0080011d sys_fork
+008002d9 cprintf
+00800f52 loop
+0080023e getpid
+0080077a memcpy
+00802008 parent
+00800266 lab6_set_priority
+00800dd4 vsnprintf
+0080034d umain
+00202e60 __STAB_END__
+00800150 sys_kill
+00202e61 __STABSTR_BEGIN__
+00800020 __panic
+0080053a strtol
+0080038e strnlen
+0080024b print_pgdir
+00800228 kill
+0080200c pid2
+0080050b strfind
+008001ea wait
+0080027d _start
+00800e53 rand
+00800482 strncmp
+00800171 sys_putc
+008003fe strncpy
+008007ca memcmp
+008001dd fork
+00800697 memset
+00800fe8 main
+00800f12 srand
+00800e2e hash32
+008009a9 printfmt
+00800f2b do_yield
+00203c93 __STABSTR_END__
+00800438 strcmp
+00800259 gettime_msec
+00800192 sys_gettime
+008002b0 vcprintf
+0080006e __warn
+008002ff cputs
+00802010 pid1
+008001a1 sys_lab6_set_priority
+008001b7 exit
+0080012c sys_wait
+0080010b sys_exit
+00200010 __STAB_BEGIN__
+00800366 strlen
+00800183 sys_pgdir
+008004d8 strchr
+00800162 sys_getpid
+00800f6a work
diff -r -u -P lab6_origin/obj/user/yield.asm lab6/obj/user/yield.asm
--- lab6_origin/obj/user/yield.asm	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/yield.asm	2019-05-13 17:39:43.310214600 +0800
@@ -0,0 +1,2622 @@
+
+obj/__user_yield.out:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00800020 <__panic>:
+#include <stdio.h>
+#include <ulib.h>
+#include <error.h>
+
+void
+__panic(const char *file, int line, const char *fmt, ...) {
+  800020:	55                   	push   %ebp
+  800021:	89 e5                	mov    %esp,%ebp
+  800023:	83 ec 18             	sub    $0x18,%esp
+    // print the 'message'
+    va_list ap;
+    va_start(ap, fmt);
+  800026:	8d 45 14             	lea    0x14(%ebp),%eax
+  800029:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("user panic at %s:%d:\n    ", file, line);
+  80002c:	83 ec 04             	sub    $0x4,%esp
+  80002f:	ff 75 0c             	pushl  0xc(%ebp)
+  800032:	ff 75 08             	pushl  0x8(%ebp)
+  800035:	68 c0 0f 80 00       	push   $0x800fc0
+  80003a:	e8 9a 02 00 00       	call   8002d9 <cprintf>
+  80003f:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+  800042:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800045:	83 ec 08             	sub    $0x8,%esp
+  800048:	50                   	push   %eax
+  800049:	ff 75 10             	pushl  0x10(%ebp)
+  80004c:	e8 5f 02 00 00       	call   8002b0 <vcprintf>
+  800051:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+  800054:	83 ec 0c             	sub    $0xc,%esp
+  800057:	68 da 0f 80 00       	push   $0x800fda
+  80005c:	e8 78 02 00 00       	call   8002d9 <cprintf>
+  800061:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+    exit(-E_PANIC);
+  800064:	83 ec 0c             	sub    $0xc,%esp
+  800067:	6a f6                	push   $0xfffffff6
+  800069:	e8 49 01 00 00       	call   8001b7 <exit>
+
+0080006e <__warn>:
+}
+
+void
+__warn(const char *file, int line, const char *fmt, ...) {
+  80006e:	55                   	push   %ebp
+  80006f:	89 e5                	mov    %esp,%ebp
+  800071:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    va_start(ap, fmt);
+  800074:	8d 45 14             	lea    0x14(%ebp),%eax
+  800077:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("user warning at %s:%d:\n    ", file, line);
+  80007a:	83 ec 04             	sub    $0x4,%esp
+  80007d:	ff 75 0c             	pushl  0xc(%ebp)
+  800080:	ff 75 08             	pushl  0x8(%ebp)
+  800083:	68 dc 0f 80 00       	push   $0x800fdc
+  800088:	e8 4c 02 00 00       	call   8002d9 <cprintf>
+  80008d:	83 c4 10             	add    $0x10,%esp
+    vcprintf(fmt, ap);
+  800090:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800093:	83 ec 08             	sub    $0x8,%esp
+  800096:	50                   	push   %eax
+  800097:	ff 75 10             	pushl  0x10(%ebp)
+  80009a:	e8 11 02 00 00       	call   8002b0 <vcprintf>
+  80009f:	83 c4 10             	add    $0x10,%esp
+    cprintf("\n");
+  8000a2:	83 ec 0c             	sub    $0xc,%esp
+  8000a5:	68 da 0f 80 00       	push   $0x800fda
+  8000aa:	e8 2a 02 00 00       	call   8002d9 <cprintf>
+  8000af:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+  8000b2:	90                   	nop
+  8000b3:	c9                   	leave  
+  8000b4:	c3                   	ret    
+
+008000b5 <syscall>:
+#include <syscall.h>
+
+#define MAX_ARGS            5
+
+static inline int
+syscall(int num, ...) {
+  8000b5:	55                   	push   %ebp
+  8000b6:	89 e5                	mov    %esp,%ebp
+  8000b8:	57                   	push   %edi
+  8000b9:	56                   	push   %esi
+  8000ba:	53                   	push   %ebx
+  8000bb:	83 ec 20             	sub    $0x20,%esp
+    va_list ap;
+    va_start(ap, num);
+  8000be:	8d 45 0c             	lea    0xc(%ebp),%eax
+  8000c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    uint32_t a[MAX_ARGS];
+    int i, ret;
+    for (i = 0; i < MAX_ARGS; i ++) {
+  8000c4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  8000cb:	eb 16                	jmp    8000e3 <syscall+0x2e>
+        a[i] = va_arg(ap, uint32_t);
+  8000cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8000d0:	8d 50 04             	lea    0x4(%eax),%edx
+  8000d3:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  8000d6:	8b 10                	mov    (%eax),%edx
+  8000d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8000db:	89 54 85 d4          	mov    %edx,-0x2c(%ebp,%eax,4)
+syscall(int num, ...) {
+    va_list ap;
+    va_start(ap, num);
+    uint32_t a[MAX_ARGS];
+    int i, ret;
+    for (i = 0; i < MAX_ARGS; i ++) {
+  8000df:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+  8000e3:	83 7d f0 04          	cmpl   $0x4,-0x10(%ebp)
+  8000e7:	7e e4                	jle    8000cd <syscall+0x18>
+    asm volatile (
+        "int %1;"
+        : "=a" (ret)
+        : "i" (T_SYSCALL),
+          "a" (num),
+          "d" (a[0]),
+  8000e9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+          "c" (a[1]),
+  8000ec:	8b 4d d8             	mov    -0x28(%ebp),%ecx
+          "b" (a[2]),
+  8000ef:	8b 5d dc             	mov    -0x24(%ebp),%ebx
+          "D" (a[3]),
+  8000f2:	8b 7d e0             	mov    -0x20(%ebp),%edi
+          "S" (a[4])
+  8000f5:	8b 75 e4             	mov    -0x1c(%ebp),%esi
+    for (i = 0; i < MAX_ARGS; i ++) {
+        a[i] = va_arg(ap, uint32_t);
+    }
+    va_end(ap);
+
+    asm volatile (
+  8000f8:	8b 45 08             	mov    0x8(%ebp),%eax
+  8000fb:	cd 80                	int    $0x80
+  8000fd:	89 45 ec             	mov    %eax,-0x14(%ebp)
+          "c" (a[1]),
+          "b" (a[2]),
+          "D" (a[3]),
+          "S" (a[4])
+        : "cc", "memory");
+    return ret;
+  800100:	8b 45 ec             	mov    -0x14(%ebp),%eax
+}
+  800103:	83 c4 20             	add    $0x20,%esp
+  800106:	5b                   	pop    %ebx
+  800107:	5e                   	pop    %esi
+  800108:	5f                   	pop    %edi
+  800109:	5d                   	pop    %ebp
+  80010a:	c3                   	ret    
+
+0080010b <sys_exit>:
+
+int
+sys_exit(int error_code) {
+  80010b:	55                   	push   %ebp
+  80010c:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_exit, error_code);
+  80010e:	ff 75 08             	pushl  0x8(%ebp)
+  800111:	6a 01                	push   $0x1
+  800113:	e8 9d ff ff ff       	call   8000b5 <syscall>
+  800118:	83 c4 08             	add    $0x8,%esp
+}
+  80011b:	c9                   	leave  
+  80011c:	c3                   	ret    
+
+0080011d <sys_fork>:
+
+int
+sys_fork(void) {
+  80011d:	55                   	push   %ebp
+  80011e:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_fork);
+  800120:	6a 02                	push   $0x2
+  800122:	e8 8e ff ff ff       	call   8000b5 <syscall>
+  800127:	83 c4 04             	add    $0x4,%esp
+}
+  80012a:	c9                   	leave  
+  80012b:	c3                   	ret    
+
+0080012c <sys_wait>:
+
+int
+sys_wait(int pid, int *store) {
+  80012c:	55                   	push   %ebp
+  80012d:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_wait, pid, store);
+  80012f:	ff 75 0c             	pushl  0xc(%ebp)
+  800132:	ff 75 08             	pushl  0x8(%ebp)
+  800135:	6a 03                	push   $0x3
+  800137:	e8 79 ff ff ff       	call   8000b5 <syscall>
+  80013c:	83 c4 0c             	add    $0xc,%esp
+}
+  80013f:	c9                   	leave  
+  800140:	c3                   	ret    
+
+00800141 <sys_yield>:
+
+int
+sys_yield(void) {
+  800141:	55                   	push   %ebp
+  800142:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_yield);
+  800144:	6a 0a                	push   $0xa
+  800146:	e8 6a ff ff ff       	call   8000b5 <syscall>
+  80014b:	83 c4 04             	add    $0x4,%esp
+}
+  80014e:	c9                   	leave  
+  80014f:	c3                   	ret    
+
+00800150 <sys_kill>:
+
+int
+sys_kill(int pid) {
+  800150:	55                   	push   %ebp
+  800151:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_kill, pid);
+  800153:	ff 75 08             	pushl  0x8(%ebp)
+  800156:	6a 0c                	push   $0xc
+  800158:	e8 58 ff ff ff       	call   8000b5 <syscall>
+  80015d:	83 c4 08             	add    $0x8,%esp
+}
+  800160:	c9                   	leave  
+  800161:	c3                   	ret    
+
+00800162 <sys_getpid>:
+
+int
+sys_getpid(void) {
+  800162:	55                   	push   %ebp
+  800163:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_getpid);
+  800165:	6a 12                	push   $0x12
+  800167:	e8 49 ff ff ff       	call   8000b5 <syscall>
+  80016c:	83 c4 04             	add    $0x4,%esp
+}
+  80016f:	c9                   	leave  
+  800170:	c3                   	ret    
+
+00800171 <sys_putc>:
+
+int
+sys_putc(int c) {
+  800171:	55                   	push   %ebp
+  800172:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_putc, c);
+  800174:	ff 75 08             	pushl  0x8(%ebp)
+  800177:	6a 1e                	push   $0x1e
+  800179:	e8 37 ff ff ff       	call   8000b5 <syscall>
+  80017e:	83 c4 08             	add    $0x8,%esp
+}
+  800181:	c9                   	leave  
+  800182:	c3                   	ret    
+
+00800183 <sys_pgdir>:
+
+int
+sys_pgdir(void) {
+  800183:	55                   	push   %ebp
+  800184:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_pgdir);
+  800186:	6a 1f                	push   $0x1f
+  800188:	e8 28 ff ff ff       	call   8000b5 <syscall>
+  80018d:	83 c4 04             	add    $0x4,%esp
+}
+  800190:	c9                   	leave  
+  800191:	c3                   	ret    
+
+00800192 <sys_gettime>:
+
+int
+sys_gettime(void) {
+  800192:	55                   	push   %ebp
+  800193:	89 e5                	mov    %esp,%ebp
+    return syscall(SYS_gettime);
+  800195:	6a 11                	push   $0x11
+  800197:	e8 19 ff ff ff       	call   8000b5 <syscall>
+  80019c:	83 c4 04             	add    $0x4,%esp
+}
+  80019f:	c9                   	leave  
+  8001a0:	c3                   	ret    
+
+008001a1 <sys_lab6_set_priority>:
+
+void
+sys_lab6_set_priority(uint32_t priority)
+{
+  8001a1:	55                   	push   %ebp
+  8001a2:	89 e5                	mov    %esp,%ebp
+    syscall(SYS_lab6_set_priority, priority);
+  8001a4:	ff 75 08             	pushl  0x8(%ebp)
+  8001a7:	68 ff 00 00 00       	push   $0xff
+  8001ac:	e8 04 ff ff ff       	call   8000b5 <syscall>
+  8001b1:	83 c4 08             	add    $0x8,%esp
+}
+  8001b4:	90                   	nop
+  8001b5:	c9                   	leave  
+  8001b6:	c3                   	ret    
+
+008001b7 <exit>:
+#include <syscall.h>
+#include <stdio.h>
+#include <ulib.h>
+
+void
+exit(int error_code) {
+  8001b7:	55                   	push   %ebp
+  8001b8:	89 e5                	mov    %esp,%ebp
+  8001ba:	83 ec 08             	sub    $0x8,%esp
+    sys_exit(error_code);
+  8001bd:	83 ec 0c             	sub    $0xc,%esp
+  8001c0:	ff 75 08             	pushl  0x8(%ebp)
+  8001c3:	e8 43 ff ff ff       	call   80010b <sys_exit>
+  8001c8:	83 c4 10             	add    $0x10,%esp
+    cprintf("BUG: exit failed.\n");
+  8001cb:	83 ec 0c             	sub    $0xc,%esp
+  8001ce:	68 f8 0f 80 00       	push   $0x800ff8
+  8001d3:	e8 01 01 00 00       	call   8002d9 <cprintf>
+  8001d8:	83 c4 10             	add    $0x10,%esp
+    while (1);
+  8001db:	eb fe                	jmp    8001db <exit+0x24>
+
+008001dd <fork>:
+}
+
+int
+fork(void) {
+  8001dd:	55                   	push   %ebp
+  8001de:	89 e5                	mov    %esp,%ebp
+  8001e0:	83 ec 08             	sub    $0x8,%esp
+    return sys_fork();
+  8001e3:	e8 35 ff ff ff       	call   80011d <sys_fork>
+}
+  8001e8:	c9                   	leave  
+  8001e9:	c3                   	ret    
+
+008001ea <wait>:
+
+int
+wait(void) {
+  8001ea:	55                   	push   %ebp
+  8001eb:	89 e5                	mov    %esp,%ebp
+  8001ed:	83 ec 08             	sub    $0x8,%esp
+    return sys_wait(0, NULL);
+  8001f0:	83 ec 08             	sub    $0x8,%esp
+  8001f3:	6a 00                	push   $0x0
+  8001f5:	6a 00                	push   $0x0
+  8001f7:	e8 30 ff ff ff       	call   80012c <sys_wait>
+  8001fc:	83 c4 10             	add    $0x10,%esp
+}
+  8001ff:	c9                   	leave  
+  800200:	c3                   	ret    
+
+00800201 <waitpid>:
+
+int
+waitpid(int pid, int *store) {
+  800201:	55                   	push   %ebp
+  800202:	89 e5                	mov    %esp,%ebp
+  800204:	83 ec 08             	sub    $0x8,%esp
+    return sys_wait(pid, store);
+  800207:	83 ec 08             	sub    $0x8,%esp
+  80020a:	ff 75 0c             	pushl  0xc(%ebp)
+  80020d:	ff 75 08             	pushl  0x8(%ebp)
+  800210:	e8 17 ff ff ff       	call   80012c <sys_wait>
+  800215:	83 c4 10             	add    $0x10,%esp
+}
+  800218:	c9                   	leave  
+  800219:	c3                   	ret    
+
+0080021a <yield>:
+
+void
+yield(void) {
+  80021a:	55                   	push   %ebp
+  80021b:	89 e5                	mov    %esp,%ebp
+  80021d:	83 ec 08             	sub    $0x8,%esp
+    sys_yield();
+  800220:	e8 1c ff ff ff       	call   800141 <sys_yield>
+}
+  800225:	90                   	nop
+  800226:	c9                   	leave  
+  800227:	c3                   	ret    
+
+00800228 <kill>:
+
+int
+kill(int pid) {
+  800228:	55                   	push   %ebp
+  800229:	89 e5                	mov    %esp,%ebp
+  80022b:	83 ec 08             	sub    $0x8,%esp
+    return sys_kill(pid);
+  80022e:	83 ec 0c             	sub    $0xc,%esp
+  800231:	ff 75 08             	pushl  0x8(%ebp)
+  800234:	e8 17 ff ff ff       	call   800150 <sys_kill>
+  800239:	83 c4 10             	add    $0x10,%esp
+}
+  80023c:	c9                   	leave  
+  80023d:	c3                   	ret    
+
+0080023e <getpid>:
+
+int
+getpid(void) {
+  80023e:	55                   	push   %ebp
+  80023f:	89 e5                	mov    %esp,%ebp
+  800241:	83 ec 08             	sub    $0x8,%esp
+    return sys_getpid();
+  800244:	e8 19 ff ff ff       	call   800162 <sys_getpid>
+}
+  800249:	c9                   	leave  
+  80024a:	c3                   	ret    
+
+0080024b <print_pgdir>:
+
+//print_pgdir - print the PDT&PT
+void
+print_pgdir(void) {
+  80024b:	55                   	push   %ebp
+  80024c:	89 e5                	mov    %esp,%ebp
+  80024e:	83 ec 08             	sub    $0x8,%esp
+    sys_pgdir();
+  800251:	e8 2d ff ff ff       	call   800183 <sys_pgdir>
+}
+  800256:	90                   	nop
+  800257:	c9                   	leave  
+  800258:	c3                   	ret    
+
+00800259 <gettime_msec>:
+
+unsigned int
+gettime_msec(void) {
+  800259:	55                   	push   %ebp
+  80025a:	89 e5                	mov    %esp,%ebp
+  80025c:	83 ec 08             	sub    $0x8,%esp
+    return (unsigned int)sys_gettime();
+  80025f:	e8 2e ff ff ff       	call   800192 <sys_gettime>
+}
+  800264:	c9                   	leave  
+  800265:	c3                   	ret    
+
+00800266 <lab6_set_priority>:
+
+void
+lab6_set_priority(uint32_t priority)
+{
+  800266:	55                   	push   %ebp
+  800267:	89 e5                	mov    %esp,%ebp
+  800269:	83 ec 08             	sub    $0x8,%esp
+    sys_lab6_set_priority(priority);
+  80026c:	83 ec 0c             	sub    $0xc,%esp
+  80026f:	ff 75 08             	pushl  0x8(%ebp)
+  800272:	e8 2a ff ff ff       	call   8001a1 <sys_lab6_set_priority>
+  800277:	83 c4 10             	add    $0x10,%esp
+}
+  80027a:	90                   	nop
+  80027b:	c9                   	leave  
+  80027c:	c3                   	ret    
+
+0080027d <_start>:
+.text
+.globl _start
+_start:
+    # set ebp for backtrace
+    movl $0x0, %ebp
+  80027d:	bd 00 00 00 00       	mov    $0x0,%ebp
+
+    # move down the esp register
+    # since it may cause page fault in backtrace
+    subl $0x20, %esp
+  800282:	83 ec 20             	sub    $0x20,%esp
+
+    # call user-program function
+    call umain
+  800285:	e8 c3 00 00 00       	call   80034d <umain>
+1:  jmp 1b
+  80028a:	eb fe                	jmp    80028a <_start+0xd>
+
+0080028c <cputch>:
+/* *
+ * cputch - writes a single character @c to stdout, and it will
+ * increace the value of counter pointed by @cnt.
+ * */
+static void
+cputch(int c, int *cnt) {
+  80028c:	55                   	push   %ebp
+  80028d:	89 e5                	mov    %esp,%ebp
+  80028f:	83 ec 08             	sub    $0x8,%esp
+    sys_putc(c);
+  800292:	83 ec 0c             	sub    $0xc,%esp
+  800295:	ff 75 08             	pushl  0x8(%ebp)
+  800298:	e8 d4 fe ff ff       	call   800171 <sys_putc>
+  80029d:	83 c4 10             	add    $0x10,%esp
+    (*cnt) ++;
+  8002a0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002a3:	8b 00                	mov    (%eax),%eax
+  8002a5:	8d 50 01             	lea    0x1(%eax),%edx
+  8002a8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002ab:	89 10                	mov    %edx,(%eax)
+}
+  8002ad:	90                   	nop
+  8002ae:	c9                   	leave  
+  8002af:	c3                   	ret    
+
+008002b0 <vcprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want cprintf() instead.
+ * */
+int
+vcprintf(const char *fmt, va_list ap) {
+  8002b0:	55                   	push   %ebp
+  8002b1:	89 e5                	mov    %esp,%ebp
+  8002b3:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+  8002b6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    vprintfmt((void*)cputch, &cnt, fmt, ap);
+  8002bd:	ff 75 0c             	pushl  0xc(%ebp)
+  8002c0:	ff 75 08             	pushl  0x8(%ebp)
+  8002c3:	8d 45 f4             	lea    -0xc(%ebp),%eax
+  8002c6:	50                   	push   %eax
+  8002c7:	68 8c 02 80 00       	push   $0x80028c
+  8002cc:	e8 fc 06 00 00       	call   8009cd <vprintfmt>
+  8002d1:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+  8002d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8002d7:	c9                   	leave  
+  8002d8:	c3                   	ret    
+
+008002d9 <cprintf>:
+ *
+ * The return value is the number of characters which would be
+ * written to stdout.
+ * */
+int
+cprintf(const char *fmt, ...) {
+  8002d9:	55                   	push   %ebp
+  8002da:	89 e5                	mov    %esp,%ebp
+  8002dc:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  8002df:	8d 45 0c             	lea    0xc(%ebp),%eax
+  8002e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    int cnt = vcprintf(fmt, ap);
+  8002e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8002e8:	83 ec 08             	sub    $0x8,%esp
+  8002eb:	50                   	push   %eax
+  8002ec:	ff 75 08             	pushl  0x8(%ebp)
+  8002ef:	e8 bc ff ff ff       	call   8002b0 <vcprintf>
+  8002f4:	83 c4 10             	add    $0x10,%esp
+  8002f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+
+    return cnt;
+  8002fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8002fd:	c9                   	leave  
+  8002fe:	c3                   	ret    
+
+008002ff <cputs>:
+/* *
+ * cputs- writes the string pointed by @str to stdout and
+ * appends a newline character.
+ * */
+int
+cputs(const char *str) {
+  8002ff:	55                   	push   %ebp
+  800300:	89 e5                	mov    %esp,%ebp
+  800302:	83 ec 18             	sub    $0x18,%esp
+    int cnt = 0;
+  800305:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    char c;
+    while ((c = *str ++) != '\0') {
+  80030c:	eb 14                	jmp    800322 <cputs+0x23>
+        cputch(c, &cnt);
+  80030e:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
+  800312:	83 ec 08             	sub    $0x8,%esp
+  800315:	8d 55 f0             	lea    -0x10(%ebp),%edx
+  800318:	52                   	push   %edx
+  800319:	50                   	push   %eax
+  80031a:	e8 6d ff ff ff       	call   80028c <cputch>
+  80031f:	83 c4 10             	add    $0x10,%esp
+ * */
+int
+cputs(const char *str) {
+    int cnt = 0;
+    char c;
+    while ((c = *str ++) != '\0') {
+  800322:	8b 45 08             	mov    0x8(%ebp),%eax
+  800325:	8d 50 01             	lea    0x1(%eax),%edx
+  800328:	89 55 08             	mov    %edx,0x8(%ebp)
+  80032b:	0f b6 00             	movzbl (%eax),%eax
+  80032e:	88 45 f7             	mov    %al,-0x9(%ebp)
+  800331:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
+  800335:	75 d7                	jne    80030e <cputs+0xf>
+        cputch(c, &cnt);
+    }
+    cputch('\n', &cnt);
+  800337:	83 ec 08             	sub    $0x8,%esp
+  80033a:	8d 45 f0             	lea    -0x10(%ebp),%eax
+  80033d:	50                   	push   %eax
+  80033e:	6a 0a                	push   $0xa
+  800340:	e8 47 ff ff ff       	call   80028c <cputch>
+  800345:	83 c4 10             	add    $0x10,%esp
+    return cnt;
+  800348:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+  80034b:	c9                   	leave  
+  80034c:	c3                   	ret    
+
+0080034d <umain>:
+#include <ulib.h>
+
+int main(void);
+
+void
+umain(void) {
+  80034d:	55                   	push   %ebp
+  80034e:	89 e5                	mov    %esp,%ebp
+  800350:	83 ec 18             	sub    $0x18,%esp
+    int ret = main();
+  800353:	e8 d3 0b 00 00       	call   800f2b <main>
+  800358:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    exit(ret);
+  80035b:	83 ec 0c             	sub    $0xc,%esp
+  80035e:	ff 75 f4             	pushl  -0xc(%ebp)
+  800361:	e8 51 fe ff ff       	call   8001b7 <exit>
+
+00800366 <strlen>:
+ * @s:      the input string
+ *
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+  800366:	55                   	push   %ebp
+  800367:	89 e5                	mov    %esp,%ebp
+  800369:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  80036c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (*s ++ != '\0') {
+  800373:	eb 04                	jmp    800379 <strlen+0x13>
+        cnt ++;
+  800375:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+    size_t cnt = 0;
+    while (*s ++ != '\0') {
+  800379:	8b 45 08             	mov    0x8(%ebp),%eax
+  80037c:	8d 50 01             	lea    0x1(%eax),%edx
+  80037f:	89 55 08             	mov    %edx,0x8(%ebp)
+  800382:	0f b6 00             	movzbl (%eax),%eax
+  800385:	84 c0                	test   %al,%al
+  800387:	75 ec                	jne    800375 <strlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  800389:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  80038c:	c9                   	leave  
+  80038d:	c3                   	ret    
+
+0080038e <strnlen>:
+ * The return value is strlen(s), if that is less than @len, or
+ * @len if there is no '\0' character among the first @len characters
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+  80038e:	55                   	push   %ebp
+  80038f:	89 e5                	mov    %esp,%ebp
+  800391:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  800394:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (cnt < len && *s ++ != '\0') {
+  80039b:	eb 04                	jmp    8003a1 <strnlen+0x13>
+        cnt ++;
+  80039d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+    size_t cnt = 0;
+    while (cnt < len && *s ++ != '\0') {
+  8003a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8003a4:	3b 45 0c             	cmp    0xc(%ebp),%eax
+  8003a7:	73 10                	jae    8003b9 <strnlen+0x2b>
+  8003a9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003ac:	8d 50 01             	lea    0x1(%eax),%edx
+  8003af:	89 55 08             	mov    %edx,0x8(%ebp)
+  8003b2:	0f b6 00             	movzbl (%eax),%eax
+  8003b5:	84 c0                	test   %al,%al
+  8003b7:	75 e4                	jne    80039d <strnlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  8003b9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  8003bc:	c9                   	leave  
+  8003bd:	c3                   	ret    
+
+008003be <strcpy>:
+ * To avoid overflows, the size of array pointed by @dst should be long enough to
+ * contain the same string as @src (including the terminating null character), and
+ * should not overlap in memory with @src.
+ * */
+char *
+strcpy(char *dst, const char *src) {
+  8003be:	55                   	push   %ebp
+  8003bf:	89 e5                	mov    %esp,%ebp
+  8003c1:	57                   	push   %edi
+  8003c2:	56                   	push   %esi
+  8003c3:	83 ec 20             	sub    $0x20,%esp
+  8003c6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  8003cc:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8003cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCPY
+#define __HAVE_ARCH_STRCPY
+static inline char *
+__strcpy(char *dst, const char *src) {
+    int d0, d1, d2;
+    asm volatile (
+  8003d2:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  8003d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8003d8:	89 d1                	mov    %edx,%ecx
+  8003da:	89 c2                	mov    %eax,%edx
+  8003dc:	89 ce                	mov    %ecx,%esi
+  8003de:	89 d7                	mov    %edx,%edi
+  8003e0:	ac                   	lods   %ds:(%esi),%al
+  8003e1:	aa                   	stos   %al,%es:(%edi)
+  8003e2:	84 c0                	test   %al,%al
+  8003e4:	75 fa                	jne    8003e0 <strcpy+0x22>
+  8003e6:	89 fa                	mov    %edi,%edx
+  8003e8:	89 f1                	mov    %esi,%ecx
+  8003ea:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  8003ed:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  8003f0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+        "stosb;"
+        "testb %%al, %%al;"
+        "jne 1b;"
+        : "=&S" (d0), "=&D" (d1), "=&a" (d2)
+        : "0" (src), "1" (dst) : "memory");
+    return dst;
+  8003f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCPY
+    return __strcpy(dst, src);
+  8003f6:	90                   	nop
+    char *p = dst;
+    while ((*p ++ = *src ++) != '\0')
+        /* nothing */;
+    return dst;
+#endif /* __HAVE_ARCH_STRCPY */
+}
+  8003f7:	83 c4 20             	add    $0x20,%esp
+  8003fa:	5e                   	pop    %esi
+  8003fb:	5f                   	pop    %edi
+  8003fc:	5d                   	pop    %ebp
+  8003fd:	c3                   	ret    
+
+008003fe <strncpy>:
+ * @len:    maximum number of characters to be copied from @src
+ *
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+  8003fe:	55                   	push   %ebp
+  8003ff:	89 e5                	mov    %esp,%ebp
+  800401:	83 ec 10             	sub    $0x10,%esp
+    char *p = dst;
+  800404:	8b 45 08             	mov    0x8(%ebp),%eax
+  800407:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    while (len > 0) {
+  80040a:	eb 21                	jmp    80042d <strncpy+0x2f>
+        if ((*p = *src) != '\0') {
+  80040c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80040f:	0f b6 10             	movzbl (%eax),%edx
+  800412:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800415:	88 10                	mov    %dl,(%eax)
+  800417:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  80041a:	0f b6 00             	movzbl (%eax),%eax
+  80041d:	84 c0                	test   %al,%al
+  80041f:	74 04                	je     800425 <strncpy+0x27>
+            src ++;
+  800421:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+        }
+        p ++, len --;
+  800425:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800429:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+    char *p = dst;
+    while (len > 0) {
+  80042d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800431:	75 d9                	jne    80040c <strncpy+0xe>
+        if ((*p = *src) != '\0') {
+            src ++;
+        }
+        p ++, len --;
+    }
+    return dst;
+  800433:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800436:	c9                   	leave  
+  800437:	c3                   	ret    
+
+00800438 <strcmp>:
+ * - A value greater than zero indicates that the first character that does
+ *   not match has a greater value in @s1 than in @s2;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+strcmp(const char *s1, const char *s2) {
+  800438:	55                   	push   %ebp
+  800439:	89 e5                	mov    %esp,%ebp
+  80043b:	57                   	push   %edi
+  80043c:	56                   	push   %esi
+  80043d:	83 ec 20             	sub    $0x20,%esp
+  800440:	8b 45 08             	mov    0x8(%ebp),%eax
+  800443:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800446:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800449:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCMP
+#define __HAVE_ARCH_STRCMP
+static inline int
+__strcmp(const char *s1, const char *s2) {
+    int d0, d1, ret;
+    asm volatile (
+  80044c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80044f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800452:	89 d1                	mov    %edx,%ecx
+  800454:	89 c2                	mov    %eax,%edx
+  800456:	89 ce                	mov    %ecx,%esi
+  800458:	89 d7                	mov    %edx,%edi
+  80045a:	ac                   	lods   %ds:(%esi),%al
+  80045b:	ae                   	scas   %es:(%edi),%al
+  80045c:	75 08                	jne    800466 <strcmp+0x2e>
+  80045e:	84 c0                	test   %al,%al
+  800460:	75 f8                	jne    80045a <strcmp+0x22>
+  800462:	31 c0                	xor    %eax,%eax
+  800464:	eb 04                	jmp    80046a <strcmp+0x32>
+  800466:	19 c0                	sbb    %eax,%eax
+  800468:	0c 01                	or     $0x1,%al
+  80046a:	89 fa                	mov    %edi,%edx
+  80046c:	89 f1                	mov    %esi,%ecx
+  80046e:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800471:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  800474:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+        "orb $1, %%al;"
+        "3:"
+        : "=a" (ret), "=&S" (d0), "=&D" (d1)
+        : "1" (s1), "2" (s2)
+        : "memory");
+    return ret;
+  800477:	8b 45 ec             	mov    -0x14(%ebp),%eax
+#ifdef __HAVE_ARCH_STRCMP
+    return __strcmp(s1, s2);
+  80047a:	90                   	nop
+    while (*s1 != '\0' && *s1 == *s2) {
+        s1 ++, s2 ++;
+    }
+    return (int)((unsigned char)*s1 - (unsigned char)*s2);
+#endif /* __HAVE_ARCH_STRCMP */
+}
+  80047b:	83 c4 20             	add    $0x20,%esp
+  80047e:	5e                   	pop    %esi
+  80047f:	5f                   	pop    %edi
+  800480:	5d                   	pop    %ebp
+  800481:	c3                   	ret    
+
+00800482 <strncmp>:
+ * they are equal to each other, it continues with the following pairs until
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+  800482:	55                   	push   %ebp
+  800483:	89 e5                	mov    %esp,%ebp
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  800485:	eb 0c                	jmp    800493 <strncmp+0x11>
+        n --, s1 ++, s2 ++;
+  800487:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  80048b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  80048f:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  800493:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800497:	74 1a                	je     8004b3 <strncmp+0x31>
+  800499:	8b 45 08             	mov    0x8(%ebp),%eax
+  80049c:	0f b6 00             	movzbl (%eax),%eax
+  80049f:	84 c0                	test   %al,%al
+  8004a1:	74 10                	je     8004b3 <strncmp+0x31>
+  8004a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004a6:	0f b6 10             	movzbl (%eax),%edx
+  8004a9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004ac:	0f b6 00             	movzbl (%eax),%eax
+  8004af:	38 c2                	cmp    %al,%dl
+  8004b1:	74 d4                	je     800487 <strncmp+0x5>
+        n --, s1 ++, s2 ++;
+    }
+    return (n == 0) ? 0 : (int)((unsigned char)*s1 - (unsigned char)*s2);
+  8004b3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8004b7:	74 18                	je     8004d1 <strncmp+0x4f>
+  8004b9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004bc:	0f b6 00             	movzbl (%eax),%eax
+  8004bf:	0f b6 d0             	movzbl %al,%edx
+  8004c2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004c5:	0f b6 00             	movzbl (%eax),%eax
+  8004c8:	0f b6 c0             	movzbl %al,%eax
+  8004cb:	29 c2                	sub    %eax,%edx
+  8004cd:	89 d0                	mov    %edx,%eax
+  8004cf:	eb 05                	jmp    8004d6 <strncmp+0x54>
+  8004d1:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  8004d6:	5d                   	pop    %ebp
+  8004d7:	c3                   	ret    
+
+008004d8 <strchr>:
+ *
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+  8004d8:	55                   	push   %ebp
+  8004d9:	89 e5                	mov    %esp,%ebp
+  8004db:	83 ec 04             	sub    $0x4,%esp
+  8004de:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004e1:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  8004e4:	eb 14                	jmp    8004fa <strchr+0x22>
+        if (*s == c) {
+  8004e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004e9:	0f b6 00             	movzbl (%eax),%eax
+  8004ec:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  8004ef:	75 05                	jne    8004f6 <strchr+0x1e>
+            return (char *)s;
+  8004f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004f4:	eb 13                	jmp    800509 <strchr+0x31>
+        }
+        s ++;
+  8004f6:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+    while (*s != '\0') {
+  8004fa:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004fd:	0f b6 00             	movzbl (%eax),%eax
+  800500:	84 c0                	test   %al,%al
+  800502:	75 e2                	jne    8004e6 <strchr+0xe>
+        if (*s == c) {
+            return (char *)s;
+        }
+        s ++;
+    }
+    return NULL;
+  800504:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800509:	c9                   	leave  
+  80050a:	c3                   	ret    
+
+0080050b <strfind>:
+ * The strfind() function is like strchr() except that if @c is
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+  80050b:	55                   	push   %ebp
+  80050c:	89 e5                	mov    %esp,%ebp
+  80050e:	83 ec 04             	sub    $0x4,%esp
+  800511:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800514:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  800517:	eb 0f                	jmp    800528 <strfind+0x1d>
+        if (*s == c) {
+  800519:	8b 45 08             	mov    0x8(%ebp),%eax
+  80051c:	0f b6 00             	movzbl (%eax),%eax
+  80051f:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800522:	74 10                	je     800534 <strfind+0x29>
+            break;
+        }
+        s ++;
+  800524:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+    while (*s != '\0') {
+  800528:	8b 45 08             	mov    0x8(%ebp),%eax
+  80052b:	0f b6 00             	movzbl (%eax),%eax
+  80052e:	84 c0                	test   %al,%al
+  800530:	75 e7                	jne    800519 <strfind+0xe>
+  800532:	eb 01                	jmp    800535 <strfind+0x2a>
+        if (*s == c) {
+            break;
+  800534:	90                   	nop
+        }
+        s ++;
+    }
+    return (char *)s;
+  800535:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800538:	c9                   	leave  
+  800539:	c3                   	ret    
+
+0080053a <strtol>:
+ * an optional "0x" or "0X" prefix.
+ *
+ * The strtol() function returns the converted integral number as a long int value.
+ * */
+long
+strtol(const char *s, char **endptr, int base) {
+  80053a:	55                   	push   %ebp
+  80053b:	89 e5                	mov    %esp,%ebp
+  80053d:	83 ec 10             	sub    $0x10,%esp
+    int neg = 0;
+  800540:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    long val = 0;
+  800547:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  80054e:	eb 04                	jmp    800554 <strtol+0x1a>
+        s ++;
+  800550:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+strtol(const char *s, char **endptr, int base) {
+    int neg = 0;
+    long val = 0;
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  800554:	8b 45 08             	mov    0x8(%ebp),%eax
+  800557:	0f b6 00             	movzbl (%eax),%eax
+  80055a:	3c 20                	cmp    $0x20,%al
+  80055c:	74 f2                	je     800550 <strtol+0x16>
+  80055e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800561:	0f b6 00             	movzbl (%eax),%eax
+  800564:	3c 09                	cmp    $0x9,%al
+  800566:	74 e8                	je     800550 <strtol+0x16>
+        s ++;
+    }
+
+    // plus/minus sign
+    if (*s == '+') {
+  800568:	8b 45 08             	mov    0x8(%ebp),%eax
+  80056b:	0f b6 00             	movzbl (%eax),%eax
+  80056e:	3c 2b                	cmp    $0x2b,%al
+  800570:	75 06                	jne    800578 <strtol+0x3e>
+        s ++;
+  800572:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800576:	eb 15                	jmp    80058d <strtol+0x53>
+    }
+    else if (*s == '-') {
+  800578:	8b 45 08             	mov    0x8(%ebp),%eax
+  80057b:	0f b6 00             	movzbl (%eax),%eax
+  80057e:	3c 2d                	cmp    $0x2d,%al
+  800580:	75 0b                	jne    80058d <strtol+0x53>
+        s ++, neg = 1;
+  800582:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800586:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+    }
+
+    // hex or octal base prefix
+    if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x')) {
+  80058d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800591:	74 06                	je     800599 <strtol+0x5f>
+  800593:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+  800597:	75 24                	jne    8005bd <strtol+0x83>
+  800599:	8b 45 08             	mov    0x8(%ebp),%eax
+  80059c:	0f b6 00             	movzbl (%eax),%eax
+  80059f:	3c 30                	cmp    $0x30,%al
+  8005a1:	75 1a                	jne    8005bd <strtol+0x83>
+  8005a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005a6:	83 c0 01             	add    $0x1,%eax
+  8005a9:	0f b6 00             	movzbl (%eax),%eax
+  8005ac:	3c 78                	cmp    $0x78,%al
+  8005ae:	75 0d                	jne    8005bd <strtol+0x83>
+        s += 2, base = 16;
+  8005b0:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+  8005b4:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+  8005bb:	eb 2a                	jmp    8005e7 <strtol+0xad>
+    }
+    else if (base == 0 && s[0] == '0') {
+  8005bd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8005c1:	75 17                	jne    8005da <strtol+0xa0>
+  8005c3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005c6:	0f b6 00             	movzbl (%eax),%eax
+  8005c9:	3c 30                	cmp    $0x30,%al
+  8005cb:	75 0d                	jne    8005da <strtol+0xa0>
+        s ++, base = 8;
+  8005cd:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  8005d1:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+  8005d8:	eb 0d                	jmp    8005e7 <strtol+0xad>
+    }
+    else if (base == 0) {
+  8005da:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  8005de:	75 07                	jne    8005e7 <strtol+0xad>
+        base = 10;
+  8005e0:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+    // digits
+    while (1) {
+        int dig;
+
+        if (*s >= '0' && *s <= '9') {
+  8005e7:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005ea:	0f b6 00             	movzbl (%eax),%eax
+  8005ed:	3c 2f                	cmp    $0x2f,%al
+  8005ef:	7e 1b                	jle    80060c <strtol+0xd2>
+  8005f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005f4:	0f b6 00             	movzbl (%eax),%eax
+  8005f7:	3c 39                	cmp    $0x39,%al
+  8005f9:	7f 11                	jg     80060c <strtol+0xd2>
+            dig = *s - '0';
+  8005fb:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005fe:	0f b6 00             	movzbl (%eax),%eax
+  800601:	0f be c0             	movsbl %al,%eax
+  800604:	83 e8 30             	sub    $0x30,%eax
+  800607:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80060a:	eb 48                	jmp    800654 <strtol+0x11a>
+        }
+        else if (*s >= 'a' && *s <= 'z') {
+  80060c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80060f:	0f b6 00             	movzbl (%eax),%eax
+  800612:	3c 60                	cmp    $0x60,%al
+  800614:	7e 1b                	jle    800631 <strtol+0xf7>
+  800616:	8b 45 08             	mov    0x8(%ebp),%eax
+  800619:	0f b6 00             	movzbl (%eax),%eax
+  80061c:	3c 7a                	cmp    $0x7a,%al
+  80061e:	7f 11                	jg     800631 <strtol+0xf7>
+            dig = *s - 'a' + 10;
+  800620:	8b 45 08             	mov    0x8(%ebp),%eax
+  800623:	0f b6 00             	movzbl (%eax),%eax
+  800626:	0f be c0             	movsbl %al,%eax
+  800629:	83 e8 57             	sub    $0x57,%eax
+  80062c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80062f:	eb 23                	jmp    800654 <strtol+0x11a>
+        }
+        else if (*s >= 'A' && *s <= 'Z') {
+  800631:	8b 45 08             	mov    0x8(%ebp),%eax
+  800634:	0f b6 00             	movzbl (%eax),%eax
+  800637:	3c 40                	cmp    $0x40,%al
+  800639:	7e 3c                	jle    800677 <strtol+0x13d>
+  80063b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80063e:	0f b6 00             	movzbl (%eax),%eax
+  800641:	3c 5a                	cmp    $0x5a,%al
+  800643:	7f 32                	jg     800677 <strtol+0x13d>
+            dig = *s - 'A' + 10;
+  800645:	8b 45 08             	mov    0x8(%ebp),%eax
+  800648:	0f b6 00             	movzbl (%eax),%eax
+  80064b:	0f be c0             	movsbl %al,%eax
+  80064e:	83 e8 37             	sub    $0x37,%eax
+  800651:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+  800654:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800657:	3b 45 10             	cmp    0x10(%ebp),%eax
+  80065a:	7d 1a                	jge    800676 <strtol+0x13c>
+            break;
+        }
+        s ++, val = (val * base) + dig;
+  80065c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800660:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800663:	0f af 45 10          	imul   0x10(%ebp),%eax
+  800667:	89 c2                	mov    %eax,%edx
+  800669:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  80066c:	01 d0                	add    %edx,%eax
+  80066e:	89 45 f8             	mov    %eax,-0x8(%ebp)
+        // we don't properly detect overflow!
+    }
+  800671:	e9 71 ff ff ff       	jmp    8005e7 <strtol+0xad>
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+            break;
+  800676:	90                   	nop
+        }
+        s ++, val = (val * base) + dig;
+        // we don't properly detect overflow!
+    }
+
+    if (endptr) {
+  800677:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  80067b:	74 08                	je     800685 <strtol+0x14b>
+        *endptr = (char *) s;
+  80067d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800680:	8b 55 08             	mov    0x8(%ebp),%edx
+  800683:	89 10                	mov    %edx,(%eax)
+    }
+    return (neg ? -val : val);
+  800685:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+  800689:	74 07                	je     800692 <strtol+0x158>
+  80068b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  80068e:	f7 d8                	neg    %eax
+  800690:	eb 03                	jmp    800695 <strtol+0x15b>
+  800692:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  800695:	c9                   	leave  
+  800696:	c3                   	ret    
+
+00800697 <memset>:
+ * @n:      number of bytes to be set to the value
+ *
+ * The memset() function returns @s.
+ * */
+void *
+memset(void *s, char c, size_t n) {
+  800697:	55                   	push   %ebp
+  800698:	89 e5                	mov    %esp,%ebp
+  80069a:	57                   	push   %edi
+  80069b:	83 ec 24             	sub    $0x24,%esp
+  80069e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006a1:	88 45 d8             	mov    %al,-0x28(%ebp)
+#ifdef __HAVE_ARCH_MEMSET
+    return __memset(s, c, n);
+  8006a4:	0f be 45 d8          	movsbl -0x28(%ebp),%eax
+  8006a8:	8b 55 08             	mov    0x8(%ebp),%edx
+  8006ab:	89 55 f8             	mov    %edx,-0x8(%ebp)
+  8006ae:	88 45 f7             	mov    %al,-0x9(%ebp)
+  8006b1:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_MEMSET
+#define __HAVE_ARCH_MEMSET
+static inline void *
+__memset(void *s, char c, size_t n) {
+    int d0, d1;
+    asm volatile (
+  8006b7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+  8006ba:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
+  8006be:	8b 55 f8             	mov    -0x8(%ebp),%edx
+  8006c1:	89 d7                	mov    %edx,%edi
+  8006c3:	f3 aa                	rep stos %al,%es:(%edi)
+  8006c5:	89 fa                	mov    %edi,%edx
+  8006c7:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  8006ca:	89 55 e8             	mov    %edx,-0x18(%ebp)
+        "rep; stosb;"
+        : "=&c" (d0), "=&D" (d1)
+        : "0" (n), "a" (c), "1" (s)
+        : "memory");
+    return s;
+  8006cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8006d0:	90                   	nop
+    while (n -- > 0) {
+        *p ++ = c;
+    }
+    return s;
+#endif /* __HAVE_ARCH_MEMSET */
+}
+  8006d1:	83 c4 24             	add    $0x24,%esp
+  8006d4:	5f                   	pop    %edi
+  8006d5:	5d                   	pop    %ebp
+  8006d6:	c3                   	ret    
+
+008006d7 <memmove>:
+ * @n:      number of bytes to copy
+ *
+ * The memmove() function returns @dst.
+ * */
+void *
+memmove(void *dst, const void *src, size_t n) {
+  8006d7:	55                   	push   %ebp
+  8006d8:	89 e5                	mov    %esp,%ebp
+  8006da:	57                   	push   %edi
+  8006db:	56                   	push   %esi
+  8006dc:	53                   	push   %ebx
+  8006dd:	83 ec 30             	sub    $0x30,%esp
+  8006e0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8006e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8006e6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  8006ec:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006ef:	89 45 e8             	mov    %eax,-0x18(%ebp)
+
+#ifndef __HAVE_ARCH_MEMMOVE
+#define __HAVE_ARCH_MEMMOVE
+static inline void *
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+  8006f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006f5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  8006f8:	73 42                	jae    80073c <memmove+0x65>
+  8006fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006fd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800700:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800703:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800706:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800709:	89 45 dc             	mov    %eax,-0x24(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  80070c:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  80070f:	c1 e8 02             	shr    $0x2,%eax
+  800712:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  800714:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800717:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80071a:	89 d7                	mov    %edx,%edi
+  80071c:	89 c6                	mov    %eax,%esi
+  80071e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800720:	8b 4d dc             	mov    -0x24(%ebp),%ecx
+  800723:	83 e1 03             	and    $0x3,%ecx
+  800726:	74 02                	je     80072a <memmove+0x53>
+  800728:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  80072a:	89 f0                	mov    %esi,%eax
+  80072c:	89 fa                	mov    %edi,%edx
+  80072e:	89 4d d8             	mov    %ecx,-0x28(%ebp)
+  800731:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  800734:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  800737:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMMOVE
+    return __memmove(dst, src, n);
+  80073a:	eb 36                	jmp    800772 <memmove+0x9b>
+    asm volatile (
+        "std;"
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+  80073c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80073f:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800742:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800745:	01 c2                	add    %eax,%edx
+  800747:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80074a:	8d 48 ff             	lea    -0x1(%eax),%ecx
+  80074d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800750:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+        return __memcpy(dst, src, n);
+    }
+    int d0, d1, d2;
+    asm volatile (
+  800753:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800756:	89 c1                	mov    %eax,%ecx
+  800758:	89 d8                	mov    %ebx,%eax
+  80075a:	89 d6                	mov    %edx,%esi
+  80075c:	89 c7                	mov    %eax,%edi
+  80075e:	fd                   	std    
+  80075f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  800761:	fc                   	cld    
+  800762:	89 f8                	mov    %edi,%eax
+  800764:	89 f2                	mov    %esi,%edx
+  800766:	89 4d cc             	mov    %ecx,-0x34(%ebp)
+  800769:	89 55 c8             	mov    %edx,-0x38(%ebp)
+  80076c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+        : "memory");
+    return dst;
+  80076f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+            *d ++ = *s ++;
+        }
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMMOVE */
+}
+  800772:	83 c4 30             	add    $0x30,%esp
+  800775:	5b                   	pop    %ebx
+  800776:	5e                   	pop    %esi
+  800777:	5f                   	pop    %edi
+  800778:	5d                   	pop    %ebp
+  800779:	c3                   	ret    
+
+0080077a <memcpy>:
+ * it always copies exactly @n bytes. To avoid overflows, the size of arrays pointed
+ * by both @src and @dst, should be at least @n bytes, and should not overlap
+ * (for overlapping memory area, memmove is a safer approach).
+ * */
+void *
+memcpy(void *dst, const void *src, size_t n) {
+  80077a:	55                   	push   %ebp
+  80077b:	89 e5                	mov    %esp,%ebp
+  80077d:	57                   	push   %edi
+  80077e:	56                   	push   %esi
+  80077f:	83 ec 20             	sub    $0x20,%esp
+  800782:	8b 45 08             	mov    0x8(%ebp),%eax
+  800785:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800788:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80078b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80078e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800791:	89 45 ec             	mov    %eax,-0x14(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  800794:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800797:	c1 e8 02             	shr    $0x2,%eax
+  80079a:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  80079c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80079f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8007a2:	89 d7                	mov    %edx,%edi
+  8007a4:	89 c6                	mov    %eax,%esi
+  8007a6:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  8007a8:	8b 4d ec             	mov    -0x14(%ebp),%ecx
+  8007ab:	83 e1 03             	and    $0x3,%ecx
+  8007ae:	74 02                	je     8007b2 <memcpy+0x38>
+  8007b0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  8007b2:	89 f0                	mov    %esi,%eax
+  8007b4:	89 fa                	mov    %edi,%edx
+  8007b6:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  8007b9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  8007bc:	89 45 e0             	mov    %eax,-0x20(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  8007bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+#ifdef __HAVE_ARCH_MEMCPY
+    return __memcpy(dst, src, n);
+  8007c2:	90                   	nop
+    while (n -- > 0) {
+        *d ++ = *s ++;
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMCPY */
+}
+  8007c3:	83 c4 20             	add    $0x20,%esp
+  8007c6:	5e                   	pop    %esi
+  8007c7:	5f                   	pop    %edi
+  8007c8:	5d                   	pop    %ebp
+  8007c9:	c3                   	ret    
+
+008007ca <memcmp>:
+ *   match in both memory blocks has a greater value in @v1 than in @v2
+ *   as if evaluated as unsigned char values;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+  8007ca:	55                   	push   %ebp
+  8007cb:	89 e5                	mov    %esp,%ebp
+  8007cd:	83 ec 10             	sub    $0x10,%esp
+    const char *s1 = (const char *)v1;
+  8007d0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8007d3:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    const char *s2 = (const char *)v2;
+  8007d6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8007d9:	89 45 f8             	mov    %eax,-0x8(%ebp)
+    while (n -- > 0) {
+  8007dc:	eb 30                	jmp    80080e <memcmp+0x44>
+        if (*s1 != *s2) {
+  8007de:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8007e1:	0f b6 10             	movzbl (%eax),%edx
+  8007e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8007e7:	0f b6 00             	movzbl (%eax),%eax
+  8007ea:	38 c2                	cmp    %al,%dl
+  8007ec:	74 18                	je     800806 <memcmp+0x3c>
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+  8007ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  8007f1:	0f b6 00             	movzbl (%eax),%eax
+  8007f4:	0f b6 d0             	movzbl %al,%edx
+  8007f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  8007fa:	0f b6 00             	movzbl (%eax),%eax
+  8007fd:	0f b6 c0             	movzbl %al,%eax
+  800800:	29 c2                	sub    %eax,%edx
+  800802:	89 d0                	mov    %edx,%eax
+  800804:	eb 1a                	jmp    800820 <memcmp+0x56>
+        }
+        s1 ++, s2 ++;
+  800806:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  80080a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+    const char *s1 = (const char *)v1;
+    const char *s2 = (const char *)v2;
+    while (n -- > 0) {
+  80080e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800811:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800814:	89 55 10             	mov    %edx,0x10(%ebp)
+  800817:	85 c0                	test   %eax,%eax
+  800819:	75 c3                	jne    8007de <memcmp+0x14>
+        if (*s1 != *s2) {
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+        }
+        s1 ++, s2 ++;
+    }
+    return 0;
+  80081b:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800820:	c9                   	leave  
+  800821:	c3                   	ret    
+
+00800822 <printnum>:
+ * @width:      maximum number of digits, if the actual width is less than @width, use @padc instead
+ * @padc:       character that padded on the left if the actual width is less than @width
+ * */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+        unsigned long long num, unsigned base, int width, int padc) {
+  800822:	55                   	push   %ebp
+  800823:	89 e5                	mov    %esp,%ebp
+  800825:	83 ec 38             	sub    $0x38,%esp
+  800828:	8b 45 10             	mov    0x10(%ebp),%eax
+  80082b:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  80082e:	8b 45 14             	mov    0x14(%ebp),%eax
+  800831:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+    unsigned long long result = num;
+  800834:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  800837:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  80083a:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  80083d:	89 55 ec             	mov    %edx,-0x14(%ebp)
+    unsigned mod = do_div(result, base);
+  800840:	8b 45 18             	mov    0x18(%ebp),%eax
+  800843:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800846:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800849:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  80084c:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  80084f:	89 55 f0             	mov    %edx,-0x10(%ebp)
+  800852:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800855:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800858:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  80085c:	74 1c                	je     80087a <printnum+0x58>
+  80085e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800861:	ba 00 00 00 00       	mov    $0x0,%edx
+  800866:	f7 75 e4             	divl   -0x1c(%ebp)
+  800869:	89 55 f4             	mov    %edx,-0xc(%ebp)
+  80086c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  80086f:	ba 00 00 00 00       	mov    $0x0,%edx
+  800874:	f7 75 e4             	divl   -0x1c(%ebp)
+  800877:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80087a:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80087d:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800880:	f7 75 e4             	divl   -0x1c(%ebp)
+  800883:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800886:	89 55 dc             	mov    %edx,-0x24(%ebp)
+  800889:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80088c:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  80088f:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800892:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  800895:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  800898:	89 45 d8             	mov    %eax,-0x28(%ebp)
+
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+  80089b:	8b 45 18             	mov    0x18(%ebp),%eax
+  80089e:	ba 00 00 00 00       	mov    $0x0,%edx
+  8008a3:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  8008a6:	77 41                	ja     8008e9 <printnum+0xc7>
+  8008a8:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  8008ab:	72 05                	jb     8008b2 <printnum+0x90>
+  8008ad:	3b 45 d0             	cmp    -0x30(%ebp),%eax
+  8008b0:	77 37                	ja     8008e9 <printnum+0xc7>
+        printnum(putch, putdat, result, base, width - 1, padc);
+  8008b2:	8b 45 1c             	mov    0x1c(%ebp),%eax
+  8008b5:	83 e8 01             	sub    $0x1,%eax
+  8008b8:	83 ec 04             	sub    $0x4,%esp
+  8008bb:	ff 75 20             	pushl  0x20(%ebp)
+  8008be:	50                   	push   %eax
+  8008bf:	ff 75 18             	pushl  0x18(%ebp)
+  8008c2:	ff 75 ec             	pushl  -0x14(%ebp)
+  8008c5:	ff 75 e8             	pushl  -0x18(%ebp)
+  8008c8:	ff 75 0c             	pushl  0xc(%ebp)
+  8008cb:	ff 75 08             	pushl  0x8(%ebp)
+  8008ce:	e8 4f ff ff ff       	call   800822 <printnum>
+  8008d3:	83 c4 20             	add    $0x20,%esp
+  8008d6:	eb 1b                	jmp    8008f3 <printnum+0xd1>
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+            putch(padc, putdat);
+  8008d8:	83 ec 08             	sub    $0x8,%esp
+  8008db:	ff 75 0c             	pushl  0xc(%ebp)
+  8008de:	ff 75 20             	pushl  0x20(%ebp)
+  8008e1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8008e4:	ff d0                	call   *%eax
+  8008e6:	83 c4 10             	add    $0x10,%esp
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+        printnum(putch, putdat, result, base, width - 1, padc);
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+  8008e9:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+  8008ed:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+  8008f1:	7f e5                	jg     8008d8 <printnum+0xb6>
+            putch(padc, putdat);
+    }
+    // then print this (the least significant) digit
+    putch("0123456789abcdef"[mod], putdat);
+  8008f3:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  8008f6:	05 24 11 80 00       	add    $0x801124,%eax
+  8008fb:	0f b6 00             	movzbl (%eax),%eax
+  8008fe:	0f be c0             	movsbl %al,%eax
+  800901:	83 ec 08             	sub    $0x8,%esp
+  800904:	ff 75 0c             	pushl  0xc(%ebp)
+  800907:	50                   	push   %eax
+  800908:	8b 45 08             	mov    0x8(%ebp),%eax
+  80090b:	ff d0                	call   *%eax
+  80090d:	83 c4 10             	add    $0x10,%esp
+}
+  800910:	90                   	nop
+  800911:	c9                   	leave  
+  800912:	c3                   	ret    
+
+00800913 <getuint>:
+ * getuint - get an unsigned int of various possible sizes from a varargs list
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static unsigned long long
+getuint(va_list *ap, int lflag) {
+  800913:	55                   	push   %ebp
+  800914:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  800916:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  80091a:	7e 14                	jle    800930 <getuint+0x1d>
+        return va_arg(*ap, unsigned long long);
+  80091c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80091f:	8b 00                	mov    (%eax),%eax
+  800921:	8d 48 08             	lea    0x8(%eax),%ecx
+  800924:	8b 55 08             	mov    0x8(%ebp),%edx
+  800927:	89 0a                	mov    %ecx,(%edx)
+  800929:	8b 50 04             	mov    0x4(%eax),%edx
+  80092c:	8b 00                	mov    (%eax),%eax
+  80092e:	eb 30                	jmp    800960 <getuint+0x4d>
+    }
+    else if (lflag) {
+  800930:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800934:	74 16                	je     80094c <getuint+0x39>
+        return va_arg(*ap, unsigned long);
+  800936:	8b 45 08             	mov    0x8(%ebp),%eax
+  800939:	8b 00                	mov    (%eax),%eax
+  80093b:	8d 48 04             	lea    0x4(%eax),%ecx
+  80093e:	8b 55 08             	mov    0x8(%ebp),%edx
+  800941:	89 0a                	mov    %ecx,(%edx)
+  800943:	8b 00                	mov    (%eax),%eax
+  800945:	ba 00 00 00 00       	mov    $0x0,%edx
+  80094a:	eb 14                	jmp    800960 <getuint+0x4d>
+    }
+    else {
+        return va_arg(*ap, unsigned int);
+  80094c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80094f:	8b 00                	mov    (%eax),%eax
+  800951:	8d 48 04             	lea    0x4(%eax),%ecx
+  800954:	8b 55 08             	mov    0x8(%ebp),%edx
+  800957:	89 0a                	mov    %ecx,(%edx)
+  800959:	8b 00                	mov    (%eax),%eax
+  80095b:	ba 00 00 00 00       	mov    $0x0,%edx
+    }
+}
+  800960:	5d                   	pop    %ebp
+  800961:	c3                   	ret    
+
+00800962 <getint>:
+ * getint - same as getuint but signed, we can't use getuint because of sign extension
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static long long
+getint(va_list *ap, int lflag) {
+  800962:	55                   	push   %ebp
+  800963:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  800965:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  800969:	7e 14                	jle    80097f <getint+0x1d>
+        return va_arg(*ap, long long);
+  80096b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80096e:	8b 00                	mov    (%eax),%eax
+  800970:	8d 48 08             	lea    0x8(%eax),%ecx
+  800973:	8b 55 08             	mov    0x8(%ebp),%edx
+  800976:	89 0a                	mov    %ecx,(%edx)
+  800978:	8b 50 04             	mov    0x4(%eax),%edx
+  80097b:	8b 00                	mov    (%eax),%eax
+  80097d:	eb 28                	jmp    8009a7 <getint+0x45>
+    }
+    else if (lflag) {
+  80097f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800983:	74 12                	je     800997 <getint+0x35>
+        return va_arg(*ap, long);
+  800985:	8b 45 08             	mov    0x8(%ebp),%eax
+  800988:	8b 00                	mov    (%eax),%eax
+  80098a:	8d 48 04             	lea    0x4(%eax),%ecx
+  80098d:	8b 55 08             	mov    0x8(%ebp),%edx
+  800990:	89 0a                	mov    %ecx,(%edx)
+  800992:	8b 00                	mov    (%eax),%eax
+  800994:	99                   	cltd   
+  800995:	eb 10                	jmp    8009a7 <getint+0x45>
+    }
+    else {
+        return va_arg(*ap, int);
+  800997:	8b 45 08             	mov    0x8(%ebp),%eax
+  80099a:	8b 00                	mov    (%eax),%eax
+  80099c:	8d 48 04             	lea    0x4(%eax),%ecx
+  80099f:	8b 55 08             	mov    0x8(%ebp),%edx
+  8009a2:	89 0a                	mov    %ecx,(%edx)
+  8009a4:	8b 00                	mov    (%eax),%eax
+  8009a6:	99                   	cltd   
+    }
+}
+  8009a7:	5d                   	pop    %ebp
+  8009a8:	c3                   	ret    
+
+008009a9 <printfmt>:
+ * @putch:      specified putch function, print a single character
+ * @putdat:     used by @putch function
+ * @fmt:        the format string to use
+ * */
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...) {
+  8009a9:	55                   	push   %ebp
+  8009aa:	89 e5                	mov    %esp,%ebp
+  8009ac:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  8009af:	8d 45 14             	lea    0x14(%ebp),%eax
+  8009b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    vprintfmt(putch, putdat, fmt, ap);
+  8009b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8009b8:	50                   	push   %eax
+  8009b9:	ff 75 10             	pushl  0x10(%ebp)
+  8009bc:	ff 75 0c             	pushl  0xc(%ebp)
+  8009bf:	ff 75 08             	pushl  0x8(%ebp)
+  8009c2:	e8 06 00 00 00       	call   8009cd <vprintfmt>
+  8009c7:	83 c4 10             	add    $0x10,%esp
+    va_end(ap);
+}
+  8009ca:	90                   	nop
+  8009cb:	c9                   	leave  
+  8009cc:	c3                   	ret    
+
+008009cd <vprintfmt>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want printfmt() instead.
+ * */
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap) {
+  8009cd:	55                   	push   %ebp
+  8009ce:	89 e5                	mov    %esp,%ebp
+  8009d0:	56                   	push   %esi
+  8009d1:	53                   	push   %ebx
+  8009d2:	83 ec 20             	sub    $0x20,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  8009d5:	eb 17                	jmp    8009ee <vprintfmt+0x21>
+            if (ch == '\0') {
+  8009d7:	85 db                	test   %ebx,%ebx
+  8009d9:	0f 84 8e 03 00 00    	je     800d6d <vprintfmt+0x3a0>
+                return;
+            }
+            putch(ch, putdat);
+  8009df:	83 ec 08             	sub    $0x8,%esp
+  8009e2:	ff 75 0c             	pushl  0xc(%ebp)
+  8009e5:	53                   	push   %ebx
+  8009e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009e9:	ff d0                	call   *%eax
+  8009eb:	83 c4 10             	add    $0x10,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  8009ee:	8b 45 10             	mov    0x10(%ebp),%eax
+  8009f1:	8d 50 01             	lea    0x1(%eax),%edx
+  8009f4:	89 55 10             	mov    %edx,0x10(%ebp)
+  8009f7:	0f b6 00             	movzbl (%eax),%eax
+  8009fa:	0f b6 d8             	movzbl %al,%ebx
+  8009fd:	83 fb 25             	cmp    $0x25,%ebx
+  800a00:	75 d5                	jne    8009d7 <vprintfmt+0xa>
+            }
+            putch(ch, putdat);
+        }
+
+        // Process a %-escape sequence
+        char padc = ' ';
+  800a02:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+        width = precision = -1;
+  800a06:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+  800a0d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800a10:	89 45 e8             	mov    %eax,-0x18(%ebp)
+        lflag = altflag = 0;
+  800a13:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+  800a1a:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  800a1d:	89 45 e0             	mov    %eax,-0x20(%ebp)
+
+    reswitch:
+        switch (ch = *(unsigned char *)fmt ++) {
+  800a20:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a23:	8d 50 01             	lea    0x1(%eax),%edx
+  800a26:	89 55 10             	mov    %edx,0x10(%ebp)
+  800a29:	0f b6 00             	movzbl (%eax),%eax
+  800a2c:	0f b6 d8             	movzbl %al,%ebx
+  800a2f:	8d 43 dd             	lea    -0x23(%ebx),%eax
+  800a32:	83 f8 55             	cmp    $0x55,%eax
+  800a35:	0f 87 05 03 00 00    	ja     800d40 <vprintfmt+0x373>
+  800a3b:	8b 04 85 48 11 80 00 	mov    0x801148(,%eax,4),%eax
+  800a42:	ff e0                	jmp    *%eax
+
+        // flag to pad on the right
+        case '-':
+            padc = '-';
+  800a44:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+            goto reswitch;
+  800a48:	eb d6                	jmp    800a20 <vprintfmt+0x53>
+
+        // flag to pad with 0's instead of spaces
+        case '0':
+            padc = '0';
+  800a4a:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+            goto reswitch;
+  800a4e:	eb d0                	jmp    800a20 <vprintfmt+0x53>
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  800a50:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+                precision = precision * 10 + ch - '0';
+  800a57:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800a5a:	89 d0                	mov    %edx,%eax
+  800a5c:	c1 e0 02             	shl    $0x2,%eax
+  800a5f:	01 d0                	add    %edx,%eax
+  800a61:	01 c0                	add    %eax,%eax
+  800a63:	01 d8                	add    %ebx,%eax
+  800a65:	83 e8 30             	sub    $0x30,%eax
+  800a68:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+                ch = *fmt;
+  800a6b:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a6e:	0f b6 00             	movzbl (%eax),%eax
+  800a71:	0f be d8             	movsbl %al,%ebx
+                if (ch < '0' || ch > '9') {
+  800a74:	83 fb 2f             	cmp    $0x2f,%ebx
+  800a77:	7e 39                	jle    800ab2 <vprintfmt+0xe5>
+  800a79:	83 fb 39             	cmp    $0x39,%ebx
+  800a7c:	7f 34                	jg     800ab2 <vprintfmt+0xe5>
+            padc = '0';
+            goto reswitch;
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  800a7e:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+                precision = precision * 10 + ch - '0';
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+  800a82:	eb d3                	jmp    800a57 <vprintfmt+0x8a>
+            goto process_precision;
+
+        case '*':
+            precision = va_arg(ap, int);
+  800a84:	8b 45 14             	mov    0x14(%ebp),%eax
+  800a87:	8d 50 04             	lea    0x4(%eax),%edx
+  800a8a:	89 55 14             	mov    %edx,0x14(%ebp)
+  800a8d:	8b 00                	mov    (%eax),%eax
+  800a8f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+            goto process_precision;
+  800a92:	eb 1f                	jmp    800ab3 <vprintfmt+0xe6>
+
+        case '.':
+            if (width < 0)
+  800a94:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800a98:	79 86                	jns    800a20 <vprintfmt+0x53>
+                width = 0;
+  800a9a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+            goto reswitch;
+  800aa1:	e9 7a ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        case '#':
+            altflag = 1;
+  800aa6:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+            goto reswitch;
+  800aad:	e9 6e ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+            goto process_precision;
+  800ab2:	90                   	nop
+        case '#':
+            altflag = 1;
+            goto reswitch;
+
+        process_precision:
+            if (width < 0)
+  800ab3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ab7:	0f 89 63 ff ff ff    	jns    800a20 <vprintfmt+0x53>
+                width = precision, precision = -1;
+  800abd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800ac0:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800ac3:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+            goto reswitch;
+  800aca:	e9 51 ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        // long flag (doubled for long long)
+        case 'l':
+            lflag ++;
+  800acf:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
+            goto reswitch;
+  800ad3:	e9 48 ff ff ff       	jmp    800a20 <vprintfmt+0x53>
+
+        // character
+        case 'c':
+            putch(va_arg(ap, int), putdat);
+  800ad8:	8b 45 14             	mov    0x14(%ebp),%eax
+  800adb:	8d 50 04             	lea    0x4(%eax),%edx
+  800ade:	89 55 14             	mov    %edx,0x14(%ebp)
+  800ae1:	8b 00                	mov    (%eax),%eax
+  800ae3:	83 ec 08             	sub    $0x8,%esp
+  800ae6:	ff 75 0c             	pushl  0xc(%ebp)
+  800ae9:	50                   	push   %eax
+  800aea:	8b 45 08             	mov    0x8(%ebp),%eax
+  800aed:	ff d0                	call   *%eax
+  800aef:	83 c4 10             	add    $0x10,%esp
+            break;
+  800af2:	e9 71 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // error message
+        case 'e':
+            err = va_arg(ap, int);
+  800af7:	8b 45 14             	mov    0x14(%ebp),%eax
+  800afa:	8d 50 04             	lea    0x4(%eax),%edx
+  800afd:	89 55 14             	mov    %edx,0x14(%ebp)
+  800b00:	8b 18                	mov    (%eax),%ebx
+            if (err < 0) {
+  800b02:	85 db                	test   %ebx,%ebx
+  800b04:	79 02                	jns    800b08 <vprintfmt+0x13b>
+                err = -err;
+  800b06:	f7 db                	neg    %ebx
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+  800b08:	83 fb 18             	cmp    $0x18,%ebx
+  800b0b:	7f 0b                	jg     800b18 <vprintfmt+0x14b>
+  800b0d:	8b 34 9d c0 10 80 00 	mov    0x8010c0(,%ebx,4),%esi
+  800b14:	85 f6                	test   %esi,%esi
+  800b16:	75 19                	jne    800b31 <vprintfmt+0x164>
+                printfmt(putch, putdat, "error %d", err);
+  800b18:	53                   	push   %ebx
+  800b19:	68 35 11 80 00       	push   $0x801135
+  800b1e:	ff 75 0c             	pushl  0xc(%ebp)
+  800b21:	ff 75 08             	pushl  0x8(%ebp)
+  800b24:	e8 80 fe ff ff       	call   8009a9 <printfmt>
+  800b29:	83 c4 10             	add    $0x10,%esp
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+            }
+            break;
+  800b2c:	e9 37 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+                printfmt(putch, putdat, "error %d", err);
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+  800b31:	56                   	push   %esi
+  800b32:	68 3e 11 80 00       	push   $0x80113e
+  800b37:	ff 75 0c             	pushl  0xc(%ebp)
+  800b3a:	ff 75 08             	pushl  0x8(%ebp)
+  800b3d:	e8 67 fe ff ff       	call   8009a9 <printfmt>
+  800b42:	83 c4 10             	add    $0x10,%esp
+            }
+            break;
+  800b45:	e9 1e 02 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // string
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+  800b4a:	8b 45 14             	mov    0x14(%ebp),%eax
+  800b4d:	8d 50 04             	lea    0x4(%eax),%edx
+  800b50:	89 55 14             	mov    %edx,0x14(%ebp)
+  800b53:	8b 30                	mov    (%eax),%esi
+  800b55:	85 f6                	test   %esi,%esi
+  800b57:	75 05                	jne    800b5e <vprintfmt+0x191>
+                p = "(null)";
+  800b59:	be 41 11 80 00       	mov    $0x801141,%esi
+            }
+            if (width > 0 && padc != '-') {
+  800b5e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800b62:	7e 76                	jle    800bda <vprintfmt+0x20d>
+  800b64:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+  800b68:	74 70                	je     800bda <vprintfmt+0x20d>
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  800b6a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800b6d:	83 ec 08             	sub    $0x8,%esp
+  800b70:	50                   	push   %eax
+  800b71:	56                   	push   %esi
+  800b72:	e8 17 f8 ff ff       	call   80038e <strnlen>
+  800b77:	83 c4 10             	add    $0x10,%esp
+  800b7a:	89 c2                	mov    %eax,%edx
+  800b7c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800b7f:	29 d0                	sub    %edx,%eax
+  800b81:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800b84:	eb 17                	jmp    800b9d <vprintfmt+0x1d0>
+                    putch(padc, putdat);
+  800b86:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+  800b8a:	83 ec 08             	sub    $0x8,%esp
+  800b8d:	ff 75 0c             	pushl  0xc(%ebp)
+  800b90:	50                   	push   %eax
+  800b91:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b94:	ff d0                	call   *%eax
+  800b96:	83 c4 10             	add    $0x10,%esp
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+                p = "(null)";
+            }
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  800b99:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800b9d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ba1:	7f e3                	jg     800b86 <vprintfmt+0x1b9>
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  800ba3:	eb 35                	jmp    800bda <vprintfmt+0x20d>
+                if (altflag && (ch < ' ' || ch > '~')) {
+  800ba5:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+  800ba9:	74 1c                	je     800bc7 <vprintfmt+0x1fa>
+  800bab:	83 fb 1f             	cmp    $0x1f,%ebx
+  800bae:	7e 05                	jle    800bb5 <vprintfmt+0x1e8>
+  800bb0:	83 fb 7e             	cmp    $0x7e,%ebx
+  800bb3:	7e 12                	jle    800bc7 <vprintfmt+0x1fa>
+                    putch('?', putdat);
+  800bb5:	83 ec 08             	sub    $0x8,%esp
+  800bb8:	ff 75 0c             	pushl  0xc(%ebp)
+  800bbb:	6a 3f                	push   $0x3f
+  800bbd:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bc0:	ff d0                	call   *%eax
+  800bc2:	83 c4 10             	add    $0x10,%esp
+  800bc5:	eb 0f                	jmp    800bd6 <vprintfmt+0x209>
+                }
+                else {
+                    putch(ch, putdat);
+  800bc7:	83 ec 08             	sub    $0x8,%esp
+  800bca:	ff 75 0c             	pushl  0xc(%ebp)
+  800bcd:	53                   	push   %ebx
+  800bce:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bd1:	ff d0                	call   *%eax
+  800bd3:	83 c4 10             	add    $0x10,%esp
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  800bd6:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800bda:	89 f0                	mov    %esi,%eax
+  800bdc:	8d 70 01             	lea    0x1(%eax),%esi
+  800bdf:	0f b6 00             	movzbl (%eax),%eax
+  800be2:	0f be d8             	movsbl %al,%ebx
+  800be5:	85 db                	test   %ebx,%ebx
+  800be7:	74 26                	je     800c0f <vprintfmt+0x242>
+  800be9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800bed:	78 b6                	js     800ba5 <vprintfmt+0x1d8>
+  800bef:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800bf3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800bf7:	79 ac                	jns    800ba5 <vprintfmt+0x1d8>
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  800bf9:	eb 14                	jmp    800c0f <vprintfmt+0x242>
+                putch(' ', putdat);
+  800bfb:	83 ec 08             	sub    $0x8,%esp
+  800bfe:	ff 75 0c             	pushl  0xc(%ebp)
+  800c01:	6a 20                	push   $0x20
+  800c03:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c06:	ff d0                	call   *%eax
+  800c08:	83 c4 10             	add    $0x10,%esp
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  800c0b:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  800c0f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800c13:	7f e6                	jg     800bfb <vprintfmt+0x22e>
+                putch(' ', putdat);
+            }
+            break;
+  800c15:	e9 4e 01 00 00       	jmp    800d68 <vprintfmt+0x39b>
+
+        // (signed) decimal
+        case 'd':
+            num = getint(&ap, lflag);
+  800c1a:	83 ec 08             	sub    $0x8,%esp
+  800c1d:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c20:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c23:	50                   	push   %eax
+  800c24:	e8 39 fd ff ff       	call   800962 <getint>
+  800c29:	83 c4 10             	add    $0x10,%esp
+  800c2c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c2f:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            if ((long long)num < 0) {
+  800c32:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c35:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800c38:	85 d2                	test   %edx,%edx
+  800c3a:	79 23                	jns    800c5f <vprintfmt+0x292>
+                putch('-', putdat);
+  800c3c:	83 ec 08             	sub    $0x8,%esp
+  800c3f:	ff 75 0c             	pushl  0xc(%ebp)
+  800c42:	6a 2d                	push   $0x2d
+  800c44:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c47:	ff d0                	call   *%eax
+  800c49:	83 c4 10             	add    $0x10,%esp
+                num = -(long long)num;
+  800c4c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c4f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800c52:	f7 d8                	neg    %eax
+  800c54:	83 d2 00             	adc    $0x0,%edx
+  800c57:	f7 da                	neg    %edx
+  800c59:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c5c:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            }
+            base = 10;
+  800c5f:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  800c66:	e9 9f 00 00 00       	jmp    800d0a <vprintfmt+0x33d>
+
+        // unsigned decimal
+        case 'u':
+            num = getuint(&ap, lflag);
+  800c6b:	83 ec 08             	sub    $0x8,%esp
+  800c6e:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c71:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c74:	50                   	push   %eax
+  800c75:	e8 99 fc ff ff       	call   800913 <getuint>
+  800c7a:	83 c4 10             	add    $0x10,%esp
+  800c7d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800c80:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 10;
+  800c83:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  800c8a:	eb 7e                	jmp    800d0a <vprintfmt+0x33d>
+
+        // (unsigned) octal
+        case 'o':
+            num = getuint(&ap, lflag);
+  800c8c:	83 ec 08             	sub    $0x8,%esp
+  800c8f:	ff 75 e0             	pushl  -0x20(%ebp)
+  800c92:	8d 45 14             	lea    0x14(%ebp),%eax
+  800c95:	50                   	push   %eax
+  800c96:	e8 78 fc ff ff       	call   800913 <getuint>
+  800c9b:	83 c4 10             	add    $0x10,%esp
+  800c9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800ca1:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 8;
+  800ca4:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+            goto number;
+  800cab:	eb 5d                	jmp    800d0a <vprintfmt+0x33d>
+
+        // pointer
+        case 'p':
+            putch('0', putdat);
+  800cad:	83 ec 08             	sub    $0x8,%esp
+  800cb0:	ff 75 0c             	pushl  0xc(%ebp)
+  800cb3:	6a 30                	push   $0x30
+  800cb5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cb8:	ff d0                	call   *%eax
+  800cba:	83 c4 10             	add    $0x10,%esp
+            putch('x', putdat);
+  800cbd:	83 ec 08             	sub    $0x8,%esp
+  800cc0:	ff 75 0c             	pushl  0xc(%ebp)
+  800cc3:	6a 78                	push   $0x78
+  800cc5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cc8:	ff d0                	call   *%eax
+  800cca:	83 c4 10             	add    $0x10,%esp
+            num = (unsigned long long)(uintptr_t)va_arg(ap, void *);
+  800ccd:	8b 45 14             	mov    0x14(%ebp),%eax
+  800cd0:	8d 50 04             	lea    0x4(%eax),%edx
+  800cd3:	89 55 14             	mov    %edx,0x14(%ebp)
+  800cd6:	8b 00                	mov    (%eax),%eax
+  800cd8:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800cdb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+            base = 16;
+  800ce2:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+            goto number;
+  800ce9:	eb 1f                	jmp    800d0a <vprintfmt+0x33d>
+
+        // (unsigned) hexadecimal
+        case 'x':
+            num = getuint(&ap, lflag);
+  800ceb:	83 ec 08             	sub    $0x8,%esp
+  800cee:	ff 75 e0             	pushl  -0x20(%ebp)
+  800cf1:	8d 45 14             	lea    0x14(%ebp),%eax
+  800cf4:	50                   	push   %eax
+  800cf5:	e8 19 fc ff ff       	call   800913 <getuint>
+  800cfa:	83 c4 10             	add    $0x10,%esp
+  800cfd:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800d00:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 16;
+  800d03:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+        number:
+            printnum(putch, putdat, num, base, width, padc);
+  800d0a:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+  800d0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800d11:	83 ec 04             	sub    $0x4,%esp
+  800d14:	52                   	push   %edx
+  800d15:	ff 75 e8             	pushl  -0x18(%ebp)
+  800d18:	50                   	push   %eax
+  800d19:	ff 75 f4             	pushl  -0xc(%ebp)
+  800d1c:	ff 75 f0             	pushl  -0x10(%ebp)
+  800d1f:	ff 75 0c             	pushl  0xc(%ebp)
+  800d22:	ff 75 08             	pushl  0x8(%ebp)
+  800d25:	e8 f8 fa ff ff       	call   800822 <printnum>
+  800d2a:	83 c4 20             	add    $0x20,%esp
+            break;
+  800d2d:	eb 39                	jmp    800d68 <vprintfmt+0x39b>
+
+        // escaped '%' character
+        case '%':
+            putch(ch, putdat);
+  800d2f:	83 ec 08             	sub    $0x8,%esp
+  800d32:	ff 75 0c             	pushl  0xc(%ebp)
+  800d35:	53                   	push   %ebx
+  800d36:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d39:	ff d0                	call   *%eax
+  800d3b:	83 c4 10             	add    $0x10,%esp
+            break;
+  800d3e:	eb 28                	jmp    800d68 <vprintfmt+0x39b>
+
+        // unrecognized escape sequence - just print it literally
+        default:
+            putch('%', putdat);
+  800d40:	83 ec 08             	sub    $0x8,%esp
+  800d43:	ff 75 0c             	pushl  0xc(%ebp)
+  800d46:	6a 25                	push   $0x25
+  800d48:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d4b:	ff d0                	call   *%eax
+  800d4d:	83 c4 10             	add    $0x10,%esp
+            for (fmt --; fmt[-1] != '%'; fmt --)
+  800d50:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800d54:	eb 04                	jmp    800d5a <vprintfmt+0x38d>
+  800d56:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800d5a:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d5d:	83 e8 01             	sub    $0x1,%eax
+  800d60:	0f b6 00             	movzbl (%eax),%eax
+  800d63:	3c 25                	cmp    $0x25,%al
+  800d65:	75 ef                	jne    800d56 <vprintfmt+0x389>
+                /* do nothing */;
+            break;
+  800d67:	90                   	nop
+        }
+    }
+  800d68:	e9 68 fc ff ff       	jmp    8009d5 <vprintfmt+0x8>
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+            if (ch == '\0') {
+                return;
+  800d6d:	90                   	nop
+            for (fmt --; fmt[-1] != '%'; fmt --)
+                /* do nothing */;
+            break;
+        }
+    }
+}
+  800d6e:	8d 65 f8             	lea    -0x8(%ebp),%esp
+  800d71:	5b                   	pop    %ebx
+  800d72:	5e                   	pop    %esi
+  800d73:	5d                   	pop    %ebp
+  800d74:	c3                   	ret    
+
+00800d75 <sprintputch>:
+ * sprintputch - 'print' a single character in a buffer
+ * @ch:         the character will be printed
+ * @b:          the buffer to place the character @ch
+ * */
+static void
+sprintputch(int ch, struct sprintbuf *b) {
+  800d75:	55                   	push   %ebp
+  800d76:	89 e5                	mov    %esp,%ebp
+    b->cnt ++;
+  800d78:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d7b:	8b 40 08             	mov    0x8(%eax),%eax
+  800d7e:	8d 50 01             	lea    0x1(%eax),%edx
+  800d81:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d84:	89 50 08             	mov    %edx,0x8(%eax)
+    if (b->buf < b->ebuf) {
+  800d87:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8a:	8b 10                	mov    (%eax),%edx
+  800d8c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8f:	8b 40 04             	mov    0x4(%eax),%eax
+  800d92:	39 c2                	cmp    %eax,%edx
+  800d94:	73 12                	jae    800da8 <sprintputch+0x33>
+        *b->buf ++ = ch;
+  800d96:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d99:	8b 00                	mov    (%eax),%eax
+  800d9b:	8d 48 01             	lea    0x1(%eax),%ecx
+  800d9e:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800da1:	89 0a                	mov    %ecx,(%edx)
+  800da3:	8b 55 08             	mov    0x8(%ebp),%edx
+  800da6:	88 10                	mov    %dl,(%eax)
+    }
+}
+  800da8:	90                   	nop
+  800da9:	5d                   	pop    %ebp
+  800daa:	c3                   	ret    
+
+00800dab <snprintf>:
+ * @str:        the buffer to place the result into
+ * @size:       the size of buffer, including the trailing null space
+ * @fmt:        the format string to use
+ * */
+int
+snprintf(char *str, size_t size, const char *fmt, ...) {
+  800dab:	55                   	push   %ebp
+  800dac:	89 e5                	mov    %esp,%ebp
+  800dae:	83 ec 18             	sub    $0x18,%esp
+    va_list ap;
+    int cnt;
+    va_start(ap, fmt);
+  800db1:	8d 45 14             	lea    0x14(%ebp),%eax
+  800db4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    cnt = vsnprintf(str, size, fmt, ap);
+  800db7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800dba:	50                   	push   %eax
+  800dbb:	ff 75 10             	pushl  0x10(%ebp)
+  800dbe:	ff 75 0c             	pushl  0xc(%ebp)
+  800dc1:	ff 75 08             	pushl  0x8(%ebp)
+  800dc4:	e8 0b 00 00 00       	call   800dd4 <vsnprintf>
+  800dc9:	83 c4 10             	add    $0x10,%esp
+  800dcc:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+    return cnt;
+  800dcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800dd2:	c9                   	leave  
+  800dd3:	c3                   	ret    
+
+00800dd4 <vsnprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want snprintf() instead.
+ * */
+int
+vsnprintf(char *str, size_t size, const char *fmt, va_list ap) {
+  800dd4:	55                   	push   %ebp
+  800dd5:	89 e5                	mov    %esp,%ebp
+  800dd7:	83 ec 18             	sub    $0x18,%esp
+    struct sprintbuf b = {str, str + size - 1, 0};
+  800dda:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ddd:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800de0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800de3:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800de6:	8b 45 08             	mov    0x8(%ebp),%eax
+  800de9:	01 d0                	add    %edx,%eax
+  800deb:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800dee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    if (str == NULL || b.buf > b.ebuf) {
+  800df5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  800df9:	74 0a                	je     800e05 <vsnprintf+0x31>
+  800dfb:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  800dfe:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800e01:	39 c2                	cmp    %eax,%edx
+  800e03:	76 07                	jbe    800e0c <vsnprintf+0x38>
+        return -E_INVAL;
+  800e05:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+  800e0a:	eb 20                	jmp    800e2c <vsnprintf+0x58>
+    }
+    // print the string to the buffer
+    vprintfmt((void*)sprintputch, &b, fmt, ap);
+  800e0c:	ff 75 14             	pushl  0x14(%ebp)
+  800e0f:	ff 75 10             	pushl  0x10(%ebp)
+  800e12:	8d 45 ec             	lea    -0x14(%ebp),%eax
+  800e15:	50                   	push   %eax
+  800e16:	68 75 0d 80 00       	push   $0x800d75
+  800e1b:	e8 ad fb ff ff       	call   8009cd <vprintfmt>
+  800e20:	83 c4 10             	add    $0x10,%esp
+    // null terminate the buffer
+    *b.buf = '\0';
+  800e23:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e26:	c6 00 00             	movb   $0x0,(%eax)
+    return b.cnt;
+  800e29:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800e2c:	c9                   	leave  
+  800e2d:	c3                   	ret    
+
+00800e2e <hash32>:
+ * @bits:   the number of bits in a return value
+ *
+ * High bits are more random, so we use them.
+ * */
+uint32_t
+hash32(uint32_t val, unsigned int bits) {
+  800e2e:	55                   	push   %ebp
+  800e2f:	89 e5                	mov    %esp,%ebp
+  800e31:	83 ec 10             	sub    $0x10,%esp
+    uint32_t hash = val * GOLDEN_RATIO_PRIME_32;
+  800e34:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e37:	69 c0 01 00 37 9e    	imul   $0x9e370001,%eax,%eax
+  800e3d:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    return (hash >> (32 - bits));
+  800e40:	b8 20 00 00 00       	mov    $0x20,%eax
+  800e45:	2b 45 0c             	sub    0xc(%ebp),%eax
+  800e48:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  800e4b:	89 c1                	mov    %eax,%ecx
+  800e4d:	d3 ea                	shr    %cl,%edx
+  800e4f:	89 d0                	mov    %edx,%eax
+}
+  800e51:	c9                   	leave  
+  800e52:	c3                   	ret    
+
+00800e53 <rand>:
+ * rand - returns a pseudo-random integer
+ *
+ * The rand() function return a value in the range [0, RAND_MAX].
+ * */
+int
+rand(void) {
+  800e53:	55                   	push   %ebp
+  800e54:	89 e5                	mov    %esp,%ebp
+  800e56:	57                   	push   %edi
+  800e57:	56                   	push   %esi
+  800e58:	53                   	push   %ebx
+  800e59:	83 ec 24             	sub    $0x24,%esp
+    next = (next * 0x5DEECE66DLL + 0xBLL) & ((1LL << 48) - 1);
+  800e5c:	a1 00 20 80 00       	mov    0x802000,%eax
+  800e61:	8b 15 04 20 80 00    	mov    0x802004,%edx
+  800e67:	69 fa 6d e6 ec de    	imul   $0xdeece66d,%edx,%edi
+  800e6d:	6b f0 05             	imul   $0x5,%eax,%esi
+  800e70:	01 fe                	add    %edi,%esi
+  800e72:	bf 6d e6 ec de       	mov    $0xdeece66d,%edi
+  800e77:	f7 e7                	mul    %edi
+  800e79:	01 d6                	add    %edx,%esi
+  800e7b:	89 f2                	mov    %esi,%edx
+  800e7d:	83 c0 0b             	add    $0xb,%eax
+  800e80:	83 d2 00             	adc    $0x0,%edx
+  800e83:	89 c7                	mov    %eax,%edi
+  800e85:	83 e7 ff             	and    $0xffffffff,%edi
+  800e88:	89 f9                	mov    %edi,%ecx
+  800e8a:	0f b7 da             	movzwl %dx,%ebx
+  800e8d:	89 0d 00 20 80 00    	mov    %ecx,0x802000
+  800e93:	89 1d 04 20 80 00    	mov    %ebx,0x802004
+    unsigned long long result = (next >> 12);
+  800e99:	a1 00 20 80 00       	mov    0x802000,%eax
+  800e9e:	8b 15 04 20 80 00    	mov    0x802004,%edx
+  800ea4:	0f ac d0 0c          	shrd   $0xc,%edx,%eax
+  800ea8:	c1 ea 0c             	shr    $0xc,%edx
+  800eab:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800eae:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+    return (int)do_div(result, RAND_MAX + 1);
+  800eb1:	c7 45 dc 00 00 00 80 	movl   $0x80000000,-0x24(%ebp)
+  800eb8:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  800ebb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800ebe:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  800ec1:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  800ec4:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ec7:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800eca:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  800ece:	74 1c                	je     800eec <rand+0x99>
+  800ed0:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ed3:	ba 00 00 00 00       	mov    $0x0,%edx
+  800ed8:	f7 75 dc             	divl   -0x24(%ebp)
+  800edb:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  800ede:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800ee1:	ba 00 00 00 00       	mov    $0x0,%edx
+  800ee6:	f7 75 dc             	divl   -0x24(%ebp)
+  800ee9:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  800eec:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  800eef:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  800ef2:	f7 75 dc             	divl   -0x24(%ebp)
+  800ef5:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  800ef8:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  800efb:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  800efe:	8b 55 e8             	mov    -0x18(%ebp),%edx
+  800f01:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  800f04:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  800f07:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+}
+  800f0a:	83 c4 24             	add    $0x24,%esp
+  800f0d:	5b                   	pop    %ebx
+  800f0e:	5e                   	pop    %esi
+  800f0f:	5f                   	pop    %edi
+  800f10:	5d                   	pop    %ebp
+  800f11:	c3                   	ret    
+
+00800f12 <srand>:
+/* *
+ * srand - seed the random number generator with the given number
+ * @seed:   the required seed number
+ * */
+void
+srand(unsigned int seed) {
+  800f12:	55                   	push   %ebp
+  800f13:	89 e5                	mov    %esp,%ebp
+    next = seed;
+  800f15:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f18:	ba 00 00 00 00       	mov    $0x0,%edx
+  800f1d:	a3 00 20 80 00       	mov    %eax,0x802000
+  800f22:	89 15 04 20 80 00    	mov    %edx,0x802004
+}
+  800f28:	90                   	nop
+  800f29:	5d                   	pop    %ebp
+  800f2a:	c3                   	ret    
+
+00800f2b <main>:
+#include <ulib.h>
+#include <stdio.h>
+
+int
+main(void) {
+  800f2b:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+  800f2f:	83 e4 f0             	and    $0xfffffff0,%esp
+  800f32:	ff 71 fc             	pushl  -0x4(%ecx)
+  800f35:	55                   	push   %ebp
+  800f36:	89 e5                	mov    %esp,%ebp
+  800f38:	51                   	push   %ecx
+  800f39:	83 ec 14             	sub    $0x14,%esp
+    int i;
+    cprintf("Hello, I am process %d.\n", getpid());
+  800f3c:	e8 fd f2 ff ff       	call   80023e <getpid>
+  800f41:	83 ec 08             	sub    $0x8,%esp
+  800f44:	50                   	push   %eax
+  800f45:	68 a0 12 80 00       	push   $0x8012a0
+  800f4a:	e8 8a f3 ff ff       	call   8002d9 <cprintf>
+  800f4f:	83 c4 10             	add    $0x10,%esp
+    for (i = 0; i < 5; i ++) {
+  800f52:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  800f59:	eb 22                	jmp    800f7d <main+0x52>
+        yield();
+  800f5b:	e8 ba f2 ff ff       	call   80021a <yield>
+        cprintf("Back in process %d, iteration %d.\n", getpid(), i);
+  800f60:	e8 d9 f2 ff ff       	call   80023e <getpid>
+  800f65:	83 ec 04             	sub    $0x4,%esp
+  800f68:	ff 75 f4             	pushl  -0xc(%ebp)
+  800f6b:	50                   	push   %eax
+  800f6c:	68 bc 12 80 00       	push   $0x8012bc
+  800f71:	e8 63 f3 ff ff       	call   8002d9 <cprintf>
+  800f76:	83 c4 10             	add    $0x10,%esp
+
+int
+main(void) {
+    int i;
+    cprintf("Hello, I am process %d.\n", getpid());
+    for (i = 0; i < 5; i ++) {
+  800f79:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  800f7d:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
+  800f81:	7e d8                	jle    800f5b <main+0x30>
+        yield();
+        cprintf("Back in process %d, iteration %d.\n", getpid(), i);
+    }
+    cprintf("All done in process %d.\n", getpid());
+  800f83:	e8 b6 f2 ff ff       	call   80023e <getpid>
+  800f88:	83 ec 08             	sub    $0x8,%esp
+  800f8b:	50                   	push   %eax
+  800f8c:	68 df 12 80 00       	push   $0x8012df
+  800f91:	e8 43 f3 ff ff       	call   8002d9 <cprintf>
+  800f96:	83 c4 10             	add    $0x10,%esp
+    cprintf("yield pass.\n");
+  800f99:	83 ec 0c             	sub    $0xc,%esp
+  800f9c:	68 f8 12 80 00       	push   $0x8012f8
+  800fa1:	e8 33 f3 ff ff       	call   8002d9 <cprintf>
+  800fa6:	83 c4 10             	add    $0x10,%esp
+    return 0;
+  800fa9:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800fae:	8b 4d fc             	mov    -0x4(%ebp),%ecx
+  800fb1:	c9                   	leave  
+  800fb2:	8d 61 fc             	lea    -0x4(%ecx),%esp
+  800fb5:	c3                   	ret    
diff -r -u -P lab6_origin/obj/user/yield.d lab6/obj/user/yield.d
--- lab6_origin/obj/user/yield.d	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/yield.d	2019-05-13 17:39:38.449005500 +0800
@@ -0,0 +1,2 @@
+obj/user/yield.o obj/user/yield.d: user/yield.c user/libs/ulib.h \
+ libs/defs.h libs/stdio.h libs/stdarg.h
Binary files lab6_origin/obj/user/yield.o and lab6/obj/user/yield.o differ
diff -r -u -P lab6_origin/obj/user/yield.sym lab6/obj/user/yield.sym
--- lab6_origin/obj/user/yield.sym	1970-01-01 08:00:00.000000000 +0800
+++ lab6/obj/user/yield.sym	2019-05-13 17:39:43.782943400 +0800
@@ -0,0 +1,76 @@
+00800020 .text
+00800fc0 .rodata
+00802000 .data
+00200000 .stab_info
+00200010 .stab
+00202d1d .stabstr
+00000000 panic.c
+00000000 syscall.c
+008000b5 syscall
+00000000 ulib.c
+00000000 stdio.c
+0080028c cputch
+00000000 umain.c
+00000000 string.c
+00000000 printfmt.c
+008010c0 error_string
+00800822 printnum
+00800913 getuint
+00800962 getint
+00800d75 sprintputch
+00000000 hash.c
+00000000 rand.c
+00802000 next
+00000000 yield.c
+008003be strcpy
+0080021a yield
+00800201 waitpid
+00800141 sys_yield
+008006d7 memmove
+00800dab snprintf
+008009cd vprintfmt
+0080011d sys_fork
+008002d9 cprintf
+0080023e getpid
+0080077a memcpy
+00800266 lab6_set_priority
+00800dd4 vsnprintf
+0080034d umain
+00202d1c __STAB_END__
+00800150 sys_kill
+00202d1d __STABSTR_BEGIN__
+00800020 __panic
+0080053a strtol
+0080038e strnlen
+0080024b print_pgdir
+00800228 kill
+0080050b strfind
+008001ea wait
+0080027d _start
+00800e53 rand
+00800482 strncmp
+00800171 sys_putc
+008003fe strncpy
+008007ca memcmp
+008001dd fork
+00800697 memset
+00800f2b main
+00800f12 srand
+00800e2e hash32
+008009a9 printfmt
+00203afb __STABSTR_END__
+00800438 strcmp
+00800259 gettime_msec
+00800192 sys_gettime
+008002b0 vcprintf
+0080006e __warn
+008002ff cputs
+008001a1 sys_lab6_set_priority
+008001b7 exit
+0080012c sys_wait
+0080010b sys_exit
+00200010 __STAB_BEGIN__
+00800366 strlen
+00800183 sys_pgdir
+008004d8 strchr
+00800162 sys_getpid
Binary files lab6_origin/obj/__user_badarg.out and lab6/obj/__user_badarg.out differ
Binary files lab6_origin/obj/__user_badsegment.out and lab6/obj/__user_badsegment.out differ
Binary files lab6_origin/obj/__user_divzero.out and lab6/obj/__user_divzero.out differ
Binary files lab6_origin/obj/__user_exit.out and lab6/obj/__user_exit.out differ
Binary files lab6_origin/obj/__user_faultreadkernel.out and lab6/obj/__user_faultreadkernel.out differ
Binary files lab6_origin/obj/__user_faultread.out and lab6/obj/__user_faultread.out differ
Binary files lab6_origin/obj/__user_forktest.out and lab6/obj/__user_forktest.out differ
Binary files lab6_origin/obj/__user_forktree.out and lab6/obj/__user_forktree.out differ
Binary files lab6_origin/obj/__user_hello.out and lab6/obj/__user_hello.out differ
Binary files lab6_origin/obj/__user_matrix.out and lab6/obj/__user_matrix.out differ
Binary files lab6_origin/obj/__user_pgdir.out and lab6/obj/__user_pgdir.out differ
Binary files lab6_origin/obj/__user_priority.out and lab6/obj/__user_priority.out differ
Binary files lab6_origin/obj/__user_softint.out and lab6/obj/__user_softint.out differ
Binary files lab6_origin/obj/__user_spin.out and lab6/obj/__user_spin.out differ
Binary files lab6_origin/obj/__user_testbss.out and lab6/obj/__user_testbss.out differ
Binary files lab6_origin/obj/__user_waitkill.out and lab6/obj/__user_waitkill.out differ
Binary files lab6_origin/obj/__user_yield.out and lab6/obj/__user_yield.out differ
diff -r -u -P lab6_origin/.pgdir.log lab6/.pgdir.log
--- lab6_origin/.pgdir.log	1970-01-01 08:00:00.000000000 +0800
+++ lab6/.pgdir.log	2019-05-13 17:40:22.043125500 +0800
@@ -0,0 +1,129 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc010b8ec (phys)
+  edata  0xc01b0000 (phys)
+  end    0xc01b3178 (phys)
+Kernel executable memory footprint: 717KB
+ebp:0xc012bf48 eip:0xc0100b65 args:0x00010094 0x00010094 0xc012bf78 0xc01000d1 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc012bf58 eip:0xc0100e65 args:0x00000000 0x00000000 0x00000000 0xc012bfc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc012bf78 eip:0xc01000d1 args:0x00000000 0xc012bfa0 0xffff0000 0xc012bfa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc012bf98 eip:0xc01000f3 args:0x00000000 0xffff0000 0xc012bfc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc012bfb8 eip:0xc0100110 args:0x00000000 0xc0100036 0xffff0000 0xc0100079 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc012bfd8 eip:0xc0100131 args:0x00000000 0x00000000 0x00000000 0xc010b900 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc012bff8 eip:0xc0100086 args:0xc010bafc 0xc010bb04 0xc0100dee 0xc010bb23 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 31818, total 31818
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 5, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+kernel_execve: pid = 2, name = "pgdir".
+I am 2, print pgdir.
+-------------------- BEGIN --------------------
+PDE(001) 00000000-00400000 00400000 urw
+  |-- PTE(00004) 00200000-00204000 00004000 urw
+PDE(001) 00800000-00c00000 00400000 urw
+  |-- PTE(00002) 00800000-00802000 00002000 ur-
+  |-- PTE(00001) 00802000-00803000 00001000 urw
+PDE(001) afc00000-b0000000 00400000 urw
+  |-- PTE(00004) afffc000-b0000000 00004000 urw
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(00001) fac00000-fac01000 00001000 urw
+  |-- PTE(00001) fac02000-fac03000 00001000 urw
+  |-- PTE(00001) faebf000-faec0000 00001000 urw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+pgdir pass.
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:477:
+    initproc exit.
+
+stack trackback:
+ebp:0xc0395f98 eip:0xc0100b65 args:0x00000018 0x00000000 0x00000000 0xc0395fcc 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc0395fb8 eip:0xc0100461 args:0xc010d994 0x000001dd 0xc010d9e6 0x00000000 
+    kern/debug/panic.c:27: __panic+107
+ebp:0xc0395fe8 eip:0xc0109511 args:0x00000000 0x00000000 0x00000000 0x00000010 
+    kern/process/proc.c:477: do_exit+81
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -r -u -P lab6_origin/.priority.log lab6/.priority.log
--- lab6_origin/.priority.log	1970-01-01 08:00:00.000000000 +0800
+++ lab6/.priority.log	2019-05-13 17:41:23.384350100 +0800
@@ -0,0 +1,123 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc010b8ec (phys)
+  edata  0xc01b0000 (phys)
+  end    0xc01b3178 (phys)
+Kernel executable memory footprint: 717KB
+ebp:0xc012bf48 eip:0xc0100b65 args:0x00010094 0x00010094 0xc012bf78 0xc01000d1 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc012bf58 eip:0xc0100e65 args:0x00000000 0x00000000 0x00000000 0xc012bfc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc012bf78 eip:0xc01000d1 args:0x00000000 0xc012bfa0 0xffff0000 0xc012bfa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc012bf98 eip:0xc01000f3 args:0x00000000 0xffff0000 0xc012bfc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc012bfb8 eip:0xc0100110 args:0x00000000 0xc0100036 0xffff0000 0xc0100079 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc012bfd8 eip:0xc0100131 args:0x00000000 0x00000000 0x00000000 0xc010b900 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc012bff8 eip:0xc0100086 args:0xc010bafc 0xc010bb04 0xc0100dee 0xc010bb23 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 31818, total 31818
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 5, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+kernel_execve: pid = 2, name = "priority".
+main: fork ok,now need to wait pids.
+child pid 5, acc 840000, time 1001
+child pid 6, acc 1124000, time 1001
+child pid 4, acc 560000, time 1002
+child pid 7, acc 1388000, time 1003
+child pid 3, acc 304000, time 1004
+main: pid 3, acc 304000, time 1004
+main: pid 4, acc 560000, time 1004
+main: pid 5, acc 840000, time 1004
+main: pid 6, acc 1124000, time 1004
+main: pid 7, acc 1388000, time 1004
+main: wait pids over
+stride sched correct result: 1 2 3 4 5
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:477:
+    initproc exit.
+
+stack trackback:
+ebp:0xc0395f98 eip:0xc0100b65 args:0x00000018 0x00000000 0x00000000 0xc0395fcc 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc0395fb8 eip:0xc0100461 args:0xc010d994 0x000001dd 0xc010d9e6 0x00000000 
+    kern/debug/panic.c:27: __panic+107
+ebp:0xc0395fe8 eip:0xc0109511 args:0x00000000 0x00000000 0x00000000 0x00000010 
+    kern/process/proc.c:477: do_exit+81
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -r -u -P lab6_origin/.qemu.out lab6/.qemu.out
--- lab6_origin/.qemu.out	1970-01-01 08:00:00.000000000 +0800
+++ lab6/.qemu.out	2019-05-13 17:41:23.315388000 +0800
@@ -0,0 +1,123 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc010b8ec (phys)
+  edata  0xc01b0000 (phys)
+  end    0xc01b3178 (phys)
+Kernel executable memory footprint: 717KB
+ebp:0xc012bf48 eip:0xc0100b65 args:0x00010094 0x00010094 0xc012bf78 0xc01000d1 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc012bf58 eip:0xc0100e65 args:0x00000000 0x00000000 0x00000000 0xc012bfc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc012bf78 eip:0xc01000d1 args:0x00000000 0xc012bfa0 0xffff0000 0xc012bfa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc012bf98 eip:0xc01000f3 args:0x00000000 0xffff0000 0xc012bfc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc012bfb8 eip:0xc0100110 args:0x00000000 0xc0100036 0xffff0000 0xc0100079 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc012bfd8 eip:0xc0100131 args:0x00000000 0x00000000 0x00000000 0xc010b900 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc012bff8 eip:0xc0100086 args:0xc010bafc 0xc010bb04 0xc0100dee 0xc010bb23 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 31818, total 31818
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 5, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+kernel_execve: pid = 2, name = "priority".
+main: fork ok,now need to wait pids.
+child pid 5, acc 840000, time 1001
+child pid 6, acc 1124000, time 1001
+child pid 4, acc 560000, time 1002
+child pid 7, acc 1388000, time 1003
+child pid 3, acc 304000, time 1004
+main: pid 3, acc 304000, time 1004
+main: pid 4, acc 560000, time 1004
+main: pid 5, acc 840000, time 1004
+main: pid 6, acc 1124000, time 1004
+main: pid 7, acc 1388000, time 1004
+main: wait pids over
+stride sched correct result: 1 2 3 4 5
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:477:
+    initproc exit.
+
+stack trackback:
+ebp:0xc0395f98 eip:0xc0100b65 args:0x00000018 0x00000000 0x00000000 0xc0395fcc 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc0395fb8 eip:0xc0100461 args:0xc010d994 0x000001dd 0xc010d9e6 0x00000000 
+    kern/debug/panic.c:27: __panic+107
+ebp:0xc0395fe8 eip:0xc0109511 args:0x00000000 0x00000000 0x00000000 0x00000010 
+    kern/process/proc.c:477: do_exit+81
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -r -u -P lab6_origin/.softint.log lab6/.softint.log
--- lab6_origin/.softint.log	1970-01-01 08:00:00.000000000 +0800
+++ lab6/.softint.log	2019-05-13 17:40:02.288869700 +0800
@@ -0,0 +1,131 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc010b8ec (phys)
+  edata  0xc01b0000 (phys)
+  end    0xc01b3178 (phys)
+Kernel executable memory footprint: 717KB
+ebp:0xc012bf48 eip:0xc0100b65 args:0x00010094 0x00010094 0xc012bf78 0xc01000d1 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc012bf58 eip:0xc0100e65 args:0x00000000 0x00000000 0x00000000 0xc012bfc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc012bf78 eip:0xc01000d1 args:0x00000000 0xc012bfa0 0xffff0000 0xc012bfa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc012bf98 eip:0xc01000f3 args:0x00000000 0xffff0000 0xc012bfc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc012bfb8 eip:0xc0100110 args:0x00000000 0xc0100036 0xffff0000 0xc0100079 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc012bfd8 eip:0xc0100131 args:0x00000000 0x00000000 0x00000000 0xc010b900 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc012bff8 eip:0xc0100086 args:0xc010bafc 0xc010bb04 0xc0100dee 0xc010bb23 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 31818, total 31818
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 5, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+kernel_execve: pid = 2, name = "softint".
+trapframe at 0xc039cfb4
+  edi  0x00000000
+  esi  0x00000000
+  ebp  0xafffffa8
+  oesp 0xc039cfd4
+  ebx  0x00000000
+  edx  0x00000000
+  ecx  0xafffffc0
+  eax  0x00000000
+  ds   0x----0023
+  es   0x----0023
+  fs   0x----0000
+  gs   0x----0000
+  trap 0x0000000d General Protection
+  err  0x00000072
+  eip  0x00800f3c
+  cs   0x----001b
+  flag 0x00000286 PF,SF,IF,IOPL=0
+  esp  0xafffffa0
+  ss   0x----0023
+unhandled trap.
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:477:
+    initproc exit.
+
+stack trackback:
+ebp:0xc0395f98 eip:0xc0100b65 args:0x00000018 0x00000000 0x00000000 0xc0395fcc 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc0395fb8 eip:0xc0100461 args:0xc010d994 0x000001dd 0xc010d9e6 0x00000000 
+    kern/debug/panic.c:27: __panic+107
+ebp:0xc0395fe8 eip:0xc0109511 args:0x00000000 0x00000000 0x00000000 0x00000010 
+    kern/process/proc.c:477: do_exit+81
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -r -u -P lab6_origin/.spin.log lab6/.spin.log
--- lab6_origin/.spin.log	1970-01-01 08:00:00.000000000 +0800
+++ lab6/.spin.log	2019-05-13 17:40:38.224290200 +0800
@@ -0,0 +1,117 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc010b8ec (phys)
+  edata  0xc01b0000 (phys)
+  end    0xc01b3178 (phys)
+Kernel executable memory footprint: 717KB
+ebp:0xc012bf48 eip:0xc0100b65 args:0x00010094 0x00010094 0xc012bf78 0xc01000d1 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc012bf58 eip:0xc0100e65 args:0x00000000 0x00000000 0x00000000 0xc012bfc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc012bf78 eip:0xc01000d1 args:0x00000000 0xc012bfa0 0xffff0000 0xc012bfa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc012bf98 eip:0xc01000f3 args:0x00000000 0xffff0000 0xc012bfc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc012bfb8 eip:0xc0100110 args:0x00000000 0xc0100036 0xffff0000 0xc0100079 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc012bfd8 eip:0xc0100131 args:0x00000000 0x00000000 0x00000000 0xc010b900 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc012bff8 eip:0xc0100086 args:0xc010bafc 0xc010bb04 0xc0100dee 0xc010bb23 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 31818, total 31818
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 5, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+kernel_execve: pid = 2, name = "spin".
+I am the parent. Forking the child...
+I am the parent. Running the child...
+I am the child. spinning ...
+I am the parent.  Killing the child...
+kill returns 0
+wait returns 0
+spin may pass.
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:477:
+    initproc exit.
+
+stack trackback:
+ebp:0xc0395f98 eip:0xc0100b65 args:0x00000018 0x00000000 0x00000000 0xc0395fcc 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc0395fb8 eip:0xc0100461 args:0xc010d994 0x000001dd 0xc010d9e6 0x00000000 
+    kern/debug/panic.c:27: __panic+107
+ebp:0xc0395fe8 eip:0xc0109511 args:0x00000000 0x00000000 0x00000000 0x00000010 
+    kern/process/proc.c:477: do_exit+81
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -r -u -P lab6_origin/.testbss.log lab6/.testbss.log
--- lab6_origin/.testbss.log	1970-01-01 08:00:00.000000000 +0800
+++ lab6/.testbss.log	2019-05-13 17:40:18.226376900 +0800
@@ -0,0 +1,139 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc010b8ec (phys)
+  edata  0xc01b0000 (phys)
+  end    0xc01b3178 (phys)
+Kernel executable memory footprint: 717KB
+ebp:0xc012bf48 eip:0xc0100b65 args:0x00010094 0x00010094 0xc012bf78 0xc01000d1 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc012bf58 eip:0xc0100e65 args:0x00000000 0x00000000 0x00000000 0xc012bfc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc012bf78 eip:0xc01000d1 args:0x00000000 0xc012bfa0 0xffff0000 0xc012bfa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc012bf98 eip:0xc01000f3 args:0x00000000 0xffff0000 0xc012bfc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc012bfb8 eip:0xc0100110 args:0x00000000 0xc0100036 0xffff0000 0xc0100079 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc012bfd8 eip:0xc0100131 args:0x00000000 0x00000000 0x00000000 0xc010b900 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc012bff8 eip:0xc0100086 args:0xc010bafc 0xc010bb04 0xc0100dee 0xc010bb23 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 31818, total 31818
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 5, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+kernel_execve: pid = 2, name = "testbss".
+Making sure bss works right...
+Yes, good.  Now doing a wild write off the end...
+testbss may pass.
+not valid addr c03020, and  can not find it in vma
+trapframe at 0xc039cfb4
+  edi  0x00000000
+  esi  0x00000000
+  ebp  0xafffffa8
+  oesp 0xc039cfd4
+  ebx  0x00000000
+  edx  0x008013da
+  ecx  0xaffffed8
+  eax  0x00000012
+  ds   0x----0023
+  es   0x----0023
+  fs   0x----0000
+  gs   0x----0000
+  trap 0x0000000e Page Fault
+  err  0x00000006
+  eip  0x00801002
+  cs   0x----001b
+  flag 0x00000286 PF,SF,IF,IOPL=0
+  esp  0xafffff90
+  ss   0x----0023
+killed by kernel.
+kernel panic at kern/trap/trap.c:213:
+    handle user mode pgfault failed. ret=-3
+
+stack trackback:
+ebp:0xc039cf28 eip:0xc0100b65 args:0xc01b3064 0x0000000a 0xc039cf54 0xc039cf5c 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc039cf48 eip:0xc0100461 args:0xc010bd8e 0x000000d5 0xc010c030 0xfffffffd 
+    kern/debug/panic.c:27: __panic+107
+ebp:0xc039cf78 eip:0xc0102883 args:0xc039cfb4 0x00000000 0xc039cfa8 0xc0102a18 
+    kern/trap/trap.c:213: trap_dispatch+266
+ebp:0xc039cfa8 eip:0xc01029d7 args:0xc039cfb4 0x00000000 0x00000000 0xafffffa8 
+    kern/trap/trap.c:299: trap+80
+ebp:0xafffffa8 eip:0xc01034a3 args:0x00000000 0x00000000 0x00000000 0x00800358 
+    kern/trap/trapentry.S:24: <unknown>+0
+ebp:0xafffffd8 eip:0x00800358 args:0x00000000 0x00000000 0x00000000 0x00000000 
+    user/libs/umain.c:7: umain+10
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -r -u -P lab6_origin/tools/boot.ld lab6/tools/boot.ld
--- lab6_origin/tools/boot.ld	1970-01-01 08:00:00.000000000 +0800
+++ lab6/tools/boot.ld	2019-02-26 20:51:17.093308100 +0800
@@ -0,0 +1,15 @@
+OUTPUT_FORMAT("elf32-i386")
+OUTPUT_ARCH(i386)
+
+SECTIONS {
+    . = 0x7C00;
+
+    .startup : {
+        *bootasm.o(.text)
+    }
+
+    .text : { *(.text) }
+    .data : { *(.data .rodata) }
+    
+    /DISCARD/ : { *(.eh_*) }
+}
diff -r -u -P lab6_origin/tools/function.mk lab6/tools/function.mk
--- lab6_origin/tools/function.mk	1970-01-01 08:00:00.000000000 +0800
+++ lab6/tools/function.mk	2019-02-26 20:51:17.093807000 +0800
@@ -0,0 +1,95 @@
+OBJPREFIX	:= __objs_
+
+.SECONDEXPANSION:
+# -------------------- function begin --------------------
+
+# list all files in some directories: (#directories, #types)
+listf = $(filter $(if $(2),$(addprefix %.,$(2)),%),\
+		  $(wildcard $(addsuffix $(SLASH)*,$(1))))
+
+# get .o obj files: (#files[, packet])
+toobj = $(addprefix $(OBJDIR)$(SLASH)$(if $(2),$(2)$(SLASH)),\
+		$(addsuffix .o,$(basename $(1))))
+
+# get .d dependency files: (#files[, packet])
+todep = $(patsubst %.o,%.d,$(call toobj,$(1),$(2)))
+
+totarget = $(addprefix $(BINDIR)$(SLASH),$(1))
+
+# change $(name) to $(OBJPREFIX)$(name): (#names)
+packetname = $(if $(1),$(addprefix $(OBJPREFIX),$(1)),$(OBJPREFIX))
+
+# cc compile template, generate rule for dep, obj: (file, cc[, flags, dir])
+define cc_template
+$$(call todep,$(1),$(4)): $(1) | $$$$(dir $$$$@)
+	@$(2) -I$$(dir $(1)) $(3) -MM $$< -MT "$$(patsubst %.d,%.o,$$@) $$@"> $$@
+$$(call toobj,$(1),$(4)): $(1) | $$$$(dir $$$$@)
+	@echo + cc $$<
+	$(V)$(2) -I$$(dir $(1)) $(3) -c $$< -o $$@
+ALLOBJS += $$(call toobj,$(1),$(4))
+endef
+
+# compile file: (#files, cc[, flags, dir])
+define do_cc_compile
+$$(foreach f,$(1),$$(eval $$(call cc_template,$$(f),$(2),$(3),$(4))))
+endef
+
+# add files to packet: (#files, cc[, flags, packet, dir])
+define do_add_files_to_packet
+__temp_packet__ := $(call packetname,$(4))
+ifeq ($$(origin $$(__temp_packet__)),undefined)
+$$(__temp_packet__) :=
+endif
+__temp_objs__ := $(call toobj,$(1),$(5))
+$$(foreach f,$(1),$$(eval $$(call cc_template,$$(f),$(2),$(3),$(5))))
+$$(__temp_packet__) += $$(__temp_objs__)
+endef
+
+# add objs to packet: (#objs, packet)
+define do_add_objs_to_packet
+__temp_packet__ := $(call packetname,$(2))
+ifeq ($$(origin $$(__temp_packet__)),undefined)
+$$(__temp_packet__) :=
+endif
+$$(__temp_packet__) += $(1)
+endef
+
+# add packets and objs to target (target, #packes, #objs[, cc, flags])
+define do_create_target
+__temp_target__ = $(call totarget,$(1))
+__temp_objs__ = $$(foreach p,$(call packetname,$(2)),$$($$(p))) $(3)
+TARGETS += $$(__temp_target__)
+ifneq ($(4),)
+$$(__temp_target__): $$(__temp_objs__) | $$$$(dir $$$$@)
+	$(V)$(4) $(5) $$^ -o $$@
+else
+$$(__temp_target__): $$(__temp_objs__) | $$$$(dir $$$$@)
+endif
+endef
+
+# finish all
+define do_finish_all
+ALLDEPS = $$(ALLOBJS:.o=.d)
+$$(sort $$(dir $$(ALLOBJS)) $(BINDIR)$(SLASH) $(OBJDIR)$(SLASH)):
+	@$(MKDIR) $$@
+endef
+
+# --------------------  function end  --------------------
+# compile file: (#files, cc[, flags, dir])
+cc_compile = $(eval $(call do_cc_compile,$(1),$(2),$(3),$(4)))
+
+# add files to packet: (#files, cc[, flags, packet, dir])
+add_files = $(eval $(call do_add_files_to_packet,$(1),$(2),$(3),$(4),$(5)))
+
+# add objs to packet: (#objs, packet)
+add_objs = $(eval $(call do_add_objs_to_packet,$(1),$(2)))
+
+# add packets and objs to target (target, #packes, #objs, cc, [, flags])
+create_target = $(eval $(call do_create_target,$(1),$(2),$(3),$(4),$(5)))
+
+read_packet = $(foreach p,$(call packetname,$(1)),$($(p)))
+
+add_dependency = $(eval $(1): $(2))
+
+finish_all = $(eval $(call do_finish_all))
+
diff -r -u -P lab6_origin/tools/gdbinit lab6/tools/gdbinit
--- lab6_origin/tools/gdbinit	1970-01-01 08:00:00.000000000 +0800
+++ lab6/tools/gdbinit	2019-02-26 20:51:17.094306400 +0800
@@ -0,0 +1,3 @@
+file bin/kernel
+target remote :1234
+break kern_init
diff -r -u -P lab6_origin/tools/grade lab6/tools/grade
--- lab6_origin/tools/grade	1970-01-01 08:00:00.000000000 +0800
+++ lab6/tools/grade	2019-05-12 17:26:50.830949100 +0800
@@ -0,0 +1,588 @@
+#!/bin/sh
+
+verbose=false
+if [ "x$1" = "x-v" ]; then
+    verbose=true
+    out=/dev/stdout
+    err=/dev/stderr
+else
+    out=/dev/null
+    err=/dev/null
+fi
+
+## make & makeopts
+if gmake --version > /dev/null 2>&1; then
+    make=gmake;
+else
+    make=make;
+fi
+
+makeopts="--quiet --no-print-directory -j"
+
+make_print() {
+    echo `$make $makeopts print-$1`
+}
+
+## command tools
+awk='awk'
+bc='bc'
+date='date'
+grep='grep'
+rm='rm -f'
+sed='sed'
+
+## symbol table
+sym_table='obj/kernel.sym'
+
+## gdb & gdbopts
+gdb="$(make_print GDB)"
+gdbport='1234'
+
+gdb_in="$(make_print GRADE_GDB_IN)"
+
+## qemu & qemuopts
+qemu="$(make_print qemu)"
+
+qemu_out="$(make_print GRADE_QEMU_OUT)"
+
+if $qemu -nographic -help | grep -q '^-gdb'; then
+    qemugdb="-gdb tcp::$gdbport"
+else
+    qemugdb="-s -p $gdbport"
+fi
+
+## default variables
+default_timeout=30
+default_pts=5
+
+pts=5
+part=0
+part_pos=0
+total=0
+total_pos=0
+
+## default functions
+update_score() {
+    total=`expr $total + $part`
+    total_pos=`expr $total_pos + $part_pos`
+    part=0
+    part_pos=0
+}
+
+get_time() {
+    echo `$date +%s.%N 2> /dev/null`
+}
+
+show_part() {
+    echo "Part $1 Score: $part/$part_pos"
+    echo
+    update_score
+}
+
+show_final() {
+    update_score
+    echo "Total Score: $total/$total_pos"
+    if [ $total -lt $total_pos ]; then
+        exit 1
+    fi
+}
+
+show_time() {
+    t1=$(get_time)
+    time=`echo "scale=1; ($t1-$t0)/1" | $sed 's/.N/.0/g' | $bc 2> /dev/null`
+    echo "(${time}s)"
+}
+
+show_build_tag() {
+    echo "$1:" | $awk '{printf "%-24s ", $0}'
+}
+
+show_check_tag() {
+    echo "$1:" | $awk '{printf "  -%-40s  ", $0}'
+}
+
+show_msg() {
+    echo $1
+    shift
+    if [ $# -gt 0 ]; then
+        echo -e "$@" | awk '{printf "   %s\n", $0}'
+        echo
+    fi
+}
+
+pass() {
+    show_msg OK "$@"
+    part=`expr $part + $pts`
+    part_pos=`expr $part_pos + $pts`
+}
+
+fail() {
+    show_msg WRONG "$@"
+    part_pos=`expr $part_pos + $pts`
+}
+
+run_qemu() {
+    # Run qemu with serial output redirected to $qemu_out. If $brkfun is non-empty,
+    # wait until $brkfun is reached or $timeout expires, then kill QEMU
+    qemuextra=
+    if [ "$brkfun" ]; then
+        qemuextra="-S $qemugdb"
+    fi
+
+    if [ -z "$timeout" ] || [ $timeout -le 0 ]; then
+        timeout=$default_timeout;
+    fi
+
+    t0=$(get_time)
+    (
+        ulimit -t $timeout
+        exec $qemu -nographic $qemuopts -serial file:$qemu_out -monitor null -no-reboot $qemuextra
+    ) > $out 2> $err &
+    pid=$!
+
+    # wait for QEMU to start
+    sleep 1
+
+    if [ -n "$brkfun" ]; then
+        # find the address of the kernel $brkfun function
+        brkaddr=`$grep " $brkfun\$" $sym_table | $sed -e's/ .*$//g'`
+        brkaddr_phys=`echo $brkaddr | sed "s/^c0/00/g"`
+        (
+            echo "target remote localhost:$gdbport"
+            echo "break *0x$brkaddr"
+            if [ "$brkaddr" != "$brkaddr_phys" ]; then
+                echo "break *0x$brkaddr_phys"
+            fi
+            echo "continue"
+        ) > $gdb_in
+
+        $gdb -batch -nx -x $gdb_in > /dev/null 2>&1
+
+        # make sure that QEMU is dead
+        # on OS X, exiting gdb doesn't always exit qemu
+        kill $pid > /dev/null 2>&1
+    fi
+}
+
+build_run() {
+    # usage: build_run <tag> <args>
+    show_build_tag "$1"
+    shift
+
+    if $verbose; then
+        echo "$make $@ ..."
+    fi
+    $make $makeopts $@ 'DEFS+=-DDEBUG_GRADE' > $out 2> $err
+
+    if [ $? -ne 0 ]; then
+        echo $make $@ failed
+        exit 1
+    fi
+
+    # now run qemu and save the output
+    run_qemu
+
+    show_time
+
+    cp $qemu_out .`echo $tag | tr '[:upper:]' '[:lower:]' | sed 's/ /_/g'`.log
+}
+
+check_result() {
+    # usage: check_result <tag> <check> <check args...>
+    show_check_tag "$1"
+    shift
+
+    # give qemu some time to run (for asynchronous mode)
+    if [ ! -s $qemu_out ]; then
+        sleep 4
+    fi
+
+    if [ ! -s $qemu_out ]; then
+        fail > /dev/null
+        echo 'no $qemu_out'
+    else
+        check=$1
+        shift
+        $check "$@"
+    fi
+}
+
+check_regexps() {
+    okay=yes
+    not=0
+    reg=0
+    error=
+    for i do
+        if [ "x$i" = "x!" ]; then
+            not=1
+        elif [ "x$i" = "x-" ]; then
+            reg=1
+        else
+            if [ $reg -ne 0 ]; then
+                $grep '-E' "^$i\$" $qemu_out > /dev/null
+            else
+                $grep '-F' "$i" $qemu_out > /dev/null
+            fi
+            found=$(($? == 0))
+            if [ $found -eq $not ]; then
+                if [ $found -eq 0 ]; then
+                    msg="!! error: missing '$i'"
+                else
+                    msg="!! error: got unexpected line '$i'"
+                fi
+                okay=no
+                if [ -z "$error" ]; then
+                    error="$msg"
+                else
+                    error="$error\n$msg"
+                fi
+            fi
+            not=0
+            reg=0
+        fi
+    done
+    if [ "$okay" = "yes" ]; then
+        pass
+    else
+        fail "$error"
+        if $verbose; then
+            exit 1
+        fi
+    fi
+}
+
+run_test() {
+    # usage: run_test [-tag <tag>] [-prog <prog>] [-Ddef...] [-check <check>] checkargs ...
+    tag=
+    prog=
+    check=check_regexps
+    while true; do
+        select=
+        case $1 in
+            -tag|-prog)
+                select=`expr substr $1 2 ${#1}`
+                eval $select='$2'
+                ;;
+        esac
+        if [ -z "$select" ]; then
+            break
+        fi
+        shift
+        shift
+    done
+    defs=
+    while expr "x$1" : "x-D.*" > /dev/null; do
+        defs="DEFS+='$1' $defs"
+        shift
+    done
+    if [ "x$1" = "x-check" ]; then
+        check=$2
+        shift
+        shift
+    fi
+
+    if [ -z "$prog" ]; then
+        $make $makeopts touch > /dev/null 2>&1
+        args="$defs"
+    else
+        if [ -z "$tag" ]; then
+            tag="$prog"
+        fi
+        args="build-$prog $defs"
+    fi
+
+    build_run "$tag" "$args"
+
+    check_result 'check result' "$check" "$@"
+}
+
+quick_run() {
+    # usage: quick_run <tag> [-Ddef...]
+    tag="$1"
+    shift
+    defs=
+    while expr "x$1" : "x-D.*" > /dev/null; do
+        defs="DEFS+='$1' $defs"
+        shift
+    done
+
+    $make $makeopts touch > /dev/null 2>&1
+    build_run "$tag" "$defs"
+}
+
+quick_check() {
+    # usage: quick_check <tag> checkargs ...
+    tag="$1"
+    shift
+    check_result "$tag" check_regexps "$@"
+}
+
+## kernel image
+osimg=$(make_print ucoreimg)
+
+## swap image
+swapimg=$(make_print swapimg)
+
+## set default qemu-options
+qemuopts="-hda $osimg -drive file=$swapimg,media=disk,cache=writeback"
+
+## set break-function, default is readline
+brkfun=readline
+
+default_check() {
+    pts=7
+    check_regexps "$@"
+
+    pts=3
+    quick_check 'check output'                                  \
+    'memory management: default_pmm_manager'                      \
+    'check_alloc_page() succeeded!'                             \
+    'check_pgdir() succeeded!'                                  \
+    'check_boot_pgdir() succeeded!'				\
+    'PDE(0e0) c0000000-f8000000 38000000 urw'                   \
+    '  |-- PTE(38000) c0000000-f8000000 38000000 -rw'           \
+    'PDE(001) fac00000-fb000000 00400000 -rw'                   \
+    '  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw'           \
+    '  |-- PTE(00001) fafeb000-fafec000 00001000 -rw'		\
+    'check_vma_struct() succeeded!'                             \
+    'page fault at 0x00000100: K/W [no page found].'            \
+    'check_pgfault() succeeded!'                                \
+    'check_vmm() succeeded.'					\
+    'page fault at 0x00001000: K/W [no page found].'            \
+    'page fault at 0x00002000: K/W [no page found].'            \
+    'page fault at 0x00003000: K/W [no page found].'            \
+    'page fault at 0x00004000: K/W [no page found].'            \
+    'write Virt Page e in fifo_check_swap'			\
+    'page fault at 0x00005000: K/W [no page found].'		\
+    'page fault at 0x00001000: K/W [no page found]'		\
+    'page fault at 0x00002000: K/W [no page found].'		\
+    'page fault at 0x00003000: K/W [no page found].'		\
+    'page fault at 0x00004000: K/W [no page found].'		\
+    'check_swap() succeeded!'					\
+    '++ setup timer interrupts'
+}
+
+## check now!!
+
+run_test -prog 'badsegment' -check default_check                \
+        'kernel_execve: pid = 2, name = "badsegment".'          \
+      - 'trapframe at 0xc.......'                               \
+        'trap 0x0000000d General Protection'                    \
+        '  err  0x00000028'                                     \
+      - '  eip  0x008.....'                                     \
+      - '  esp  0xaff.....'                                     \
+        '  cs   0x----001b'                                     \
+        '  ss   0x----0023'                                     \
+    ! - 'user panic at .*'
+
+run_test -prog 'divzero' -check default_check                   \
+        'kernel_execve: pid = 2, name = "divzero".'             \
+      - 'trapframe at 0xc.......'                               \
+        'trap 0x00000000 Divide error'                          \
+      - '  eip  0x008.....'                                     \
+      - '  esp  0xaff.....'                                     \
+        '  cs   0x----001b'                                     \
+        '  ss   0x----0023'                                     \
+    ! - 'user panic at .*'
+
+run_test -prog 'softint' -check default_check                   \
+        'kernel_execve: pid = 2, name = "softint".'             \
+      - 'trapframe at 0xc.......'                               \
+        'trap 0x0000000d General Protection'                    \
+        '  err  0x00000072'                                     \
+      - '  eip  0x008.....'                                     \
+      - '  esp  0xaff.....'                                     \
+        '  cs   0x----001b'                                     \
+        '  ss   0x----0023'                                     \
+    ! - 'user panic at .*'
+
+pts=10
+
+run_test -prog 'faultread'  -check default_check                                     \
+        'kernel_execve: pid = 2, name = "faultread".'           \
+      - 'trapframe at 0xc.......'                               \
+        'trap 0x0000000e Page Fault'                            \
+        '  err  0x00000004'                                     \
+      - '  eip  0x008.....'                                     \
+    ! - 'user panic at .*'
+
+run_test -prog 'faultreadkernel' -check default_check                                \
+        'kernel_execve: pid = 2, name = "faultreadkernel".'     \
+      - 'trapframe at 0xc.......'                               \
+        'trap 0x0000000e Page Fault'                            \
+        '  err  0x00000005'                                     \
+      - '  eip  0x008.....'                                     \
+    ! - 'user panic at .*'
+
+run_test -prog 'hello' -check default_check                                          \
+        'kernel_execve: pid = 2, name = "hello".'               \
+        'Hello world!!.'                                        \
+        'I am process 2.'                                       \
+        'hello pass.'
+
+run_test -prog 'testbss' -check default_check                                        \
+        'kernel_execve: pid = 2, name = "testbss".'             \
+        'Making sure bss works right...'                        \
+        'Yes, good.  Now doing a wild write off the end...'     \
+        'testbss may pass.'                                     \
+      - 'trapframe at 0xc.......'                               \
+        'trap 0x0000000e Page Fault'                            \
+        '  err  0x00000006'                                     \
+      - '  eip  0x008.....'                                     \
+        'killed by kernel.'                                     \
+    ! - 'user panic at .*'
+
+run_test -prog 'pgdir' -check default_check                                          \
+        'kernel_execve: pid = 2, name = "pgdir".'               \
+        'I am 2, print pgdir.'                                  \
+        'PDE(001) 00800000-00c00000 00400000 urw'               \
+        '  |-- PTE(00002) 00800000-00802000 00002000 ur-'       \
+        '  |-- PTE(00001) 00802000-00803000 00001000 urw'       \
+        'PDE(001) afc00000-b0000000 00400000 urw'               \
+        '  |-- PTE(00004) afffc000-b0000000 00004000 urw'       \
+        'PDE(0e0) c0000000-f8000000 38000000 urw'               \
+        '  |-- PTE(38000) c0000000-f8000000 38000000 -rw'       \
+        'pgdir pass.'
+
+run_test -prog 'yield' -check default_check                                          \
+        'kernel_execve: pid = 2, name = "yield".'               \
+        'Hello, I am process 2.'                                \
+        'Back in process 2, iteration 0.'                       \
+        'Back in process 2, iteration 1.'                       \
+        'Back in process 2, iteration 2.'                       \
+        'Back in process 2, iteration 3.'                       \
+        'Back in process 2, iteration 4.'                       \
+        'All done in process 2.'                                \
+        'yield pass.'
+
+
+run_test -prog 'badarg' -check default_check                    \
+        'kernel_execve: pid = 2, name = "badarg".'              \
+        'fork ok.'                                              \
+        'badarg pass.'                                          \
+        'all user-mode processes have quit.'                    \
+        'init check memory pass.'                               \
+    ! - 'user panic at .*'
+
+pts=10
+
+run_test -prog 'exit'  -check default_check                                          \
+        'kernel_execve: pid = 2, name = "exit".'                \
+        'I am the parent. Forking the child...'                 \
+        'I am the parent, waiting now..'                        \
+        'I am the child.'                                       \
+      - 'waitpid [0-9]+ ok\.'                                   \
+        'exit pass.'                                            \
+        'all user-mode processes have quit.'                    \
+        'init check memory pass.'                               \
+    ! - 'user panic at .*'
+
+run_test -prog 'spin'  -check default_check                                          \
+        'kernel_execve: pid = 2, name = "spin".'                \
+        'I am the parent. Forking the child...'                 \
+        'I am the parent. Running the child...'                 \
+        'I am the child. spinning ...'                          \
+        'I am the parent.  Killing the child...'                \
+        'kill returns 0'                                        \
+        'wait returns 0'                                        \
+        'spin may pass.'                                        \
+        'all user-mode processes have quit.'                    \
+        'init check memory pass.'                               \
+    ! - 'user panic at .*'
+
+run_test -prog 'waitkill'  -check default_check                                      \
+        'kernel_execve: pid = 2, name = "waitkill".'            \
+        'wait child 1.'                                         \
+        'child 2.'                                              \
+        'child 1.'                                              \
+        'kill parent ok.'                                       \
+        'kill child1 ok.'                                       \
+        'all user-mode processes have quit.'                    \
+        'init check memory pass.'                               \
+    ! - 'user panic at .*'
+
+pts=15
+
+run_test -prog 'forktest'   -check default_check                                     \
+        'kernel_execve: pid = 2, name = "forktest".'            \
+        'I am child 31'                                         \
+        'I am child 19'                                         \
+        'I am child 13'                                         \
+        'I am child 0'                                          \
+        'forktest pass.'                                        \
+        'all user-mode processes have quit.'                    \
+        'init check memory pass.'                               \
+    ! - 'fork claimed to work [0-9]+ times!'                    \
+    !   'wait stopped early'                                    \
+    !   'wait got too many'                                     \
+    ! - 'user panic at .*'
+
+pts=10
+run_test -prog 'forktree'    -check default_check               \
+        'kernel_execve: pid = 2, name = "forktree".'            \
+      - '....: I am '\'''\'                                     \
+      - '....: I am '\''0'\'                                    \
+      - '....: I am '\'''\'                                     \
+      - '....: I am '\''1'\'                                    \
+      - '....: I am '\''0'\'                                    \
+      - '....: I am '\''01'\'                                   \
+      - '....: I am '\''00'\'                                   \
+      - '....: I am '\''11'\'                                   \
+      - '....: I am '\''10'\'                                   \
+      - '....: I am '\''101'\'                                  \
+      - '....: I am '\''100'\'                                  \
+      - '....: I am '\''111'\'                                  \
+      - '....: I am '\''110'\'                                  \
+      - '....: I am '\''001'\'                                  \
+      - '....: I am '\''000'\'                                  \
+      - '....: I am '\''011'\'                                  \
+      - '....: I am '\''010'\'                                  \
+      - '....: I am '\''0101'\'                                 \
+      - '....: I am '\''0100'\'                                 \
+      - '....: I am '\''0111'\'                                 \
+      - '....: I am '\''0110'\'                                 \
+      - '....: I am '\''0001'\'                                 \
+      - '....: I am '\''0000'\'                                 \
+      - '....: I am '\''0011'\'                                 \
+      - '....: I am '\''0010'\'                                 \
+      - '....: I am '\''1101'\'                                 \
+      - '....: I am '\''1100'\'                                 \
+      - '....: I am '\''1111'\'                                 \
+      - '....: I am '\''1110'\'                                 \
+      - '....: I am '\''1001'\'                                 \
+      - '....: I am '\''1000'\'                                 \
+      - '....: I am '\''1011'\'                                 \
+      - '....: I am '\''1010'\'                                 \
+        'all user-mode processes have quit.'                    \
+        'init check memory pass.'
+
+pts=20
+timeout=500
+run_test -prog 'matrix'     -check default_check                \
+        'kernel_execve: pid = 2, name = "matrix".'              \
+        'fork ok.'                                              \
+        'pid 4 done!.'                                          \
+        'pid 7 done!.'                                          \
+        'pid 13 done!.'                                         \
+        'pid 17 done!.'                                         \
+        'pid 23 done!.'                                         \
+        'matrix pass.'                                          \
+        'all user-mode processes have quit.'                    \
+        'init check memory pass.'                               \
+    ! - 'user panic at .*'
+
+show_final
+
+pts=20
+timeout=150
+run_test -prog 'priority'      -check default_check             \
+	'sched class: stride_scheduler'                         \
+        'kernel_execve: pid = 2, name = "priority".'            \
+        'main: fork ok,now need to wait pids.'                  \
+        'stride sched correct result: 1 2 3 4 5'                \
+        'all user-mode processes have quit.'                    \
+        'init check memory pass.'                               \
+    ! - 'user panic at .*'
+
+## print final-score
+show_final
diff -r -u -P lab6_origin/tools/grade.sh lab6/tools/grade.sh
--- lab6_origin/tools/grade.sh	1970-01-01 08:00:00.000000000 +0800
+++ lab6/tools/grade.sh	2019-05-12 17:26:47.522700400 +0800
@@ -0,0 +1,588 @@
+#!/bin/sh
+
+verbose=false
+if [ "x$1" = "x-v" ]; then
+    verbose=true
+    out=/dev/stdout
+    err=/dev/stderr
+else
+    out=/dev/null
+    err=/dev/null
+fi
+
+## make & makeopts
+if gmake --version > /dev/null 2>&1; then
+    make=gmake;
+else
+    make=make;
+fi
+
+makeopts="--quiet --no-print-directory -j"
+
+make_print() {
+    echo `$make $makeopts print-$1`
+}
+
+## command tools
+awk='awk'
+bc='bc'
+date='date'
+grep='grep'
+rm='rm -f'
+sed='sed'
+
+## symbol table
+sym_table='obj/kernel.sym'
+
+## gdb & gdbopts
+gdb="$(make_print GDB)"
+gdbport='1234'
+
+gdb_in="$(make_print GRADE_GDB_IN)"
+
+## qemu & qemuopts
+qemu="$(make_print qemu)"
+
+qemu_out="$(make_print GRADE_QEMU_OUT)"
+
+if $qemu -nographic -help | grep -q '^-gdb'; then
+    qemugdb="-gdb tcp::$gdbport"
+else
+    qemugdb="-s -p $gdbport"
+fi
+
+## default variables
+default_timeout=30
+default_pts=5
+
+pts=5
+part=0
+part_pos=0
+total=0
+total_pos=0
+
+## default functions
+update_score() {
+    total=`expr $total + $part`
+    total_pos=`expr $total_pos + $part_pos`
+    part=0
+    part_pos=0
+}
+
+get_time() {
+    echo `$date +%s.%N 2> /dev/null`
+}
+
+show_part() {
+    echo "Part $1 Score: $part/$part_pos"
+    echo
+    update_score
+}
+
+show_final() {
+    update_score
+    echo "Total Score: $total/$total_pos"
+    if [ $total -lt $total_pos ]; then
+        exit 1
+    fi
+}
+
+show_time() {
+    t1=$(get_time)
+    time=`echo "scale=1; ($t1-$t0)/1" | $sed 's/.N/.0/g' | $bc 2> /dev/null`
+    echo "(${time}s)"
+}
+
+show_build_tag() {
+    echo "$1:" | $awk '{printf "%-24s ", $0}'
+}
+
+show_check_tag() {
+    echo "$1:" | $awk '{printf "  -%-40s  ", $0}'
+}
+
+show_msg() {
+    echo $1
+    shift
+    if [ $# -gt 0 ]; then
+        echo -e "$@" | awk '{printf "   %s\n", $0}'
+        echo
+    fi
+}
+
+pass() {
+    show_msg OK "$@"
+    part=`expr $part + $pts`
+    part_pos=`expr $part_pos + $pts`
+}
+
+fail() {
+    show_msg WRONG "$@"
+    part_pos=`expr $part_pos + $pts`
+}
+
+run_qemu() {
+    # Run qemu with serial output redirected to $qemu_out. If $brkfun is non-empty,
+    # wait until $brkfun is reached or $timeout expires, then kill QEMU
+    qemuextra=
+    if [ "$brkfun" ]; then
+        qemuextra="-S $qemugdb"
+    fi
+
+    if [ -z "$timeout" ] || [ $timeout -le 0 ]; then
+        timeout=$default_timeout;
+    fi
+
+    t0=$(get_time)
+    (
+        ulimit -t $timeout
+        exec $qemu -nographic $qemuopts -serial file:$qemu_out -monitor null -no-reboot $qemuextra
+    ) > $out 2> $err &
+    pid=$!
+
+    # wait for QEMU to start
+    sleep 1
+
+    if [ -n "$brkfun" ]; then
+        # find the address of the kernel $brkfun function
+        brkaddr=`$grep " $brkfun\$" $sym_table | $sed -e's/ .*$//g'`
+        brkaddr_phys=`echo $brkaddr | sed "s/^c0/00/g"`
+        (
+            echo "target remote localhost:$gdbport"
+            echo "break *0x$brkaddr"
+            if [ "$brkaddr" != "$brkaddr_phys" ]; then
+                echo "break *0x$brkaddr_phys"
+            fi
+            echo "continue"
+        ) > $gdb_in
+
+        $gdb -batch -nx -x $gdb_in > /dev/null 2>&1
+
+        # make sure that QEMU is dead
+        # on OS X, exiting gdb doesn't always exit qemu
+        kill $pid > /dev/null 2>&1
+    fi
+}
+
+build_run() {
+    # usage: build_run <tag> <args>
+    show_build_tag "$1"
+    shift
+
+    if $verbose; then
+        echo "$make $@ ..."
+    fi
+    $make $makeopts $@ 'DEFS+=-DDEBUG_GRADE' > $out 2> $err
+
+    if [ $? -ne 0 ]; then
+        echo $make $@ failed
+        exit 1
+    fi
+
+    # now run qemu and save the output
+    run_qemu
+
+    show_time
+
+    cp $qemu_out .`echo $tag | tr '[:upper:]' '[:lower:]' | sed 's/ /_/g'`.log
+}
+
+check_result() {
+    # usage: check_result <tag> <check> <check args...>
+    show_check_tag "$1"
+    shift
+
+    # give qemu some time to run (for asynchronous mode)
+    if [ ! -s $qemu_out ]; then
+        sleep 4
+    fi
+
+    if [ ! -s $qemu_out ]; then
+        fail > /dev/null
+        echo 'no $qemu_out'
+    else
+        check=$1
+        shift
+        $check "$@"
+    fi
+}
+
+check_regexps() {
+    okay=yes
+    not=0
+    reg=0
+    error=
+    for i do
+        if [ "x$i" = "x!" ]; then
+            not=1
+        elif [ "x$i" = "x-" ]; then
+            reg=1
+        else
+            if [ $reg -ne 0 ]; then
+                $grep '-E' "^$i\$" $qemu_out > /dev/null
+            else
+                $grep '-F' "$i" $qemu_out > /dev/null
+            fi
+            found=$(($? == 0))
+            if [ $found -eq $not ]; then
+                if [ $found -eq 0 ]; then
+                    msg="!! error: missing '$i'"
+                else
+                    msg="!! error: got unexpected line '$i'"
+                fi
+                okay=no
+                if [ -z "$error" ]; then
+                    error="$msg"
+                else
+                    error="$error\n$msg"
+                fi
+            fi
+            not=0
+            reg=0
+        fi
+    done
+    if [ "$okay" = "yes" ]; then
+        pass
+    else
+        fail "$error"
+        if $verbose; then
+            exit 1
+        fi
+    fi
+}
+
+run_test() {
+    # usage: run_test [-tag <tag>] [-prog <prog>] [-Ddef...] [-check <check>] checkargs ...
+    tag=
+    prog=
+    check=check_regexps
+    while true; do
+        select=
+        case $1 in
+            -tag|-prog)
+                select=`expr substr $1 2 ${#1}`
+                eval $select='$2'
+                ;;
+        esac
+        if [ -z "$select" ]; then
+            break
+        fi
+        shift
+        shift
+    done
+    defs=
+    while expr "x$1" : "x-D.*" > /dev/null; do
+        defs="DEFS+='$1' $defs"
+        shift
+    done
+    if [ "x$1" = "x-check" ]; then
+        check=$2
+        shift
+        shift
+    fi
+
+    if [ -z "$prog" ]; then
+        $make $makeopts touch > /dev/null 2>&1
+        args="$defs"
+    else
+        if [ -z "$tag" ]; then
+            tag="$prog"
+        fi
+        args="build-$prog $defs"
+    fi
+
+    build_run "$tag" "$args"
+
+    check_result 'check result' "$check" "$@"
+}
+
+quick_run() {
+    # usage: quick_run <tag> [-Ddef...]
+    tag="$1"
+    shift
+    defs=
+    while expr "x$1" : "x-D.*" > /dev/null; do
+        defs="DEFS+='$1' $defs"
+        shift
+    done
+
+    $make $makeopts touch > /dev/null 2>&1
+    build_run "$tag" "$defs"
+}
+
+quick_check() {
+    # usage: quick_check <tag> checkargs ...
+    tag="$1"
+    shift
+    check_result "$tag" check_regexps "$@"
+}
+
+## kernel image
+osimg=$(make_print ucoreimg)
+
+## swap image
+swapimg=$(make_print swapimg)
+
+## set default qemu-options
+qemuopts="-hda $osimg -drive file=$swapimg,media=disk,cache=writeback"
+
+## set break-function, default is readline
+brkfun=readline
+
+default_check() {
+    pts=7
+    check_regexps "$@"
+
+    pts=3
+    quick_check 'check output'                                  \
+    'memory management: default_pmm_manager'                      \
+    'check_alloc_page() succeeded!'                             \
+    'check_pgdir() succeeded!'                                  \
+    'check_boot_pgdir() succeeded!'				\
+    'PDE(0e0) c0000000-f8000000 38000000 urw'                   \
+    '  |-- PTE(38000) c0000000-f8000000 38000000 -rw'           \
+    'PDE(001) fac00000-fb000000 00400000 -rw'                   \
+    '  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw'           \
+    '  |-- PTE(00001) fafeb000-fafec000 00001000 -rw'		\
+    'check_vma_struct() succeeded!'                             \
+    'page fault at 0x00000100: K/W [no page found].'            \
+    'check_pgfault() succeeded!'                                \
+    'check_vmm() succeeded.'					\
+    'page fault at 0x00001000: K/W [no page found].'            \
+    'page fault at 0x00002000: K/W [no page found].'            \
+    'page fault at 0x00003000: K/W [no page found].'            \
+    'page fault at 0x00004000: K/W [no page found].'            \
+    'write Virt Page e in fifo_check_swap'			\
+    'page fault at 0x00005000: K/W [no page found].'		\
+    'page fault at 0x00001000: K/W [no page found]'		\
+    'page fault at 0x00002000: K/W [no page found].'		\
+    'page fault at 0x00003000: K/W [no page found].'		\
+    'page fault at 0x00004000: K/W [no page found].'		\
+    'check_swap() succeeded!'					\
+    '++ setup timer interrupts'
+}
+
+## check now!!
+
+run_test -prog 'badsegment' -check default_check                \
+        'kernel_execve: pid = 2, name = "badsegment".'          \
+      - 'trapframe at 0xc.......'                               \
+        'trap 0x0000000d General Protection'                    \
+        '  err  0x00000028'                                     \
+      - '  eip  0x008.....'                                     \
+      - '  esp  0xaff.....'                                     \
+        '  cs   0x----001b'                                     \
+        '  ss   0x----0023'                                     \
+    ! - 'user panic at .*'
+
+run_test -prog 'divzero' -check default_check                   \
+        'kernel_execve: pid = 2, name = "divzero".'             \
+      - 'trapframe at 0xc.......'                               \
+        'trap 0x00000000 Divide error'                          \
+      - '  eip  0x008.....'                                     \
+      - '  esp  0xaff.....'                                     \
+        '  cs   0x----001b'                                     \
+        '  ss   0x----0023'                                     \
+    ! - 'user panic at .*'
+
+run_test -prog 'softint' -check default_check                   \
+        'kernel_execve: pid = 2, name = "softint".'             \
+      - 'trapframe at 0xc.......'                               \
+        'trap 0x0000000d General Protection'                    \
+        '  err  0x00000072'                                     \
+      - '  eip  0x008.....'                                     \
+      - '  esp  0xaff.....'                                     \
+        '  cs   0x----001b'                                     \
+        '  ss   0x----0023'                                     \
+    ! - 'user panic at .*'
+
+pts=10
+
+run_test -prog 'faultread'  -check default_check                                     \
+        'kernel_execve: pid = 2, name = "faultread".'           \
+      - 'trapframe at 0xc.......'                               \
+        'trap 0x0000000e Page Fault'                            \
+        '  err  0x00000004'                                     \
+      - '  eip  0x008.....'                                     \
+    ! - 'user panic at .*'
+
+run_test -prog 'faultreadkernel' -check default_check                                \
+        'kernel_execve: pid = 2, name = "faultreadkernel".'     \
+      - 'trapframe at 0xc.......'                               \
+        'trap 0x0000000e Page Fault'                            \
+        '  err  0x00000005'                                     \
+      - '  eip  0x008.....'                                     \
+    ! - 'user panic at .*'
+
+run_test -prog 'hello' -check default_check                                          \
+        'kernel_execve: pid = 2, name = "hello".'               \
+        'Hello world!!.'                                        \
+        'I am process 2.'                                       \
+        'hello pass.'
+
+run_test -prog 'testbss' -check default_check                                        \
+        'kernel_execve: pid = 2, name = "testbss".'             \
+        'Making sure bss works right...'                        \
+        'Yes, good.  Now doing a wild write off the end...'     \
+        'testbss may pass.'                                     \
+      - 'trapframe at 0xc.......'                               \
+        'trap 0x0000000e Page Fault'                            \
+        '  err  0x00000006'                                     \
+      - '  eip  0x008.....'                                     \
+        'killed by kernel.'                                     \
+    ! - 'user panic at .*'
+
+run_test -prog 'pgdir' -check default_check                                          \
+        'kernel_execve: pid = 2, name = "pgdir".'               \
+        'I am 2, print pgdir.'                                  \
+        'PDE(001) 00800000-00c00000 00400000 urw'               \
+        '  |-- PTE(00002) 00800000-00802000 00002000 ur-'       \
+        '  |-- PTE(00001) 00802000-00803000 00001000 urw'       \
+        'PDE(001) afc00000-b0000000 00400000 urw'               \
+        '  |-- PTE(00004) afffc000-b0000000 00004000 urw'       \
+        'PDE(0e0) c0000000-f8000000 38000000 urw'               \
+        '  |-- PTE(38000) c0000000-f8000000 38000000 -rw'       \
+        'pgdir pass.'
+
+run_test -prog 'yield' -check default_check                                          \
+        'kernel_execve: pid = 2, name = "yield".'               \
+        'Hello, I am process 2.'                                \
+        'Back in process 2, iteration 0.'                       \
+        'Back in process 2, iteration 1.'                       \
+        'Back in process 2, iteration 2.'                       \
+        'Back in process 2, iteration 3.'                       \
+        'Back in process 2, iteration 4.'                       \
+        'All done in process 2.'                                \
+        'yield pass.'
+
+
+run_test -prog 'badarg' -check default_check                    \
+        'kernel_execve: pid = 2, name = "badarg".'              \
+        'fork ok.'                                              \
+        'badarg pass.'                                          \
+        'all user-mode processes have quit.'                    \
+        'init check memory pass.'                               \
+    ! - 'user panic at .*'
+
+pts=10
+
+run_test -prog 'exit'  -check default_check                                          \
+        'kernel_execve: pid = 2, name = "exit".'                \
+        'I am the parent. Forking the child...'                 \
+        'I am the parent, waiting now..'                        \
+        'I am the child.'                                       \
+      - 'waitpid [0-9]+ ok\.'                                   \
+        'exit pass.'                                            \
+        'all user-mode processes have quit.'                    \
+        'init check memory pass.'                               \
+    ! - 'user panic at .*'
+
+run_test -prog 'spin'  -check default_check                                          \
+        'kernel_execve: pid = 2, name = "spin".'                \
+        'I am the parent. Forking the child...'                 \
+        'I am the parent. Running the child...'                 \
+        'I am the child. spinning ...'                          \
+        'I am the parent.  Killing the child...'                \
+        'kill returns 0'                                        \
+        'wait returns 0'                                        \
+        'spin may pass.'                                        \
+        'all user-mode processes have quit.'                    \
+        'init check memory pass.'                               \
+    ! - 'user panic at .*'
+
+run_test -prog 'waitkill'  -check default_check                                      \
+        'kernel_execve: pid = 2, name = "waitkill".'            \
+        'wait child 1.'                                         \
+        'child 2.'                                              \
+        'child 1.'                                              \
+        'kill parent ok.'                                       \
+        'kill child1 ok.'                                       \
+        'all user-mode processes have quit.'                    \
+        'init check memory pass.'                               \
+    ! - 'user panic at .*'
+
+pts=15
+
+run_test -prog 'forktest'   -check default_check                                     \
+        'kernel_execve: pid = 2, name = "forktest".'            \
+        'I am child 31'                                         \
+        'I am child 19'                                         \
+        'I am child 13'                                         \
+        'I am child 0'                                          \
+        'forktest pass.'                                        \
+        'all user-mode processes have quit.'                    \
+        'init check memory pass.'                               \
+    ! - 'fork claimed to work [0-9]+ times!'                    \
+    !   'wait stopped early'                                    \
+    !   'wait got too many'                                     \
+    ! - 'user panic at .*'
+
+pts=10
+run_test -prog 'forktree'    -check default_check               \
+        'kernel_execve: pid = 2, name = "forktree".'            \
+      - '....: I am '\'''\'                                     \
+      - '....: I am '\''0'\'                                    \
+      - '....: I am '\'''\'                                     \
+      - '....: I am '\''1'\'                                    \
+      - '....: I am '\''0'\'                                    \
+      - '....: I am '\''01'\'                                   \
+      - '....: I am '\''00'\'                                   \
+      - '....: I am '\''11'\'                                   \
+      - '....: I am '\''10'\'                                   \
+      - '....: I am '\''101'\'                                  \
+      - '....: I am '\''100'\'                                  \
+      - '....: I am '\''111'\'                                  \
+      - '....: I am '\''110'\'                                  \
+      - '....: I am '\''001'\'                                  \
+      - '....: I am '\''000'\'                                  \
+      - '....: I am '\''011'\'                                  \
+      - '....: I am '\''010'\'                                  \
+      - '....: I am '\''0101'\'                                 \
+      - '....: I am '\''0100'\'                                 \
+      - '....: I am '\''0111'\'                                 \
+      - '....: I am '\''0110'\'                                 \
+      - '....: I am '\''0001'\'                                 \
+      - '....: I am '\''0000'\'                                 \
+      - '....: I am '\''0011'\'                                 \
+      - '....: I am '\''0010'\'                                 \
+      - '....: I am '\''1101'\'                                 \
+      - '....: I am '\''1100'\'                                 \
+      - '....: I am '\''1111'\'                                 \
+      - '....: I am '\''1110'\'                                 \
+      - '....: I am '\''1001'\'                                 \
+      - '....: I am '\''1000'\'                                 \
+      - '....: I am '\''1011'\'                                 \
+      - '....: I am '\''1010'\'                                 \
+        'all user-mode processes have quit.'                    \
+        'init check memory pass.'
+
+pts=20
+timeout=500
+run_test -prog 'matrix'     -check default_check                \
+        'kernel_execve: pid = 2, name = "matrix".'              \
+        'fork ok.'                                              \
+        'pid 4 done!.'                                          \
+        'pid 7 done!.'                                          \
+        'pid 13 done!.'                                         \
+        'pid 17 done!.'                                         \
+        'pid 23 done!.'                                         \
+        'matrix pass.'                                          \
+        'all user-mode processes have quit.'                    \
+        'init check memory pass.'                               \
+    ! - 'user panic at .*'
+
+show_final
+
+pts=20
+timeout=150
+run_test -prog 'priority'      -check default_check             \
+	'sched class: stride_scheduler'                         \
+        'kernel_execve: pid = 2, name = "priority".'            \
+        'main: fork ok,now need to wait pids.'                  \
+        'stride sched correct result: 1 2 3 4 5'                \
+        'all user-mode processes have quit.'                    \
+        'init check memory pass.'                               \
+    ! - 'user panic at .*'
+
+## print final-score
+show_final
diff -r -u -P lab6_origin/tools/kernel.ld lab6/tools/kernel.ld
--- lab6_origin/tools/kernel.ld	1970-01-01 08:00:00.000000000 +0800
+++ lab6/tools/kernel.ld	2019-02-26 20:51:17.095803500 +0800
@@ -0,0 +1,63 @@
+/* Simple linker script for the ucore kernel.
+   See the GNU ld 'info' manual ("info ld") to learn the syntax. */
+
+OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
+OUTPUT_ARCH(i386)
+ENTRY(kern_entry)
+
+SECTIONS {
+    /* Load the kernel at this address: "." means the current address */
+    . = 0xC0100000;
+
+    .text : {
+        *(.text .stub .text.* .gnu.linkonce.t.*)
+    }
+
+    PROVIDE(etext = .); /* Define the 'etext' symbol to this value */
+
+    .rodata : {
+        *(.rodata .rodata.* .gnu.linkonce.r.*)
+    }
+
+    /* Include debugging information in kernel memory */
+    .stab : {
+        PROVIDE(__STAB_BEGIN__ = .);
+        *(.stab);
+        PROVIDE(__STAB_END__ = .);
+        BYTE(0)     /* Force the linker to allocate space
+                   for this section */
+    }
+
+    .stabstr : {
+        PROVIDE(__STABSTR_BEGIN__ = .);
+        *(.stabstr);
+        PROVIDE(__STABSTR_END__ = .);
+        BYTE(0)     /* Force the linker to allocate space
+                   for this section */
+    }
+
+    /* Adjust the address for the data segment to the next page */
+    . = ALIGN(0x1000);
+
+    /* The data segment */
+    .data : {
+        *(.data)
+    }
+
+    . = ALIGN(0x1000);
+    .data.pgdir : {
+        *(.data.pgdir)
+    }
+
+    PROVIDE(edata = .);
+
+    .bss : {
+        *(.bss)
+    }
+
+    PROVIDE(end = .);
+
+    /DISCARD/ : {
+        *(.eh_frame .note.GNU-stack)
+    }
+}
diff -r -u -P lab6_origin/tools/sign.c lab6/tools/sign.c
--- lab6_origin/tools/sign.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/tools/sign.c	2019-02-26 20:51:17.096802200 +0800
@@ -0,0 +1,43 @@
+#include <stdio.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/stat.h>
+
+int
+main(int argc, char *argv[]) {
+    struct stat st;
+    if (argc != 3) {
+        fprintf(stderr, "Usage: <input filename> <output filename>\n");
+        return -1;
+    }
+    if (stat(argv[1], &st) != 0) {
+        fprintf(stderr, "Error opening file '%s': %s\n", argv[1], strerror(errno));
+        return -1;
+    }
+    printf("'%s' size: %lld bytes\n", argv[1], (long long)st.st_size);
+    if (st.st_size > 510) {
+        fprintf(stderr, "%lld >> 510!!\n", (long long)st.st_size);
+        return -1;
+    }
+    char buf[512];
+    memset(buf, 0, sizeof(buf));
+    FILE *ifp = fopen(argv[1], "rb");
+    int size = fread(buf, 1, st.st_size, ifp);
+    if (size != st.st_size) {
+        fprintf(stderr, "read '%s' error, size is %d.\n", argv[1], size);
+        return -1;
+    }
+    fclose(ifp);
+    buf[510] = 0x55;
+    buf[511] = 0xAA;
+    FILE *ofp = fopen(argv[2], "wb+");
+    size = fwrite(buf, 1, 512, ofp);
+    if (size != 512) {
+        fprintf(stderr, "write '%s' error, size is %d.\n", argv[2], size);
+        return -1;
+    }
+    fclose(ofp);
+    printf("build 512 bytes boot sector: '%s' success!\n", argv[2]);
+    return 0;
+}
+
diff -r -u -P lab6_origin/tools/user.ld lab6/tools/user.ld
--- lab6_origin/tools/user.ld	1970-01-01 08:00:00.000000000 +0800
+++ lab6/tools/user.ld	2019-02-26 20:51:17.097803200 +0800
@@ -0,0 +1,71 @@
+/* Simple linker script for ucore user-level programs.
+   See the GNU ld 'info' manual ("info ld") to learn the syntax. */
+
+OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
+OUTPUT_ARCH(i386)
+ENTRY(_start)
+
+SECTIONS {
+    /* Load programs at this address: "." means the current address */
+    . = 0x800020;
+
+    .text : {
+        *(.text .stub .text.* .gnu.linkonce.t.*)
+    }
+
+    PROVIDE(etext = .); /* Define the 'etext' symbol to this value */
+
+    .rodata : {
+        *(.rodata .rodata.* .gnu.linkonce.r.*)
+    }
+
+    /* Adjust the address for the data segment to the next page */
+    . = ALIGN(0x1000);
+
+    .data : {
+        *(.data)
+    }
+
+    PROVIDE(edata = .);
+
+    .bss : {
+        *(.bss)
+    }
+
+    PROVIDE(end = .);
+
+
+    /* Place debugging symbols so that they can be found by
+     * the kernel debugger.
+     * Specifically, the four words at 0x200000 mark the beginning of
+     * the stabs, the end of the stabs, the beginning of the stabs
+     * string table, and the end of the stabs string table, respectively.
+     */
+
+    .stab_info 0x200000 : {
+        LONG(__STAB_BEGIN__);
+        LONG(__STAB_END__);
+        LONG(__STABSTR_BEGIN__);
+        LONG(__STABSTR_END__);
+    }
+
+    .stab : {
+        __STAB_BEGIN__ = DEFINED(__STAB_BEGIN__) ? __STAB_BEGIN__ : .;
+        *(.stab);
+        __STAB_END__ = DEFINED(__STAB_END__) ? __STAB_END__ : .;
+        BYTE(0)     /* Force the linker to allocate space
+                   for this section */
+    }
+
+    .stabstr : {
+        __STABSTR_BEGIN__ = DEFINED(__STABSTR_BEGIN__) ? __STABSTR_BEGIN__ : .;
+        *(.stabstr);
+        __STABSTR_END__ = DEFINED(__STABSTR_END__) ? __STABSTR_END__ : .;
+        BYTE(0)     /* Force the linker to allocate space
+                   for this section */
+    }
+
+    /DISCARD/ : {
+        *(.eh_frame .note.GNU-stack .comment)
+    }
+}
diff -r -u -P lab6_origin/tools/vector.c lab6/tools/vector.c
--- lab6_origin/tools/vector.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/tools/vector.c	2019-02-26 20:51:17.098797400 +0800
@@ -0,0 +1,29 @@
+#include <stdio.h>
+
+int
+main(void) {
+    printf("# handler\n");
+    printf(".text\n");
+    printf(".globl __alltraps\n");
+
+    int i;
+    for (i = 0; i < 256; i ++) {
+        printf(".globl vector%d\n", i);
+        printf("vector%d:\n", i);
+        if (i != 8 && (i < 10 || i > 14) && i != 17) {
+            printf("  pushl $0\n");
+        }
+        printf("  pushl $%d\n", i);
+        printf("  jmp __alltraps\n");
+    }
+    printf("\n");
+    printf("# vector table\n");
+    printf(".data\n");
+    printf(".globl __vectors\n");
+    printf("__vectors:\n");
+    for (i = 0; i < 256; i ++) {
+        printf("  .long vector%d\n", i);
+    }
+    return 0;
+}
+
diff -r -u -P lab6_origin/user/badarg.c lab6/user/badarg.c
--- lab6_origin/user/badarg.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/user/badarg.c	2019-02-26 20:51:17.099796100 +0800
@@ -0,0 +1,22 @@
+#include <stdio.h>
+#include <ulib.h>
+
+int
+main(void) {
+    int pid, exit_code;
+    if ((pid = fork()) == 0) {
+        cprintf("fork ok.\n");
+        int i;
+        for (i = 0; i < 10; i ++) {
+            yield();
+        }
+        exit(0xbeaf);
+    }
+    assert(pid > 0);
+    assert(waitpid(-1, NULL) != 0);
+    assert(waitpid(pid, (void *)0xC0000000) != 0);
+    assert(waitpid(pid, &exit_code) == 0 && exit_code == 0xbeaf);
+    cprintf("badarg pass.\n");
+    return 0;
+}
+
diff -r -u -P lab6_origin/user/badsegment.c lab6/user/badsegment.c
--- lab6_origin/user/badsegment.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/user/badsegment.c	2019-02-26 20:51:17.100295500 +0800
@@ -0,0 +1,11 @@
+#include <stdio.h>
+#include <ulib.h>
+
+/* try to load the kernel's TSS selector into the DS register */
+
+int
+main(void) {
+    asm volatile("movw $0x28,%ax; movw %ax,%ds");
+    panic("FAIL: T.T\n");
+}
+
diff -r -u -P lab6_origin/user/divzero.c lab6/user/divzero.c
--- lab6_origin/user/divzero.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/user/divzero.c	2019-02-26 20:51:17.100793900 +0800
@@ -0,0 +1,11 @@
+#include <stdio.h>
+#include <ulib.h>
+
+int zero;
+
+int
+main(void) {
+    cprintf("value is %d.\n", 1 / zero);
+    panic("FAIL: T.T\n");
+}
+
diff -r -u -P lab6_origin/user/exit.c lab6/user/exit.c
--- lab6_origin/user/exit.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/user/exit.c	2019-02-26 20:51:17.101792200 +0800
@@ -0,0 +1,34 @@
+#include <stdio.h>
+#include <ulib.h>
+
+int magic = -0x10384;
+
+int
+main(void) {
+    int pid, code;
+    cprintf("I am the parent. Forking the child...\n");
+    if ((pid = fork()) == 0) {
+        cprintf("I am the child.\n");
+        yield();
+        yield();
+        yield();
+        yield();
+        yield();
+        yield();
+        yield();
+        exit(magic);
+    }
+    else {
+        cprintf("I am parent, fork a child pid %d\n",pid);
+    }
+    assert(pid > 0);
+    cprintf("I am the parent, waiting now..\n");
+
+    assert(waitpid(pid, &code) == 0 && code == magic);
+    assert(waitpid(pid, &code) != 0 && wait() != 0);
+    cprintf("waitpid %d ok.\n", pid);
+
+    cprintf("exit pass.\n");
+    return 0;
+}
+
diff -r -u -P lab6_origin/user/faultread.c lab6/user/faultread.c
--- lab6_origin/user/faultread.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/user/faultread.c	2019-02-26 20:51:17.102291100 +0800
@@ -0,0 +1,9 @@
+#include <stdio.h>
+#include <ulib.h>
+
+int
+main(void) {
+    cprintf("I read %8x from 0.\n", *(unsigned int *)0);
+    panic("FAIL: T.T\n");
+}
+
diff -r -u -P lab6_origin/user/faultreadkernel.c lab6/user/faultreadkernel.c
--- lab6_origin/user/faultreadkernel.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/user/faultreadkernel.c	2019-02-26 20:51:17.103291100 +0800
@@ -0,0 +1,9 @@
+#include <stdio.h>
+#include <ulib.h>
+
+int
+main(void) {
+    cprintf("I read %08x from 0xfac00000!\n", *(unsigned *)0xfac00000);
+    panic("FAIL: T.T\n");
+}
+
diff -r -u -P lab6_origin/user/forktest.c lab6/user/forktest.c
--- lab6_origin/user/forktest.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/user/forktest.c	2019-02-26 20:51:17.103798900 +0800
@@ -0,0 +1,34 @@
+#include <ulib.h>
+#include <stdio.h>
+
+const int max_child = 32;
+
+int
+main(void) {
+    int n, pid;
+    for (n = 0; n < max_child; n ++) {
+        if ((pid = fork()) == 0) {
+            cprintf("I am child %d\n", n);
+            exit(0);
+        }
+        assert(pid > 0);
+    }
+
+    if (n > max_child) {
+        panic("fork claimed to work %d times!\n", n);
+    }
+
+    for (; n > 0; n --) {
+        if (wait() != 0) {
+            panic("wait stopped early\n");
+        }
+    }
+
+    if (wait() == 0) {
+        panic("wait got too many\n");
+    }
+
+    cprintf("forktest pass.\n");
+    return 0;
+}
+
diff -r -u -P lab6_origin/user/forktree.c lab6/user/forktree.c
--- lab6_origin/user/forktree.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/user/forktree.c	2019-02-26 20:51:17.104789200 +0800
@@ -0,0 +1,37 @@
+#include <ulib.h>
+#include <stdio.h>
+#include <string.h>
+
+#define DEPTH 4
+
+void forktree(const char *cur);
+
+void
+forkchild(const char *cur, char branch) {
+    char nxt[DEPTH + 1];
+
+    if (strlen(cur) >= DEPTH)
+        return;
+
+    snprintf(nxt, DEPTH + 1, "%s%c", cur, branch);
+    if (fork() == 0) {
+        forktree(nxt);
+        yield();
+        exit(0);
+    }
+}
+
+void
+forktree(const char *cur) {
+    cprintf("%04x: I am '%s'\n", getpid(), cur);
+
+    forkchild(cur, '0');
+    forkchild(cur, '1');
+}
+
+int
+main(void) {
+    forktree("");
+    return 0;
+}
+
diff -r -u -P lab6_origin/user/hello.c lab6/user/hello.c
--- lab6_origin/user/hello.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/user/hello.c	2019-02-26 20:51:17.105783900 +0800
@@ -0,0 +1,11 @@
+#include <stdio.h>
+#include <ulib.h>
+
+int
+main(void) {
+    cprintf("Hello world!!.\n");
+    cprintf("I am process %d.\n", getpid());
+    cprintf("hello pass.\n");
+    return 0;
+}
+
diff -r -u -P lab6_origin/user/libs/initcode.S lab6/user/libs/initcode.S
--- lab6_origin/user/libs/initcode.S	1970-01-01 08:00:00.000000000 +0800
+++ lab6/user/libs/initcode.S	2019-02-26 20:51:17.106784800 +0800
@@ -0,0 +1,14 @@
+.text
+.globl _start
+_start:
+    # set ebp for backtrace
+    movl $0x0, %ebp
+
+    # move down the esp register
+    # since it may cause page fault in backtrace
+    subl $0x20, %esp
+
+    # call user-program function
+    call umain
+1:  jmp 1b
+
diff -r -u -P lab6_origin/user/libs/panic.c lab6/user/libs/panic.c
--- lab6_origin/user/libs/panic.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/user/libs/panic.c	2019-02-26 20:51:17.107283200 +0800
@@ -0,0 +1,28 @@
+#include <defs.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <ulib.h>
+#include <error.h>
+
+void
+__panic(const char *file, int line, const char *fmt, ...) {
+    // print the 'message'
+    va_list ap;
+    va_start(ap, fmt);
+    cprintf("user panic at %s:%d:\n    ", file, line);
+    vcprintf(fmt, ap);
+    cprintf("\n");
+    va_end(ap);
+    exit(-E_PANIC);
+}
+
+void
+__warn(const char *file, int line, const char *fmt, ...) {
+    va_list ap;
+    va_start(ap, fmt);
+    cprintf("user warning at %s:%d:\n    ", file, line);
+    vcprintf(fmt, ap);
+    cprintf("\n");
+    va_end(ap);
+}
+
diff -r -u -P lab6_origin/user/libs/stdio.c lab6/user/libs/stdio.c
--- lab6_origin/user/libs/stdio.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/user/libs/stdio.c	2019-02-26 20:51:17.107782600 +0800
@@ -0,0 +1,62 @@
+#include <defs.h>
+#include <stdio.h>
+#include <syscall.h>
+
+/* *
+ * cputch - writes a single character @c to stdout, and it will
+ * increace the value of counter pointed by @cnt.
+ * */
+static void
+cputch(int c, int *cnt) {
+    sys_putc(c);
+    (*cnt) ++;
+}
+
+/* *
+ * vcprintf - format a string and writes it to stdout
+ *
+ * The return value is the number of characters which would be
+ * written to stdout.
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want cprintf() instead.
+ * */
+int
+vcprintf(const char *fmt, va_list ap) {
+    int cnt = 0;
+    vprintfmt((void*)cputch, &cnt, fmt, ap);
+    return cnt;
+}
+
+/* *
+ * cprintf - formats a string and writes it to stdout
+ *
+ * The return value is the number of characters which would be
+ * written to stdout.
+ * */
+int
+cprintf(const char *fmt, ...) {
+    va_list ap;
+
+    va_start(ap, fmt);
+    int cnt = vcprintf(fmt, ap);
+    va_end(ap);
+
+    return cnt;
+}
+
+/* *
+ * cputs- writes the string pointed by @str to stdout and
+ * appends a newline character.
+ * */
+int
+cputs(const char *str) {
+    int cnt = 0;
+    char c;
+    while ((c = *str ++) != '\0') {
+        cputch(c, &cnt);
+    }
+    cputch('\n', &cnt);
+    return cnt;
+}
+
diff -r -u -P lab6_origin/user/libs/syscall.c lab6/user/libs/syscall.c
--- lab6_origin/user/libs/syscall.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/user/libs/syscall.c	2019-02-26 20:51:17.108281900 +0800
@@ -0,0 +1,82 @@
+#include <defs.h>
+#include <unistd.h>
+#include <stdarg.h>
+#include <syscall.h>
+
+#define MAX_ARGS            5
+
+static inline int
+syscall(int num, ...) {
+    va_list ap;
+    va_start(ap, num);
+    uint32_t a[MAX_ARGS];
+    int i, ret;
+    for (i = 0; i < MAX_ARGS; i ++) {
+        a[i] = va_arg(ap, uint32_t);
+    }
+    va_end(ap);
+
+    asm volatile (
+        "int %1;"
+        : "=a" (ret)
+        : "i" (T_SYSCALL),
+          "a" (num),
+          "d" (a[0]),
+          "c" (a[1]),
+          "b" (a[2]),
+          "D" (a[3]),
+          "S" (a[4])
+        : "cc", "memory");
+    return ret;
+}
+
+int
+sys_exit(int error_code) {
+    return syscall(SYS_exit, error_code);
+}
+
+int
+sys_fork(void) {
+    return syscall(SYS_fork);
+}
+
+int
+sys_wait(int pid, int *store) {
+    return syscall(SYS_wait, pid, store);
+}
+
+int
+sys_yield(void) {
+    return syscall(SYS_yield);
+}
+
+int
+sys_kill(int pid) {
+    return syscall(SYS_kill, pid);
+}
+
+int
+sys_getpid(void) {
+    return syscall(SYS_getpid);
+}
+
+int
+sys_putc(int c) {
+    return syscall(SYS_putc, c);
+}
+
+int
+sys_pgdir(void) {
+    return syscall(SYS_pgdir);
+}
+
+int
+sys_gettime(void) {
+    return syscall(SYS_gettime);
+}
+
+void
+sys_lab6_set_priority(uint32_t priority)
+{
+    syscall(SYS_lab6_set_priority, priority);
+}
diff -r -u -P lab6_origin/user/libs/syscall.h lab6/user/libs/syscall.h
--- lab6_origin/user/libs/syscall.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/user/libs/syscall.h	2019-02-26 20:51:17.109280200 +0800
@@ -0,0 +1,17 @@
+#ifndef __USER_LIBS_SYSCALL_H__
+#define __USER_LIBS_SYSCALL_H__
+
+int sys_exit(int error_code);
+int sys_fork(void);
+int sys_wait(int pid, int *store);
+int sys_yield(void);
+int sys_kill(int pid);
+int sys_getpid(void);
+int sys_putc(int c);
+int sys_pgdir(void);
+int sys_gettime(void);
+/* FOR LAB6 ONLY */
+void sys_lab6_set_priority(uint32_t priority);
+
+#endif /* !__USER_LIBS_SYSCALL_H__ */
+
diff -r -u -P lab6_origin/user/libs/ulib.c lab6/user/libs/ulib.c
--- lab6_origin/user/libs/ulib.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/user/libs/ulib.c	2019-02-26 20:51:17.110278000 +0800
@@ -0,0 +1,58 @@
+#include <defs.h>
+#include <syscall.h>
+#include <stdio.h>
+#include <ulib.h>
+
+void
+exit(int error_code) {
+    sys_exit(error_code);
+    cprintf("BUG: exit failed.\n");
+    while (1);
+}
+
+int
+fork(void) {
+    return sys_fork();
+}
+
+int
+wait(void) {
+    return sys_wait(0, NULL);
+}
+
+int
+waitpid(int pid, int *store) {
+    return sys_wait(pid, store);
+}
+
+void
+yield(void) {
+    sys_yield();
+}
+
+int
+kill(int pid) {
+    return sys_kill(pid);
+}
+
+int
+getpid(void) {
+    return sys_getpid();
+}
+
+//print_pgdir - print the PDT&PT
+void
+print_pgdir(void) {
+    sys_pgdir();
+}
+
+unsigned int
+gettime_msec(void) {
+    return (unsigned int)sys_gettime();
+}
+
+void
+lab6_set_priority(uint32_t priority)
+{
+    sys_lab6_set_priority(priority);
+}
diff -r -u -P lab6_origin/user/libs/ulib.h lab6/user/libs/ulib.h
--- lab6_origin/user/libs/ulib.h	1970-01-01 08:00:00.000000000 +0800
+++ lab6/user/libs/ulib.h	2019-02-26 20:51:17.110778300 +0800
@@ -0,0 +1,38 @@
+#ifndef __USER_LIBS_ULIB_H__
+#define __USER_LIBS_ULIB_H__
+
+#include <defs.h>
+
+void __warn(const char *file, int line, const char *fmt, ...);
+void __noreturn __panic(const char *file, int line, const char *fmt, ...);
+
+#define warn(...)                                       \
+    __warn(__FILE__, __LINE__, __VA_ARGS__)
+
+#define panic(...)                                      \
+    __panic(__FILE__, __LINE__, __VA_ARGS__)
+
+#define assert(x)                                       \
+    do {                                                \
+        if (!(x)) {                                     \
+            panic("assertion failed: %s", #x);          \
+        }                                               \
+    } while (0)
+
+// static_assert(x) will generate a compile-time error if 'x' is false.
+#define static_assert(x)                                \
+    switch (x) { case 0: case (x): ; }
+
+void __noreturn exit(int error_code);
+int fork(void);
+int wait(void);
+int waitpid(int pid, int *store);
+void yield(void);
+int kill(int pid);
+int getpid(void);
+void print_pgdir(void);
+unsigned int gettime_msec(void);
+void lab6_set_priority(uint32_t priority);
+
+#endif /* !__USER_LIBS_ULIB_H__ */
+
diff -r -u -P lab6_origin/user/libs/umain.c lab6/user/libs/umain.c
--- lab6_origin/user/libs/umain.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/user/libs/umain.c	2019-02-26 20:51:17.111775600 +0800
@@ -0,0 +1,10 @@
+#include <ulib.h>
+
+int main(void);
+
+void
+umain(void) {
+    int ret = main();
+    exit(ret);
+}
+
diff -r -u -P lab6_origin/user/matrix.c lab6/user/matrix.c
--- lab6_origin/user/matrix.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/user/matrix.c	2019-02-26 20:51:17.112276800 +0800
@@ -0,0 +1,84 @@
+#include <ulib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#define MATSIZE     10
+
+static int mata[MATSIZE][MATSIZE];
+static int matb[MATSIZE][MATSIZE];
+static int matc[MATSIZE][MATSIZE];
+
+void
+work(unsigned int times) {
+    int i, j, k, size = MATSIZE;
+    for (i = 0; i < size; i ++) {
+        for (j = 0; j < size; j ++) {
+            mata[i][j] = matb[i][j] = 1;
+        }
+    }
+
+    yield();
+
+    cprintf("pid %d is running (%d times)!.\n", getpid(), times);
+
+    while (times -- > 0) {
+        for (i = 0; i < size; i ++) {
+            for (j = 0; j < size; j ++) {
+                matc[i][j] = 0;
+                for (k = 0; k < size; k ++) {
+                    matc[i][j] += mata[i][k] * matb[k][j];
+                }
+            }
+        }
+        for (i = 0; i < size; i ++) {
+            for (j = 0; j < size; j ++) {
+                mata[i][j] = matb[i][j] = matc[i][j];
+            }
+        }
+    }
+    cprintf("pid %d done!.\n", getpid());
+    exit(0);
+}
+
+const int total = 21;
+
+int
+main(void) {
+    int pids[total];
+    memset(pids, 0, sizeof(pids));
+
+    int i;
+    for (i = 0; i < total; i ++) {
+        if ((pids[i] = fork()) == 0) {
+            srand(i * i);
+            int times = (((unsigned int)rand()) % total);
+            times = (times * times + 10) * 100;
+            work(times);
+        }
+        if (pids[i] < 0) {
+            goto failed;
+        }
+    }
+
+    cprintf("fork ok.\n");
+
+    for (i = 0; i < total; i ++) {
+        if (wait() != 0) {
+            cprintf("wait failed.\n");
+            goto failed;
+        }
+    }
+
+    cprintf("matrix pass.\n");
+    return 0;
+
+failed:
+    for (i = 0; i < total; i ++) {
+        if (pids[i] > 0) {
+            kill(pids[i]);
+        }
+    }
+    panic("FAIL: T.T\n");
+}
+
diff -r -u -P lab6_origin/user/pgdir.c lab6/user/pgdir.c
--- lab6_origin/user/pgdir.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/user/pgdir.c	2019-02-26 20:51:17.112773400 +0800
@@ -0,0 +1,11 @@
+#include <stdio.h>
+#include <ulib.h>
+
+int
+main(void) {
+    cprintf("I am %d, print pgdir.\n", getpid());
+    print_pgdir();
+    cprintf("pgdir pass.\n");
+    return 0;
+}
+
diff -r -u -P lab6_origin/user/priority.c lab6/user/priority.c
--- lab6_origin/user/priority.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/user/priority.c	2019-02-26 20:51:17.113771200 +0800
@@ -0,0 +1,77 @@
+#include <ulib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#define TOTAL 5
+/* to get enough accuracy, MAX_TIME (the running time of each process) should >1000 mseconds. */
+#define MAX_TIME  1000
+unsigned int acc[TOTAL];
+int status[TOTAL];
+int pids[TOTAL];
+
+static void
+spin_delay(void)
+{
+     int i;
+     volatile int j;
+     for (i = 0; i != 200; ++ i)
+     {
+          j = !j;
+     }
+}
+
+int
+main(void) {
+     int i,time;
+     memset(pids, 0, sizeof(pids));
+     lab6_set_priority(TOTAL + 1);
+
+     for (i = 0; i < TOTAL; i ++) {
+          acc[i]=0;
+          if ((pids[i] = fork()) == 0) {
+               lab6_set_priority(i + 1);
+               acc[i] = 0;
+               while (1) {
+                    spin_delay();
+                    ++ acc[i];
+                    if(acc[i]%4000==0) {
+                        if((time=gettime_msec())>MAX_TIME) {
+                            cprintf("child pid %d, acc %d, time %d\n",getpid(),acc[i],time);
+                            exit(acc[i]);
+                        }
+                    }
+               }
+               
+          }
+          if (pids[i] < 0) {
+               goto failed;
+          }
+     }
+
+     cprintf("main: fork ok,now need to wait pids.\n");
+
+     for (i = 0; i < TOTAL; i ++) {
+         status[i]=0;
+         waitpid(pids[i],&status[i]);
+         cprintf("main: pid %d, acc %d, time %d\n",pids[i],status[i],gettime_msec()); 
+     }
+     cprintf("main: wait pids over\n");
+     cprintf("stride sched correct result:");
+     for (i = 0; i < TOTAL; i ++)
+     {
+         cprintf(" %d", (status[i] * 2 / status[0] + 1) / 2);
+     }
+     cprintf("\n");
+
+     return 0;
+
+failed:
+     for (i = 0; i < TOTAL; i ++) {
+          if (pids[i] > 0) {
+               kill(pids[i]);
+          }
+     }
+     panic("FAIL: T.T\n");
+}
+
diff -r -u -P lab6_origin/user/softint.c lab6/user/softint.c
--- lab6_origin/user/softint.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/user/softint.c	2019-02-26 20:51:17.114270600 +0800
@@ -0,0 +1,9 @@
+#include <stdio.h>
+#include <ulib.h>
+
+int
+main(void) {
+    asm volatile("int $14");
+    panic("FAIL: T.T\n");
+}
+
diff -r -u -P lab6_origin/user/spin.c lab6/user/spin.c
--- lab6_origin/user/spin.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/user/spin.c	2019-02-26 20:51:17.114769500 +0800
@@ -0,0 +1,29 @@
+#include <stdio.h>
+#include <ulib.h>
+
+int
+main(void) {
+    int pid, ret;
+    cprintf("I am the parent. Forking the child...\n");
+    if ((pid = fork()) == 0) {
+        cprintf("I am the child. spinning ...\n");
+        while (1);
+    }
+    cprintf("I am the parent. Running the child...\n");
+
+    yield();
+    yield();
+    yield();
+
+    cprintf("I am the parent.  Killing the child...\n");
+
+    assert((ret = kill(pid)) == 0);
+    cprintf("kill returns %d\n", ret);
+
+    assert((ret = waitpid(pid, NULL)) == 0);
+    cprintf("wait returns %d\n", ret);
+
+    cprintf("spin may pass.\n");
+    return 0;
+}
+
diff -r -u -P lab6_origin/user/testbss.c lab6/user/testbss.c
--- lab6_origin/user/testbss.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/user/testbss.c	2019-02-26 20:51:17.115268400 +0800
@@ -0,0 +1,33 @@
+#include <stdio.h>
+#include <ulib.h>
+
+#define ARRAYSIZE (1024*1024)
+
+uint32_t bigarray[ARRAYSIZE];
+
+int
+main(void) {
+    cprintf("Making sure bss works right...\n");
+    int i;
+    for (i = 0; i < ARRAYSIZE; i ++) {
+        if (bigarray[i] != 0) {
+            panic("bigarray[%d] isn't cleared!\n", i);
+        }
+    }
+    for (i = 0; i < ARRAYSIZE; i ++) {
+        bigarray[i] = i;
+    }
+    for (i = 0; i < ARRAYSIZE; i ++) {
+        if (bigarray[i] != i) {
+            panic("bigarray[%d] didn't hold its value!\n", i);
+        }
+    }
+
+    cprintf("Yes, good.  Now doing a wild write off the end...\n");
+    cprintf("testbss may pass.\n");
+
+    bigarray[ARRAYSIZE + 1024] = 0;
+    asm volatile ("int $0x14");
+    panic("FAIL: T.T\n");
+}
+
diff -r -u -P lab6_origin/user/waitkill.c lab6/user/waitkill.c
--- lab6_origin/user/waitkill.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/user/waitkill.c	2019-02-26 20:51:17.115767800 +0800
@@ -0,0 +1,59 @@
+#include <ulib.h>
+#include <stdio.h>
+
+void
+do_yield(void) {
+    yield();
+    yield();
+    yield();
+    yield();
+    yield();
+    yield();
+}
+
+int parent, pid1, pid2;
+
+void
+loop(void) {
+    cprintf("child 1.\n");
+    while (1);
+}
+
+void
+work(void) {
+    cprintf("child 2.\n");
+    do_yield();
+    if (kill(parent) == 0) {
+        cprintf("kill parent ok.\n");
+        do_yield();
+        if (kill(pid1) == 0) {
+            cprintf("kill child1 ok.\n");
+            exit(0);
+        }
+    }
+    exit(-1);
+}
+
+int
+main(void) {
+    parent = getpid();
+    if ((pid1 = fork()) == 0) {
+        loop();
+    }
+
+    assert(pid1 > 0);
+
+    if ((pid2 = fork()) == 0) {
+        work();
+    }
+    if (pid2 > 0) {
+        cprintf("wait child 1.\n");
+        waitpid(pid1, NULL);
+        panic("waitpid %d returns\n", pid1);
+    }
+    else {
+        kill(pid1);
+    }
+    panic("FAIL: T.T\n");
+}
+
diff -r -u -P lab6_origin/user/yield.c lab6/user/yield.c
--- lab6_origin/user/yield.c	1970-01-01 08:00:00.000000000 +0800
+++ lab6/user/yield.c	2019-02-26 20:51:17.116766000 +0800
@@ -0,0 +1,16 @@
+#include <ulib.h>
+#include <stdio.h>
+
+int
+main(void) {
+    int i;
+    cprintf("Hello, I am process %d.\n", getpid());
+    for (i = 0; i < 5; i ++) {
+        yield();
+        cprintf("Back in process %d, iteration %d.\n", getpid(), i);
+    }
+    cprintf("All done in process %d.\n", getpid());
+    cprintf("yield pass.\n");
+    return 0;
+}
+
diff -r -u -P lab6_origin/.waitkill.log lab6/.waitkill.log
--- lab6_origin/.waitkill.log	1970-01-01 08:00:00.000000000 +0800
+++ lab6/.waitkill.log	2019-05-13 17:40:42.791060100 +0800
@@ -0,0 +1,115 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc010b8ec (phys)
+  edata  0xc01b0000 (phys)
+  end    0xc01b3178 (phys)
+Kernel executable memory footprint: 717KB
+ebp:0xc012bf48 eip:0xc0100b65 args:0x00010094 0x00010094 0xc012bf78 0xc01000d1 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc012bf58 eip:0xc0100e65 args:0x00000000 0x00000000 0x00000000 0xc012bfc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc012bf78 eip:0xc01000d1 args:0x00000000 0xc012bfa0 0xffff0000 0xc012bfa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc012bf98 eip:0xc01000f3 args:0x00000000 0xffff0000 0xc012bfc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc012bfb8 eip:0xc0100110 args:0x00000000 0xc0100036 0xffff0000 0xc0100079 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc012bfd8 eip:0xc0100131 args:0x00000000 0x00000000 0x00000000 0xc010b900 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc012bff8 eip:0xc0100086 args:0xc010bafc 0xc010bb04 0xc0100dee 0xc010bb23 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 31818, total 31818
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 5, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+kernel_execve: pid = 2, name = "waitkill".
+wait child 1.
+child 2.
+child 1.
+kill parent ok.
+kill child1 ok.
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:477:
+    initproc exit.
+
+stack trackback:
+ebp:0xc0395f98 eip:0xc0100b65 args:0x00000018 0x00000000 0x00000000 0xc0395fcc 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc0395fb8 eip:0xc0100461 args:0xc010d994 0x000001dd 0xc010d9e6 0x00000000 
+    kern/debug/panic.c:27: __panic+107
+ebp:0xc0395fe8 eip:0xc0109511 args:0x00000000 0x00000000 0x00000000 0x00000010 
+    kern/process/proc.c:477: do_exit+81
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -r -u -P lab6_origin/.yield.log lab6/.yield.log
--- lab6_origin/.yield.log	1970-01-01 08:00:00.000000000 +0800
+++ lab6/.yield.log	2019-05-13 17:40:25.926471100 +0800
@@ -0,0 +1,118 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc010b8ec (phys)
+  edata  0xc01b0000 (phys)
+  end    0xc01b3178 (phys)
+Kernel executable memory footprint: 717KB
+ebp:0xc012bf48 eip:0xc0100b65 args:0x00010094 0x00010094 0xc012bf78 0xc01000d1 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc012bf58 eip:0xc0100e65 args:0x00000000 0x00000000 0x00000000 0xc012bfc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc012bf78 eip:0xc01000d1 args:0x00000000 0xc012bfa0 0xffff0000 0xc012bfa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc012bf98 eip:0xc01000f3 args:0x00000000 0xffff0000 0xc012bfc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc012bfb8 eip:0xc0100110 args:0x00000000 0xc0100036 0xffff0000 0xc0100079 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc012bfd8 eip:0xc0100131 args:0x00000000 0x00000000 0x00000000 0xc010b900 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc012bff8 eip:0xc0100086 args:0xc010bafc 0xc010bb04 0xc0100dee 0xc010bb23 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 31818, total 31818
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 5, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+kernel_execve: pid = 2, name = "yield".
+Hello, I am process 2.
+Back in process 2, iteration 0.
+Back in process 2, iteration 1.
+Back in process 2, iteration 2.
+Back in process 2, iteration 3.
+Back in process 2, iteration 4.
+All done in process 2.
+yield pass.
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:477:
+    initproc exit.
+
+stack trackback:
+ebp:0xc0395f98 eip:0xc0100b65 args:0x00000018 0x00000000 0x00000000 0xc0395fcc 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc0395fb8 eip:0xc0100461 args:0xc010d994 0x000001dd 0xc010d9e6 0x00000000 
+    kern/debug/panic.c:27: __panic+107
+ebp:0xc0395fe8 eip:0xc0109511 args:0x00000000 0x00000000 0x00000000 0x00000010 
+    kern/process/proc.c:477: do_exit+81
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
